{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"THREE\"","webpack:///../@here/harp-utils/index.ts","webpack:///../@here/harp-datasource-protocol/index.ts","webpack:///../@here/harp-materials/index.ts","webpack:///../@here/harp-datasource-protocol/lib/Expr.ts","webpack:///../@here/harp-geoutils/index.ts","webpack:///../@here/harp-text-canvas/index.ts","webpack:///../@here/harp-geoutils/lib/coordinates/GeoCoordinates.ts","webpack:///../@here/harp-geoutils/lib/math/MathUtils.ts","webpack:///../@here/harp-mapview/lib/Utils.ts","webpack:///../@here/harp-geoutils/lib/projection/EarthConstants.ts","webpack:///../@here/harp-geoutils/lib/math/Box3Like.ts","webpack:///../@here/harp-geoutils/lib/math/OrientedBox3Like.ts","webpack:///../@here/harp-geoutils/lib/projection/Projection.ts","webpack:///../@here/harp-text-canvas/lib/rendering/TextStyle.ts","webpack:///../@here/harp-mapview/index.ts","webpack:///../@here/harp-materials/lib/Utils.ts","webpack:///../@here/harp-datasource-protocol/lib/ColorUtils.ts","webpack:///../@here/harp-datasource-protocol/lib/InterpolatedProperty.ts","webpack:///../@here/harp-geoutils/lib/coordinates/GeoBox.ts","webpack:///../@here/harp-geoutils/lib/tiling/TilingScheme.ts","webpack:///../@here/harp-text-canvas/lib/utils/UnicodeUtils.ts","webpack:///../@here/harp-mapview/lib/DecodedTileHelpers.ts","webpack:///../@here/harp-mapview/lib/text/TextElement.ts","webpack:///../@here/harp-mapview/lib/Statistics.ts","webpack:///../@here/harp-mapview/lib/composing/Pass.ts","webpack:///../@here/harp-mapview/lib/MapView.ts","webpack:///../@here/harp-datasource-protocol/lib/InterpolatedPropertyDefs.ts","webpack:///../@here/harp-datasource-protocol/lib/Theme.ts","webpack:///../@here/harp-geoutils/lib/projection/MercatorProjection.ts","webpack:///../@here/harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.ts","webpack:///../@here/harp-geoutils/lib/tiling/TileKey.ts","webpack:///../@here/harp-mapview/lib/geometry/TileGeometryCreator.ts","webpack:///../@here/harp-mapview/lib/ColorCache.ts","webpack:///../@here/harp-mapview/lib/text/TextElementType.ts","webpack:///../@here/harp-mapview/lib/text/TextElementsRenderer.ts","webpack:///../@here/harp-mapview/lib/PickHandler.ts","webpack:///../@here/harp-mapview/lib/Tile.ts","webpack:///../@here/harp-utils/lib/Logger/ILogger.ts","webpack:///../@here/harp-utils/lib/UrlUtils.ts","webpack:///../@here/harp-mapview/lib/AnimatedExtrusionHandler.ts","webpack:///../@here/harp-materials/lib/MapMeshMaterials.ts","webpack:///../@here/harp-materials/lib/ShaderChunks/LinesChunks.ts","webpack:///../@here/harp-datasource-protocol/lib/Techniques.ts","webpack:///../@here/harp-mapview/lib/DataSource.ts","webpack:///../@here/harp-text-canvas/lib/rendering/GlyphData.ts","webpack:///../@here/harp-lrucache/index.ts","webpack:///../@here/harp-text-canvas/lib/rendering/TextGeometry.ts","webpack:///../@here/harp-text-canvas/lib/utils/TypesettingUtils.ts","webpack:///../@here/harp-mapview/lib/MapViewPoints.ts","webpack:///../@here/harp-mapview/lib/DebugContext.ts","webpack:///../@here/harp-mapview/lib/geometry/TileGeometryLoader.ts","webpack:///../@here/harp-mapview/lib/ConcurrentDecoderFacade.ts","webpack:///../@here/harp-mapview/lib/copyrights/CopyrightInfo.ts","webpack:///../@here/harp-lines/lib/HighPrecisionUtils.ts","webpack:///../@here/harp-omv-datasource/lib/OmvDecoderDefs.ts","webpack:///../@here/harp-omv-datasource/lib/OmvTile.ts","webpack:///../@here/harp-utils/lib/Logger/ConsoleChannel.ts","webpack:///../@here/harp-utils/lib/Logger/Logger.ts","webpack:///../@here/harp-materials/lib/CopyMaterial.ts","webpack:///../@here/harp-datasource-protocol/lib/Env.ts","webpack:///../@here/harp-datasource-protocol/lib/StringEncodedNumeral.ts","webpack:///../@here/harp-datasource-protocol/lib/TechniqueParams.ts","webpack:///../@here/harp-datasource-protocol/lib/TechniqueDescriptor.ts","webpack:///../@here/harp-datasource-protocol/lib/DecodedTile.ts","webpack:///../@here/harp-geoutils/lib/coordinates/GeoCoordinatesLike.ts","webpack:///../@here/harp-geoutils/lib/coordinates/GeoPointLike.ts","webpack:///../@here/harp-geoutils/lib/coordinates/LatLngLike.ts","webpack:///../@here/harp-geoutils/lib/projection/EquirectangularProjection.ts","webpack:///../@here/harp-geoutils/lib/projection/TransverseMercatorProjection.ts","webpack:///../@here/harp-geoutils/lib/tiling/FlatTileBoundingBoxGenerator.ts","webpack:///../@here/harp-geoutils/lib/tiling/HalfQuadTreeSubdivisionScheme.ts","webpack:///../@here/harp-geoutils/lib/tiling/SubTiles.ts","webpack:///../@here/harp-geoutils/lib/tiling/TileKeyUtils.ts","webpack:///../@here/harp-geoutils/lib/tiling/TileTreeTraverse.ts","webpack:///../@here/harp-datasource-protocol/lib/StyleSetEvaluator.ts","webpack:///../@here/harp-text-canvas/lib/rendering/TextMaterials.ts","webpack:///../@here/harp-text-canvas/lib/rendering/TextBufferObject.ts","webpack:///../@here/harp-text-canvas/lib/utils/MaterialUtils.ts","webpack:///../@here/harp-mapview/lib/ThemeHelpers.ts","webpack:///../@here/harp-mapview/lib/DepthPrePass.ts","webpack:///../@here/harp-mapview/lib/RoadPicker.ts","webpack:///../@here/harp-mapview/lib/poi/PoiRenderer.ts","webpack:///../@here/harp-mapview/lib/poi/Poi.ts","webpack:///../@here/harp-mapview/lib/text/Placement.ts","webpack:///../@here/harp-mapview/lib/text/TextStyleCache.ts","webpack:///../@here/harp-mapview/lib/CameraMovementDetector.ts","webpack:///../@here/harp-mapview/lib/ClipPlanesEvaluator.ts","webpack:///../@here/harp-mapview/lib/composing/index.ts","webpack:///../@here/harp-mapview/lib/composing/MSAARenderPass.ts","webpack:///../@here/harp-mapview/lib/ConcurrentWorkerSet.ts","webpack:///../@here/harp-mapview/lib/workers/WorkerLoader.ts","webpack:///../@here/harp-mapview/lib/WorkerBasedDecoder.ts","webpack:///../@here/harp-mapview/lib/ElevationRangeSource.ts","webpack:///../@here/harp-mapview/lib/geometry/TileGeometryManager.ts","webpack:///../@here/harp-mapview/lib/image/MapViewImageCache.ts","webpack:///../@here/harp-mapview/lib/image/ImageCache.ts","webpack:///../@here/harp-mapview/lib/MapViewFog.ts","webpack:///../@here/harp-mapview/lib/poi/PoiManager.ts","webpack:///../@here/harp-mapview/lib/poi/PoiTableManager.ts","webpack:///../@here/harp-mapview/lib/PolarTileDataSource.ts","webpack:///../node_modules/rbush/rbush.min.js","webpack:///../@here/harp-mapview/lib/SkyCubemapTexture.ts","webpack:///../@here/harp-mapview/lib/ThemeLoader.ts","webpack:///../@here/harp-mapview/lib/VisibleTileSet.ts","webpack:///../@here/harp-mapview/lib/ConcurrentTilerFacade.ts","webpack:///../@here/harp-mapview/lib/WorkerBasedTiler.ts","webpack:///../@here/harp-mapview/lib/copyrights/CopyrightCoverageProvider.ts","webpack:///../@here/harp-transfer-manager/index.ts","webpack:///../@here/harp-mapview/lib/geometry/TileGeometry.ts","webpack:///../@here/harp-lines/lib/TriangulateLines.ts","webpack:///../@here/harp-lines/lib/HighPrecisionLines.ts","webpack:///../@here/harp-mapview-decoder/lib/TileLoader.ts","webpack:///../@here/harp-omv-datasource/lib/OmvRestClient.ts","webpack:///./index.ts","webpack:///./WorkerMapViewFacade.ts","webpack:///../@here/harp-utils/lib/GroupedPriorityList.ts","webpack:///../@here/harp-utils/lib/Logger/index.ts","webpack:///../@here/harp-utils/lib/Logger/LoggerManager.ts","webpack:///../@here/harp-utils/lib/Logger/LoggerManagerImpl.ts","webpack:///../@here/harp-utils/lib/Logger/MultiChannel.ts","webpack:///../@here/harp-utils/lib/Logger/WorkerChannel.ts","webpack:///../@here/harp-utils/lib/Math2D.ts","webpack:///../@here/harp-utils/lib/MathUtils.ts","webpack:///../@here/harp-utils/lib/Mixins.ts","webpack:///../@here/harp-utils/lib/assert.ts","webpack:///../@here/harp-utils/lib/ContextLogger.ts","webpack:///../@here/harp-utils/lib/PerformanceTimer.ts","webpack:///../@here/harp-utils/lib/ObjectUtils.ts","webpack:///../@here/harp-utils/lib/OptionsUtils.ts","webpack:///../@here/harp-utils/lib/UriResolver.ts","webpack:///../@here/harp-utils/lib/UrlPlatformUtils.web.ts","webpack:///../@here/harp-utils/lib/Functions.ts","webpack:///../node_modules/events/events.js","webpack:///./map.ts","webpack:///../@here/harp-materials/lib/CirclePointsMaterial.ts","webpack:///../@here/harp-materials/lib/EdgeMaterial.ts","webpack:///../@here/harp-materials/lib/ShaderChunks/ExtrusionChunks.ts","webpack:///../@here/harp-materials/lib/ShaderChunks/FadingChunks.ts","webpack:///../@here/harp-materials/lib/HighPrecisionLineMaterial.ts","webpack:///../@here/harp-materials/lib/HighPrecisionPointMaterial.ts","webpack:///../@here/harp-materials/lib/IconMaterial.ts","webpack:///../@here/harp-materials/lib/LuminosityHighPassShader.ts","webpack:///../@here/harp-materials/lib/MSAAMaterial.ts","webpack:///../@here/harp-materials/lib/SepiaShader.ts","webpack:///../@here/harp-materials/lib/SolidLineMaterial.ts","webpack:///../@here/harp-materials/lib/VignetteShader.ts","webpack:///../@here/harp-datasource-protocol/lib/ExprEvaluator.ts","webpack:///../@here/harp-datasource-protocol/lib/operators/ArrayOperators.ts","webpack:///../@here/harp-datasource-protocol/lib/operators/CastOperators.ts","webpack:///../@here/harp-datasource-protocol/lib/operators/ColorOperators.ts","webpack:///../@here/harp-datasource-protocol/lib/operators/ComparisonOperators.ts","webpack:///../@here/harp-datasource-protocol/lib/operators/FeatureOperators.ts","webpack:///../@here/harp-datasource-protocol/lib/operators/FlowOperators.ts","webpack:///../@here/harp-datasource-protocol/lib/operators/InterpolationOperators.ts","webpack:///../@here/harp-datasource-protocol/lib/ExponentialInterpolant.ts","webpack:///../@here/harp-datasource-protocol/lib/operators/MapOperators.ts","webpack:///../@here/harp-datasource-protocol/lib/operators/MathOperators.ts","webpack:///../@here/harp-datasource-protocol/lib/operators/MiscOperators.ts","webpack:///../@here/harp-datasource-protocol/lib/operators/ObjectOperators.ts","webpack:///../@here/harp-datasource-protocol/lib/operators/StringOperators.ts","webpack:///../@here/harp-datasource-protocol/lib/operators/TypeOperators.ts","webpack:///../@here/harp-datasource-protocol/lib/ExprInstantiator.ts","webpack:///../@here/harp-datasource-protocol/lib/ExprParser.ts","webpack:///../@here/harp-datasource-protocol/lib/WorkerServiceProtocol.ts","webpack:///../@here/harp-datasource-protocol/lib/WorkerTilerProtocol.ts","webpack:///../@here/harp-datasource-protocol/lib/WorkerDecoderProtocol.ts","webpack:///../@here/harp-geoutils/lib/projection/IdentityProjection.ts","webpack:///../@here/harp-geoutils/lib/projection/SphereProjection.ts","webpack:///../@here/harp-geoutils/lib/tiling/QuadTree.ts","webpack:///../@here/harp-geoutils/lib/tiling/HereTilingScheme.ts","webpack:///../@here/harp-geoutils/lib/tiling/WebMercatorTilingScheme.ts","webpack:///../@here/harp-geoutils/lib/tiling/MercatorTilingScheme.ts","webpack:///../@here/harp-geoutils/lib/tiling/PolarTilingScheme.ts","webpack:///../@here/harp-geoutils/lib/math/Vector3Like.ts","webpack:///../@here/harp-geoutils/lib/math/TransformLike.ts","webpack:///../@here/harp-geoutils/lib/math/OrientedBox3.ts","webpack:///../@here/harp-datasource-protocol/lib/TileInfo.ts","webpack:///../@here/harp-datasource-protocol/lib/ExprPool.ts","webpack:///../@here/harp-datasource-protocol/lib/TechniqueAttr.ts","webpack:///../@here/harp-datasource-protocol/lib/ThemeVisitor.ts","webpack:///../@here/harp-mapview/lib/BackgroundDataSource.ts","webpack:///../@here/harp-geometry/lib/SphericalGeometrySubdivisionModifier.ts","webpack:///../@here/harp-geometry/lib/SubdivisionModifier.ts","webpack:///../@here/harp-text-canvas/lib/rendering/FontCatalog.ts","webpack:///../@here/harp-text-canvas/lib/rendering/GlyphTextureCache.ts","webpack:///../@here/harp-lrucache/lib/LRUCache.ts","webpack:///../@here/harp-text-canvas/lib/TextCanvas.ts","webpack:///../@here/harp-text-canvas/lib/typesetting/LineTypesetter.ts","webpack:///../@here/harp-text-canvas/lib/typesetting/PathTypesetter.ts","webpack:///../@here/harp-text-canvas/lib/utils/ContextualArabicConverter.ts","webpack:///../@here/harp-mapview/lib/PathBlockingElement.ts","webpack:///../@here/harp-mapview/lib/poi/BoxBuffer.ts","webpack:///../@here/harp-mapview/lib/poi/PixelPicker.ts","webpack:///../@here/harp-mapview/lib/text/PlacementStats.ts","webpack:///../@here/harp-mapview/lib/text/SimplePath.ts","webpack:///../@here/harp-mapview/lib/text/TextElementsRendererOptions.ts","webpack:///../@here/harp-mapview/lib/text/TextElementStateCache.ts","webpack:///../@here/harp-mapview/lib/text/TextElementGroupState.ts","webpack:///../@here/harp-mapview/lib/text/TextElementState.ts","webpack:///../@here/harp-mapview/lib/text/RenderState.ts","webpack:///../@here/harp-mapview/lib/text/UpdateStats.ts","webpack:///../@here/harp-mapview/lib/text/TextElementGroup.ts","webpack:///../@here/harp-mapview/lib/text/TextElementGroupPriorityList.ts","webpack:///../@here/harp-mapview/lib/composing/MapRenderingManager.ts","webpack:///../@here/harp-mapview/lib/composing/LowResRenderPass.ts","webpack:///../@here/harp-mapview/lib/composing/Outline.ts","webpack:///../@here/harp-mapview/lib/composing/UnrealBloomPass.ts","webpack:///../@here/harp-mapview/lib/workers/WorkerBootstrapDefs.ts","webpack:///../@here/harp-mapview/lib/FrustumIntersection.ts","webpack:///../@here/harp-mapview/lib/MapTileCuller.ts","webpack:///../@here/harp-mapview/lib/geometry/overlayOnElevation.ts","webpack:///../@here/harp-mapview/lib/geometry/PhasedTileGeometryManager.ts","webpack:///../@here/harp-mapview/lib/geometry/PhasedTileGeometryLoader.ts","webpack:///../@here/harp-mapview/lib/poi/PoiRendererFactory.ts","webpack:///../@here/harp-datasource-protocol/index-decoder.ts","webpack:///../@here/harp-datasource-protocol/lib/Extruder.ts","webpack:///../@here/harp-datasource-protocol/lib/Outliner.ts","webpack:///../@here/harp-datasource-protocol/lib/ThreeBufferUtils.ts","webpack:///../@here/harp-mapview/lib/ScreenCollisions.ts","webpack:///../@here/harp-mapview/lib/ScreenProjector.ts","webpack:///../@here/harp-mapview/lib/SkyBackground.ts","webpack:///../@here/harp-mapview/lib/SkyGradientTexture.ts","webpack:///../@here/harp-mapview/lib/text/FontCatalogLoader.ts","webpack:///../@here/harp-mapview/lib/text/MapViewState.ts","webpack:///../@here/harp-mapview/lib/text/TextCanvasFactory.ts","webpack:///../@here/harp-mapview/lib/copyrights/CopyrightElementHandler.ts","webpack:///../@here/harp-mapview/lib/copyrights/UrlCopyrightProvider.ts","webpack:///../@here/harp-transfer-manager/src/TransferManager.ts","webpack:///../@here/harp-mapview/lib/image/Image.ts","webpack:///../@here/harp-mapview/lib/geometry/TileDataAccessor.ts","webpack:///../@here/harp-lines/index.ts","webpack:///../@here/harp-lines/lib/Lines.ts","webpack:///../@here/harp-lines/lib/HighPrecisionPoints.ts","webpack:///../@here/harp-omv-datasource/index.ts","webpack:///../@here/harp-omv-datasource/lib/OmvDataFilter.ts","webpack:///../@here/harp-omv-datasource/lib/OmvDataSource.ts","webpack:///../@here/harp-mapview-decoder/index.ts","webpack:///../@here/harp-mapview-decoder/lib/TileDataSource.ts","webpack:///../@here/harp-omv-datasource/lib/OmvDebugLabelsTile.ts","webpack:///../@here/harp-examples/config.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","THREE","exprEvaluator","ExprEvaluator","exprInstantiator","ExprInstantiator","ExprDependencies","properties","Set","ComputeExprDependencies","expr","dependencies","accept","this","instance","context","add","op","args","length","zoom","forEach","childExpr","branches","_","branch","fallback","condition","isJsonExpr","v","Array","isArray","ExprScope","Expr","code","ExprParser","parse","node","definitions","definitionExprCache","parseNode","undefined","lockedNames","cache","Map","env","scope","Value","ExprEvaluatorContext","of","pool","ExprSerializer","serialize","m_isDynamic","exprIsDynamic","VarExpr","super","visitor","visitVarExpr","LiteralExpr","BooleanLiteralExpr","NumberLiteralExpr","StringLiteralExpr","NullLiteralExpr","ObjectLiteralExpr","Error","visitNullLiteralExpr","visitBooleanLiteralExpr","visitNumberLiteralExpr","visitStringLiteralExpr","visitObjectLiteralExpr","HasAttributeExpr","visitHasAttributeExpr","ContainsExpr","elements","elementTy","every","element","visitContainsExpr","isDynamic","CallExpr","visitCallExpr","descriptor","getOperator","isDynamicOperator","some","e","MatchExpr","visitMatchExpr","CaseExpr","visitCaseExpr","cond","map","label","body","push","referenceResolverState","parseCall","slice","has","cachedEntry","result","definitionEntry","isSelectorDefinition","isValueDefinition","isInterpolatedPropertyDefinition","fromJSON","interpolatedPropertyDefinitionToJsonExpr","delete","set","resolveReference","makeCallExpr","parseGetExpr","parseHasExpr","isValidElementsArray","parseInExpr","obj","parseLiteralExpr","conditions","isValidMatchLabel","JSON","stringify","parseMatchExpr","caseFallback","parseCaseExpr","GeoCoordinates","latitude","longitude","altitude","Math","radToDeg","latLng","lat","lng","geoPoint","isGeoPointLike","fromGeoPoint","isGeoCoordinatesLike","fromDegrees","isLatLngLike","degToRad","isNaN","wrapped","sign","other","MathUtils","normalizeAngleDeg","a","angleDistanceDeg","b","newEmptyBox3","min","x","Infinity","y","z","max","newVector3","clamp","interpolateAnglesDeg","p0","p1","logger","LoggerManager","MINIMUM_OBJECT3D_SIZE_ESTIMATION","MINIMUM_ATTRIBUTE_SIZE_ESTIMATION","groundNormalPlanarProj","Vector3","groundPlane","Plane","clone","groundSphere","Sphere","EarthConstants","EQUATORIAL_RADIUS","rayCaster","Raycaster","space","tangentSpace","quaternions","Quaternion","vector3","matrix4","Matrix4","transforms","xAxis","yAxis","zAxis","position","MapViewUtils","orbitFocusPoint","mapView","deltaAzimuthDeg","deltaTiltDeg","maxTiltAngleRad","PI","target","rayCastWorldCoordinates","targetCoordinates","projection","unprojectPoint","sphericalCoordinates","extractSphericalCoordinatesFromLocation","camera","tiltDeg","tilt","lookAt","distanceTo","azimuth","getCameraPositionFromTargetCoordinates","distance","yawDeg","pitchDeg","pitchRad","cos","yawRad","projectPoint","groundDistance","sin","type","ProjectionType","Planar","Spherical","copy","normalize","projectOnPlane","setFromAxisAngle","applyQuaternion","setLength","height","cameraHeight","sqrt","pointOnScreenXinNDC","pointOnScreenYinNDC","elevation","pointInNDCPosition","extractRotation","matrixWorld","multiplyMatrices","getInverse","projectionMatrix","pointInCameraSpace","applyMatrix4","constant","worldPosition","ray","intersectPlane","intersectSphere","panCameraAboveFlatMap","offsetX","offsetY","panCameraAroundGlobe","fromWorld","toWorld","setFromUnitVectors","inverse","makeRotationFromQuaternion","applyMatrix","updateMatrixWorld","getCameraRotationAtTarget","transform","localTangentSpace","makeBasis","setFromRotationMatrix","multiply","extractAttitude","setFromMatrixPosition","setFromMatrixColumn","yaw","pitch","roll","dot","atan2","acos","location","sub","angleTo","cross","calculateDistanceToGroundFromZoomLevel","zoomLevel","cameraPitch","tileSize","EQUATORIAL_CIRCUMFERENCE","pow","focalLength","estimateTextureSize","texture","objectSize","visitedObjects","image","uuid","imageBytes","width","heapSize","gpuSize","estimateMaterialSize","material","RawShaderMaterial","ShaderMaterial","rawMaterial","uniforms","uniform","Texture","MeshBasicMaterial","MapMeshBasicMaterial","meshMaterial","aoMap","specularMap","alphaMap","envMap","MapMeshStandardMaterial","standardMaterial","lightMap","emissiveMap","bumpMap","normalMap","displacementMap","roughnessMap","metalnessMap","LineBasicMaterial","LineDashedMaterial","warn","estimateAttributeSize","attribute","attrName","generateUUID","attrBytes","bytesPerElement","array","BYTES_PER_ELEMENT","InterleavedBufferAttribute","BufferAttribute","count","itemSize","getIsoLanguageCode","language","substring","zoomOnTargetPosition","targetPositionOnScreenXinNDC","targetPositionOnScreenYinNDC","maxTiltAngle","targetPosition","zoomDistance","setZ","centerScreenTarget","deltaTilt","newTargetPosition","getCameraCoordinatesFromTargetCoordinates","rotate","deltaYawDeg","deltaPitchDeg","rotateOnWorldAxis","newPitch","maxPitch","asin","rotateX","setRotation","geoCenter","quaternion","getCameraFrustumPlanes","near","far","top","tan","fov","aspect","left","view","enabled","fullWidth","fullHeight","filmOffset","getFilmWidth","right","bottom","rayCastGeoCoordinates","worldCoordinates","calculateZoomLevelFromDistance","log2","minZoomLevel","maxZoomLevel","round","calculateDepthFromClipDistance","clipDistance","perspCam","cameraRange","viewSpaceDistance","cameraToWorldDistance","calculateVerticalFovByHorizontalFov","hFov","atan","calculateHorizontalFovByVerticalFov","vFov","calculateFocalLengthByVerticalFov","calculateFovByFocalLength","calculateScreenSizeByFocalLength","worldSize","calculateWorldSizeByFocalLength","screenSize","estimateObject3dSize","parentSize","size","isObject3D","Scene","isMesh","isLine","isPoints","mesh","materials","geometry","bufferGeometry","Geometry","vertices","faces","_bufferGeometry","BufferGeometry","attributes","index","estimateGeometrySize","featureData","userData","feature","getFeatureDataSize","estimateMeshSize","children","child","mapViewIsLoading","numTilesLoading","tileList","visibleTileSet","dataSourceTileList","tile","visibleTiles","tileLoader","isFinished","tileGeometryLoader","isLoading","textElementsRenderer","loading","poiTableManager","finishedLoading","allVisibleTilesLoaded","getBrowserLanguages","navigator","languages","languageList","lang","powerOfTwo","TileOffsetUtils","getKeyForTileKeyAndOffset","tileKey","offset","bitshift","shiftedOffset","offsetBits","totalOffsetsToStore","assert","getShiftedOffset","mortonCode","extractOffsetAndMortonKeyFromKey","num","getParentKeyFromKey","calculatedKey","TileKey","fromMortonCode","parentMortonCode","MIN_ELEVATION","MAX_ELEVATION","MAX_BUILDING_HEIGHT","box3","obb","extents","unitScale","sourceProjection","worldPos","FontUnit","FontStyle","FontVariant","VerticalAlignment","HorizontalAlignment","WrappingMode","DefaultTextStyle","DEFAULT_FONT_NAME","DEFAULT_FONT_SIZE","unit","freeze","Pixel","backgroundSize","DEFAULT_FONT_STYLE","Regular","DEFAULT_FONT_VARIANT","DEFAULT_ROTATION","DEFAULT_COLOR","Color","DEFAULT_OPACITY","DEFAULT_BACKGROUND_COLOR","DEFAULT_BACKGROUND_OPACITY","DEFAULT_TRACKING","DEFAULT_LEADING","DEFAULT_MAX_LINES","DEFAULT_LINE_WIDTH","DEFAULT_CANVAS_ROTATION","DEFAULT_LINE_ROTATION","DEFAULT_WRAPPING_MODE","Word","DEFAULT_VERTICAL_ALIGNMENT","Above","DEFAULT_HORIZONTAL_ALIGNMENT","Left","TextRenderStyle","params","m_params","fontName","fontSize","fontStyle","fontVariant","rotation","color","opacity","backgroundColor","backgroundOpacity","TextLayoutStyle","tracking","leading","maxLines","lineWidth","canvasRotation","lineRotation","wrappingMode","verticalAlignment","horizontalAlignment","enableBlending","transparent","forcedBlending","blending","CustomBlending","premultipliedAlpha","blendSrc","OneFactor","blendDst","OneMinusSrcAlphaFactor","blendSrcAlpha","blendDstAlpha","SrcAlphaFactor","shaderContent","shaderName","insertedShaderName","addTab","tabChar","replace","NormalBlending","SHIFT_TRANSPARENCY","SHIFT_RED","SHIFT_GREEN","SHIFT_BLUE","HEX_FULL_CHANNEL","HEX_RGB_MASK","HEX_TRGB_MASK","tmpColor","ColorUtils","getHexFromRgba","g","floor","getHexFromRgb","getHexFromHsl","h","setHSL","getHex","getRgbaFromHex","hex","toString","hasAlphaInHex","getAlphaFromHex","removeAlphaFromHex","interpolants","DiscreteInterpolant","LinearInterpolant","CubicInterpolant","ExponentialInterpolant","tmpBuffer","StringEncodedNumeralFormatMaxSize","isInterpolatedProperty","interpolationMode","zoomLevels","Float32Array","values","dynamicPropertiesTempEnv","MapEnv","$zoom","$pixelToMeters","getInterpolatedMetric","level","pixelToMeters","nChannels","interpolant","InterpolationMode","Exponential","exponent","evaluate","_stringEncodedNumeralDynamicMask","resultBuffer","maskInterpolant","envOrLevel","isExpr","entries","Dynamic","lookup","parseStringEncodedNumeral","_stringEncodedNumeralType","StringEncodedNumeralType","Meters","Pixels","Hex","RGB","RGBA","HSL","getInterpolatedColor","prop","isCubic","interpolation","findIndex","abs","splice","removeDuplicatePropertyValues","Discrete","firstValue","matchedFormat","StringEncodedNumeralFormats","find","format","regExp","test","error","needsMask","propValues","maskValues","baseFormat","allowedValueFormats","StringEncodedMetricFormats","StringEncodedColorFormats","valueIdx","matched","valueFormat","decoder","mask","procesStringEnocodedNumeralInterpolatedProperty","GeoBox","southWest","northEast","south","north","west","east","minAltitude","altitudeSpan","latitudeSpan","longitudeSpan","maxAltitude","point","containsHelper","isFlat","isSameAltitude","isWithinAltitudeRange","subdivisionScheme","boundingBoxGenerator","FlatTileBoundingBoxGenerator","tileTreeTraverse","TileTreeTraverse","subTiles","TileKeyUtils","geoCoordinatesToTileKey","geoBox","geoRectangleToTileKeys","getGeoBox","getWorldBox","UnicodeUtils","Direction","whiteSpaceRanges","isWhiteSpace","codePoint","range","newLineRanges","isNewLine","nonPrintableRanges","isPrintable","rtlBlocks","neutralBidirectionalRanges","weakBidirectionalRanges","getDirection","block","weakRange","Weak","neutralRange","Neutral","RTL","LTR","rtlMirroredCodePoints","isRtlMirrored","DEFAULT_SKIP_PROPERTIES","TEXTURE_PROPERTY_KEYS","getMaterialConstructor","technique","isExtrudedLineTechnique","shading","SolidLineMaterial","PointsMaterial","CirclePointsMaterial","applyTechniquePropertyToMaterial","propertyName","techniqueAttrValue","applySecondaryColorToMaterial","evaluateProperty","materialColor","techniqueColor","evaluateColorProperty","setHex","applyBaseColorToMaterial","colorValue","tech","setRGB","disableBlending","getPropertyValue","parsed","parseStringEncodedColor","getBaseColorPropName","techDescriptor","techniqueDescriptors","attrTransparencyColor","options","textureReadyCallback","Constructor","settings","fog","id","isExtrudedPolygonTechnique","flatShading","vertexColors","depthTest","isStandardTechnique","isTerrainTechnique","texturePropertyName","textureProperty","onLoad","wrapS","toWrappingMode","wrapT","magFilter","toTextureFilter","minFilter","flipY","repeatU","repeat","repeatV","needsUpdate","onError","textureUrl","isTextureBuffer","dataTextureProperties","textureDataType","toTextureDataType","textureBuffer","buffer","Uint8Array","UnsignedByteType","ByteType","Int8Array","ShortType","Int16Array","UnsignedShortType","Uint16Array","IntType","Int32Array","UnsignedIntType","Uint32Array","FloatType","HalfFloatType","getTextureBuffer","DataTexture","toPixelFormat","textureBlob","Blob","URL","createObjectURL","TextureLoader","load","isShaderTechnique","baseColorPropName","hasBaseColor","getOwnPropertyNames","filter","TRANSPARENCY_PROPERTY_KEYS","indexOf","propColor","applyShaderTechniqueToMaterial","skipExtraProps","startsWith","BASE_TECHNIQUE_NON_MATERIAL_PROPS","applyTechniqueToMaterial","itemCount","normalized","Mesh","Circles","Squares","LineSegments","primitive","Line","Points","baseColorProp","getBaseColorProp","poiInfo","poiRenderBatch","LoadingState","text","points","renderParams","layoutParams","priority","xOffset","yOffset","featureId","style","fadeNear","fadeFar","tileOffset","visible","distanceScale","renderOrder","renderStyle","layoutStyle","TextElementType","PoiLabel","PathLabel","mayOverlap","reserveSpace","m_poiInfo","path","LineMarker","poiRenderOrder","m_renderStyle","m_layoutStyle","min2","iconMinZoomLevel","textMinZoomLevel","max2","iconMaxZoomLevel","textMaxZoomLevel","RingBuffer","capacity","head","tail","data","next","enqOne","previous","Iterator","m_buffer","m_index","SimpleTimer","statistics","running","m_currentValue","val","PerformanceTimer","now","setValue","SampledTimer","numResets","maxNumSamples","samples","reset","getStats","clear","computeArrayStats","asArray","sort","median","median75","median90","median95","median97","median99","median999","mid","sum","avg","numSamples","stages","stage","hasTimer","getTimer","currentStage","stop","start","timers","nullTimer","keepSamples","timer","addTimer","header","footer","log","maxNameLength","print","toFixed","simpleStats","FrameStats","messages","oldValue","message","FrameStatsArray","frameEntries","frameStats","currentSize","enq","PerformanceStatistics","maxNumFrames","currentFrame","appResults","configs","m_instance","m_frameEvents","clearFrames","webGlInfo","render","calls","lines","triangles","memory","geometries","textures","programs","window","performance","totalJSHeapSize","usedJSHeapSize","jsHeapSizeLimit","addFrame","onlyLastFrame","frames","plainObject","getAsPlainObject","simpleStatistics","Pass","renderToScreen","renderer","scene","writeBuffer","readBuffer","delta","setRenderTarget","shader","textureID","UniformsUtils","defines","vertexShader","fragmentShader","fsQuad","FullScreenQuad","m_camera","OrthographicCamera","PlaneBufferGeometry","m_mesh","isProduction","MapViewEventNames","setLogLevelForAll","LogLevel","Log","DEFAULT_CLEAR_COLOR","DEFAULT_FOV_CALCULATION","DEFAULT_CAM_NEAR_PLANE","DEFAULT_CAM_FAR_PLANE","MAX_FIELD_OF_VIEW","MIN_FIELD_OF_VIEW","FALLBACK_RENDER_ORDER_OFFSET","DEFAULT_MIN_ZOOM_LEVEL","DEFAULT_MAX_ZOOM_LEVEL","DEFAULT_MIN_CAMERA_HEIGHT","FRAME_RATE_RING_SIZE","FALLBACK_FRAME_RATE","TERRAIN_ZOOM_LEVEL","DEFAULT_POLAR_STYLE_SET_NAME","UPDATE","Update","RENDER_EVENT","Render","DID_RENDER_EVENT","AfterRender","FIRST_FRAME_EVENT","FirstFrame","FRAME_COMPLETE_EVENT","FrameComplete","THEME_LOADED_EVENT","ThemeLoaded","ANIMATION_STARTED_EVENT","AnimationStarted","ANIMATION_FINISHED_EVENT","AnimationFinished","MOVEMENT_STARTED_EVENT","MovementStarted","MOVEMENT_FINISHED_EVENT","MovementFinished","CONTEXT_LOST_EVENT","ContextLost","CONTEXT_RESTORED_EVENT","ContextRestored","COPYRIGHT_CHANGED_EVENT","CopyrightChanged","vector2","Vector2","MapViewPowerPreference","MapViewDefaults","mercatorProjection","maxVisibleDataSourceTiles","extendedFrustumCulling","tileCacheSize","resourceComputationType","ResourceComputationType","EstimationInMb","quadTreeSearchDistanceUp","quadTreeSearchDistanceDown","pixelRatio","devicePixelRatio","heading","MapView","EventDispatcher","dumpNext","m_renderLabels","m_screenCollisions","ScreenCollisions","m_visibleTileSetLock","m_tileWrappingEnabled","m_zoomLevel","m_minZoomLevel","m_maxZoomLevel","m_minCameraHeight","m_screenCamera","m_rteCamera","PerspectiveCamera","m_viewRanges","minimum","maximum","m_scene","m_fog","MapViewFog","m_mapTilesRoot","Object3D","m_mapAnchors","m_animationCount","m_drawing","m_updatePending","m_frameNumber","m_maxFps","m_detectedFps","m_forceCameraAspect","m_tileDataSources","m_connectedDataSources","m_failedDataSources","m_enablePolarDataSource","m_raycaster","m_plane","m_sphere","m_theme","m_themeIsLoading","m_firstFrameRendered","m_firstFrameComplete","m_initialTextPlacementDone","m_frameTimeIndex","m_frameTimeRing","m_imageCache","MapViewImageCache","m_poiManager","PoiManager","m_poiTableManager","PoiTableManager","m_lastTileIds","m_copyrightInfo","onWebGLContextLost","event","dispatchEvent","onWebGLContextRestored","m_renderer","clearColor","setClearColor","update","m_options","m_uriResolver","uriResolver","minCameraHeight","decoderUrl","ConcurrentDecoderFacade","defaultScriptUrl","resolveUri","decoderCount","defaultWorkerCount","m_visibleTileSetOptions","clipPlanesEvaluator","createDefaultClipPlanesEvaluator","enablePolarDataSource","m_pixelRatio","maxFps","enableStatistics","m_languages","collisionDebugCanvas","m_collisionDebugCanvas","ScreenCollisionsDebug","handleRequestAnimationFrame","renderFunc","handlePostponedAnimationFrame","postponedAnimationFrame","m_pickHandler","PickHandler","enableRoadPicking","tileWrappingEnabled","setupStats","canvas","addEventListener","WebGLRenderer","antialias","nativeWebglAntialiasEnabled","alpha","preserveDrawingBuffer","powerPreference","Default","autoClear","localClippingEnabled","info","autoReset","setupRenderer","fovCalculation","getCanvasClientSize","up","m_lookAtDistance","m_focalLength","m_screenProjector","ScreenProjector","setupCamera","m_movementDetector","CameraMovementDetector","movementThrottleTimeout","movementStarted","movementFinished","mapPassAntialiasSettings","customAntialiasSettings","mapRenderingManager","MapRenderingManager","dynamicPixelRatio","m_tileGeometryManager","enablePhasedLoading","PhasedTileGeometryManager","SimpleTileGeometryManager","m_visibleTiles","VisibleTileSet","FrustumIntersection","m_animatedExtrusionHandler","AnimatedExtrusionHandler","m_backgroundDataSource","BackgroundDataSource","addDataSource","styleSetName","polarStyleSetName","m_polarDataSource","PolarTileDataSource","geometryLevelOffset","polarGeometryLevelOffset","updatePolarDataSource","backgroundTilingScheme","setTilingScheme","initTheme","m_textElementsRenderer","createTextRenderer","drawFrame","m_movementFinishedUpdateTimerId","clearTimeout","m_animationFrameHandle","cancelAnimationFrame","removeEventListener","dataSource","dispose","clearTileCache","clearRenderStates","getDataSourceCacheSize","numVisibleTiles","setDataSourceCacheSize","setNumberOfVisibleTiles","updateImages","updateLighting","invalidateCache","updateSkyBackground","m_pointOfView","pointOfView","postEffectsFile","fetch","then","response","json","postEffects","m_postEffects","setPostEffects","theme","ThemeLoader","isThemeLoaded","loadedTheme","catch","sky","lights","images","imageTextures","poiTables","loadPoiTables","textStyles","defaultTextStyle","fontCatalogs","resetTextRenderer","styles","setTheme","fps","setLanguages","disable","disableFading","m_previousFrameTimeStamp","listener","rendererClearColor","getClearColor","targetDistance","attitude","headingDeg","enableNativeWebglAntialias","calculateFocalLength","getSize","updateCameras","dataSourceName","ds","ready","getDataSourceByName","attach","setEnableElevationOverlay","m_elevationProvider","updateStorageLevelOffset","connect","Promise","resolve","resolveOnce","DataSourceConnect","dsIndex","detach","removeDataSource","textElements","addOverlayText","clearOverlayText","limitedTilt","geoPos","limitedPitch","maxPitchRadWithCurvature","maxPitchDegWithCurvature","time","Date","cameraIsMoving","animating","isAnimating","m_pixelToWorld","lookAtDistance","pixelToWorld","getPixelRatio","setPixelRatio","ratio","lowResPixelRatio","project","setFromCamera","getNormalizedScreenCoordinates","getWorldPositionAt","intersectMapObjects","setSize","Resize","clearCache","fun","forEachVisibleTile","forEachCachedTile","markTilesDirty","elevationSource","elevationRangeSource","elevationProvider","m_elevationRangeSource","dataSources","setTileUpdateCallback","overlayOnElevation","bloom","outline","vignette","sepia","updateOutline","twinDataSource","viewRanges","setFovOnCamera","maxGeometryHeightScaled","getScaleFactor","reduce","maxGeometryHeight","assign","updateClipPlanes","updateProjectionMatrix","setScalar","cameraPosZ","getCameraHeightAboveTerrain","zoomLevelDistance","heightAboveTerrain","getHeight","unprojectAltitude","m_previousRequestAnimationTime","currentFps","capturedFrames","synchronousRendering","requestAnimationFrame","vSyncFrameTime","frameInterval","previousFrameTime","targetTime","m_targetRequestAnimationTime","detectCurrentFps","enabledDataSources","isDataSourceEnabled","stats","gatherStatistics","frameStartTime","currentFrameEvent","setupTime","cullTime","textPlacementTime","drawTime","textDrawTime","endTime","timeSincePreviousFrame","m_thisFrameTilesChanged","remove","lockVisibleTileSet","viewRangesStatus","updateRenderList","storageLevel","getEnabledTileDataSources","viewRangesChanged","renderList","renderedTiles","renderTileObjects","frameNumLastVisible","isDynamicFrame","initializing","childObject","geoPosition","addValue","checkCameraMoved","CameraPositionChanged","renderLabels","prepareRenderTextElements","m_skyBackground","updateCamera","finishRenderTextElements","disposePendingTiles","checkCopyrightUpdates","storeFrameInfo","worldOffsetX","computeWorldOffsetX","willRender","objects","center","displacement","setRotationFromMatrix","boundingBox","getRotationMatrix","frustumCulled","_backupRenderOrder","isBuilding","kind","includes","GeometryKind","Building","levelOffset","didRender","placeText","renderText","themeName","defaultGeoCenter","setInitialCameraPosition","resize","fromObject","getOptionValue","SkyBackground","updateSkyBackgroundColors","addNewSkyBackground","removeSkyBackGround","groundColor","background","updateTexture","m_createdLights","light","lightDescription","createLight","setTimeout","tileIdList","newTileIds","join","checkIfTilesChanged","newCopyrightInfo","getRenderedTilesCopyrightInfo","allEqual","tileCopyrightInfo","copyrightInfo","CopyrightInfo","mergeArrays","poiManager","keys","addImage","url","preload","atlas","addTextureAtlas","imageTexture","addImageTexture","enable","TextElementsRenderer","MapViewState","TextCanvasFactory","PoiRendererFactory","FontCatalogLoader","overlayText","limitFov","clientWidth","clientHeight","step","def","valueDef","styleDef","MercatorProjection","Projection","MercatorConstants","MAXIMUM_LATITUDE","latitudeProject","latitudeClamp","exp","worldPoint","cosh","geoPointLike","latitudeClampProject","latitudeInRadians","fromRadians","unprojectLatitude","worldCenter","worldNorth","worldSouth","worldYCenter","isBox3Like","isOrientedBox3Like","Number","EPSILON","worldBox","minGeo","maxGeo","fromCoordinates","_worldPoint","normal","webMercatorProjection","reprojectPoint","sy","projectBox","maxY","quadTreeSubdivisionScheme","row","column","quadkey","parseInt","charAt","fromRowColumnLevel","quadKey64","quadKey","m_mortonCode","quadkey64","m_hereTile","coordX","coordY","totalWidth","totalHeight","rowsAtLevel","columnsAtLevel","changedLevelBy","col","qnr","subQuad","fromQuadKey","fromHereTile","msb","SORT_WEIGHT_PATH_LENGTH","TileGeometryCreator","clippingPlanes","decodedTile","enabledKinds","disabledKinds","techniques","GeometryKindSet","hasOrIntersects","srcGeometry","group","groups","createdOffsets","createObjects","preparePois","createTextElements","isPoiTechnique","isLineMarkerTechnique","isTextTechnique","createLabelRejectionElements","addGroundPlane","pathGeometries","addBlockingElement","PathBlockingElement","TileGeometryLoader","setDefaultGeometryKind","initDecodedTile","geometryKind","from","resetVisibilityCounter","textPathGeometries","textFilter","processedPaths","newPaths","textPath","pop","displayZoomLevel","prepareTextPaths","maxPathLengthSqr","pathLengthSqr","objInfos","getFeatureId","textElement","TextElement","ContextualArabicConverter","convert","styleCache","getRenderStyle","getLayoutStyle","DEFAULT_TEXT_DISTANCE_SCALE","addTextElement","textGeometries","stringCatalog","positions","numPositions","getX","getY","getZ","texts","techniqueFilter","groupCount","groupIndex","techniqueIndex","ObjectCtor","getObjectConstructor","onMaterialUpdated","requestUpdate","addOwnedTexture","createMaterial","setupTerrainMaterial","vertexAttributes","vertexAttribute","getBufferAttribute","setAttribute","interleavedVertexAttributes","attr","ArrayCtor","getArrayConstructor","InterleavedBuffer","stride","interleavedAttr","setIndex","getAttribute","needsVertexNormals","computeVertexNormals","addGroup","isSolidLineTechnique","lineMaterial","clipping","TILE_CLIP","USE_COLOR","caps","LineCapsDefinitions","hasSolidLinesOutlines","secondaryWidth","renderOrderOffset","geometryId","isFillTechnique","onBeforeRender","chainCallbacks","_renderer","_scene","_camera","_geometry","_material","worldExtent","expandFactor","planes","rightConstant","leftConstant","topConstant","bottomConstant","isCirclesTechnique","isSquaresTechnique","enablePicking","enableRayTesting","isLineTechnique","isSegmentsTechnique","fadingParams","getFadingParams","FadingFeature","addRenderHelper","mat","unitFactor","metricUnit","outlineWidth","dashSize","gapSize","extrudedMaterial","addFeatureData","addGeometryObjInfos","hasDynamicColor","emissive","polygonMaterial","standardMat","extrudedObjects","animatedExtrusionHandler","extrusionAnimationEnabled","animateExtrusionValue","animateExtrusion","forceEnabled","isRenderDepthPrePassEnabled","depthPassMesh","createDepthPrePassMesh","registerTileObject","materialFeature","setDepthPrePassStencil","edgeIndex","edgeGeometry","colorAttribute","extrusionAttribute","normalAttribute","uvAttribute","extrudedPolygonTechnique","getPolygonFadingParams","materialParams","colorMix","lineFadeNear","lineFadeFar","edgeMaterial","EdgeMaterial","edgeObj","lineColor","extrusionAnimationDuration","animateExtrusionDuration","duration","animatedExtrusionTileHandler","AnimatedExtrusionTileHandler","outlineGeometry","fillTechnique","outlineMaterial","outlineObj","outlineTechnique","outlineColor","ColorCache","getColor","secondaryColor","diffuse","secondaryCaps","secondaryRenderOrder","techniqueLineWidth","techniqueSecondaryWidth","techniqueOpacity","poiGeometries","addPois","tmpV","getTilingScheme","posAttr","toArray","SphericalGeometrySubdivisionModifier","modify","depthWrite","Background","createPlane","terrainColor","onBeforeCompile","planeCenter","colorHex","isVisible","PlaneGeometry","plane","geometryType","starts","featureStarts","tileDisplacementMap","xCountVertices","yCountVertices","LuminanceFormat","DEFAULT_FADE_NEAR","DEFAULT_FADE_FAR","DEFAULT_COLOR_MIX","lineColorMix","m_map","colorCode","padStart","MAX_INITIALIZED_TEXT_ELEMENTS_PER_FRAME","OVERLOAD_LABEL_LIMIT","OVERLOAD_UPDATED_LABEL_LIMIT","OVERLOAD_UPDATE_TIME_LIMIT","OVERLOAD_PLACE_TIME_LIMIT","MIN_AVERAGE_CHAR_WIDTH","PRINT_LABEL_DEBUG_INFO","updateStats","UpdateStats","placementStats","PlacementStats","tempBox","Box2","tempBoxes","tempBox2D","Math2D","Box","tempPosition","tempScreenPosition","tempScreenPoints","tempPoiScreenPosition","tempTextOffset","tmpTextBufferCreationParams","TileTextElements","TextElementLists","lists","list","isPlacementTimeExceeded","startTime","debug","m_viewState","m_viewCamera","m_viewUpdateCallback","m_textCanvasFactory","m_poiRendererFactory","m_fontCatalogLoader","m_initialized","m_glyphLoadingCount","m_initializedTextElementCount","m_textRenderers","m_tmpVector","m_overloaded","m_cacheInvalidated","m_forceNewLabelsPass","m_textElementStateCache","TextElementStateCache","m_textStyleCache","TextStyleCache","initializeDefaultOptions","setGlyphCountLimits","minNumGlyphs","maxNumGlyphs","initialized","updateGlyphDebugMesh","textRenderer","textCanvas","tileTextElementsChanged","textElementsChanged","checkIfTextElementsChanged","textElementsAvailable","hasOverlayText","initialize","updateTextElements","renderedTilesChanged","frameNumber","clearVisited","findReplacements","anyTextGroupEvicted","prepopulateScreenWithBlockingElements","placeNewTextElements","placeTextElements","placeOverlayTextElements","updateTextRenderers","m_overlayTextElements","concat","screenPosition","pickResults","pickHandler","pickData","pickObjectType","isDuplicate","pickResult","pickText","PickObjectType","Text","poiRenderer","pickTextElements","Icon","waitInitialized","m_loadPromise","memoryUsage","getMemoryUsage","m_initPromise","initializeDefaultAssets","initializeTextCanvases","boxes","renderListEntry","startLinePointProj","endLinePointProj","pathBlockingElement","blockingElements","project3","line","screenSpaceLines","end","lineWithBound","minX","maxX","minY","allocateIBoxes","groupState","maxNumPlacedLabels","pass","visited","shieldGroups","temp","additionParams","poiMeasurementParams","measurementParams","bufferAdditionParams","hiddenKinds","hiddenGeometryKinds","textElementState","textElementStates","PersistentLabels","total","numRenderedTextElements","uninitialized","viewDistance","tooFar","elementVisible","NewLabels","textElementStyle","getTextElementStyle","elementType","checkForSmallLabels","numNotVisible","dbgPathTooSmall","numPathTooSmall","initializeGlyphs","layer","getLayer","DEFAULT_TEXT_CANVAS_LAYER","storage","drawCount","glyphs","numCannotAdd","textRenderStyle","textLayoutStyle","addPoiLabel","addLineMarkerLabel","addPathLabel","tempParams","loadingState","Initialized","Requested","Loaded","newLoadPromise","fontCatalog","loadCharset","all","glyphCaseArray","getGlyphs","bounds","letterCaseArray","measureText","defaultFontCatalogName","initializeDefaultTextElementStyle","loadCatalogs","catalog","loadedTextCanvas","createTextCanvas","createPoiRenderer","defaultTextCanvas","defaultPoiRenderer","initializeTextElementStyles","debugGlyphs","debugContext","getValue","m_debugGlyphTextureCacheMesh","initializeGlyphDebugMesh","m_debugGlyphTextureCacheWireMesh","defaultFontCatalog","planeGeometry","textureSize","maxWidth","maxHeight","wireframe","WireframeGeometry","wireframeMaterial","clearTextCache","checkIfOverloaded","updateStartTime","overloaded","updateTextElementsFromSource","tileDataSource","tiles","sortedTiles","prepareTextElementGroup","userTextElements","sortedGroups","createSortedGroupsForSorting","numTextElementsUpdated","textElementLists","selectTextElementsToUpdateByDistance","textElementGroup","maxViewDistance","found","getOrSet","checkReadyForPlacement","PrePlacementResult","Ok","deduplicateElement","Duplicate","totalLabels","results","totalGroups","newGroups","tilesToRender","shouldRenderText","groupedPriorityLists","textElementGroups","foundGroup","farDistanceLimitRatio","maxDistanceRatioForTextLabels","maxDistanceRatioForPoiLabels","getMaxViewDistance","tileTextElements","fadeAnimationRunning","placeStartTime","placeNew","maxNumPlacedTextElements","maxNumVisibleLabels","groupStates","sortedGroupStates","currentPriority","currentPriorityBegin","textElementGroupState","newPriority","placeTextElementGroup","beginGroupIndex","endGroupIndex","screenXOrigin","screenYOrigin","tempAdditionParams","tempBufferAdditionParams","pickingData","addText","screenPoints","pt","pX","pY","SimplePath","LineCurve","pathOverflow","factor","labelDistanceScaleMin","labelDistanceScaleMax","state","maxVisibilityDist","distanceFadeValue","textDistance","labelState","iconIndex","pointLabel","textRenderState","iconRenderStates","iconRenderState","poiTextMaxDistance","hasText","textScale","distanceScaleFactor","setViewDistance","getDistanceScalingFactor","distanceFadeFactor","getDistanceFadingFactor","iconRejected","renderIcon","isClamped","isValid","iconReady","prepareRender","PoiRenderer","computeIconScreenBox","iconSpaceAvailable","isAllocated","ignoreDistance","iconIsOptional","computePointTextOffset","renderDistance","w","numPoiTextsInvisible","textIsOptional","textRejected","textMayOverlap","startFadeOut","isFading","textReservesSpace","allocate","renderTextDuringMovements","isFadedOut","startFadeIn","textBufferObject","createTextBufferObject","backgroundIsVisible","scale","addTextBufferObject","numRenderedPoiTexts","allocateSpace","renderPoi","numRenderedPoiIcons","addPointLabel","lineMarkerLabel","shieldGroup","shieldGroupIndex","lineTechnique","minDistanceSqr","minDistance","pointIndex","tooClose","j","distSquared","textMaxDistance","pathLabel","Path","SimpleLineCurve","getPoint","computeViewDistance","textRenderDistance","prevSize","outputCharacterBounds","charBounds","prevOpacity","prevBgOpacity","anyPointVisible","projectOnScreen","minScreenSpace","setFromPoints","lengthSq","numTextElementsInScene","newOverloaded","m_roadPicker","RoadPicker","registerTile","raycasterFromScreenPoint","screenX","screenY","scenePosition","intersects","intersectObjects","worldRootObject","intersect","Unspecified","intersection","addObjInfo","GeometryType","Point","ExtrudedLine","SolidLine","TextPath","Polygon","ExtrudedPolygon","Area","planeIntersectPosition","cameraPos","intersectRoads","MapViewPoints","faceIndex","objInfosIndex","polygonStartFace","MINIMUM_SMALL_OBJECT_SIZE_ESTIMATION","MINIMUM_OBJECT_SIZE_ESTIMATION","TileLoaderState","numBytes","OrientedBox3","frameNumLastRequested","frameNumVisible","numFramesVisible","visibilityCounter","m_disposed","m_localTangentSpace","m_forceHasGeometry","m_userTextElements","TextElementGroup","MAX_SAFE_INTEGER","m_textElementGroups","TextElementGroupPriorityList","m_pathBlockingElements","m_textElementsChanged","m_visibleArea","m_minElevation","m_maxElevation","m_ownedTextures","WeakSet","m_nextTextElementToOverlay","elementIndex","m_resourceInfo","computeResourceInfo","foundIndex","blockingElement","changed","m_decodedTile","tileInfo","roadIntersectionData","_zoomLevel","area","updatePriority","invalidateResourceInfo","forceHasGeometry","decodeTime","copyrightHolderIds","m_tileGeometryLoader","hasGeometry","basicGeometryLoaded","allGeometryLoaded","m_tileLoader","loadAndDecode","tileLoaderState","Ready","Canceled","Failed","m_animatedExtrusionTileHandler","handler","nextTextElementToOverlay","disposeMaterial","materialProperty","shouldDisposeTexture","disposeObject","shouldDisposeObjectGeometry","shouldDisposeObjectMaterial","rootObject","traverse","preparedTextPaths","clearTextElements","hasTextElements","cancel","num3dObjects","numTextElements","numUserTextElements","aggregatedObjSize","intersectionData","bytesPerEntry","numEntries","ids","getRoadIntersectionDataSize","parentUri","childUri","absoluteUrlWithOriginRe","getUrlOrigin","substr","baseUrl","RegExp","idx","lastIndexOf","getUrlHostAndProtocol","protocol","host","urlOriginRe","match","AnimatedExtrusionState","m_mapView","m_tileHandlerMap","m_zoomDirection","m_zoomLevelPrevious","tileHandler","zoomLevelChanged","m_forceAnimatedExtrusion","animatedExtrusion","m_forceAnimatedExtrusionDuration","extrusionDuration","tileKeys","m_tile","m_animatedExtrusionDuration","m_extrudedObjects","m_animatedExtrusionRatio","ExtrusionFeature","DEFAULT_RATIO_MAX","m_animatedExtrusionState","None","m_animatedExtrusionStartTime","Playing","Started","currentTime","timeProgress","extrusionRatio","easeInOutCubic","DEFAULT_RATIO_MIN","Finished","stopExtrusionAnimation","extrudedObject","startExtrusionAnimationIfNeeded","zoomDirection","removeTile","childTileKeys","getSubTileKeys","childTileKey","extrusionStartTime","nextLevelDiff","getChildTiles","parentTileKey","parent","startExtrusionAnimation","visibilityRange","DisplacementFeature","updateDisplacementFeature","displacementMaterial","USE_DISPLACEMENTMAP","displacementScale","displacementBias","insertShaderInclude","DisplacementFeatureMixin","m_displacementMap","getDisplacementMap","setDisplacementMap","source","patchGlobalShaderChunks","ShaderChunk","fading_pars_vertex","updateDistanceFadeFeature","fadingMaterial","FADING_MATERIAL","updateUniforms","additionalCallback","uniformsNeedUpdate","FadingFeatureMixin","m_fadeNear","m_fadeFar","getFadeNear","setFadeNear","getFadeFar","setFadeFar","extrusion_pars_vertex","updateExtrusionFeature","extrusionMaterial","EXTRUSION_MATERIAL","ExtrusionFeatureMixin","m_extrusion","getExtrusionRatio","setExtrusionRatio","addFadingProperties","applyFadingParameters","addExtrusionProperties","applyExtrusionParameters","addDisplacementProperties","applyDisplacementParameters","copyFadingParameters","copyExtrusionParameters","copyDisplacementParameters","MeshStandardMaterial","applyMixinsWithoutProperties","extrude_line_vert_func","round_edges_and_add_caps","tile_clip_func","high_precision_vert_func","baseTechniqueParamsDescriptor","attrScopes","AttrScope","TechniqueGeometry","transient","TechniqueRendering","pointTechniquePropTypes","mergeTechniqueDescriptor","squaresTechniquePropTypes","squares","circlesTechniquePropTypes","circles","lineMarkerTechniquePropTypes","FeatureGeometry","useAbbreviation","useIsoCode","iconMayOverlap","textReserveSpace","iconReserveSpace","alwaysOnTop","showOnMap","stackMode","iconFadeTime","textFadeTime","iconXOffset","iconYOffset","iconScale","screenHeight","screenWidth","poiTable","poiName","poiNameField","imageTextureField","imageTexturePrefix","imageTexturePostfix","hAlignment","vAlignment","polygonalTechniqueDescriptor","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","solidLineTechniqueDescriptor","lineTechniqueDescriptor","fillTechniqueDescriptor","fill","standardTechniqueDescriptor","roughness","metalness","alphaTest","emissiveIntensity","refractionRatio","mapProperties","normalMapProperties","displacementMapProperties","roughnessMapProperties","emissiveMapProperties","bumpMapProperties","metalnessMapProperties","alphaMapProperties","standard","extrudedPolygonTechniqueDescriptor","floorHeight","defaultColor","defaultHeight","constantHeight","boundaryWalls","footprint","maxSlope","enableDepthPrePass","textTechniqueDescriptor","shaderTechniqueDescriptor","isStandardExtrudedLineTechnique","textureCoordinateType","transferList","texturePropertyKey","ArrayBuffer","imageName","textureName","UPDATE_EVENT","DataSource","uniqueName","storageLevelOffset","cacheable","useGeometryLoader","m_maxGeometryHeight","m_storageLevelOffset","uniqueNameCounter","m_styleSetName","styleSet","GlyphData","advanceX","u0","v0","u1","v1","font","sourceTextureCoordinates","dynamicTextureCoordinates","copyIndex","isInCache","character","String","fromCodePoint","direction","metrics","lineHeight","MAX_CAPACITY","VERTEX_BUFFER_STRIDE","INDEX_BUFFER_STRIDE","VERTICES_PER_QUAD","INDICES_PER_QUAD","QUAD_VERTEX_MEMORY_FOOTPRINT","QUAD_INDEX_MEMORY_FOOTPRINT","NUM_BYTES_PER_FLOAT","NUM_BYTES_PER_INT32","backgroundMaterial","initialSize","m_currentCapacity","m_drawCount","m_updateOffset","m_pickingCount","m_vertexBuffer","setUsage","DynamicDrawUsage","m_positionAttribute","m_uvAttribute","m_colorAttribute","m_bgColorAttribute","m_indexBuffer","m_geometry","m_pickingDataArray","m_bgMesh","updateRange","setDrawRange","glyphData","corners","weight","bgWeight","mirrored","newSize","resizeBuffers","baseVertex","baseIndex","setXYZW","mirroredUVIdx","setX","vertexOffset","bgColor","bgOpacity","cosR","sinR","offsetZ","rotSign","red","green","blue","bgRed","bgGreen","bgBlue","bgAlpha","targetOffset","srcOffset","glyph","bw","startIdx","endIdx","pickCallback","positionIndex","newVertexBuffer","newIndexBuffer","TypesettingUtils","EM_TO_PX","PT_TO_PX","OBLIQUE_ANGLE","OBLIQUE_OFFSET","getPixelSize","originalSize","Em","Percent","getSmallCapsScale","smallCapsTransformations","SmallCaps","xHeight","capHeight","computeGlyphTransform","localRotation","cosAngle","sinAngle","localCosAngle","localSinAngle","updateBounds","globalBounds","individualBounds","raycaster","screenCoords","origin","mouseCoords","ceil","indices","il","fromArray","pointInfo","getPointInfo","pointIsOnScreen","testPoint","absoluteScreenPosition","relativeScreenPosition","pickCoordinates","dx","dy","halfSize","isNode","DebugOption","SET_EVENT_TYPE","DebugContext","m_optionsMap","__debugContext","opt","hasEventListener","option","Label","All","prepareDecodedTile","foundSet","m_isFinished","m_availableGeometryKinds","processTechniques","setDecodedTile","prepareForRender","m_timeout","loadingFinished","removeDecodedTile","disposed","disposeTile","addMessage","finish","geometryCreator","createAllGeometries","geometryCreationTime","decoderServiceType","scriptUrl","workerCount","workerSet","getWorkerSet","WorkerBasedDecoder","workerSets","ConcurrentWorkerSet","destroy","sourceInfo","existingInfo","findItem","year","link","formatAsHtml","filtered","entry","HighPrecisionUtils","doubleToFloatVec","fround","createHighPrecisionCameraPos","objectInverseWorldMatrix","mvp","matrixWorldInverse","eyePos","eyePosFloat","viewProjection","eyePosHi","eyePosLo","createAttributes","positionVec","positionVecLow","addHPValue","major","addHPVector","vec","positionHigh","Float32BufferAttribute","positionLow","addInterleavedAttributes3","positionOffset","newPositions","majorX","minorX","majorY","minorY","majorZ","minorZ","setPositions","makeFloatVec","minorVec","updateHpUniforms","shaderMaterial","highPrecisionCameraInfo","isMaterial","u_mvp","u_eyepos","u_eyepos_lowpart","convertPositions","vAny","returnPositions","createLine","linePositions","addCircles","wireFrame","triangulateLine","hpLineGeometry","hpPositions","positionAttribute","positionLowAttribute","hpSolidMaterial","HighPrecisionLineMaterial","lineObject","HPL","HighPrecisionWireFrameLine","HighPrecisionLine","setupForRendering","createPoints","pointPositions","materialParameters","hpPointsGeometry","hpPointsMaterial","isHighPrecisionPointMaterial","HighPrecisionPointMaterial","pointsObject","HPP","HighPrecisionPoints","FeatureModifierId","OmvFilterString","StringMatch","matchString","str","filterString","Any","Match","StartsWith","EndsWith","endsWith","OmvGeometryType","OMV_TILE_DECODER_SERVICE_TYPE","OMV_TILER_SERVICE_TYPE","OmvTile","Tile","optionalParams","console","trace","m_channel","Trace","prefix","Debug","Info","Warn","CopyShader","tDiffuse","CopyMaterial","NoBlending","Env","_name","unmap","StringEncodedMeters","encodedValue","exec","StringEncodedPixels","StringEncodedHex","StringEncodedRGB","channels","StringEncodedRGBA","StringEncodedHSL","StringEncodedMetricFormatMaxSize","StringEncodedColorFormatMaxSize","numeral","formats","subset","elem","hasIntersection","TextureCoordinateType","PoiStackMode","descriptors","projectionName","sphereProjection","normalizedEquirectangularProjection","equirectangularProjection","attributeMap","$id","EquirectangularProjection","geoToWorldScale","worldToGeoScale","latitudeSpanInRadians","longitudeSpanInRadians","sizeX","sizeY","TransverseMercatorProjection","m_phi0","m_lambda0","lon","TransverseMercatorUtils","POLE_RADIUS","rsq","POLE_RADIUS_SQ","nearestQuarter","deltaLon","deltaLat","distanceToPoleSq","distanceToPole","dir","offsetLon","clamped","clampGeoPoint","normalLon","phi","lambda","B","atanh","outScale","tau","nx","ny","D","sinh","pointsToCheck","E","POLE_EDGE_DEG","containsEastCut","containsCenterX","containsCenterY","alignLatitude","projected","vx","vy","vz","minZ","maxZ","lowerQ","upperQ","containsLowerQY","containsUpperQY","geoPoints","alignLongitude","latitudes","longitudes","altitudes","referencePoint","bad","good","POLE_EDGE","transverseMercatorProjection","tilingScheme","minElevation","maxElevation","m_tilingScheme","m_worldBox","m_worldDimensions","levelDimensionX","getLevelDimensionX","levelDimensionY","getLevelDimensionY","originX","originY","unprojectBox","halfQuadTreeSubdivisionScheme","SubTiles","iterator","ZCurveIterator","RowColumnIterator","parentKey","worldCoordinatesToTileKey","cx","cy","worldSizeX","worldSizeY","wrap","lower","upper","minVal","maxVal","southWestLongitude","longitudeInRadians","southWestLatitude","northEastLongitude","northEastLatitude","minTileKey","maxTileKey","columnCount","minColumn","maxColumn","minRow","maxRow","m_subdivisionScheme","divX","getSubdivisionX","divY","getSubdivisionY","emptyTechniqueDescriptor","StyleConditionClassifier","_whenExpr","savedStyle","switchStyle","_style","enclosingExpr","matchVarStringComparison","_geometryType","saved","OptimizedSubSetKey","keyUpdateNeeded","envLayer","envGeometryType","updateKey","cachedStyleSet","makeDecodedTechnique","attrValue","toJSON","m_techniques","m_exprPool","ExprPool","m_cachedResults","m_styleConditionClassifier","m_subStyleSetCache","m_definitionExprCache","m_tmpOptimizedSubSetKey","m_emptyEnv","m_definitions","resolveStyleReferences","isJsonExprReference","definitionName","isActualSelectorDefinition","resolveReferences","techniqueRenderOrder","styleSetIndex","_styleSetIndex","computeDefaultRenderOrder","compileStyleSet","optimizedSubSetKey","m_layer","m_geometryType","searchedStyleSet","getOptimizedStyleSet","currStyle","processStyle","techinque","_index","subSetKey","optimizedStyleSet","createPreFilteredStyleSet","compileStyle","when","classify","intern","_minZoomLevelExpr","_maxZoomLevelExpr","err","checkZoomLevel","Condition","getTechniqueForStyleMatch","final","checkStyleDynamicAttributes","_dynamicTechniques","dynamicAttributes","evaluateTechniqueProperties","getDynamicTechniqueKey","createTechnique","_staticTechnique","dynamicAttrKey","_attrName","_dynamicTechniqueAttributes","_dynamicFeatureAttributes","_dynamicForwardedAttributes","_staticAttributes","dynamicFeatureAttributes","dynamicTechniqueAttributes","dynamicForwardedAttributes","targetStaticAttributes","techniqueDescriptor","processAttribute","deps","attrScope","labelProperty","instantiationContext","attrExpr","instantiate","dynamicAttrs","_key","SdfShaderChunks","sdf_attributes","sdf_varying","sdf_varying_computation","sdf_frag_uniforms","sdf_sampling_functions","clearVertexSource","clearFragmentSource","copyVertexSource","copyFragmentSource","sdfTextVertexSource","sdfTextFragmentSource","GlyphClearMaterial","GlyphCopyMaterial","pageOffset","Uniform","page0","DEFAULT_IMAGE","page1","page2","page3","page4","page5","page6","page7","SdfTextMaterial","vertexSource","fragmentSource","sdfTexture","sdfParams","Vector4","distanceRange","MSDF","isMsdf","BG_TEXT","isBackground","side","DoubleSide","extensions","derivatives","characterBounds","AlphaFormat","RGBFormat","RGBAFormat","LuminanceAlphaFormat","RGBEFormat","DepthFormat","DepthStencilFormat","RedFormat","dataType","ClampToEdgeWrapping","RepeatWrapping","MirroredRepeatWrapping","NearestFilter","NearestMipMapNearestFilter","NearestMipMapLinearFilter","LinearFilter","LinearMipMapNearestFilter","LinearMipMapLinearFilter","AmbientLight","intensity","DirectionalLight","castShadow","DEPTH_PRE_PASS_STENCIL_MASK","DEPTH_PRE_PASS_RENDER_ORDER_OFFSET","createDepthPrePassMaterial","baseMaterial","depthFunc","EqualDepth","colorWrite","enforceBlending","depthPassMaterial","LessDepth","evaluateBaseColorProperty","originalGeometry","depthPassGeometry","extrusionAxisAttribute","materialIndex","depthMesh","colorMesh","depthMaterial","stencilWrite","stencilFail","KeepStencilOp","stencilZFail","stencilZPass","ReplaceStencilOp","stencilFunc","AlwaysStencilFunc","stencilRef","stencilFuncMask","colorMaterial","ZeroStencilOp","EqualStencilFunc","MAX_DISTANCE_ERROR","extendedTileInfo","lineFeatures","lineGroup","numFeatures","widths","techniqueCatalog","featureIds","pickPos","distanceToPoint","techniqueIndices","px","py","pickDistance","featureStart","featureEnd","startX","startY","widthEntry","actualWidth","lineWidthSqr","closestDistSqr","MAX_VALUE","endX","endY","distSqr","distToSegmentSquared","roadPickResult","distFromCenter","addUserData","INVALID_RENDER_BATCH","tempPos","PoiRenderBufferBatch","imageItem","boxBuffer","setup","init","updateBufferGeometry","updateMemoryUsage","iconTexture","IconTexture","imageData","UVMapping","premultiplyAlpha","generateMipmaps","m_material","IconMaterial","BoxBuffer","PoiRenderBuffer","batches","m_batchMap","imageTextureName","batchKey","mappedIndex","bufferBatch","batchSet","screenBox","batchIndex","registerPoi","uvBox","addBox","batch","pickBoxes","m_tempScreenBox","m_renderBuffer","computedWidth","computedHeight","centerX","centerY","preparePoi","screenCollisions","allocateScreenSpace","addPoi","poiTableName","updatePoiFromPoiTable","getImageTexture","m_missingTextureName","imageDefinition","imageCache","findImageByName","loaded","loadingPromise","imageUrl","loadImage","loadedImageItem","setupPoiInfo","imageWidth","imageHeight","iconWidth","iconHeight","minS","maxS","minT","maxT","iconScaleH","iconScaleV","s0","t0","s1","t1","ImageOrigin","tmpPosition","tmpCameraDir","COS_TEXT_ELEMENT_FALLOFF_ANGLE","refPosition","viewDistance0","viewDistance1","viewState","viewCamera","projectionType","getWorldPosition","checkViewDistance","TooFar","Invisible","NotReady","hAlign","vAlign","Right","Below","poiIsRenderable","computeStyleCacheId","datasourceName","DEFAULT_TEXT_STYLE_CACHE_ID","TextRenderStyleCache","TextLayoutStyleCache","Center","DEFAULT_STYLE_NAME","m_textRenderStyleCache","m_textLayoutStyleCache","m_colorMap","m_textStyles","m_defaultStyle","themedDefaultStyle","createTextElementStyle","textRenderers","styledTextRenderer","styleId","cacheId","defaultRenderParams","hexColor","hexBgColor","themeRenderParams","floorZoomLevel","defaultLayoutParams","themeLayoutParams","styleName","fontCatalogName","DEFAULT_THROTTLING_TIMEOUT","m_throttlingTimeout","m_movementStartedFunc","m_movementFinishedFunc","m_lastCameraPos","m_newCameraPos","m_throttlingTimerId","m_movementDetectorDeadline","onDeadlineTimer","startMovementFinishedTimer","newAttitude","newCameraPos","m_lastAttitude","cameraMoved","equals","m_cameraMovedLastFrame","NaN","removeMovementFinishedTimer","remainingTime","epsilon","nearMin","nearMultiplier","nearFarMultiplier","farOffset","m_tmpVectors","m_tmpQuaternion","farMin","nearPlane","farPlane","extractBasis","fwd","negate","fwdRot","addScaledVector","ElevationBasedClipPlanesEvaluator","TopViewClipPlanesEvaluator","nearFarMarginRatio","farMaxRatio","nearFarMargin","m_minimumViewRange","evaluateDistanceSphericalProj","evaluateDistancePlanarProj","minimumViewRange","getCameraAltitude","farMax","cameraAltitude","cam","halfFovAngle","farTangent","getTangentBasedFarPlane","getFovBasedFarPlane","getOrthoBasedFarPlane","getTangentDistance","te","fovAngle","dVec","cameraFwdVec","tVec","cta","a2","r2","TiltViewClipPlanesEvaluator","getWorldDirection","surfaceNormal","cosTiltAngle","halfPiLimit","cameraTilt","topAngleRad","bottomAngleRad","z1","z2","sinBeta","topDist","bottomDist","planesDist","getFrustumGroundIntersectionDist","cosHalfFov","getCameraLookAtDistance","cameraToOrigin","getCameraPitch","modifiedAlpha","getTiltedFovBasedFarPlane","cosAlpha","dSqr","cosAlpha1","minNear","minFarOffset","minFar","m_nearPlane","m_farPlane","fixedNear","invalidatePlanes","fixedFar","nearDist","farDist","MSAARenderPass","MSAASampling","samplingLevel","Level_1","m_renderTarget","m_localCamera","m_quadScene","m_quadUniforms","m_quadMaterial","MSAAMaterial","m_quad","WebGLRenderTarget","offsets","OffsetVectors","oldClearColor","oldView","oldRenderTarget","getRenderTarget","setViewOffset","uniformCenteredDistribution","sampleWeight","isLoggingMessage","WORKERCHANNEL_MSG_TYPE","DEFAULT_WORKER_COUNT","DEFAULT_WORKER_INITIALIZATION_TIMEOUT","m_workerChannelLogger","m_eventListeners","m_workers","m_availableWorkers","m_workerPromises","m_readyPromises","m_requests","m_workerRequestQueue","m_nextMessageId","m_stopped","m_referenceCount","onWorkerMessage","workerId","WorkerServiceProtocol","isResponseMessage","messageId","worker","checkWorkerRequestQueue","errorMessage","errorStack","stack","resolver","isInitializedMessage","readyPromise","getReadyPromise","service","eventHandler","m_workerCount","hardwareConcurrency","timeout","workerConnectionTimeout","workerPromise","WorkerLoader","startWorker","evt","waitForAllResponses","terminateWorkers","serviceId","ensureStarted","promise","callback","request","requestController","reject","ServiceMessageName","Request","postRequestMessage","promises","postMessage","buffers","signal","aborted","RequestController","unshift","workerEntry","terminate","newPromise","that","startWorkerImmediately","directlyFallbackToBlobBasedLoading","startWorkerBlob","pageUrl","href","fullScriptUrl","Worker","waitWorkerInitialized","fetchScriptSourceToBlobUrl","blobUrl","sourceLoaderCache","scriptSource","blob","firstMessageCallback","isWorkerBootstrapRequest","resolvedDependencies","dependency","resolved","dependencyUrlMapping","cleanup","errorCallback","filename","lineno","timerId","nextUniqueServiceId","m_serviceCreated","addReference","broadcastRequest","WORKER_SERVICE_MANAGER_SERVICE_ID","Requests","DestroyService","targetServiceId","removeReference","CreateService","targetServiceType","tileKeyCode","WorkerDecoderProtocol","DecodeTileRequest","getProjectionName","invokeRequest","TileInfoRequest","DecoderMessageName","Configuration","broadcastMessage","CalculationStatus","TileGeometryManagerBase","enableFilterByKind","m_visibilityCounter","kinds","incrementVisibilityCounter","addOrRemoveToEnabledSet","enableDisableKinds","addOrRemoveToDisabledSet","addOrRemoveToHiddenSet","visibilityHasChanged","oneKind","addRemove","kindSet","visibleKinds","geometryLoader","tileKinds","availableGeometryKinds","needUpdate","nowVisible","m_tileUpdateCallback","addToSet","kindsSet","SimpleTileGeometryLoader","enabledGeometryKinds","disabledGeometryKinds","updateTileObjectVisibility","m_name2Url","m_url2Name","hasName","oldNames","ImageCache","findImage","registerImage","startLoading","m_images","imageCacheItem","findImageCacheItem","mapViews","itemsToRemove","mapViewIndex","keyToDelete","imageLoader","ImageLoader","renderImage","ex","errorEvent","createImageBitmap","imageOrientation","imageBitmap","document","createElement","getContext","drawImage","getImageData","m_enabled","Fog","m_fogIsDefined","m_cachedTheme","enableFog","startRatio","viewRange","horizontalDensity","verticalDensity","endRatio","density","smoothStep","lerp","setFogInRawShaderMaterials","Material","updateFog","m_imageTextures","m_poiShieldGroups","m_missingPoiTableName","loadedOk","m_missingPoiName","assertExists","poiGeometry","addLineMarker","ok","statusText","jsonAtlas","imageTextureDef","reason","getPoiTable","notifyMissingPoiTable","poiTableEntry","getEntry","notifyMissingPoi","iconName","composeTechniqueTextureName","iconMinLevel","iconMaxLevel","textMinLevel","textMaxLevel","updateMinMaxZoomLevelsFromPoiInfo","groupKey","positionArray","checkCreateTextElement","techniqueTextureName","poiTechnique","PoiTableEntry","jsonEntry","isOK","altNames","Show","Hide","ShowParent","PoiTable","useAltNamesForKey","poiList","poiDict","m_isLoading","m_loadedOk","entryIdx","poiTableUrl","jsonPoiTable","tableEntry","verifyJSON","newPoiEntry","altName","m_poiTables","loadPromises","poiTableRef","addTable","finally","finishLoading","debugTiles","polarTilingScheme","m_maxLatitude","m_geometryLevelOffset","m_debugTiles","m_northPoleMaterial","m_southPoleMaterial","m_styleSetEvaluator","styleSetEvaluator","$geometryType","$layer","getMatchingTechniques","StyleSetEvaluator","setStyleSet","createTileGeometry","latA","latB","lonA","lonB","isNorthPole","srcProjection","dstProjection","maxLat","poleLat","box","pBL","pBR","pTR","pTL","needsGeometryCut","isLeftHalf","poleX","poleY","pPole","pXX","lats","lmax","lmin","nearest","shift","inPointB","inPointD","cutStart","intersectEdge","cutEnd","cutIndexStart","cutIndexEnd","Face3","fromGeometry","f","u","_maxEntries","_minEntries","leaf","_all","search","toBBox","collides","insert","_build","_splitRoot","_insert","_condense","compareMinX","compareMinY","apply","_chooseSubtree","_split","_adjustParentBBoxes","_chooseSplitAxis","_chooseSplitIndex","M","_allDistMargin","SkyCubemapFaceId","SKY_CUBEMAP_FACE_COUNT","createCubemapFaceArray","m_skybox","CubeTextureLoader","CubeTexture","face","DEFAULT_MAX_THEME_INTHERITANCE_DEPTH","themeUrl","resolveReferenceUri","getAppBaseUrl","resolveUrls","checkTechniqueSupport","resolveDefinitions","resolveBaseThemes","contextLoader","ContextLogger","resolveThemeReferences","extends","childUrlResolver","composeUriResolvers","RelativeUriResolver","baseTheme","faceUrl","contextLogger","pushAttr","resolvedDef","resolveStyle","resolveStyleSet","currentStyle","pushIndex","resolvedStyle","cloneDeep","resolvedWhen","resolveExpressionReferences","resolvedValue","failed","resolveInternal","defName","maxInheritanceDepth","baseThemes","baseThemesMerged","actualBaseTheme","mergeThemes","MB_FACTOR","DataSourceCache","cacheSize","rct","m_disposedTiles","m_resourceComputationType","m_tileCache","LRUCache","evictionCallback","canEvict","getKey","setCapacityAndMeasure","getKeyForTile","deleteByKey","shrinkToCapacity","evictAll","selector","evictSelected","inDataSource","m_frustumIntersection","m_projectionMatrixOverride","m_viewRange","m_dataSourceCache","computationType","setCapacity","evaluateClipPlanes","visibleTileKeysResult","getVisibleTileKeysForDataSources","visibleTileKeys","areaDiff","minDiff","actuallyVisibleTiles","allDataSourceTilesLoaded","getDisplayZoomLevel","tileEntry","shouldRender","getTile","prepareTileInfo","visibleArea","updateTiles","allVisibleTileLoaded","allBoundingBoxesFinal","fillMissingTilesFromCache","oldViewRanges","newViewRanges","getTileImpl","dataSourceVisibleTileList","visibleLevel","visibleTileKey","getTileKey","searchLevelsUp","searchLevelsDown","getCacheSearchLevels","childLevel","markDataSourceTilesDirty","disposeTiles","listEntry","SearchDirection","defaultSearchDirection","NONE","BOTH","DOWN","UP","incompleteTiles","tileCode","checkedTiles","searchDirection","findUp","findDown","childTileCode","childTile","parentCode","exists","parentTile","foundUp","cacheOnly","updateTile","tileToUpdate","resultTile","tileCache","initTile","dataSourceCache","retainedTiles","markTileDirty","tileGeometryManager","dataSourceBuckets","bucket","fp","makePerspective","updateFrustum","maxDisplayLevel","compute","calculationFinal","tileKeyEntries","ConcurrentTilerFacade","tilerServiceType","WorkerBasedTiler","indexId","input","WorkerTilerProtocol","RegisterIndex","UpdateIndex","TileRequest","RBush","m_cachedTreePromise","getCopyrightCoverageData","coverageInfo","initRBush","matchingEntries","getTree","minLevel","maxLevel","item","tree","alt","arg","isLineAccessor","isObject3dAccessor","BufferedGeometryAccessorBase","startCapSize","endCapSize","constructor","rawShaderMaterial","BufferedGeometryAccessor","checkSetUp","positionsArray","subarray","getVertices","IndexedBufferedGeometryAccessor","reconstructLineWidth","k","UNIT_Z","POINTS","BEVEL_POINTS","SECTORS_IN_CIRCLE","STEP","addCircle","lineAngle","radius","angle","startWithCircle","endWithCircle","angleVec","prevBt","bt","averageBt","p2","p3","N","useBevel","multiplyScalar","inclineWidth","inBuffer","startOffset","outBuffer","i2","startIndex","xd","yd","zd","_group","force","doUpdateMatrixWorldInverse","matrixWorldNeedsUpdate","TileLoader","dataProvider","tileDecoder","loadAbortController","AbortController","countRequests","Loading","Decoding","donePromise","abort","onDone","myLoadCancellationToken","payload","onLoaded","resolveDonePromise","rejectedDonePromise","byteLength","startDecodeTile","decodeTile","onDecoded","doneState","getTileInfo","APIFormat","AuthenticationMethod","AuthenticationTypeBearer","method","AuthorizationHeader","AuthenticationTypeTomTomV1","QueryString","AuthenticationTypeAccessToken","downloadManager","TransferManager","urlParams","abortSignal","tileUrl","dataUrl","authenticationCode","getActualAuthenticationCode","applyAuthCode","addQueryParams","apiFormat","XYZJson","downloadJson","downloadArrayBuffer","getBearerToken","HereV1","MapboxV4","XYZOMV","XYZMVT","XYZSpace","TomtomV1","authMethod","authenticationMethod","getDefaultAuthMethod","headers","Headers","authType","append","authParams","queryParams","queryString","concatinator","s3Base","querySelector","getElementById","innerText","getFullYear","releases","date","hash","version","dropdown","res","release","appendChild","onchange","selected","async","theCanvas","transferControlToOffscreen","createMapViewInWorker","createMap","createMapInt","innerWidth","Boston","beginAnimation","main","offscreen","EventEmitter","emit","eventName","listenerCount","on","long","PriorityListGroup","getGroup","normalizedPriority","m_sortedGroups","otherGroup","findGroup","priorityList","LoggerManagerImpl","m_loggers","channel","ConsoleChannel","loggerName","m_levelSetForAll","Logger","config","workerMessage","self","ax","ay","bx","by","computeSquaredLineLength","squaredLineLength","xDiff","yDiff","l0x","l0y","l1x","l1y","lineLengthSuared","edge0","edge1","smootherStep","inMin","inMax","outMin","outMax","lowerBound","upperBound","startValue","endValue","derivedCtor","baseCtors","baseCtor","getOwnPropertyDescriptor","m_logger","headerMessage","m_headerLogged","createLogMethod","severity","rest","nowFunc","getTime","getNowFunc","cloneInternal","src","cached","flags","candidate","parameters","optionValue","uri","resolvers","originalUrl","appBaseUrl","f1","f2","ReflectOwnKeys","R","Reflect","ReflectApply","receiver","Function","ownKeys","getOwnPropertySymbols","NumberIsNaN","_events","_eventsCount","_maxListeners","defaultMaxListeners","$getMaxListeners","_addListener","prepend","events","existing","warning","TypeError","newListener","warned","emitter","onceWrapper","arguments","fired","removeListener","wrapFn","_onceWrap","_listeners","unwrap","evlistener","arr","ret","unwrapListeners","arrayClone","RangeError","getPrototypeOf","setMaxListeners","getMaxListeners","doError","er","len","listeners","addListener","prependListener","once","prependOnceListener","originalListener","spliceOne","off","removeAllListeners","rawListeners","eventNames","omvDataSource","OmvDataSource","accessToken","DEFAULT_CIRCLE_SIZE","isCirclePointsMaterial","m_size","m_color","getHexString","hasDisplacementMap","edgeColor","edgeColorMix","USE_FADING","USE_EXTRUSION","extrusion_vertex","extrusion_normal_fragment_begin","extrusion_pars_fragment","extrusion_fragment","fading_vertex","fading_pars_fragment","fading_fragment","shaderParams","isHighPrecisionLineMaterial","updateTransparencyFeature","points_frag","DEFAULT_SIZE","DEFAULT_SCALE","uvTransform","Matrix3","VertexColors","LuminosityHighPassShader","luminosityThreshold","smoothWidth","defaultOpacity","AdditiveBlending","SepiaShader","amount","Square","Round","TriangleIn","TriangleOut","DASHED_LINE","USE_DASH_COLOR","CAPS_SQUARE","CAPS_ROUND","CAPS_NONE","CAPS_TRIANGLE_IN","CAPS_TRIANGLE_OUT","hasFog","USE_FOG","USE_OUTLINE","merge","dashColor","DEFAULT_WIDTH","DEFAULT_OUTLINE_WIDTH","drawRange","DEFAULT_DRAW_RANGE_START","DEFAULT_DRAW_RANGE_END","DEFAULT_DASH_SIZE","DEFAULT_GAP_SIZE","UniformsLib","drawRangeStart","drawRangeEnd","enableOutline","VignetteShader","darkness","operatorDescriptors","evaluator","m_partialEvaluation","previousEvaluationMode","fromValue","builtin","builtins","defineOperator","defineOperators","CastOperators","ComparisonOperators","MathOperators","StringOperators","ColorOperators","TypeOperators","MiscOperators","FlowOperators","ArrayOperators","InterpolationOperators","ObjectOperators","FeatureOperators","MapOperators","operators","at","Boolean","rgba","rgbaToHex","rgb","rgbToHex","hsl","euclideanModulo","hslToHex","compare","strict","conditionalCast","any","none","boolean","number","string","interpolate","_interpolatedProperty","_mode","interpolatorType","base","stops","isConstantInterpolation","createInterpolatedProperty","_exponent","_stops","prepareInterpolateCallExpr","interpolatedProperty","_inputIsZoom","classifyStepCallExpr","first","last","MIN_SAFE_INTEGER","hasConstantValues","literal","prepareStepCallExpr","Interpolant","i1","sampleValues","valueSize","offset1","offset0","weight1","weight0","ppi","ln","ln2","log10","pi","coalesce","LookupMode","lookupMember","lookupMode","memberName","downcase","toLocaleLowerCase","upcase","toLocaleUpperCase","typeof","_context","preserve","newBranch","newCondition","instantiatedBranch","Character","Token","isSpace","codepoint","Tab","Lf","Cr","Space","isNumber","_0","_9","isLetter","A","Z","isIdentChar","isLetterOrNumber","Dollar","Dot","LBracket","RBracket","tokenSpell","token","Eof","Identifier","Comma","LParen","RParen","Exclaim","TildeEqual","CaretEqual","DollarEqual","EqualEqual","ExclaimEqual","Less","Greater","LessEqual","GreaterEqual","BarBar","AmpAmp","Lexer","m_token","m_char","m_text","yylex","codePointAt","yyinp","ch","SingleQuote","DoubleQuote","Equal","Caret","Tilde","Bar","Amp","getEqualityOp","getRelationalOp","lex","parseLogicalOr","yyexpect","hasAttribute","parseLiteral","parseFloat","parseUnary","parsePrimary","parseRelational","parseEquality","expressions","parseLogicalAnd","isUnknownServiceError","isRequestMessage","Response","isRegisterIndexRequest","isUpdateIndexRequest","isTileRequest","abortController","isConfigurationMessage","isDecodeTileRequest","isTileInfoRequest","IdentityProjection","identityProjection","getLongitudeQuadrant","oneOverPI","quadrantIndex","lengthOfVector3","makeBox3","halfEquatorialRadius","minLongitude","maxLongitude","minLongitudeQuadrant","maxLongitudeQuadrant","xMin","xMax","yMin","yMax","cosMaxLongitude","sinMaxLongitude","xCenter","xExtent","yCenter","yExtent","minLatitude","maxLatutide","zMax","zMin","zCenter","zExtent","SphereProjection","_minElevation","worldpoint","cosLatitude","parallelRadiusSq","parallelRadius","midX","midY","cosSouth","sinSouth","cosWest","sinWest","cosNorth","sinNorth","cosEast","sinEast","cosMidX","sinMidX","cosMidY","sinMidY","rMax","rMin","_worldBox","mx","my","gx","gy","cosLongitude","sinLongitude","sinLatitude","visitTileKey","subTileKey","hereTilingScheme","TilingScheme","webMercatorTilingScheme","mercatorTilingScheme","rotationMatrix","newBox","matrix","frustumOrPlanes","dz","distanceToPointSquared","subVectors","lengths","extent","getComponent","dd","FeatureGroupType","FeatureGroup","storeExtendedTags","startSize","textIndex","layerIndex","classIndex","typeIndex","LineFeatureGroup","getNumBytes","segmentIds","segmentStartOffsets","segmentEndOffsets","PolygonFeatureGroup","groupNumRings","outerRingStartIndex","innerRingIsOuterContour","innerRingStartIndex","ExtendedTileInfo","textCatalog","pointGroup","polygonGroup","layerCatalog","classCatalog","typeCatalog","finishFeatureGroup","featureGroup","featureGroupFinished","getFeatureName","abbreviation","isoCode","featureGroupSize","tileInfoFinished","getFeatureText","evaluateTechniqueAttr","techniqueIndexMap","stringMap","layerMap","classMap","typeMap","infoTileTechniqueIndex","decodedTechnique","featureText","featureGroupType","stringIndex","addLayer","addClass","addType","segmentId","endOffset","contour","isOuterRing","addStringValue","ExtendedTileInfoVisitor","visitAllPointFeatures","visitAllLineFeatures","visitAllPolygonFeatures","numFeaturesFound","numPointFeatures","pointFeatures","visitPointFeature","numLineFeatures","visitLineFeature","numPolygonFeatures","polygonsFeatures","visitPolygonFeature","featureIndex","acceptPoint","getTag","positionsStart","numPointValues","acceptLine","acceptPolygon","polygons","ringStart","numRings","polygonAccessor","ringIndex","pointsStart","m_booleanLiterals","m_numberLiterals","m_stringLiterals","m_objectLiterals","m_varExprs","m_hasAttributeExprs","m_inExprs","m_callExprs","inExprs","inExpr","defaultValue","evaluated","cachedExprResults","visitFunc","visit","DEFAULT_TILING_SCHEME","newScheme","VERTEX_POSITION_CACHE","SubdivisionModifier","aa","bb","cc","beta","gamma","tmpVectorA","tmpVectorB","tmpVectorC","positionAttr","uvAttr","uv","edgeAttr","edge","wallAttr","wall","indexAttr","getIndex","middleVertex","lerpVectors","newIndices","v2","shouldSplitTriangle","v3","ASSETS_PATH","BOLD_ASSETS_PATH","ITALIC_ASSETS_PATH","BOLD_ITALIC_ASSETS_PATH","REPLACEMENT_PATH","FontCatalog","fonts","unicodeBlocks","maxCodePointCount","m_replacementGlyph","m_glyphTextureCache","GlyphTextureCache","m_loadingJson","m_loadingPages","m_loadingGlyphs","m_loadedJson","m_loadedPages","m_loadedGlyphs","loadJSON","replacementDirUrl","replacementJson","replacementTexture","loadTexture","replacementFont","replacementGlyph","chars","xadvance","xoffset","yoffset","supportedBlocks","rawJSON","loadPages","assetsPath","getAssetsPath","jsonPath","jsonPromise","pagePromises","page","pages","loadPage","pagePath","charset","AllCaps","toUpperCase","glyphPromises","char","getFont","fontHash","glyphHash","fontGlyphMap","glyphPromise","createReplacementGlyph","charUnicodeBlock","loadAssets","loadedGlyph","shouldTransform","transformedCharacter","getGlyph","selectedFontName","textureBytes","loadedPage","loadBlock","sourceGlyphData","texturePath","pagePromise","fontStylePath","Bold","bold","Italic","italic","BoldItalic","boldItalic","MAX_NUM_COPY_PAGES","MAX_TEXTURE_SIZE","entryWidth","entryHeight","nRows","m_cacheHeight","m_cacheWidth","m_textureSize","m_entryCache","initCacheEntries","m_rt","depthBuffer","stencilBuffer","m_copyTextureSet","m_copyTransform","m_copyPositions","m_copyMaterial","m_copyVertexBuffer","m_copyPositionAttribute","m_copyUVAttribute","m_copyGeometry","copyIndexBuffer","m_copyMesh","m_copyGeometryDrawCount","m_clearMaterial","m_clearPositionAttribute","m_clearGeometry","clearIndexBuffer","m_clearMesh","m_clearGeometryDrawCount","oldestEntry","oldest","clearCacheEntry","copyGlyphToCache","willClearGeometry","willCopyGeometry","srcPages","nCopies","pageIndex","dummyFont","lineGap","dummyGlyphData","dummyEntry","cacheLocation","copyTextureIndex","applyMatrix3","setXYZ","setXY","Entry","newer","older","cacheCapacity","sizeFunction","m_newest","m_oldest","m_capacity","m_sizeFunction","callbackfn","thisArg","newCapacity","evict","sizeMeasure","entrySize","promoteEntry","newest","cb","entryOlder","deleteEntry","evictOldest","itemToRemove","isOk","tempTextPosition","tempTextBounds","tempVertexBuffer","m_fontCatalog","minGlyphCount","maxGlyphCount","m_ownsMaterial","createSdfTextMaterial","m_ownsBgMaterial","m_bgMaterial","m_defaultLayer","TextGeometry","m_layers","m_defaultTextRenderStyle","m_currentTextRenderStyle","m_defaultTextLayoutStyle","m_currentTextLayoutStyle","m_lineTypesetter","LineTypesetter","m_pathTypesetter","PathTypesetter","bgMaterial","backgroundMesh","oldTarget","layerId","outputBounds","upperCaseArray","pathOrigin","textPathOverflow","targetLayer","tempLayer","prevDrawCount","updatePosition","addPickingData","glyphArray","smallCapsEnabled","textBounds","storeStyles","computeTextBuffer","TextBufferObject","pick","glyphBounds","isPath","typesettingParams","smallCapsArray","vertexBuffer","arrangeGlyphs","m_tempTransform","m_tempCorners","m_tempLineDirection","m_tempRunDirection","m_tempPixelSize","m_tempPixelBgSize","m_tempScale","m_tempSmallCaps","m_currentParams","isOnlyMeasured","lineStartIdx","glyphWrapIdx","wordWrapIdx","lineStartX","lineCurrX","glyphWrapX","wordWrapX","lineCount","isBidirectionalLine","wrapPointIdx","wrapPointX","lineAlignment","placeLine","isBidirectional","placeRun","glyphDataArray","isRTL","runStart","neutralIdx","weakRunStart","weakGlyph","glyphFont","glyphFontMetrics","isBoldEmulated","isItalicEmulated","isSmallCaps","smallCapsScale","glyphScale","emulationWeight","isMirrored","verticalOffset","glyphVertexPosition","horizontalOffset","addToBuffer","m_tempPathPosition","m_tempPathLength","m_tempPathOffset","getLength","pathWidth","defaultGlyphRotation","normalDisplacement","textPoint","tangent","getTangent","ContextualForm","CombinedForm","m_singleCharactersMap","m_combinedCharactersMap","m_neutralCharacters","output","currentCodePoint","charCodeAt","isArabicCharacter","prevIndex","isNeutral","prevCodePoint","prevMap","getCharacterMap","Initial","Medial","nextIndex","nextCodePoint","nextMap","Final","combinedMap","getCombinedCharacterMap","fromCharCode","Connected","Isolated","Line3","START_BOX_BUFFER_SIZE","MAX_BOX_BUFFER_SIZE","NUM_VERTICES_PER_ELEMENT","NUM_INDICES_PER_ELEMENT","NUM_POSITION_VALUES_PER_VERTEX","NUM_COLOR_VALUES_PER_VERTEX","NUM_UV_VALUES_PER_VERTEX","NUM_INDEX_VALUES_PER_VERTEX","BoxBufferMesh","startElementCount","maxElementCount","resizeBuffer","pickInfos","internalMesh","indexAttribute","glyphCount","positionAttributeCount","colorAttributeCount","uvAttributeCount","indexAttributeCount","pickInfoCount","pickInfo","canAddElements","clearGroups","clearAttributes","isEmpty","pickInfoIndex","isPixelTransparent","forceResize","xScreenPos","yScreenPos","pixelIsTransparent","screenToUvCoordinates","pixel","getPixelFromImage","newPositionArray","newColorArray","newUvArray","numIndexValues","newIndexArray","getPixelFromImageBitmap","xPos","yPos","pixelData","getPixelFromImageData","imgData","strd","Uint8ClampedArray","getPixel","pickedColor","close","isImageBitmap","pixelsData","resortedGroups","numNotRendered","m_lengths","PathParam","curves","m_point","curve","m_cache","lineCurve","curveLengths","getCurveLengths","diff","segmentLength","DEFAULT_FONT_CATALOG","DEFAULT_MAX_NUM_RENDERED_TEXT_ELEMENTS","DEFAULT_MAX_NUM_SECOND_CHANCE_ELEMENTS","DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS","DEFAULT_LABEL_DISTANCE_SCALE_MIN","DEFAULT_LABEL_DISTANCE_SCALE_MAX","MIN_GLYPH_COUNT","MAX_GLYPH_COUNT","numSecondChanceLabels","tmpCachedDuplicate","getCacheKey","hasFeatureId","m_referenceMap","m_textMap","textElementFilter","updateElements","TextElementGroupState","m_sortedGroupStates","replaceCallback","replaceElement","anyEviction","updateFading","traverseVisibleElements","elementState","cacheKey","cacheResult","findDuplicate","cachedDuplicate","replacement","cachedEntries","cachedElement","maxSqDistError","getDedupSqDistTolerance","entryCount","elementPosition","duplicateIndex","distanceToSquared","m_visited","m_textElementStates","TextElementState","visibleElementsCallback","m_textRenderState","m_iconRenderStates","renderState","m_viewDistance","predecessor","RenderState","_point","FadingState","DEFAULT_FADE_TIME","m_state","Undefined","FadingIn","FadingOut","FadedIn","FadedOut","fadingTime","Count","GroupedPriorityList","DEFAULT_DYNAMIC_MSAA_SAMPLING_LEVEL","DEFAULT_STATIC_MSAA_SAMPLING_LEVEL","Level_4","antialiasSettings","msaaEnabled","strength","threshold","thickness","ghostExtrudedPolygons","m_width","m_height","m_renderPass","RenderPass","m_target1","m_target2","m_sepiaPass","ShaderPass","m_vignettePass","m_readBuffer","m_msaaPass","m_dynamicMsaaSamplingLevel","dynamicMsaaSamplingLevel","m_staticMsaaSamplingLevel","staticMsaaSamplingLevel","m_lowResPass","LowResRenderPass","isStaticFrame","usePostEffects","activeTarget","clearDepth","m_outlineEffect","OutlineEffect","nextEffectEnabled","m_bloomPass","BloomPass","m_savedWidth","m_savedHeight","vertexShaderChunk","vertexShaderChunk2","m_defaultThickness","m_defaultColor","m_defaultAlpha","m_defaultKeepAlive","m_ghostExtrudedPolygons","m_removeThresholdCount","m_originalMaterials","m_originalOnBeforeRenders","m_shaderIDs","MeshLambertMaterial","MeshPhongMaterial","MeshToonMaterial","MeshPhysicalMaterial","m_uniformsChunk","outlineThickness","outlineAlpha","domElement","shadowMap","ghost","depth","stencil","updateStyle","setViewport","setScissor","setScissorTest","renderTarget","currentAutoClear","renderOutline","currentSceneAutoUpdate","autoUpdate","currentSceneBackground","currentShadowMapEnabled","setOutlineMaterial","restoreOriginalMaterial","cleanupCache","originalMaterial","shaderID","originalUniforms","originalVertexShader","ShaderLib","isRawShaderMaterial","createInvisibleMaterial","isShaderMaterial","DECLARE_TRANSFORMED","BackSide","skinning","morphTargets","morphNormals","used","keepAlive","getOutlineMaterialFromCache","updateOutlineMaterial","getOutlineMaterial","outlineParameters","BlurDirectionX","BlurDirectionY","resolution","m_renderTargetsHorizontal","m_renderTargetsVertical","m_nMips","m_separableBlurMaterials","m_basic","m_bloomTintColors","pars","resx","resy","m_renderTargetBright","renderTargetHorizonal","renderTargetVertical","m_highPassUniforms","m_materialHighPassFilter","kernelSizeArray","getSeperableBlurMaterial","m_compositeMaterial","getCompositeMaterial","m_copyUniforms","m_materialCopy","rt","inputRenderTarget","kernelRadius","KERNEL_RADIUS","SIGMA","colorTexture","texSize","nMips","NUM_MIPS","blurTexture1","blurTexture2","blurTexture3","blurTexture4","blurTexture5","dirtTexture","bloomStrength","bloomFactors","bloomTintColors","bloomRadius","TileKeyEntry","longitudeOffset","m_extendedFrustumCulling","m_frustum","Frustum","m_viewProjectionMatrix","m_rootTileKeys","m_tileKeyEntries","m_mapTileCuller","MapTileCuller","projectionMatrixOverride","setFromMatrix","computeRequiredInitialRootTileKeys","maxTileLevel","useElevationRangeSource","tileBounds","Box3","workList","shouldSubdivide","uniqueKey","cachedTileEntry","tileKeyAndOffset","getElevationRange","calculationStatus","FinalPrecise","subTileArea","computeSubTileArea","subTileEntry","frustumIntersectsTileBox","intersectsBox","q","getCenter","modelViewProjMatrix","makeTranslation","projectedPoints","tmpVector2","expandByPoint","rootTileKey","worldGeoPoint","totalAngleRad","worldLengthHorizontal","worldLeftPoint","worldLeftGeoPoint","offsetRange","SQRT2","m_globalFrustumMin","m_globalFrustumMax","m_frustumCorners","frustumCorners","getFrustumCorners","frustumCorner","globalFrustumMin","globalFrustumMax","invProjMatrix","projectionMatrixInverse","cornerIndex","addPoint","overlayObject","overlayPosition","worldCoords","geoCoords","overlayTextElement","TEXT_OVERLAY_SPREAD_FRAME_COUNT","firstObject","Terrain","allTextElementsOverlaid","textElementsPerFrame","textElementsCount","DefaultPhases","Border","DefaultBasicGeometryKinds","m_maxUpdatedTilePerFrame","m_loadPhaseDefinitions","m_basicGeometryKinds","PhasedTileGeometryLoader","updateSomeTiles","updateAllTilesTogether","checkTilesFinished","phasedGeometryLoader","numTilesUpdated","lowestPhase","currentPhase","nextPhase","updateTilesIfNeeded","toPhase","updateToPhase","m_geometryKindsLoaded","m_currentPhaseIndex","didUpdate","numberOfPhases","doFullUpdate","loadPhaseDefinitions","currentPhaseDefinition","createKind","kindToCreate","techniqueKind","indexBuffer","vertexStride","contourEdges","nSegments","vFootprint0","vRoof0","vFootprint1","vRoof1","currEdgeStart","currEdgeGoal","prevEdgeStart","prevEdgeGoal","polygonContour","polygonContourEdges","isExtruded","addFootprintEdges","wallEdgeSlope","prevEdgeIdx","v0x","v0y","v1x","v1y","vFoot0","ThreeBufferUtils","getBufferElementType","fromThreeBufferAttribute","bufferAttribute","fromThreeInterleavedBufferAttribute","fromThreeBufferGeometry","attributeNames","screenBounds","rtree","threeBox","box2","bbox","collisionBox","toCollisionBox","boundedLine","intersectsLine","lineXDiffTransformed","signBL","signBR","signTL","signTR","lineYDiffTransformed","normalX","normalY","debugCanvas","m_renderContext","m_renderingEnabled","m_numAllocations","m_numSuccessfulTests","m_numFailedTests","m_numSuccessfulVisibilityTests","m_numFailedVisibilityTests","strokeStyle","strokeRect","boundsArray","isFailed","isOnScreen","ndc","projectVector","tempV3","ndcToScreen","tempV2","m_sky","m_projectionType","m_skyTexture","SkyGradientTexture","SkyCubemapTexture","isSameSkyType","DEFAULT_TEXTURE_SIZE","DEFAULT_MONOMIAL_POWER","cameraDir","cameraRight","cameraUp","topColor","bottomColor","m_faceCount","m_faces","fillTextureData","monomialPower","unpackAlignment","m_farClipPlaneDividedVertically","m_groundPlane","m_bottomMidFarPoint","m_topMidFarPoint","m_horizonPosition","m_farClipPlaneCorners","setHorizonPosition","updateTexturePosition","faceIdx","upDir","unproject","intersectLine","skyRatio","DEFAULT_FONT_CATALOG_NAME","m_catalogsLoading","defaultFontCatalogUrl","catalogCallback","fontCatalogConfig","fontCatalogPromise","m_renderedTilesChangeCheck","m_minGlyphCount","m_maxGlyphCount","TextCanvas","CopyrightElementHandler","m_defaults","m_mapViews","mergedCopyrightInfo","staticInfo","m_element","display","defaults","deduped","innerHTML","htmlElement","UrlCopyrightProvider","CopyrightCoverageProvider","m_fetchURL","m_baseScheme","m_cachedCopyrightResponse","DeferredPromise","executor","doExec","resolveFunc","rejectFunc","execInnerPromise","fetchFunction","maxRetries","activeDownloadCount","downloadQueue","activeDownloads","defaultInstance","retryCount","status","waitFor","retryTimeout","fetchRepeatedly","milliseconds","downloadAs","download","arrayBuffer","maxParallelDownloads","deferred","doDownload","onDownloadDone","execDeferredDownload","future","converter","pendingFetch","newFetch","ImageItem","m_wantsPoints","m_wantsLines","m_wantsAreas","m_wantsObject3D","wantsAll","wantsPoints","wantsLines","wantsAreas","wantsObject3D","visitObject","wantsFeature","visitMesh","BufferedGeometryLineAccessor","BufferedGeometryObject3dAccessor","IndexedBufferedGeometryLineAccessor","meshObject","geometryAccessor","getBufferGeometry","getIndexedGeometryAccessor","getGeometryAccessor","getCount","setRange","visitPoint","visitLine","visitArea","visitObject3D","tmpNormal","tmpTangent0","tmpTangent1","tmpBitangent","SEGMENT_OFFSET","LINE_VERTEX_ATTRIBUTES","NORMAL_UV_VERTEX_ATTRIBUTES","LINE_VERTEX_ATTRIBUTES_NUV","HP_LINE_VERTEX_ATTRIBUTES","HP_LINE_VERTEX_ATTRIBUTES_NUV","LineGeometry","getVertexDescriptor","hasNormalsAndUvs","highPrecision","createLineGeometry","polyline","uvs","colors","pointCount","segments","tangents","hasSegmentOffsets","hasTexCoords","sqrLength","lineCoverage","lineLength","isClosed","tmpVertices","addVertexPair","T1","T2","segment","extrusionCoord","highComp","lowComp","setComponent","computeBitangent","createSimpleLineGeometry","LineGroup","isSimple","vertexDescriptor","descr","createGeometry","isHighPrecisionPointsMaterial","dimensionality","setDimensionality","m_processLayersDefault","m_processPointsDefault","m_processLinesDefault","m_processPolygonsDefault","m_layersToProcess","m_layersToIgnore","m_pointsToProcess","m_ignoredPoints","m_linesToProcess","m_linesToIgnore","m_polygonsToProcess","m_polygonsToIgnore","m_kindsToProcess","m_kindsToIgnore","processLayersDefault","processPointsDefault","processLinesDefault","processPolygonsDefault","addItem","addItems","layersToProcess","layersToIgnore","pointsToProcess","pointsToIgnore","linesToProcess","linesToIgnore","polygonsToProcess","polygonsToIgnore","kindsToProcess","kindsToIgnore","items","layerName","matchLayer","geometryTypes","geomType","classes","featureClass","matchClass","featureAttribute","geomTypes","featureClasses","OmvGenericFeatureFilter","description","layerItems","layerItem","itemsToProcess","itemsToIgnore","defaultResult","filters","hasKindFilter","wantsLayer","wantsPointFeature","wantsLineFeature","wantsPolygonFeature","wantsKind","OmvGenericFeatureModifier","doProcessFeature","featureClassThing","matchItems","matchAttribute","getDataProvider","OmvRestClient","missingOmvDecoderServiceInfoEmitted","TileDataSource","tileFactory","TileFactory","concurrentDecoderServiceName","concurrentDecoderScriptUrl","copyrightProvider","m_decoderOptions","showMissingTechniques","filterDescription","filterDescr","gatherFeatureAttributes","createTileInfo","gatherRoadSegments","featureModifierId","skipShortLabels","enableElevationOverlay","configureDecoder","configure","m_modelConstructor","maxLevelTileLoaderCache","m_tileFactory","m_isReady","m_decoder","getTileDecoder","concurrentDecoderWorkerCount","m_tileLoaderCache","getCacheCount","newTileLoader","getCopyrights","TileInfoLoader","loaderState","debugMaterial","linewidth","NeverDepth","debugCircleMaterial","debugBlackCircleMaterial","OmvDebugLabelsTile","addLabelDebugInfo","debugTextPaths","debugTextPathsFull","tileGeometryCreator","colorMap","indexFilter","lineGeometry","lineIndices","redPointGeometry","redPointIndices","redPointPositions","blackPointGeometry","blackPointIndices","blackPointPositions","pointScale","pathIndex","isRedPoint","pointSize","labelElement","addUserTextElement","lineMesh","redPointMesh","blackPointMesh","appId","appCode"],"mappings":"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","file":"index.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 115);\n","module.exports = THREE;","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport * from \"./lib/GroupedPriorityList\";\nexport * from \"./lib/Logger\";\nexport * from \"./lib/Math2D\";\nexport * from \"./lib/MathUtils\";\nexport * from \"./lib/Mixins\";\nexport * from \"./lib/assert\";\nexport * from \"./lib/CachedResource\";\nexport * from \"./lib/ContextLogger\";\nexport * from \"./lib/PerformanceTimer\";\nexport * from \"./lib/ObjectUtils\";\nexport * from \"./lib/OptionsUtils\";\nexport * from \"./lib/UriResolver\";\nexport * from \"./lib/UrlUtils\";\nexport * from \"./lib/UrlPlatformUtils\";\nexport * from \"./lib/Functions\";\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport * from \"./lib/ColorUtils\";\nexport * from \"./lib/Expr\";\nexport * from \"./lib/Techniques\";\nexport * from \"./lib/TechniqueParams\";\nexport * from \"./lib/Theme\";\nexport * from \"./lib/PostEffects\";\nexport * from \"./lib/InterpolatedProperty\";\nexport * from \"./lib/InterpolatedPropertyDefs\";\nexport * from \"./lib/WorkerServiceProtocol\";\nexport * from \"./lib/WorkerTilerProtocol\";\nexport * from \"./lib/WorkerDecoderProtocol\";\nexport * from \"./lib/ITileDecoder\";\nexport * from \"./lib/ITiler\";\nexport * from \"./lib/DecodedTile\";\nexport * from \"./lib/TileInfo\";\nexport * from \"./lib/GeoJsonDataType\";\nexport * from \"./lib/ThemeVisitor\";\nexport * from \"./lib/StringEncodedNumeral\";\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport * from \"./lib/CirclePointsMaterial\";\nexport * from \"./lib/CopyMaterial\";\nexport * from \"./lib/EdgeMaterial\";\nexport * from \"./lib/HighPrecisionLineMaterial\";\nexport * from \"./lib/HighPrecisionPointMaterial\";\nexport * from \"./lib/IconMaterial\";\nexport * from \"./lib/LuminosityHighPassShader\";\nexport * from \"./lib/MapMeshMaterials\";\nexport * from \"./lib/MSAAMaterial\";\nexport * from \"./lib/SepiaShader\";\nexport * from \"./lib/SolidLineMaterial\";\nexport * from \"./lib/Utils\";\nexport * from \"./lib/VignetteShader\";\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Env, Value } from \"./Env\";\nimport { ExprEvaluator, ExprEvaluatorContext, OperatorDescriptor } from \"./ExprEvaluator\";\nimport { ExprInstantiator, InstantiationContext } from \"./ExprInstantiator\";\nimport { ExprParser } from \"./ExprParser\";\nimport { ExprPool } from \"./ExprPool\";\nimport { isInterpolatedPropertyDefinition } from \"./InterpolatedProperty\";\nimport { interpolatedPropertyDefinitionToJsonExpr } from \"./InterpolatedPropertyDefs\";\nimport { Definitions, isSelectorDefinition, isValueDefinition } from \"./Theme\";\n\nexport * from \"./Env\";\n\nconst exprEvaluator = new ExprEvaluator();\n\nconst exprInstantiator = new ExprInstantiator();\n\nexport interface ExprVisitor<Result, Context> {\n    visitNullLiteralExpr(expr: NullLiteralExpr, context: Context): Result;\n    visitBooleanLiteralExpr(expr: BooleanLiteralExpr, context: Context): Result;\n    visitNumberLiteralExpr(expr: NumberLiteralExpr, context: Context): Result;\n    visitStringLiteralExpr(expr: StringLiteralExpr, context: Context): Result;\n    visitObjectLiteralExpr(expr: ObjectLiteralExpr, context: Context): Result;\n    visitVarExpr(expr: VarExpr, context: Context): Result;\n    visitHasAttributeExpr(expr: HasAttributeExpr, context: Context): Result;\n    visitContainsExpr(expr: ContainsExpr, context: Context): Result;\n    visitCallExpr(expr: CallExpr, context: Context): Result;\n    visitMatchExpr(expr: MatchExpr, context: Context): Result;\n    visitCaseExpr(expr: CaseExpr, context: Context): Result;\n}\n\n/**\n * The dependencies of an [[Expr]].\n */\nexport class ExprDependencies {\n    /**\n     * The properties needed to evaluate the [[Expr]].\n     */\n    readonly properties = new Set<string>();\n\n    /**\n     * `true` if the [[Expr]] depends on zoom level. Default is `false`.\n     */\n    zoom?: boolean;\n}\n\nclass ComputeExprDependencies implements ExprVisitor<void, ExprDependencies> {\n    static instance = new ComputeExprDependencies();\n\n    /**\n     * Gets the dependencies of an [[Expr]].\n     *\n     * @param expr The [[Expr]] to process.\n     * @param scope The evaluation scope. Defaults to [[ExprScope.Value]].\n     * @param dependencies The output [[Set]] of dependency names.\n     */\n    static of(expr: Expr) {\n        const dependencies = new ExprDependencies();\n        expr.accept(this.instance, dependencies);\n        return dependencies;\n    }\n\n    visitNullLiteralExpr(expr: NullLiteralExpr, context: ExprDependencies): void {\n        // nothing to do\n    }\n\n    visitBooleanLiteralExpr(expr: BooleanLiteralExpr, context: ExprDependencies): void {\n        // nothing to do\n    }\n\n    visitNumberLiteralExpr(expr: NumberLiteralExpr, context: ExprDependencies): void {\n        // nothing to do\n    }\n\n    visitStringLiteralExpr(expr: StringLiteralExpr, context: ExprDependencies): void {\n        // nothing to do\n    }\n\n    visitObjectLiteralExpr(expr: ObjectLiteralExpr, context: ExprDependencies): void {\n        // nothing to do\n    }\n\n    visitVarExpr(expr: VarExpr, context: ExprDependencies): void {\n        context.properties.add(expr.name);\n    }\n\n    visitHasAttributeExpr(expr: HasAttributeExpr, context: ExprDependencies): void {\n        context.properties.add(expr.name);\n    }\n\n    visitContainsExpr(expr: ContainsExpr, context: ExprDependencies): void {\n        expr.value.accept(this, context);\n    }\n\n    visitCallExpr(expr: CallExpr, context: ExprDependencies): void {\n        if (expr.op === \"zoom\" && expr.args.length === 0) {\n            context.zoom = true;\n        } else {\n            expr.args.forEach(childExpr => childExpr.accept(this, context));\n        }\n    }\n\n    visitMatchExpr(expr: MatchExpr, context: ExprDependencies): void {\n        expr.value.accept(this, context);\n        expr.branches.forEach(([_, branch]) => branch.accept(this, context));\n        expr.fallback.accept(this, context);\n    }\n\n    visitCaseExpr(expr: CaseExpr, context: ExprDependencies): void {\n        expr.branches.forEach(([condition, branch]) => {\n            condition.accept(this, context);\n            branch.accept(this, context);\n        });\n        expr.fallback.accept(this, context);\n    }\n}\n\n/**\n * A type represeting JSON values.\n */\nexport type JsonValue = null | boolean | number | string | JsonObject | JsonArray;\n\n/**\n * A type representing JSON arrays.\n */\nexport interface JsonArray extends Array<JsonValue> {}\n\n/**\n * A type representing JSON objects.\n */\nexport interface JsonObject {\n    [name: string]: JsonValue;\n}\n\n/**\n * The JSON representation of an [[Expr]] object.\n */\nexport type JsonExpr = JsonArray;\n\nexport function isJsonExpr(v: any): v is JsonExpr {\n    return Array.isArray(v) && v.length > 0 && typeof v[0] === \"string\";\n}\n\n/**\n * Internal state needed by [[Expr.fromJSON]] to resolve `\"ref\"` expressions.\n * @hidden\n */\ninterface ReferenceResolverState {\n    definitions: Definitions;\n    lockedNames: Set<string>;\n    cache: Map<string, Expr>;\n}\n\n/**\n * The evaluation scope of an [[Expr]].\n */\nexport enum ExprScope {\n    /**\n     * The scope of an [[Expr]] used as value of an attribute.\n     */\n    Value,\n\n    /**\n     * The scope of an [[Expr]] used in a [[Technique]] `when` condition.\n     */\n    Condition,\n\n    /**\n     * The scope of an [[Expr]] used as dynamic property attribute value.\n     */\n    Dynamic\n}\n\n/**\n * Abstract class defining a shape of a [[Theme]]'s expression\n */\nexport abstract class Expr {\n    /**\n     * Tests of given value is an [[Expr]].\n     *\n     * @param value The object to test.\n     */\n    static isExpr(value: any): value is Expr {\n        return value instanceof Expr;\n    }\n\n    /**\n     * Creates an expression from the given `code`.\n     *\n     * @param code The code to parse.\n     * @returns The parsed [[Expr]].\n     * @deprecated\n     */\n    static parse(code: string): Expr | never {\n        const parser = new ExprParser(code);\n        const expr = parser.parse();\n        return expr;\n    }\n\n    /**\n     * Parse expression in JSON form.\n     *\n     * If `definitions` are defined, then references (`['ref', name]`) are resolved.\n     *\n     * Pass `definitionExprCache` to reuse `Expr` instances created from definitions across\n     * many `fromJSON` calls.\n     *\n     * @param node expression in JSON format to parse\n     * @param definitions optional set of definitions needed definition resolved by `ref` operator\n     * @param definitionExprCache optional cache of `Expr` instances derived from `definitions`\n     */\n    static fromJSON(\n        node: JsonValue,\n        definitions?: Definitions,\n        definitionExprCache?: Map<string, Expr>\n    ) {\n        const referenceResolverState: ReferenceResolverState | undefined =\n            definitions !== undefined\n                ? {\n                      definitions,\n                      lockedNames: new Set(),\n                      cache: definitionExprCache || new Map<string, Expr>()\n                  }\n                : undefined;\n\n        return parseNode(node, referenceResolverState);\n    }\n\n    private m_isDynamic?: boolean;\n\n    /**\n     * Evaluate an expression returning a [[Value]] object.\n     *\n     * @param env The [[Env]] used to lookup symbols.\n     * @param scope The evaluation scope. Defaults to [[ExprScope.Value]].\n     * @param cache A cache of previously computed results.\n     */\n    evaluate(\n        env: Env,\n        scope: ExprScope = ExprScope.Value,\n        cache?: Map<Expr, Value>\n    ): Value | never {\n        return this.accept(\n            exprEvaluator,\n            new ExprEvaluatorContext(exprEvaluator, env, scope, cache)\n        );\n    }\n\n    /**\n     * Instantiates this [[Expr]] by resolving references to the `get` and\n     * `has` operator using the given instantiation context.\n     *\n     * @param context The [[InstantationContext]] used to resolve names.\n     */\n    instantiate(context: InstantiationContext): Expr {\n        return this.accept(exprInstantiator, context);\n    }\n\n    /**\n     * Gets the dependencies of this [[Expr]].\n     */\n    dependencies(): ExprDependencies {\n        return ComputeExprDependencies.of(this);\n    }\n\n    /**\n     * Create a unique object that is structurally equivalent to this [[Expr]].\n     *\n     * @param pool The [[ExprPool]] used to create a unique\n     * equivalent object of this [[Expr]].\n     */\n    intern(pool: ExprPool): Expr {\n        return pool.add(this);\n    }\n\n    toJSON(): JsonValue {\n        return new ExprSerializer().serialize(this);\n    }\n\n    /**\n     * Returns `true` if a dynamic execution context is required to evaluate this [[Expr]].\n     */\n    isDynamic(): boolean {\n        if (this.m_isDynamic === undefined) {\n            this.m_isDynamic = this.exprIsDynamic();\n        }\n        return this.m_isDynamic;\n    }\n\n    abstract accept<Result, Context>(\n        visitor: ExprVisitor<Result, Context>,\n        context: Context\n    ): Result;\n\n    /**\n     * Update the dynamic state of this [[Expr]].\n     *\n     * [[exprIsDynamic]] must never be called directly.\n     *\n     * @hidden\n     */\n    protected abstract exprIsDynamic(): boolean;\n}\n\n/**\n * @hidden\n */\nexport type RelationalOp = \"<\" | \">\" | \"<=\" | \">=\";\n\n/**\n * @hidden\n */\nexport type EqualityOp = \"~=\" | \"^=\" | \"$=\" | \"==\" | \"!=\";\n\n/**\n * @hidden\n */\nexport type BinaryOp = RelationalOp | EqualityOp;\n\n/**\n * Var expression.\n * @hidden\n */\nexport class VarExpr extends Expr {\n    constructor(readonly name: string) {\n        super();\n    }\n\n    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result {\n        return visitor.visitVarExpr(this, context);\n    }\n\n    protected exprIsDynamic() {\n        return false;\n    }\n}\n\nexport abstract class LiteralExpr extends Expr {\n    /**\n     * Create a [[LiteralExpr]] from the given value.\n     *\n     * @param value A constant value.\n     */\n    static fromValue(value: Value): Expr {\n        switch (typeof value) {\n            case \"boolean\":\n                return new BooleanLiteralExpr(value);\n            case \"number\":\n                return new NumberLiteralExpr(value);\n            case \"string\":\n                return new StringLiteralExpr(value);\n            case \"object\":\n                return value === null ? NullLiteralExpr.instance : new ObjectLiteralExpr(value);\n            default:\n                throw new Error(`failed to create a literal from '${value}'`);\n        } // switch\n    }\n\n    abstract get value(): Value;\n\n    protected exprIsDynamic() {\n        return false;\n    }\n}\n\n/**\n * Null literal expression.\n * @hidden\n */\nexport class NullLiteralExpr extends LiteralExpr {\n    static instance = new NullLiteralExpr();\n    readonly value = null;\n\n    protected constructor() {\n        super();\n    }\n\n    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result {\n        return visitor.visitNullLiteralExpr(this, context);\n    }\n\n    protected exprIsDynamic() {\n        return false;\n    }\n}\n\n/**\n * Boolean literal expression.\n * @hidden\n */\nexport class BooleanLiteralExpr extends LiteralExpr {\n    constructor(readonly value: boolean) {\n        super();\n    }\n\n    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result {\n        return visitor.visitBooleanLiteralExpr(this, context);\n    }\n}\n\n/**\n * Number literal expression.\n * @hidden\n */\nexport class NumberLiteralExpr extends LiteralExpr {\n    constructor(readonly value: number) {\n        super();\n    }\n\n    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result {\n        return visitor.visitNumberLiteralExpr(this, context);\n    }\n}\n\n/**\n * String literal expression.\n * @hidden\n */\nexport class StringLiteralExpr extends LiteralExpr {\n    constructor(readonly value: string) {\n        super();\n    }\n\n    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result {\n        return visitor.visitStringLiteralExpr(this, context);\n    }\n}\n\n/**\n * Object literal expression.\n * @hidden\n */\nexport class ObjectLiteralExpr extends LiteralExpr {\n    constructor(readonly value: object) {\n        super();\n    }\n\n    get isArrayLiteral() {\n        return Array.isArray(this.value);\n    }\n\n    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result {\n        return visitor.visitObjectLiteralExpr(this, context);\n    }\n}\n\n/**\n * A has expression with an attribute, for example `has(ref)`.\n * @hidden\n */\nexport class HasAttributeExpr extends Expr {\n    constructor(readonly name: string) {\n        super();\n    }\n\n    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result {\n        return visitor.visitHasAttributeExpr(this, context);\n    }\n\n    protected exprIsDynamic() {\n        return false;\n    }\n}\n\n/**\n * A contains expression.\n * @hidden\n */\nexport class ContainsExpr extends Expr {\n    static isValidElementsArray(elements: JsonValue): elements is Array<number | string> {\n        if (!Array.isArray(elements) || elements.length === 0) {\n            return false;\n        }\n\n        const elementTy = typeof elements[0];\n\n        if (elementTy === \"number\" || elementTy === \"string\") {\n            return elements.every(element => typeof element === elementTy);\n        }\n\n        return false;\n    }\n\n    constructor(readonly value: Expr, readonly elements: Array<number | string>) {\n        super();\n    }\n\n    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result {\n        return visitor.visitContainsExpr(this, context);\n    }\n\n    protected exprIsDynamic() {\n        return this.value.isDynamic();\n    }\n}\n\n/**\n * @hidden\n */\nexport class CallExpr extends Expr {\n    descriptor?: OperatorDescriptor;\n\n    constructor(readonly op: string, readonly args: Expr[]) {\n        super();\n    }\n\n    /**\n     * Returns the child nodes of this [[Expr]].\n     * @deprecated\n     */\n    get children() {\n        return this.args;\n    }\n\n    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result {\n        return visitor.visitCallExpr(this, context);\n    }\n\n    protected exprIsDynamic() {\n        const descriptor = this.descriptor || ExprEvaluator.getOperator(this.op);\n\n        if (descriptor && descriptor.isDynamicOperator && descriptor.isDynamicOperator(this)) {\n            return true;\n        }\n\n        return this.args.some(e => e.isDynamic());\n    }\n}\n\n/**\n * @hidden\n */\nexport type MatchLabel = number | string | number[] | string[];\n\n/**\n * @hidden\n */\nexport class MatchExpr extends Expr {\n    /**\n     * Tests if the given JSON node is a valid label for the `\"match\"` operator.\n     *\n     * @param node A JSON value.\n     */\n    static isValidMatchLabel(node: JsonValue): node is MatchLabel {\n        switch (typeof node) {\n            case \"number\":\n            case \"string\":\n                return true;\n            case \"object\":\n                if (!Array.isArray(node) || node.length === 0) {\n                    return false;\n                }\n                const elementTy = typeof node[0];\n                if (elementTy === \"number\" || elementTy === \"string\") {\n                    return node.every(t => typeof t === elementTy);\n                }\n                return false;\n            default:\n                return false;\n        } // switch\n    }\n\n    constructor(\n        readonly value: Expr,\n        readonly branches: Array<[MatchLabel, Expr]>,\n        readonly fallback: Expr\n    ) {\n        super();\n    }\n\n    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result {\n        return visitor.visitMatchExpr(this, context);\n    }\n\n    protected exprIsDynamic() {\n        return (\n            this.value.isDynamic() ||\n            this.branches.some(([_, branch]) => branch.isDynamic()) ||\n            this.fallback.isDynamic()\n        );\n    }\n}\n\n/**\n * @hidden\n */\nexport class CaseExpr extends Expr {\n    constructor(readonly branches: Array<[Expr, Expr]>, readonly fallback: Expr) {\n        super();\n    }\n\n    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result {\n        return visitor.visitCaseExpr(this, context);\n    }\n\n    protected exprIsDynamic() {\n        return (\n            this.branches.some(([cond, branch]) => cond.isDynamic() || branch.isDynamic()) ||\n            this.fallback.isDynamic()\n        );\n    }\n}\n\n/**\n * @hidden\n */\nclass ExprSerializer implements ExprVisitor<JsonValue, void> {\n    serialize(expr: Expr): JsonValue {\n        return expr.accept(this, undefined);\n    }\n\n    visitNullLiteralExpr(expr: NullLiteralExpr, context: void): JsonValue {\n        return null;\n    }\n\n    visitBooleanLiteralExpr(expr: BooleanLiteralExpr, context: void): JsonValue {\n        return expr.value;\n    }\n\n    visitNumberLiteralExpr(expr: NumberLiteralExpr, context: void): JsonValue {\n        return expr.value;\n    }\n\n    visitStringLiteralExpr(expr: StringLiteralExpr, context: void): JsonValue {\n        return expr.value;\n    }\n\n    visitObjectLiteralExpr(expr: ObjectLiteralExpr, context: void): JsonValue {\n        return [\"literal\", expr.value as JsonObject];\n    }\n\n    visitVarExpr(expr: VarExpr, context: void): JsonValue {\n        return [\"get\", expr.name];\n    }\n\n    visitHasAttributeExpr(expr: HasAttributeExpr, context: void): JsonValue {\n        return [\"has\", expr.name];\n    }\n\n    visitContainsExpr(expr: ContainsExpr, context: void): JsonValue {\n        return [\"in\", this.serialize(expr.value), expr.elements];\n    }\n\n    visitCallExpr(expr: CallExpr, context: void): JsonValue {\n        return [expr.op, ...expr.args.map(childExpr => this.serialize(childExpr))];\n    }\n\n    visitMatchExpr(expr: MatchExpr, context: void): JsonValue {\n        const branches: JsonValue[] = [];\n        for (const [label, body] of expr.branches) {\n            branches.push(label, this.serialize(body));\n        }\n        return [\"match\", this.serialize(expr.value), ...branches, this.serialize(expr.fallback)];\n    }\n\n    visitCaseExpr(expr: CaseExpr, context: void): JsonValue {\n        const branches: JsonValue[] = [];\n        for (const [condition, body] of expr.branches) {\n            branches.push(this.serialize(condition), this.serialize(body));\n        }\n        return [\"case\", ...branches, this.serialize(expr.fallback)];\n    }\n}\n\nfunction parseNode(\n    node: JsonValue,\n    referenceResolverState: ReferenceResolverState | undefined\n): Expr {\n    if (Array.isArray(node)) {\n        return parseCall(node, referenceResolverState);\n    } else if (node === null) {\n        return NullLiteralExpr.instance;\n    } else if (typeof node === \"boolean\") {\n        return new BooleanLiteralExpr(node);\n    } else if (typeof node === \"number\") {\n        return new NumberLiteralExpr(node);\n    } else if (typeof node === \"string\") {\n        return new StringLiteralExpr(node);\n    }\n    throw new Error(`failed to create expression from: ${JSON.stringify(node)}`);\n}\n\nfunction parseCall(node: JsonArray, referenceResolverState?: ReferenceResolverState): Expr {\n    const op = node[0];\n\n    if (typeof op !== \"string\") {\n        throw new Error(\"expected a builtin function name\");\n    }\n\n    switch (op) {\n        case \"!has\":\n        case \"!in\":\n            return new CallExpr(\"!\", [parseCall([op.slice(1), ...node.slice(1)])]);\n\n        case \"ref\":\n            return resolveReference(node, referenceResolverState);\n\n        case \"get\":\n            return parseGetExpr(node, referenceResolverState);\n\n        case \"has\":\n            return parseHasExpr(node, referenceResolverState);\n\n        case \"in\":\n            return parseInExpr(node, referenceResolverState);\n\n        case \"literal\":\n            return parseLiteralExpr(node);\n\n        case \"match\":\n            return parseMatchExpr(node, referenceResolverState);\n\n        case \"case\":\n            return parseCaseExpr(node, referenceResolverState);\n\n        default:\n            return makeCallExpr(op, node, referenceResolverState);\n    } // switch\n}\n\nfunction parseGetExpr(node: JsonArray, referenceResolverState: ReferenceResolverState | undefined) {\n    if (node[2] !== undefined) {\n        return makeCallExpr(\"get\", node, referenceResolverState);\n    }\n    const name = node[1];\n    if (typeof name !== \"string\") {\n        throw new Error(`expected the name of an attribute`);\n    }\n    return new VarExpr(name);\n}\n\nfunction parseHasExpr(node: JsonArray, referenceResolverState: ReferenceResolverState | undefined) {\n    if (node[2] !== undefined) {\n        return makeCallExpr(\"has\", node, referenceResolverState);\n    }\n    const name = node[1];\n    if (typeof name !== \"string\") {\n        throw new Error(`expected the name of an attribute`);\n    }\n    return new HasAttributeExpr(name);\n}\n\nfunction parseInExpr(node: JsonArray, referenceResolverState: ReferenceResolverState | undefined) {\n    const elements = node[2];\n    if (!ContainsExpr.isValidElementsArray(elements)) {\n        // tslint:disable-next-line: max-line-length\n        throw new Error(`'in' expects an array of number or string literals`);\n    }\n    return new ContainsExpr(parseNode(node[1], referenceResolverState), elements);\n}\n\nfunction parseLiteralExpr(node: JsonArray) {\n    const obj = node[1];\n    if (obj === null || typeof obj !== \"object\") {\n        throw new Error(\"expected an object or array literal\");\n    }\n    return new ObjectLiteralExpr(obj);\n}\n\nfunction parseMatchExpr(\n    node: JsonArray,\n    referenceResolverState: ReferenceResolverState | undefined\n) {\n    if (node.length < 4) {\n        throw new Error(\"not enough arguments\");\n    }\n    if (!(node.length % 2)) {\n        throw new Error(\"fallback is missing in 'match' expression\");\n    }\n    const value = parseNode(node[1], referenceResolverState);\n    const conditions: Array<[MatchLabel, Expr]> = [];\n    for (let i = 2; i < node.length - 1; i += 2) {\n        const label = node[i];\n        if (!MatchExpr.isValidMatchLabel(label)) {\n            throw new Error(`'${JSON.stringify(label)}' is not a valid label for 'match'`);\n        }\n        const expr = parseNode(node[i + 1], referenceResolverState);\n        conditions.push([label, expr]);\n    }\n    const fallback = parseNode(node[node.length - 1], referenceResolverState);\n    return new MatchExpr(value, conditions, fallback);\n}\n\nfunction parseCaseExpr(\n    node: JsonArray,\n    referenceResolverState: ReferenceResolverState | undefined\n) {\n    if (node.length < 3) {\n        throw new Error(\"not enough arguments\");\n    }\n    if (node.length % 2) {\n        throw new Error(\"fallback is missing in 'case' expression\");\n    }\n    const branches: Array<[Expr, Expr]> = [];\n    for (let i = 1; i < node.length - 1; i += 2) {\n        const condition = parseNode(node[i], referenceResolverState);\n        const expr = parseNode(node[i + 1], referenceResolverState);\n        branches.push([condition, expr]);\n    }\n    const caseFallback = parseNode(node[node.length - 1], referenceResolverState);\n    return new CaseExpr(branches, caseFallback);\n}\n\nfunction makeCallExpr(\n    op: string,\n    node: any[],\n    referenceResolverState?: ReferenceResolverState\n): Expr {\n    return new CallExpr(\n        op,\n        node.slice(1).map(childExpr => parseNode(childExpr, referenceResolverState))\n    );\n}\n\nfunction resolveReference(node: JsonArray, referenceResolverState?: ReferenceResolverState) {\n    if (typeof node[1] !== \"string\") {\n        throw new Error(`expected the name of an attribute`);\n    }\n    if (referenceResolverState === undefined) {\n        throw new Error(`ref used with no definitions`);\n    }\n    const name = node[1] as string;\n\n    if (referenceResolverState.lockedNames.has(name)) {\n        throw new Error(`circular referene to '${name}'`);\n    }\n\n    if (!(name in referenceResolverState.definitions)) {\n        throw new Error(`definition '${name}' not found`);\n    }\n\n    const cachedEntry = referenceResolverState.cache.get(name);\n    if (cachedEntry !== undefined) {\n        return cachedEntry;\n    }\n    let definitionEntry = referenceResolverState.definitions[name] as any;\n    if (isSelectorDefinition(definitionEntry)) {\n        definitionEntry = definitionEntry.value;\n    }\n    let result: Expr;\n    if (isValueDefinition(definitionEntry)) {\n        if (isInterpolatedPropertyDefinition(definitionEntry.value)) {\n            // found a reference to an interpolation using\n            // the deprecated object-like syntax.\n            return Expr.fromJSON(interpolatedPropertyDefinitionToJsonExpr(definitionEntry.value));\n        } else if (isJsonExpr(definitionEntry.value)) {\n            definitionEntry = definitionEntry.value;\n        } else {\n            return Expr.fromJSON(definitionEntry.value);\n        }\n    }\n    if (isJsonExpr(definitionEntry)) {\n        referenceResolverState.lockedNames.add(name);\n        try {\n            result = parseNode(definitionEntry, referenceResolverState);\n        } finally {\n            referenceResolverState.lockedNames.delete(name);\n        }\n    } else {\n        throw new Error(`unsupported definition ${name}`);\n    }\n    referenceResolverState.cache.set(name, result);\n    return result;\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport * from \"./lib/coordinates/GeoBox\";\nexport * from \"./lib/coordinates/GeoCoordinatesLike\";\nexport * from \"./lib/coordinates/GeoCoordinates\";\nexport * from \"./lib/coordinates/GeoPointLike\";\nexport * from \"./lib/coordinates/LatLngLike\";\nexport * from \"./lib/projection/EarthConstants\";\nexport * from \"./lib/projection/EquirectangularProjection\";\nexport * from \"./lib/projection/IdentityProjection\";\nexport * from \"./lib/projection/Projection\";\nexport * from \"./lib/projection/MercatorProjection\";\nexport * from \"./lib/projection/TransverseMercatorProjection\";\nexport * from \"./lib/projection/SphereProjection\";\nexport * from \"./lib/tiling/FlatTileBoundingBoxGenerator\";\nexport * from \"./lib/tiling/HalfQuadTreeSubdivisionScheme\";\nexport * from \"./lib/tiling/QuadTreeSubdivisionScheme\";\nexport * from \"./lib/tiling/QuadTree\";\nexport * from \"./lib/tiling/SubTiles\";\nexport * from \"./lib/tiling/SubdivisionScheme\";\nexport * from \"./lib/tiling/TileKey\";\nexport * from \"./lib/tiling/TileKeyUtils\";\nexport * from \"./lib/tiling/TileTreeTraverse\";\nexport * from \"./lib/tiling/TilingScheme\";\nexport * from \"./lib/tiling/HereTilingScheme\";\nexport * from \"./lib/tiling/WebMercatorTilingScheme\";\nexport * from \"./lib/tiling/MercatorTilingScheme\";\nexport * from \"./lib/tiling/PolarTilingScheme\";\nexport * from \"./lib/math/Vector3Like\";\nexport * from \"./lib/math/Box3Like\";\nexport * from \"./lib/math/OrientedBox3Like\";\nexport * from \"./lib/math/MathUtils\";\nexport * from \"./lib/math/TransformLike\";\nexport * from \"./lib/math/OrientedBox3\";\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport * from \"./lib/rendering/FontCatalog\";\nexport * from \"./lib/rendering/GlyphData\";\nexport * from \"./lib/rendering/TextStyle\";\nexport * from \"./lib/rendering/TextBufferObject\";\nexport * from \"./lib/TextCanvas\";\n\nexport * from \"./lib/utils/ContextualArabicConverter\";\nexport * from \"./lib/utils/MaterialUtils\";\nexport * from \"./lib/utils/TypesettingUtils\";\nexport * from \"./lib/utils/UnicodeUtils\";\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeoCoordinatesLike, isGeoCoordinatesLike } from \"./GeoCoordinatesLike\";\nimport { GeoPointLike, isGeoPointLike } from \"./GeoPointLike\";\nimport { isLatLngLike, LatLngLike } from \"./LatLngLike\";\n\nimport * as THREE from \"three\";\n\n/**\n * Represents an object in different geo coordinate formats\n */\nexport type GeoCoordLike = GeoPointLike | GeoCoordinatesLike | LatLngLike;\n\n/**\n * `GeoCoordinates` is used to represent geo positions.\n */\nexport class GeoCoordinates implements GeoCoordinatesLike {\n    /**\n     * Returns a `GeoCoordinates` from the given latitude, longitude, and optional altitude.\n     *\n     * @param latitude Latitude in degrees.\n     * @param longitude Longitude in degrees.\n     * @param altitude Altitude in meters.\n     */\n    static fromDegrees(latitude: number, longitude: number, altitude?: number): GeoCoordinates {\n        return new GeoCoordinates(latitude, longitude, altitude);\n    }\n\n    /**\n     * Returns a `GeoCoordinates` from the given latitude, longitude, and optional altitude.\n     *\n     * @param latitude Latitude in radians.\n     * @param longitude Longitude in radians.\n     * @param altitude Altitude in meters.\n     */\n    static fromRadians(latitude: number, longitude: number, altitude?: number): GeoCoordinates {\n        return new GeoCoordinates(\n            THREE.Math.radToDeg(latitude),\n            THREE.Math.radToDeg(longitude),\n            altitude\n        );\n    }\n\n    /**\n     * Creates a [[GeoCoordinates]] from a [[LatLngLike]] literal.\n     * ```typescript\n     * const center = { lat: 53.3, lng: 13.4 };\n     * mapView.geoCenter = GeoCoordinates.fromLatLng(center);\n     * ```\n     * @param latLng A [[LatLngLike]] object literal.\n     */\n    static fromLatLng(latLng: LatLngLike) {\n        return new GeoCoordinates(latLng.lat, latLng.lng);\n    }\n\n    /**\n     * Creates a [[GeoCoordinates]] from a [[GeoPointLike]] tuple.\n     *\n     * Example:\n     * ```typescript\n     * mapView.geoCenter = GeoCoordinates.fromGeoPoint([longitude, latitude]);\n     *\n     * let geoCoords: number[] = ...;\n     *\n     * if (isGeoPointLike(geoCoords)) {\n     *     const p = GeoCoordinates.fromGeoPoint(geoCoords);\n     * }\n     * ```\n     * @param geoPoint An [[Array]] of at least two elements following the order\n     * longitude, latitude, altitude.\n     */\n    static fromGeoPoint(geoPoint: GeoPointLike): GeoCoordinates {\n        return new GeoCoordinates(geoPoint[1], geoPoint[0], geoPoint[2]);\n    }\n\n    /**\n     * Creates a [[GeoCoordinates]] from different types of geo coordinate objects.\n     *\n     * Example:\n     * ```typescript\n     * const fromGeoPointLike = GeoCoordinates.fromObject([longitude, latitude]);\n     * const fromGeoCoordinateLike = GeoCoordinates.fromObject({ longitude, latitude });\n     * const fromGeoCoordinate = GeoCoordinates.fromObject(new GeoCoordinates(latitude, longitude));\n     * const fromLatLngLike = GeoCoordinates.fromObject({ lat: latitude , lng: longitude });\n     * ```\n     *\n     * @param geoPoint Either [[GeoPointLike]], [[GeoCoordinatesLike]]\n     * or [[LatLngLike]] object literal.\n     */\n    static fromObject(geoPoint: GeoCoordLike): GeoCoordinates {\n        if (isGeoPointLike(geoPoint)) {\n            return GeoCoordinates.fromGeoPoint(geoPoint);\n        } else if (isGeoCoordinatesLike(geoPoint)) {\n            return GeoCoordinates.fromDegrees(\n                geoPoint.latitude,\n                geoPoint.longitude,\n                geoPoint.altitude\n            );\n        } else if (isLatLngLike(geoPoint)) {\n            return GeoCoordinates.fromDegrees(geoPoint.lat, geoPoint.lng);\n        }\n\n        throw new Error(\"Invalid input coordinate format.\");\n    }\n\n    /**\n     * Creates a `GeoCoordinates` from the given latitude, longitude, and optional altitude.\n     *\n     * @param latitude Latitude in degrees.\n     * @param longitude Longitude in degrees.\n     * @param altitude Altitude in meters.\n     */\n    constructor(public latitude: number, public longitude: number, public altitude?: number) {}\n\n    /**\n     * Returns the latitude in radians.\n     */\n    get latitudeInRadians(): number {\n        return THREE.Math.degToRad(this.latitude);\n    }\n\n    /**\n     * Returns the longitude in radians.\n     */\n    get longitudeInRadians(): number {\n        return THREE.Math.degToRad(this.longitude);\n    }\n\n    /**\n     * Returns the latitude in degrees.\n     * @deprecated Use the [[latitude]] property instead.\n     */\n    get latitudeInDegrees(): number {\n        return this.latitude;\n    } // compat api\n\n    /**\n     * Returns the longitude in degrees.\n     * @deprecated Use the [[longitude]] property instead.\n     */\n    get longitudeInDegrees(): number {\n        return this.longitude;\n    } // compat api\n\n    /**\n     * The latitude in the degrees.\n     */\n    get lat() {\n        return this.latitude;\n    }\n\n    /**\n     * The longitude in the degrees.\n     */\n    get lng() {\n        return this.longitude;\n    }\n\n    /**\n     * Returns `true` if this `GeoCoordinates` is valid; returns `false` otherwise.\n     */\n    isValid(): boolean {\n        return !isNaN(this.latitude) && !isNaN(this.longitude);\n    }\n\n    /**\n     * Returns the normalized `GeoCoordinates`.\n     */\n    normalized(): GeoCoordinates {\n        let { latitude, longitude } = this;\n\n        if (isNaN(latitude) || isNaN(longitude)) {\n            return this;\n        }\n\n        if (latitude > 90) {\n            let wrapped = (latitude + 90) % 360;\n            if (wrapped >= 180) {\n                longitude += 180;\n                wrapped = 360 - wrapped;\n            }\n\n            latitude = wrapped - 90;\n        }\n\n        if (latitude < -90) {\n            let wrapped = (latitude - 90) % 360;\n            if (wrapped <= -180) {\n                longitude += 180;\n                wrapped = -360 - wrapped;\n            }\n\n            latitude = wrapped + 90;\n        }\n\n        if (longitude < -180 || longitude > 180) {\n            const sign = Math.sign(longitude);\n            longitude = (((longitude % 360) + 180 * sign) % 360) - 180 * sign;\n        }\n\n        if (latitude === this.latitude && longitude === this.longitude) {\n            return this;\n        }\n\n        return new GeoCoordinates(latitude, longitude, this.altitude);\n    }\n\n    /**\n     * Returns `true` if this `GeoCoordinates` is equal to the other.\n     *\n     * @param other GeoCoordinatesLike to compare to.\n     */\n    equals(other: GeoCoordinatesLike): boolean {\n        return (\n            this.latitude === other.latitude &&\n            this.longitude === other.longitude &&\n            this.altitude === other.altitude\n        );\n    }\n\n    /**\n     * Copy values from the other.\n     *\n     * @param other GeoCoordinatesLike to copy all values from.\n     */\n    copy(other: GeoCoordinatesLike): GeoCoordinates {\n        this.latitude = other.latitude;\n        this.longitude = other.longitude;\n        this.altitude = other.altitude;\n        return this;\n    }\n\n    /**\n     * Clones this `GeoCoordinates`.\n     * @deprecated\n     */\n    clone(): GeoCoordinates {\n        return new GeoCoordinates(this.latitude, this.longitude, this.altitude);\n    }\n\n    /**\n     * Returns this [[GeoCoordinates]] as [[LatLngLike]] literal.\n     */\n    toLatLng(): LatLngLike {\n        return { lat: this.latitude, lng: this.longitude };\n    }\n\n    /**\n     * Converts this [[GeoCoordinates]] to a [[GeoPointLike]].\n     */\n    toGeoPoint(): GeoPointLike {\n        return this.altitude !== undefined\n            ? [this.longitude, this.latitude, this.altitude]\n            : [this.longitude, this.latitude];\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Box3Like } from \"./Box3Like\";\nimport { Vector3Like } from \"./Vector3Like\";\n\nimport * as THREE from \"three\";\n\nexport namespace MathUtils {\n    /**\n     * Creates a new empty bounding box.\n     * @deprecated\n     */\n    export function newEmptyBox3(): Box3Like {\n        return {\n            min: { x: Infinity, y: Infinity, z: Infinity },\n            max: { x: -Infinity, y: -Infinity, z: -Infinity }\n        };\n    }\n\n    /**\n     * Creates a new [Vector3Like] instance.\n     *\n     * @param x The x component.\n     * @param y The y component.\n     * @param z The z component.\n     */\n    export function newVector3(x: number, y: number, z: number): Vector3Like;\n\n    /**\n     * Creates a new [Vector3Like] instance.\n     *\n     * @param x The x component.\n     * @param y The y component.\n     * @param z The z component.\n     * @param v The resulting [Vector3Like] instance.\n     */\n    export function newVector3<Vector extends Vector3Like>(\n        x: number,\n        y: number,\n        z: number,\n        v: Vector\n    ): Vector;\n\n    /**\n     * Set the components of the given [Vector3Like] instance.\n     *\n     * @param x The x component.\n     * @param y The y component.\n     * @param z The z component.\n     * @param v The [Vector3Like]\n     */\n    export function newVector3(x: number, y: number, z: number, v?: Vector3Like): Vector3Like {\n        if (v === undefined) {\n            return { x, y, z };\n        }\n        v.x = x;\n        v.y = y;\n        v.z = z;\n        return v;\n    }\n\n    /**\n     * Converts an angle measured in degrees to an equivalent value in radians.\n     *\n     * @param degrees Value in degrees.\n     * @returns Value in radians.\n     * @deprecated\n     */\n    export const degToRad = THREE.Math.degToRad;\n\n    /**\n     * Converts an angle measured in radians to an equivalent value in degrees.\n     *\n     * @param degrees Value in radians.\n     * @returns Value in degrees.\n     * @deprecated\n     */\n    export const radToDeg = THREE.Math.radToDeg;\n\n    /**\n     * Ensures that input value fits in a given range.\n     *\n     * @param value The value to be clamped.\n     * @param min Minimum value.\n     * @param max Maximum value.\n     * @returns Clamped value.\n     * @deprecated\n     */\n    export const clamp = THREE.Math.clamp;\n\n    /**\n     * Normalize angle in degrees to range `[0, 360)`.\n     *\n     * @param a Angle in degrees.\n     * @returns Angle in degrees in range `[0, 360)`.\n     */\n    export function normalizeAngleDeg(a: number): number {\n        a = a % 360;\n        if (a < 0) {\n            a = a + 360;\n        }\n        return a;\n    }\n\n    /**\n     * Return the minimal delta between angles `a` and `b` given in degrees.\n     *\n     * Equivalent to `a - b` in coordinate space with exception vector direction can be reversed\n     * that if `abs(a-b) > 180` because trip is shorter in 'other' direction.\n     *\n     * Useful when interpolating between `b` and `a` in angle space.\n     *\n     * @param a Start angle in degrees.\n     * @param b End angle in degrees.\n     * @returns Angle that that satisfies condition `a - b - d = 0` in angle space.\n     */\n    export function angleDistanceDeg(a: number, b: number): number {\n        a = normalizeAngleDeg(a);\n        b = normalizeAngleDeg(b);\n\n        const d = a - b;\n        if (d > 180) {\n            return d - 360;\n        } else if (d <= -180) {\n            return d + 360;\n        } else {\n            return d;\n        }\n    }\n\n    /**\n     * Interpolate linearly between two angles given in degrees.\n     *\n     * @param p0 Angle from in degrees\n     * @param p1 Angle to in degrees\n     * @param t Interpolation factor (alpha), in range `0-1`.\n     */\n    export function interpolateAnglesDeg(p0: number, p1: number, t: number): number {\n        // hand crafted version,\n        // see stack for maybe better versions:\n        //    https://stackoverflow.com/questions/2708476/rotation-interpolation\n\n        const d = angleDistanceDeg(p1, p0);\n        const r = (p0 + d * t) % 360;\n        return r;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport {\n    GeoCoordinates,\n    MathUtils,\n    Projection,\n    ProjectionType,\n    TileKey\n} from \"@here/harp-geoutils\";\nimport { EarthConstants } from \"@here/harp-geoutils/lib/projection/EarthConstants\";\nimport { MapMeshBasicMaterial, MapMeshStandardMaterial } from \"@here/harp-materials\";\nimport { assert, LoggerManager } from \"@here/harp-utils\";\nimport { MapView } from \"./MapView\";\nimport { getFeatureDataSize, TileFeatureData } from \"./Tile\";\n\nconst logger = LoggerManager.instance.create(\"MapViewUtils\");\n\n// Estimation of the size of an Object3D with all the simple properties, like matrices and flags.\n// There may be cases where it is possible to construct Object3Ds with considerable less memory\n// consumption, but this value is used to simplify the estimation.\nconst MINIMUM_OBJECT3D_SIZE_ESTIMATION = 1000;\n\nconst MINIMUM_ATTRIBUTE_SIZE_ESTIMATION = 56;\n\n// Caching those for performance reasons.\nconst groundNormalPlanarProj = new THREE.Vector3(0, 0, 1);\nconst groundPlane = new THREE.Plane(groundNormalPlanarProj.clone());\nconst groundSphere = new THREE.Sphere(undefined, EarthConstants.EQUATORIAL_RADIUS);\nconst rayCaster = new THREE.Raycaster();\n\n/**\n * Cached ThreeJS instances for realtime maths.\n */\nconst space = {\n    x: new THREE.Vector3(),\n    y: new THREE.Vector3(),\n    z: new THREE.Vector3()\n};\nconst tangentSpace = {\n    x: new THREE.Vector3(),\n    y: new THREE.Vector3(),\n    z: new THREE.Vector3()\n};\nconst cache = {\n    quaternions: [new THREE.Quaternion(), new THREE.Quaternion()],\n    vector3: [new THREE.Vector3(), new THREE.Vector3()],\n    matrix4: [new THREE.Matrix4(), new THREE.Matrix4()],\n    transforms: [\n        {\n            xAxis: new THREE.Vector3(),\n            yAxis: new THREE.Vector3(),\n            zAxis: new THREE.Vector3(),\n            position: new THREE.Vector3()\n        }\n    ]\n};\n\nexport namespace MapViewUtils {\n    /**\n     * The anti clockwise rotation of an object along the axes of its tangent space, with itself\n     * as origin.\n     */\n    export interface Attitude {\n        /**\n         * Rotation of the object along its vertical axis.\n         */\n        yaw: number;\n\n        /**\n         * Rotation of the object along its horizontal axis.\n         */\n        pitch: number;\n\n        /**\n         * Rotation of the object along its forward axis.\n         */\n        roll: number;\n    }\n\n    /**\n     * Describes estimated usage of memory on heap and GPU.\n     */\n    export interface MemoryUsage {\n        heapSize: number;\n        gpuSize: number;\n    }\n\n    /**\n     * Zooms and moves the map in such a way that the given target position remains at the same\n     * position after the zoom.\n     *\n     * @param mapView Instance of MapView.\n     * @param targetPositionOnScreenXinNDC Target x position in NDC space.\n     * @param targetPositionOnScreenYinNDC Target y position in NDC space.\n     * @param zoomLevel The desired zoom level.\n     * @param maxTiltAngle The maximum tilt angle to comply by, in globe projection, in radian.\n     */\n    export function zoomOnTargetPosition(\n        mapView: MapView,\n        targetPositionOnScreenXinNDC: number,\n        targetPositionOnScreenYinNDC: number,\n        zoomLevel: number,\n        maxTiltAngle: number = Math.PI / 2\n    ): void {\n        // Get current target position in world space before we zoom.\n        const targetPosition = rayCastWorldCoordinates(\n            mapView,\n            targetPositionOnScreenXinNDC,\n            targetPositionOnScreenYinNDC\n        );\n        const zoomDistance = calculateDistanceToGroundFromZoomLevel(mapView, zoomLevel);\n\n        // Set the cameras height according to the given zoom level.\n        if (mapView.projection.type === ProjectionType.Planar) {\n            mapView.camera.position.setZ(zoomDistance);\n        } else if (mapView.projection.type === ProjectionType.Spherical) {\n            mapView.camera.position.setLength(EarthConstants.EQUATORIAL_RADIUS + zoomDistance);\n        }\n\n        // In sphere, we may have to also orbit the camera around the position located at the\n        // center of the screen, in order to limit the tilt to `maxTiltAngle`, as we change\n        // this tilt by changing the camera's height above.\n        if (mapView.projection.type === ProjectionType.Spherical) {\n            const centerScreenTarget = rayCastWorldCoordinates(mapView, 0, 0);\n            if (centerScreenTarget !== null) {\n                const tilt = extractSphericalCoordinatesFromLocation(\n                    mapView,\n                    mapView.camera,\n                    mapView.projection.unprojectPoint(centerScreenTarget)\n                ).tilt;\n                const deltaTilt = tilt - maxTiltAngle;\n                if (deltaTilt > 0) {\n                    orbitFocusPoint(mapView, 0, deltaTilt, maxTiltAngle);\n                }\n            }\n        }\n\n        // Get new target position after the zoom\n        const newTargetPosition = rayCastWorldCoordinates(\n            mapView,\n            targetPositionOnScreenXinNDC,\n            targetPositionOnScreenYinNDC\n        );\n\n        if (!targetPosition || !newTargetPosition) {\n            return;\n        }\n\n        if (mapView.projection.type === ProjectionType.Planar) {\n            // Calculate the difference and pan the map to maintain the map relative to the target\n            // position.\n            targetPosition.sub(newTargetPosition);\n            panCameraAboveFlatMap(mapView, targetPosition.x, targetPosition.y);\n        } else if (mapView.projection.type === ProjectionType.Spherical) {\n            panCameraAroundGlobe(mapView, targetPosition, newTargetPosition);\n        }\n    }\n\n    /**\n     * Orbits the camera around the focus point of the camera.\n     *\n     * @param mapView The [[MapView]] instance to manipulate.\n     * @param deltaAzimuthDeg Delta azimuth in degrees.\n     * @param deltaTiltDeg Delta tilt in degrees.\n     * @param maxTiltAngleRad The maximum tilt between the camera and its target in radian.\n     */\n    export function orbitFocusPoint(\n        mapView: MapView,\n        deltaAzimuthDeg: number,\n        deltaTiltDeg: number,\n        maxTiltAngleRad = Math.PI / 2\n    ) {\n        const target = rayCastWorldCoordinates(mapView, 0, 0);\n        if (target === null) {\n            throw new Error(\"MapView does not support a view pointing in the void\");\n        }\n        const targetCoordinates = mapView.projection.unprojectPoint(target);\n        const sphericalCoordinates = extractSphericalCoordinatesFromLocation(\n            mapView,\n            mapView.camera,\n            targetCoordinates\n        );\n        const tiltDeg = Math.max(\n            Math.min(\n                THREE.Math.radToDeg(maxTiltAngleRad),\n                deltaTiltDeg + THREE.Math.radToDeg(sphericalCoordinates.tilt)\n            ),\n            0\n        );\n        mapView.lookAt(\n            targetCoordinates,\n            target.distanceTo(mapView.camera.position),\n            tiltDeg,\n            THREE.Math.radToDeg(sphericalCoordinates.azimuth + Math.PI) + deltaAzimuthDeg\n        );\n    }\n\n    /**\n     * Returns the [[GeoCoordinates]] of the camera, given its target coordinates on the map and its\n     * zoom, yaw and pitch.\n     *\n     * @param targetCoordinates Coordinates of the center of the view.\n     * @param distance Distance to the target in meters.\n     * @param yawDeg Camera yaw in degrees.\n     * @param pitchDeg Camera pitch in degrees.\n     * @param projection Active MapView, needed to get the camera fov and map projection.\n     * @param result Optional output vector.\n     * @returns Camera position in world space.\n     */\n    export function getCameraPositionFromTargetCoordinates(\n        targetCoordinates: GeoCoordinates,\n        distance: number,\n        yawDeg: number,\n        pitchDeg: number,\n        projection: Projection,\n        result: THREE.Vector3 = new THREE.Vector3()\n    ): THREE.Vector3 {\n        const pitchRad = THREE.Math.degToRad(pitchDeg);\n        const altitude = Math.cos(pitchRad) * distance;\n        const yawRad = THREE.Math.degToRad(yawDeg);\n        projection.projectPoint(targetCoordinates, result);\n        const groundDistance = distance * Math.sin(pitchRad);\n        if (projection.type === ProjectionType.Planar) {\n            result.x = result.x + Math.sin(yawRad) * groundDistance;\n            result.y = result.y - Math.cos(yawRad) * groundDistance;\n            result.z = result.z + altitude;\n        } else if (projection.type === ProjectionType.Spherical) {\n            // In globe yaw and pitch are understood to be in tangent space. The approach below is\n            // to find the Z and Y tangent space axes, then rotate Y around Z by the given yaw, and\n            // set its new length (groundDistance). Finally the up vector's length is set to the\n            // camera height and added to the transformed Y above.\n\n            // Get the Z axis in tangent space: it is the normalized position vector of the target.\n            tangentSpace.z.copy(result).normalize();\n\n            // Get the Y axis (north axis in tangent space):\n            tangentSpace.y\n                .set(0, 0, 1)\n                .projectOnPlane(tangentSpace.z)\n                .normalize();\n\n            // Rotate this north axis by the given yaw, giving the camera direction relative to\n            // the target.\n            cache.quaternions[0].setFromAxisAngle(tangentSpace.z, yawRad - Math.PI);\n            tangentSpace.y.applyQuaternion(cache.quaternions[0]);\n\n            // Push the camera to the specified distance.\n            tangentSpace.y.setLength(groundDistance);\n\n            // Now get the actual camera position vector: from the target position, add the\n            // previous computation to get the projection of the camera on the ground, then add\n            // the height of the camera in the tangent space.\n            const height = distance * Math.cos(pitchRad);\n            result.add(tangentSpace.y).add(tangentSpace.z.setLength(height));\n\n            const a = EarthConstants.EQUATORIAL_RADIUS + altitude;\n            const b = Math.sin(pitchRad) * distance;\n            const cameraHeight = Math.sqrt(a * a + b * b);\n            result.setLength(cameraHeight);\n        }\n\n        return result;\n    }\n\n    /**\n     * @deprecated use getCameraPositionFromTargetCoordinates instead\n     */\n    export function getCameraCoordinatesFromTargetCoordinates(\n        targetCoordinates: GeoCoordinates,\n        distance: number,\n        yawDeg: number,\n        pitchDeg: number,\n        mapView: MapView\n    ): GeoCoordinates {\n        return mapView.projection.unprojectPoint(\n            getCameraPositionFromTargetCoordinates(\n                targetCoordinates,\n                distance,\n                yawDeg,\n                pitchDeg,\n                mapView.projection,\n                cache.vector3[1]\n            )\n        );\n    }\n\n    /**\n     * Casts a ray in NDC space from the current map view and returns the intersection point of that\n     * ray wih the map in world space.\n     *\n     * @param mapView Instance of MapView.\n     * @param pointOnScreenXinNDC X coordinate in NDC space.\n     * @param pointOnScreenYinNDC Y coordinate in NDC space.\n     * @param elevation Optional param used to offset the ground plane. Used when wanting to pan\n     * based on a plane at some altitude. Necessary for example when panning with terrain.\n     *\n     * @returns Intersection coordinates, or `null` if raycast failed.\n     */\n    export function rayCastWorldCoordinates(\n        mapView: MapView,\n        pointOnScreenXinNDC: number,\n        pointOnScreenYinNDC: number,\n        elevation?: number\n    ): THREE.Vector3 | null {\n        const pointInNDCPosition = new THREE.Vector3(pointOnScreenXinNDC, pointOnScreenYinNDC, 0);\n\n        cache.vector3[1].copy(mapView.camera.position);\n\n        cache.matrix4[0].extractRotation(mapView.camera.matrixWorld);\n\n        // Prepare the unprojection matrix which projects from NDC space to camera space\n        // and takes the current rotation of the camera into account.\n        cache.matrix4[1].multiplyMatrices(\n            cache.matrix4[0],\n            cache.matrix4[1].getInverse(mapView.camera.projectionMatrix)\n        );\n        // Unproject the point via the unprojection matrix.\n        const pointInCameraSpace = pointInNDCPosition.applyMatrix4(cache.matrix4[1]);\n        // Use the point in camera space as the vector towards this point.\n        rayCaster.set(cache.vector3[1], pointInCameraSpace.normalize());\n        if (elevation !== undefined) {\n            groundPlane.constant = -elevation;\n        }\n\n        const worldPosition = new THREE.Vector3();\n        const result =\n            mapView.projection.type === ProjectionType.Planar\n                ? rayCaster.ray.intersectPlane(groundPlane, worldPosition)\n                : rayCaster.ray.intersectSphere(groundSphere, worldPosition);\n        groundPlane.constant = 0;\n        return result;\n    }\n\n    /**\n     * Pans the camera according to the projection.\n     *\n     * @param mapView Instance of MapView.\n     * @param xOffset In world space. Value > 0 will pan the map to the right, value < 0 will pan\n     * the map to the left in default camera orientation.\n     * @param yOffset In world space. Value > 0 will pan the map upwards, value < 0 will pan the map\n     * downwards in default camera orientation.\n     */\n    export function panCameraAboveFlatMap(\n        mapView: MapView,\n        offsetX: number,\n        offsetY: number\n    ): void {\n        mapView.camera.position.x += offsetX;\n        mapView.camera.position.y += offsetY;\n    }\n\n    /**\n     * The function doing a pan in the spherical space when [[MapView]]'s active [[ProjectionType]]\n     * is spherical. In other words, the function that rotates the camera around the globe.\n     *\n     * @param mapView MapView instance.\n     * @param fromWorld Start vector representing the scene position of a geolocation.\n     * @param toWorld End vector representing the scene position of a geolocation.\n     */\n    export function panCameraAroundGlobe(\n        mapView: MapView,\n        fromWorld: THREE.Vector3,\n        toWorld: THREE.Vector3\n    ) {\n        cache.quaternions[0]\n            .setFromUnitVectors(fromWorld.normalize(), toWorld.normalize())\n            .inverse();\n        cache.matrix4[0].makeRotationFromQuaternion(cache.quaternions[0]);\n        mapView.camera.applyMatrix(cache.matrix4[0]);\n        mapView.camera.updateMatrixWorld();\n    }\n\n    /**\n     * Rotates the camera by the given delta yaw and delta pitch. The pitch will be clamped to the\n     * maximum possible tilt to the new target, and under the horizon in sphere projection.\n     *\n     * @param mapView The [[MapView]] instance in use.\n     * @param deltaYawDeg Delta yaw in degrees.\n     * @param deltaPitchDeg Delta pitch in degrees.\n     * @param maxTiltAngleRad Max tilt angle in radians.\n     */\n    export function rotate(\n        mapView: MapView,\n        deltaYawDeg: number,\n        deltaPitchDeg: number = 0,\n        maxTiltAngleRad = Math.PI / 4\n    ) {\n        // 1. Apply yaw: rotate around the vertical axis.\n        mapView.camera.rotateOnWorldAxis(\n            mapView.projection.type === ProjectionType.Spherical\n                ? cache.vector3[0].copy(mapView.camera.position).normalize()\n                : cache.vector3[0].set(0, 0, 1),\n            MathUtils.degToRad(-deltaYawDeg)\n        );\n        mapView.camera.updateMatrixWorld();\n\n        // 2. Apply pitch: rotate around the camera's local X axis.\n        if (deltaPitchDeg === 0) {\n            return;\n        }\n        const pitch = MapViewUtils.extractAttitude(mapView, mapView.camera).pitch;\n        // `maxTiltAngle` is equivalent to a `maxPitchAngle` in flat projections.\n        let newPitch = THREE.Math.clamp(\n            pitch + THREE.Math.degToRad(deltaPitchDeg),\n            0,\n            maxTiltAngleRad\n        );\n        // In sphere projection, the value of a maximum pitch is smaller than the value of the\n        // maximum tilt, as the curvature of the surface adds up to it.\n        if (mapView.projection.type === ProjectionType.Spherical) {\n            // Deduce max pitch from max tilt. To this end the sine law of triangles is used below.\n            const maxPitch = Math.asin(\n                (EarthConstants.EQUATORIAL_RADIUS * Math.sin(Math.PI - maxTiltAngleRad)) /\n                    mapView.camera.position.length()\n            );\n            newPitch = Math.min(newPitch, maxPitch);\n        }\n        mapView.camera.rotateX(newPitch - pitch);\n    }\n\n    /**\n     * Computes the rotation of the camera according to yaw and pitch in degrees. The computations\n     * hinge on the current `projection` and `target`, because yaw and pitch are defined in\n     * tangent space of the target point.\n     *\n     * **Note:** `yaw == 0 && pitch == 0` will north up the map and you will look downwards onto the\n     * map.\n     *\n     * @param projection Current projection.\n     * @param target The camera target.\n     * @param yawDeg Yaw in degrees, counter-clockwise (as opposed to azimuth), starting north.\n     * @param pitchDeg Pitch in degrees.\n     */\n    export function getCameraRotationAtTarget(\n        projection: Projection,\n        target: GeoCoordinates,\n        yawDeg: number,\n        pitchDeg: number,\n        result: THREE.Quaternion = new THREE.Quaternion()\n    ): THREE.Quaternion {\n        const transform = cache.transforms[0];\n        projection.localTangentSpace(target, transform);\n\n        cache.matrix4[0].makeBasis(transform.xAxis, transform.yAxis, transform.zAxis);\n        result.setFromRotationMatrix(cache.matrix4[0]);\n\n        cache.quaternions[0].setFromAxisAngle(\n            cache.vector3[1].set(0, 0, 1),\n            THREE.Math.degToRad(yawDeg)\n        );\n        cache.quaternions[1].setFromAxisAngle(\n            cache.vector3[1].set(1, 0, 0),\n            THREE.Math.degToRad(pitchDeg)\n        );\n\n        result.multiply(cache.quaternions[0]);\n        result.multiply(cache.quaternions[1]);\n        return result;\n    }\n\n    /**\n     * Sets the rotation of the camera according to yaw and pitch in degrees. The computations hinge\n     * on the current projection and `geoCenter`, because yaw and pitch are defined in tangent\n     * space. In particular, `MapView#geoCenter` needs to be set before calling `setRotation`.\n     *\n     * **Note:** `yaw == 0 && pitch == 0` will north up the map and you will look downwards onto the\n     * map.\n     *\n     * @param mapView Instance of MapView.\n     * @param yawDeg Yaw in degrees, counter-clockwise (as opposed to azimuth), starting north.\n     * @param pitchDeg Pitch in degrees.\n     */\n    export function setRotation(mapView: MapView, yawDeg: number, pitchDeg: number) {\n        getCameraRotationAtTarget(\n            mapView.projection,\n            mapView.geoCenter,\n            yawDeg,\n            pitchDeg,\n            mapView.camera.quaternion\n        );\n    }\n\n    /**\n     * Extracts yaw, pitch, and roll rotation in radians.\n     * - Yaw : Rotation around the vertical axis, counter-clockwise (as opposed to azimuth),\n     * starting north.\n     * - Pitch :Rotation around the horizontal axis.\n     * - Roll : Rotation around the view axis.\n     *\n     * @see https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles\n     *\n     * @param mapView The [[MapView]] in use.\n     * @param object The [[THREE.Object3D]] instance to extract the rotations from.\n     */\n    export function extractAttitude(mapView: MapView, object: THREE.Object3D): Attitude {\n        // 1. Build the matrix of the tangent space of the object.\n        cache.vector3[1].setFromMatrixPosition(object.matrixWorld); // Ensure using world position.\n        mapView.projection.localTangentSpace(mapView.projection.unprojectPoint(cache.vector3[1]), {\n            xAxis: tangentSpace.x,\n            yAxis: tangentSpace.y,\n            zAxis: tangentSpace.z,\n            position: cache.vector3[0]\n        });\n        cache.matrix4[1].makeBasis(tangentSpace.x, tangentSpace.y, tangentSpace.z);\n\n        // 2. Change the basis of matrixWorld to the tangent space to get the new base axes.\n        cache.matrix4[0].getInverse(cache.matrix4[1]).multiply(object.matrixWorld);\n        space.x.setFromMatrixColumn(cache.matrix4[0], 0);\n        space.y.setFromMatrixColumn(cache.matrix4[0], 1);\n        space.z.setFromMatrixColumn(cache.matrix4[0], 2);\n\n        // 3. Deduce orientation from the base axes.\n        let yaw = 0;\n        let pitch = 0;\n        let roll = 0;\n\n        const EPS = 1e-5;\n\n        // Decompose rotation matrix into Z0 X Z1 Euler angles.\n        const d = space.z.dot(cache.vector3[1].set(0, 0, 1));\n        if (d < 1.0 - EPS) {\n            if (d > -1.0 + EPS) {\n                yaw = Math.atan2(space.z.x, -space.z.y);\n                pitch = Math.acos(space.z.z);\n                roll = Math.atan2(space.x.z, space.y.z);\n            } else {\n                // Looking bottom-up with space.z.z == -1.0\n                yaw = -Math.atan2(-space.y.x, space.x.x);\n                pitch = 180;\n                roll = 0;\n            }\n        } else {\n            // Looking top-down with space.z.z == 1.0\n            yaw = Math.atan2(-space.y.x, space.x.x);\n            pitch = 0.0;\n            roll = 0.0;\n        }\n\n        return {\n            yaw,\n            pitch,\n            roll\n        };\n    }\n\n    /**\n     * Gets the spherical coordinates in radian of the object to the coordinates of `point`.\n     *\n     * Note: this method can be used to get the direction that an object points to, when `location`\n     * is the target of that object, by adding PI to it. Otherwise it only returns the spherical\n     * coordinates of `object` in the tangent space of `location`.\n     *\n     * @param mapView The [[MapView]] instance to consider.\n     * @param object The object to get the coordinates from.\n     * @param location The reference point.\n     */\n    export function extractSphericalCoordinatesFromLocation(\n        mapView: MapView,\n        object: THREE.Object3D,\n        location: GeoCoordinates\n    ): { azimuth: number; tilt: number } {\n        mapView.projection.localTangentSpace(location, {\n            xAxis: tangentSpace.x,\n            yAxis: tangentSpace.y,\n            zAxis: tangentSpace.z,\n            position: cache.vector3[0]\n        });\n\n        let tilt = 0;\n        let azimuth = 0;\n\n        // Get point to object vector in `cache.vector3[1]` and deduce `tilt` from the angle with\n        // tangent Z.\n        cache.vector3[1]\n            .copy(object.position)\n            .sub(cache.vector3[0])\n            .normalize();\n        if (cache.vector3[1].dot(tangentSpace.z) > 1 - 1e-5) {\n            // Top down view: the azimuth of the object would be opposite the yaw, and clockwise.\n            azimuth = Math.PI - extractAttitude(mapView, object).yaw;\n            // Wrap between -PI and PI.\n            azimuth = Math.atan2(Math.sin(azimuth), Math.cos(azimuth));\n            tilt = 0;\n            return { tilt, azimuth };\n        }\n        tilt = cache.vector3[1].angleTo(tangentSpace.z);\n        // Tilted view: the azimuth is the direction of the object from the origin.\n        cache.vector3[1]\n            .copy(object.position)\n            .sub(cache.vector3[0])\n            .projectOnPlane(tangentSpace.z)\n            .normalize();\n        azimuth = cache.vector3[1].angleTo(tangentSpace.y);\n        if (cache.vector3[1].cross(tangentSpace.y).dot(tangentSpace.z) < 0) {\n            azimuth = -azimuth;\n        }\n        return { tilt, azimuth };\n    }\n\n    /**\n     * Get perspective camera frustum planes distances.\n     * @return all plane distances in helper object.\n     */\n    export function getCameraFrustumPlanes(\n        camera: THREE.PerspectiveCamera\n    ): { left: number; right: number; top: number; bottom: number; near: number; far: number } {\n        const near = camera.near;\n        const far = camera.far;\n        let top = (near * Math.tan(THREE.Math.degToRad(0.5 * camera.fov))) / camera.zoom;\n        let height = 2 * top;\n        let width = camera.aspect * height;\n        let left = -0.5 * width;\n\n        const view = camera.view;\n        if (view !== null && view.enabled) {\n            const fullWidth = view.fullWidth;\n            const fullHeight = view.fullHeight;\n\n            left += (view.offsetX * width) / fullWidth;\n            top -= (view.offsetY * height) / fullHeight;\n            width *= view.width / fullWidth;\n            height *= view.height / fullHeight;\n        }\n\n        // Correct by skew factor\n        left += camera.filmOffset !== 0 ? (near * camera.filmOffset) / camera.getFilmWidth() : 0;\n\n        return {\n            left,\n            right: left + width,\n            top,\n            bottom: top - height,\n            near,\n            far\n        };\n    }\n\n    /**\n     * Casts a ray in NDC space from the current view of the camera and returns the intersection\n     * point of that ray against the map in geo coordinates. The return value can be `null` when\n     * the raycast is above the horizon.\n     *\n     * @param mapView Instance of MapView.\n     * @param pointOnScreenXNDC  Abscissa in NDC space.\n     * @param pointOnScreenYNDC  Ordinate in NDC space.\n     * @returns Intersection geo coordinates, or `null` if raycast is above the horizon.\n     */\n    export function rayCastGeoCoordinates(\n        mapView: MapView,\n        pointOnScreenXinNDC: number,\n        pointOnScreenYinNDC: number\n    ): GeoCoordinates | null {\n        const worldCoordinates = rayCastWorldCoordinates(\n            mapView,\n            pointOnScreenXinNDC,\n            pointOnScreenYinNDC\n        );\n\n        if (!worldCoordinates) {\n            return null;\n        }\n\n        return mapView.projection.unprojectPoint(worldCoordinates);\n    }\n\n    /**\n     * Calculates and returns the distance from the ground, which is needed to put the camera to\n     * this height, to see the size of the area that would be covered by one tile for the given zoom\n     * level.\n     *\n     * @param mapView Instance of MapView.\n     * @param zoomLevel The zoom level to get the equivalent height to.\n     */\n    export function calculateDistanceToGroundFromZoomLevel(\n        mapView: MapView,\n        zoomLevel: number\n    ): number {\n        const cameraPitch = extractAttitude(mapView, mapView.camera).pitch;\n        const tileSize = EarthConstants.EQUATORIAL_CIRCUMFERENCE / Math.pow(2, zoomLevel);\n        return ((mapView.focalLength * tileSize) / 256) * Math.cos(cameraPitch);\n    }\n\n    /**\n     * Calculates the zoom level, which corresponds to the current distance from\n     * camera to lookAt point.\n     * Therefore the zoom level is a `float` and not an `int`. The height of the camera can be in\n     * between zoom levels. By setting the zoom level, you change the height position of the camera\n     * in away that the field of view of the camera should be able to cover one tile for the given\n     * zoom level.\n     *\n     * As an example for this, when you have a tile of zoom level 14 in front of the camera and you\n     * set the zoom level of the camera to 14, then you are able to see the whole tile in front of\n     * you.\n     *\n     * @param distance The distance in meters, which are scene units in [[MapView]].\n     * @param mapView [[MapView]] instance.\n     */\n    export function calculateZoomLevelFromDistance(distance: number, mapView: MapView): number {\n        const tileSize = (256 * distance) / mapView.focalLength;\n        const zoomLevel = THREE.Math.clamp(\n            Math.log2(EarthConstants.EQUATORIAL_CIRCUMFERENCE / tileSize),\n            mapView.minZoomLevel,\n            mapView.maxZoomLevel\n        );\n        // Round to avoid modify the zoom level without distance change, with the imprecision\n        // introduced by raycasting.\n        return Math.round(zoomLevel * 10e15) / 10e15;\n    }\n\n    /**\n     * Translates a linear clip-space distance value to the actual value stored in the depth buffer.\n     * This is useful as the depth values are not stored in the depth buffer linearly, and this can\n     * lead into confusing behavior when not taken into account.\n     *\n     * @param clipDistance Distance from the camera in clip space (range: [0, 1]).\n     * @param camera Camera applying the perspective projection.\n     */\n    export function calculateDepthFromClipDistance(\n        clipDistance: number,\n        camera: THREE.Camera\n    ): number {\n        const perspCam = camera as THREE.PerspectiveCamera;\n        const cameraRange = perspCam.far - perspCam.near;\n        const viewSpaceDistance = clipDistance * perspCam.far;\n\n        return (1.0 - perspCam.near / viewSpaceDistance) * (perspCam.far / cameraRange);\n    }\n\n    /**\n     * Translates a linear distance value [0..1], where 1 is the distance to the far plane, into\n     * [0..cameraFar].\n     *\n     * @param distance Distance from the camera (range: [0, 1]).\n     * @param camera Camera applying the perspective projection.\n     */\n    export function cameraToWorldDistance(distance: number, camera: THREE.Camera): number {\n        const perspCam = camera as THREE.PerspectiveCamera;\n        return distance * perspCam.far;\n    }\n\n    /**\n     * Calculates vertical field of view for given horizontal field of vision and aspect ratio.\n     *\n     * @param hFov Horizontal field of view in rad.\n     * @param aspect Aspect ratio.\n     */\n    export function calculateVerticalFovByHorizontalFov(hFov: number, aspect: number): number {\n        return 2 * Math.atan(Math.tan(hFov / 2) / aspect);\n    }\n\n    /**\n     * Calculates horizontal field of view for given vertical field of vision and aspect ratio.\n     *\n     * @param hFov Vertical field of view in rad.\n     * @param aspect Aspect ratio.\n     */\n    export function calculateHorizontalFovByVerticalFov(vFov: number, aspect: number): number {\n        return 2 * Math.atan(Math.tan(vFov / 2) * aspect);\n    }\n\n    /**\n     * Calculates the focal length based on the vertical FOV and height.\n     *\n     * @param vFov Vertical field of view in rad.\n     * @param height Height of canvas in pixels.\n     */\n    export function calculateFocalLengthByVerticalFov(vFov: number, height: number): number {\n        return height / 2 / Math.tan(vFov / 2);\n    }\n\n    /**\n     * Calculates the vertical field of view based on the focal length and the height.\n     *\n     * @param focalLength Focal length in pixels (see [[calculateFocalLengthByVerticalFov]])\n     * @param height Height of canvas in pixels.\n     */\n    export function calculateFovByFocalLength(focalLength: number, height: number): number {\n        return THREE.Math.radToDeg(2 * Math.atan(height / 2 / focalLength));\n    }\n\n    /**\n     * Calculates object's screen size based on the focal length and it's camera distance.\n     *\n     * @param focalLength Focal length in pixels (see [[calculateFocalLengthByVerticalFov]])\n     * @param distance Object distance in world space.\n     * @param worldSize Object size in world space.\n     * @return object size in screen space.\n     */\n    export function calculateScreenSizeByFocalLength(\n        focalLength: number,\n        distance: number,\n        worldSize: number\n    ): number {\n        return (focalLength * worldSize) / distance;\n    }\n\n    /**\n     * Calculates object's world size based on the focal length and it's camera distance.\n     *\n     * @param focalLength Focal length in pixels (see [[calculateFocalLengthByVerticalFov]])\n     * @param distance Object distance in world space.\n     * @param screenSize Object size in screen space.\n     * @return object size in world space.\n     */\n    export function calculateWorldSizeByFocalLength(\n        focalLength: number,\n        distance: number,\n        screenSize: number\n    ): number {\n        return (distance * screenSize) / focalLength;\n    }\n\n    /**\n     * Computes estimate for size of a THREE.Object3D object and its children. Shared materials\n     * and/or attributes will be counted multiple times.\n     *\n     * @param object The mesh object to evaluate\n     * @param size The [[MemoryUsage]] to update.\n     * @param visitedObjects Optional map to store large objects that could be shared.\n     *\n     * @returns Estimate of object size in bytes for heap and GPU.\n     */\n    export function estimateObject3dSize(\n        object: THREE.Object3D,\n        parentSize?: MemoryUsage,\n        visitedObjects?: Map<string, boolean>\n    ): MemoryUsage {\n        const size =\n            parentSize !== undefined\n                ? parentSize\n                : {\n                      heapSize: 0,\n                      gpuSize: 0\n                  };\n\n        if (visitedObjects === undefined) {\n            visitedObjects = new Map();\n        }\n\n        estimateMeshSize(object, size, visitedObjects);\n\n        if (object.children.length > 0) {\n            for (const child of object.children) {\n                estimateObject3dSize(child, size, visitedObjects);\n            }\n        }\n        return size;\n    }\n\n    /**\n     * Check if tiles or other content is currently being loaded.\n     *\n     * This method can be removed once HARP-7932 is implemented.\n     *\n     * @returns `true` if MapView has visible tiles or other content that is being loaded.\n     */\n    export function mapViewIsLoading(mapView: MapView) {\n        let numTilesLoading = 0;\n\n        for (const tileList of mapView.visibleTileSet.dataSourceTileList) {\n            numTilesLoading += tileList.numTilesLoading;\n\n            for (const tile of tileList.visibleTiles) {\n                if (tile.tileLoader !== undefined && !tile.tileLoader.isFinished) {\n                    numTilesLoading++;\n                }\n                if (tile.tileGeometryLoader !== undefined && !tile.tileGeometryLoader.isFinished) {\n                    numTilesLoading++;\n                }\n            }\n        }\n        let isLoading = numTilesLoading > 0;\n\n        if (mapView.textElementsRenderer !== undefined) {\n            isLoading = isLoading || mapView.textElementsRenderer.loading;\n        }\n\n        isLoading =\n            isLoading ||\n            !mapView.poiTableManager.finishedLoading ||\n            !mapView.visibleTileSet.allVisibleTilesLoaded;\n\n        return isLoading;\n    }\n\n    function estimateTextureSize(\n        texture: THREE.Texture | null,\n        objectSize: MemoryUsage,\n        visitedObjects: Map<string, boolean>\n    ): void {\n        if (texture === null || texture === undefined || texture.image === undefined) {\n            return;\n        }\n\n        if (texture.uuid !== undefined && visitedObjects.get(texture.uuid) === true) {\n            return;\n        }\n        visitedObjects.set(texture.uuid, true);\n\n        // May be HTMLImage or ImageData\n        const image = texture.image;\n        // Assuming RGBA\n        const imageBytes = 4 * image.width * image.height;\n        objectSize.heapSize += imageBytes;\n        objectSize.gpuSize += imageBytes;\n    }\n\n    function estimateMaterialSize(\n        material: THREE.Material,\n        objectSize: MemoryUsage,\n        visitedObjects: Map<string, boolean>\n    ): void {\n        if (material.uuid !== undefined && visitedObjects.get(material.uuid) === true) {\n            return;\n        }\n        visitedObjects.set(material.uuid, true);\n\n        if (\n            material instanceof THREE.RawShaderMaterial ||\n            material instanceof THREE.ShaderMaterial\n        ) {\n            const rawMaterial = material;\n            for (const name in rawMaterial.uniforms) {\n                if (rawMaterial.uniforms[name] !== undefined) {\n                    const uniform = rawMaterial.uniforms[name];\n                    if (uniform instanceof THREE.Texture) {\n                        estimateTextureSize(uniform, objectSize, visitedObjects);\n                    }\n                }\n            }\n        } else if (\n            material instanceof THREE.MeshBasicMaterial ||\n            material instanceof MapMeshBasicMaterial\n        ) {\n            const meshMaterial = material;\n            estimateTextureSize(meshMaterial.map, objectSize, visitedObjects);\n            estimateTextureSize(meshMaterial.aoMap, objectSize, visitedObjects);\n            estimateTextureSize(meshMaterial.specularMap, objectSize, visitedObjects);\n            estimateTextureSize(meshMaterial.alphaMap, objectSize, visitedObjects);\n            estimateTextureSize(meshMaterial.envMap, objectSize, visitedObjects);\n        } else if (material instanceof MapMeshStandardMaterial) {\n            const standardMaterial = material;\n\n            estimateTextureSize(standardMaterial.map, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.lightMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.aoMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.emissiveMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.bumpMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.normalMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.displacementMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.roughnessMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.metalnessMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.alphaMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.envMap, objectSize, visitedObjects);\n        } else if (\n            material instanceof THREE.LineBasicMaterial ||\n            material instanceof THREE.LineDashedMaterial\n        ) {\n            // Nothing to be done here\n        } else {\n            logger.warn(\"estimateMeshSize: unidentified material: \", material);\n        }\n    }\n\n    function estimateAttributeSize(\n        attribute: any,\n        attrName: string,\n        objectSize: MemoryUsage,\n        visitedObjects: Map<string, boolean>\n    ): void {\n        // Attributes (apparently) do not have their uuid set up.\n        if (attribute.uuid === undefined) {\n            attribute.uuid = THREE.Math.generateUUID();\n        }\n\n        if (visitedObjects.get(attribute.uuid) === true) {\n            return;\n        }\n        visitedObjects.set(attribute.uuid, true);\n\n        let attrBytes = 0;\n        let bytesPerElement = 4;\n        if (attribute.array.BYTES_PER_ELEMENT !== undefined) {\n            bytesPerElement = attribute.array.BYTES_PER_ELEMENT;\n        }\n        if (\n            attribute instanceof THREE.InterleavedBufferAttribute ||\n            attribute instanceof THREE.BufferAttribute\n        ) {\n            attrBytes = bytesPerElement * attribute.count * attribute.itemSize;\n        } else {\n            logger.warn(\"estimateMeshSize: unidentified attribute: \", attrName);\n        }\n\n        objectSize.heapSize += attrBytes + MINIMUM_ATTRIBUTE_SIZE_ESTIMATION;\n        objectSize.gpuSize += attrBytes;\n    }\n\n    function estimateGeometrySize(\n        geometry: THREE.Geometry | THREE.BufferGeometry,\n        objectSize: MemoryUsage,\n        visitedObjects: Map<string, boolean>\n    ): void {\n        const isNewObject =\n            geometry.uuid === undefined || visitedObjects.get(geometry.uuid) !== true;\n\n        if (!isNewObject) {\n            return;\n        }\n        visitedObjects.set(geometry.uuid, true);\n\n        let bufferGeometry: THREE.BufferGeometry | undefined;\n\n        if (geometry instanceof THREE.Geometry) {\n            // Each vertex is represented as 3 floats vector (24 bytes).\n            objectSize.heapSize += geometry.vertices.length * 24;\n            // Face: 3 indices (24 byte), 1 normal (3 floats = 24). Vertex normals and\n            // colors are not counted here.\n            objectSize.heapSize += geometry.faces.length * (24 + 24);\n            // Additionally, the internal _bufferGeometry is also counted:\n            bufferGeometry = (geometry as any)._bufferGeometry;\n        } else if (geometry instanceof THREE.BufferGeometry) {\n            bufferGeometry = geometry;\n        }\n\n        if (bufferGeometry === undefined) {\n            // Nothing more to calculate.\n            return;\n        }\n\n        const attributes = bufferGeometry.attributes;\n        if (attributes === undefined) {\n            logger.warn(\"estimateGeometrySize: unidentified geometry: \", geometry);\n            return;\n        }\n\n        for (const property in attributes) {\n            if (attributes[property] !== undefined) {\n                estimateAttributeSize(attributes[property], property, objectSize, visitedObjects);\n            }\n        }\n        if (bufferGeometry.index !== null) {\n            estimateAttributeSize(bufferGeometry.index, \"index\", objectSize, visitedObjects);\n        }\n    }\n\n    function estimateMeshSize(\n        object: THREE.Object3D,\n        objectSize: MemoryUsage,\n        visitedObjects: Map<string, boolean>\n    ): void {\n        if (!object.isObject3D || object instanceof THREE.Scene) {\n            return;\n        }\n\n        if (object.uuid !== undefined && visitedObjects.get(object.uuid) === true) {\n            return;\n        }\n        visitedObjects.set(object.uuid, true);\n\n        if ((object as any).isMesh || (object as any).isLine || (object as any).isPoints) {\n            // Estimated minimum impact on heap.\n            let heapSize = MINIMUM_OBJECT3D_SIZE_ESTIMATION;\n            const gpuSize = 0;\n\n            // Cast to Points class which contains the minimal required properties sub-set.\n            const mesh = object as THREE.Points;\n\n            // Calculate material(s) impact.\n            if (mesh.material !== undefined) {\n                if (Array.isArray(mesh.material)) {\n                    const materials = mesh.material as THREE.Material[];\n                    for (const material of materials) {\n                        estimateMaterialSize(material, objectSize, visitedObjects);\n                    }\n                } else {\n                    const material = mesh.material as THREE.Material;\n                    estimateMaterialSize(material, objectSize, visitedObjects);\n                }\n            }\n\n            // Calculate cost of geometry.\n            if (mesh.geometry !== undefined) {\n                estimateGeometrySize(mesh.geometry, objectSize, visitedObjects);\n            }\n\n            // Add info that is required for picking (parts of) objects and match them to\n            // the featureID in the map data.\n            const featureData: TileFeatureData | undefined =\n                object.userData !== undefined\n                    ? (object.userData.feature as TileFeatureData)\n                    : undefined;\n\n            if (featureData !== undefined) {\n                heapSize += getFeatureDataSize(featureData);\n            }\n\n            objectSize.heapSize += heapSize;\n            objectSize.gpuSize += gpuSize;\n        } else {\n            logger.warn(\"estimateMeshSize: unidentified object\", object);\n        }\n    }\n\n    /**\n     * Gets language list used by the browser\n     *\n     * @returns Array of iso language codes\n     */\n    export function getBrowserLanguages(): string[] | undefined {\n        if (navigator.languages !== undefined && navigator.languages.length > 0) {\n            const languageList = [];\n            for (const lang of navigator.languages) {\n                languageList.push(getIsoLanguageCode(lang));\n            }\n            return languageList;\n        }\n        if (navigator.language !== undefined) {\n            return [getIsoLanguageCode(navigator.language)];\n        }\n        return undefined;\n    }\n\n    /**\n     * Gets ISO-639-1 language code from browser's code (ex. en for en-US)\n     */\n    function getIsoLanguageCode(language: string) {\n        return language.substring(0, 2);\n    }\n}\n\n/** @hidden */\nconst powerOfTwo = [\n    0x1,\n    0x2,\n    0x4,\n    0x8,\n    0x10,\n    0x20,\n    0x40,\n    0x80,\n    0x100,\n    0x200,\n    0x400,\n    0x800,\n    0x1000,\n    0x2000,\n    0x4000,\n    0x8000,\n    0x10000,\n    0x20000,\n    0x40000,\n    0x80000,\n    0x100000,\n    0x200000,\n    0x400000,\n    0x800000,\n    0x1000000,\n    0x2000000,\n    0x4000000,\n    0x8000000,\n    0x10000000,\n    0x20000000,\n    0x40000000,\n    0x80000000,\n    0x100000000,\n    0x200000000,\n    0x400000000,\n    0x800000000,\n    0x1000000000,\n    0x2000000000,\n    0x4000000000,\n    0x8000000000,\n    0x10000000000,\n    0x20000000000,\n    0x40000000000,\n    0x80000000000,\n    0x100000000000,\n    0x200000000000,\n    0x400000000000,\n    0x800000000000,\n    0x1000000000000,\n    0x2000000000000,\n    0x4000000000000,\n    0x8000000000000,\n    0x10000000000000\n];\n\nexport namespace TileOffsetUtils {\n    /**\n     * Creates a unique key based on the supplied parameters. Note, the uniqueness is bounded by the\n     * bitshift. The [[TileKey.mortonCode()]] supports currently up to 26 levels (this is because\n     * 26*2 equals 52, and 2^52 is the highest bit that can be set in an integer in Javascript), the\n     * bitshift reduces this accordingly, so given the default bitshift of four, we support up to 24\n     * levels. Given the current support up to level 19 this should be fine.\n     *\n     * @param tileKey The unique [[TileKey]] from which to compute the unique key.\n     * @param offset How much the given [[TileKey]] is offset\n     * @param bitshift How much space we have to store the offset. The default of 4 means we have\n     *      enough space to store 16 unique tiles in a single view.\n     */\n    export function getKeyForTileKeyAndOffset(\n        tileKey: TileKey,\n        offset: number,\n        bitshift: number = 4\n    ) {\n        const shiftedOffset = getShiftedOffset(offset, bitshift);\n        return tileKey.mortonCode() + shiftedOffset;\n    }\n\n    /**\n     * Extracts the offset and morton key from the given key (must be created by:\n     * [[getKeyForTileKeyAndOffset]])\n     *\n     * Note, we can't use bitshift operators in Javascript because they work on 32-bit integers, and\n     * would truncate the numbers, hence using powers of two.\n     *\n     * @param key Key to extract offset and morton key.\n     * @param bitshift How many bits to shift by, must be the same as was used when creating the\n     * key.\n     */\n    export function extractOffsetAndMortonKeyFromKey(key: number, bitshift: number = 4) {\n        let offset = 0;\n        let mortonCode = key;\n        let i = 0;\n        // Compute the offset\n        for (; i < bitshift; i++) {\n            // Note, we use 52, because 2^53-1 is the biggest value, the highest value\n            // that can be set is the bit in the 52th position.\n            const num = powerOfTwo[52 - i];\n            if (mortonCode >= num) {\n                mortonCode -= num;\n                offset += powerOfTwo[bitshift - 1 - i];\n            }\n        }\n        // We subtract half of the total amount, this undoes what is computed in getShiftedOffset\n        offset -= powerOfTwo[bitshift - 1];\n        return { offset, mortonCode };\n    }\n\n    /**\n     * Returns the key of the parent. Key must have been computed using the function\n     * [[getKeyForTileKeyAndOffset]].\n     *\n     * @param calculatedKey Key to decompose\n     * @param bitshift Bit shift used to create the key\n     */\n    export function getParentKeyFromKey(calculatedKey: number, bitshift: number = 4) {\n        const { offset, mortonCode } = extractOffsetAndMortonKeyFromKey(calculatedKey, bitshift);\n        const parentTileKey = TileKey.fromMortonCode(TileKey.parentMortonCode(mortonCode));\n        return getKeyForTileKeyAndOffset(parentTileKey, offset, bitshift);\n    }\n\n    /**\n     * Packs the supplied offset into the high bits, where the highbits are between 2^52 and\n     * 2^(52-bitshift).\n     *\n     * Offsets are wrapped around, to fit in the offsetBits. In practice, this doesn't really\n     * matter, this is primarily used to find a unique id, if there is an offset 10, which is\n     * wrapped to 2, it doesn't matter, because the offset of 10 is still stored in the tile.\n     * What can be a problem though is that the cache gets filled up and isn't emptied.\n     *\n     * Note, because bit shifting in JavaScript works on 32 bit integers, we use powers of 2 to set\n     * the high bits instead.\n     *\n     * @param offset Offset to pack into the high bits.\n     * @param offsetBits How many bits to use to pack the offset.\n     */\n    function getShiftedOffset(offset: number, offsetBits: number = 4) {\n        let result = 0;\n        const totalOffsetsToStore = powerOfTwo[offsetBits];\n        //Offsets are stored by adding half 2 ^ (bitshift - 1), i.e.half of the max amount stored,\n        //and then wrapped based on this value.For example, given a bitshift of 3, and an offset -\n        //3, it would have 4 added(half of 2 ^ 3), and be stored as 1, 3 would have 4 added and be\n        //stored as 7, 4 would be added with 4 and be stored as 0 (it wraps around).\n        offset += totalOffsetsToStore / 2;\n        while (offset < 0) {\n            offset += totalOffsetsToStore;\n        }\n        while (offset >= totalOffsetsToStore) {\n            offset -= totalOffsetsToStore;\n        }\n        // Offset is now a number between >= 0 and < totalOffsetsToStore\n        for (let i = 0; i < offsetBits && offset > 0; i++) {\n            // tslint:disable: no-bitwise\n            // 53 is used because 2^53-1 is the biggest number that Javascript can represent as an\n            // integer safely.\n            if (offset & 0x1) {\n                result += powerOfTwo[53 - offsetBits + i];\n            }\n            offset >>>= 1;\n            // tslint:enable: no-bitwise\n        }\n        assert(offset === 0);\n        return result;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport class EarthConstants {\n    /** The equatorial circumference in meters. */\n    static EQUATORIAL_CIRCUMFERENCE: number = 40075016.6855784861531768177614;\n\n    /** The equatorial radius in meters. */\n    static EQUATORIAL_RADIUS: number = 6378137.0;\n\n    /** The lowest point on earth (Dead Sea) in meters. */\n    static MIN_ELEVATION: number = -433.0;\n\n    /** The highest point on earth (Mt. Everest) in meters. */\n    static MAX_ELEVATION: number = 8848.0;\n\n    /** The highest artificial structure (building) on earth, Burj Khalifa tower in Dubai */\n    static MAX_BUILDING_HEIGHT: number = 828;\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Vector3Like } from \"./Vector3Like\";\n\n/**\n * An interface representing bounding box in world coordinates.\n */\nexport interface Box3Like {\n    /**\n     * The minimum position in world coordinates of this bounding box.\n     */\n    readonly min: Vector3Like;\n\n    /**\n     * The maximum position in world coordinates of this bounding box.\n     */\n    readonly max: Vector3Like;\n}\n\n/**\n * Returns true if the given object implements the [[Box3Like]] interface.\n *\n * @param object A valid object.\n */\nexport function isBox3Like(object: {}): object is Box3Like {\n    const box3 = object as Partial<Box3Like>;\n    return box3.min !== undefined && box3.max !== undefined;\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { TransformLike } from \"./TransformLike\";\nimport { Vector3Like } from \"./Vector3Like\";\n\n/**\n * The interface [[OrientedBox3Like]] is used to represent oriented bounding box.\n */\nexport interface OrientedBox3Like extends TransformLike {\n    /**\n     * The extents of this bounding box.\n     */\n    readonly extents: Vector3Like;\n}\n\n/**\n * Returns true if the given object implements the interface [[OrientedBox3Like]].\n *\n * @param object The object.\n */\nexport function isOrientedBox3Like(object: {}): object is OrientedBox3Like {\n    const obb = object as Partial<OrientedBox3Like>;\n    return (\n        obb.position !== undefined &&\n        obb.xAxis !== undefined &&\n        obb.yAxis !== undefined &&\n        obb.zAxis !== undefined &&\n        obb.extents !== undefined\n    );\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeoBox } from \"../coordinates/GeoBox\";\nimport { GeoCoordinates } from \"../coordinates/GeoCoordinates\";\nimport { GeoCoordinatesLike } from \"../coordinates/GeoCoordinatesLike\";\nimport { Box3Like } from \"../math/Box3Like\";\nimport { MathUtils } from \"../math/MathUtils\";\nimport { OrientedBox3Like } from \"../math/OrientedBox3Like\";\nimport { TransformLike } from \"../math/TransformLike\";\nimport { Vector3Like } from \"../math/Vector3Like\";\n\n/**\n * The type of projection.\n */\nexport enum ProjectionType {\n    /**\n     * A type of [Projection] with zero curvature.\n     */\n    Planar,\n\n    /**\n     * A spherical [Projection].\n     */\n    Spherical\n}\n\n/**\n * `Projection` is used to convert positions from geo coordinates to world coordinates and vice\n * versa.\n */\nexport abstract class Projection {\n    /**\n     * The type of this [Projection].\n     */\n    abstract get type(): ProjectionType;\n\n    /**\n     * Constructs the Projection\n     *\n     * @param unitScale How to transform the projected coordinates to world units.\n     */\n    constructor(readonly unitScale: number) {\n        //Prevent empty constructor error.\n    }\n\n    /**\n     * Returns the world extents in world coordinates.\n     *\n     * @param minElevation The minimum elevation in meters.\n     * @param maxElevation The maximum elevation in meters.\n     * @param result The optional object that will be used to create the resulting bounding box.\n     */\n    abstract worldExtent<Bounds extends Box3Like>(\n        minElevation: number,\n        maxElevation: number,\n        result?: Bounds\n    ): Bounds;\n\n    /**\n     * Projects a point from geo coordinates (latitude, longitude, altitude) to world coordinates\n     * (x,y,z).\n     *\n     * Example:\n     * ```typescript\n     * const worldPos = new THREE.Vector3();\n     * projection.projectPoint(geoPos, worldPos);\n     * ```\n     *\n     * @param geoPoint The position in geo coordinates.\n     * @param result The optional object used to store the resulting world position, result must\n     * implement [[Vector3Like]].\n     */\n    abstract projectPoint<WorldCoordinates extends Vector3Like>(\n        geoPoint: GeoCoordinatesLike,\n        result?: WorldCoordinates\n    ): WorldCoordinates;\n\n    /**\n     * Gets the [[TransformLike]] of the local tangent space at the given geo coordinates.\n     *\n     * @param geoPoint The geo coordinates.\n     * @param result The [[TransformLike]].\n     */\n    localTangentSpace(geoPoint: GeoCoordinatesLike, result: TransformLike): TransformLike {\n        this.projectPoint(geoPoint, result.position);\n        MathUtils.newVector3(1, 0, 0, result.xAxis);\n        MathUtils.newVector3(0, 1, 0, result.yAxis);\n        MathUtils.newVector3(0, 0, 1, result.zAxis);\n        return result;\n    }\n\n    /**\n     * Returns the geo coordinates (latitude, longitude, altitude) from the given world position\n     * (x,y,z).\n     *\n     * Example:\n     * ```typescript\n     * const geoPos = projection.unprojectPoint(worldPos);\n     * console.log(geoPos.latitude, geoPos.longitude, geoPos.altitude);\n     * ```\n     *\n     * @param worldPoint The position in world coordinates.\n     */\n    abstract unprojectPoint(worldPoint: Vector3Like): GeoCoordinates;\n\n    /**\n     * Returns the altitude at the given world position (x,y,z) in meters.\n     *\n     * @param worldPoint The position in world coordinates.\n     */\n    abstract unprojectAltitude(worldPoint: Vector3Like): number;\n\n    /**\n     * Projects bounds in geo coordinates to a bounding box in world coordinates.\n     *\n     * Example:\n     * ```typescript\n     * const bounds = projection.projectBox(geoBox);\n     * console.log(bounds.min, bounds.max);\n     * ```\n     *\n     * @param geoBox The bounding box in geo coordinates.\n     */\n    abstract projectBox(geoBox: GeoBox): Box3Like;\n\n    /**\n     * Projects bounds in geo coordinates to a bounding box in world coordinates.\n     *\n     * Example:\n     * ```typescript\n     * const bounds = projection.projectBox(geoBox, new THREE.Box3());\n     * console.log(bounds.min, bounds.max);\n     * ```\n     *\n     * @param geoBox The bounding box in geo coordinates.\n     * @param result The resulting [[OrientedBox3Like]].\n     */\n    abstract projectBox<WorldBoundingBox extends Box3Like | OrientedBox3Like>(\n        geoBox: GeoBox,\n        result: WorldBoundingBox\n    ): WorldBoundingBox;\n\n    /**\n     * Converts a bounding box in world coordinates to a bounding box in geo coordinates.\n     *\n     * Example:\n     * ```typescript\n     * const geoPos = projection.unprojectPoint(worldPos);\n     * console.log(geoPos.latitude, geoPos.longitude, geoPos.altitude);\n     * ```\n     *\n     * @param worldBox The bounding box in world coordinates.\n     */\n    abstract unprojectBox(worldBox: Box3Like): GeoBox;\n\n    /**\n     * Returns the scaling factor that must be used to convert the units used by `worldPoint` to\n     * meters.\n     *\n     * @param worldPoint The position in world coordinates.\n     */\n    abstract getScaleFactor(worldPoint: Vector3Like): number;\n\n    /**\n     * Returns the surface normal at the given world position.\n     *\n     * @param worldPoint The position in world coordinates.\n     */\n    abstract surfaceNormal(worldPoint: Vector3Like): Vector3Like;\n\n    /**\n     * Returns the surface normal at the given world position.\n     *\n     * @param worldPoint The position in world coordinates.\n     * @returns The resulting normal vector.\n     */\n    abstract surfaceNormal<Normal extends Vector3Like>(\n        worldPoint: Vector3Like,\n        result: Normal\n    ): Normal;\n\n    /**\n     * Returns the signed distance between the given coordinates and\n     * the closest point on the surface.\n     *\n     * @param worldPoint The position in world coordinates.\n     */\n    abstract groundDistance(worldPoint: Vector3Like): number;\n\n    /**\n     * Scales the given world coordinates to the surface.\n     *\n     * @param worldPoint The position in world coordinates.\n     */\n    abstract scalePointToSurface(worldPoint: Vector3Like): Vector3Like;\n\n    /**\n     * Reproject a world position from the given source [[Projection]].\n     *\n     * @param sourceProjection The source projection.\n     * @param worldPos A valid world position for the given source projection.\n     * @returns The world position reprojected using this [[Projection]].\n     */\n    reprojectPoint(sourceProjection: Projection, worldPos: Vector3Like): Vector3Like;\n\n    /**\n     * Reproject a world position from the given source [[Projection]].\n     *\n     * @param sourceProjection The source projection.\n     * @param worldPos A valid position in the world space defined by the source projection.\n     * @param result The resulting position reprojected using this [[Projection]].\n     */\n    reprojectPoint<WorldCoordinates extends Vector3Like>(\n        sourceProjection: Projection,\n        worldPos: Vector3Like,\n        result: WorldCoordinates\n    ): typeof result;\n\n    /**\n     * Reproject a world position from the given source [[Projection]].\n     * Implementations should be aware of worldPos and result may be one object\n     *\n     * @param sourceProjection The source projection.\n     * @param worldPos A valid position in the world space defined by the source projection.\n     * @param result The resulting position reprojected using this [[Projection]].\n     * @hidden\n     */\n    reprojectPoint(\n        sourceProjection: Projection,\n        worldPos: Vector3Like,\n        result?: Vector3Like\n    ): Vector3Like {\n        if (sourceProjection === this) {\n            if (result === undefined) {\n                return { x: worldPos.x, y: worldPos.y, z: worldPos.z };\n            }\n            result.x = worldPos.x;\n            result.y = worldPos.y;\n            result.z = worldPos.z;\n            return result;\n        }\n        return this.projectPoint(sourceProjection.unprojectPoint(worldPos), result);\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\n/**\n * Unit of measurement used to specify a font's size.\n */\nexport enum FontUnit {\n    Em,\n    Pixel,\n    Point,\n    Percent\n}\n\n/**\n * Pair of unit and size specifying a font's size.\n */\nexport interface FontSize {\n    unit: FontUnit;\n    size: number;\n    backgroundSize: number;\n}\n\n/**\n * Style to be used when rendering glyphs.\n */\nexport enum FontStyle {\n    Regular,\n    Bold,\n    Italic,\n    BoldItalic\n}\n\n/**\n * Variant to be used when rendering.\n */\nexport enum FontVariant {\n    Regular,\n    AllCaps,\n    SmallCaps\n}\n\n/**\n * Vertical alignment to be used when placing text.\n */\nexport enum VerticalAlignment {\n    Above = 0.0,\n    Center = -0.5,\n    Below = -1.0\n}\n\n/**\n * Horizontal alignment to be used when placing text.\n */\nexport enum HorizontalAlignment {\n    Left = 0.0,\n    Center = -0.5,\n    Right = -1.0\n}\n\n/**\n * Text wrapping rule used when `lineWidth` is reached.\n */\nexport enum WrappingMode {\n    None,\n    Character,\n    Word\n}\n\n/**\n * Namespace containing default values for all members of [[TextRenderParameters]] and\n * [[TextLayoutParameters]].\n */\nexport namespace DefaultTextStyle {\n    export const DEFAULT_FONT_NAME: string = \"\";\n    export const DEFAULT_FONT_SIZE: FontSize = {\n        unit: Object.freeze(FontUnit.Pixel),\n        size: Object.freeze(16.0),\n        backgroundSize: Object.freeze(0.0)\n    };\n    export const DEFAULT_FONT_STYLE: FontStyle = FontStyle.Regular;\n    export const DEFAULT_FONT_VARIANT: FontVariant = FontVariant.Regular;\n    export const DEFAULT_ROTATION: number = 0.0;\n    export const DEFAULT_COLOR: THREE.Color = new THREE.Color(0x000000);\n    export const DEFAULT_OPACITY: number = 1.0;\n    export const DEFAULT_BACKGROUND_COLOR: THREE.Color = new THREE.Color(0x000000);\n    export const DEFAULT_BACKGROUND_OPACITY: number = 0.0;\n\n    export const DEFAULT_TRACKING: number = 0.0;\n    export const DEFAULT_LEADING: number = 0.0;\n    export const DEFAULT_MAX_LINES: number = Infinity;\n    export const DEFAULT_LINE_WIDTH: number = Infinity;\n    export const DEFAULT_CANVAS_ROTATION: number = 0.0;\n    export const DEFAULT_LINE_ROTATION: number = 0.0;\n    export const DEFAULT_WRAPPING_MODE: WrappingMode = WrappingMode.Word;\n    export const DEFAULT_VERTICAL_ALIGNMENT: VerticalAlignment = VerticalAlignment.Above;\n    export const DEFAULT_HORIZONTAL_ALIGNMENT: HorizontalAlignment = HorizontalAlignment.Left;\n}\n\n/**\n * [[TextCanvas]] text rendering parameters.\n */\nexport interface TextRenderParameters {\n    fontName?: string;\n    fontSize?: FontSize;\n    fontStyle?: FontStyle;\n    fontVariant?: FontVariant;\n    rotation?: number;\n    color?: THREE.Color;\n    backgroundColor?: THREE.Color;\n    opacity?: number;\n    backgroundOpacity?: number;\n}\n\n/**\n * [[TextCanvas]] text rendering style.\n */\nexport class TextRenderStyle {\n    private m_params: TextRenderParameters;\n\n    /**\n     * Creates a new `TextRenderStyle`.\n     *\n     * @param params Input [[TextRenderParameters]].\n     *\n     * @returns New `TextRenderStyle`.\n     */\n    constructor(params: TextRenderParameters = {}) {\n        this.m_params = {\n            fontName:\n                params.fontName !== undefined\n                    ? params.fontName\n                    : DefaultTextStyle.DEFAULT_FONT_NAME,\n            fontSize:\n                params.fontSize !== undefined\n                    ? params.fontSize\n                    : {\n                          unit: DefaultTextStyle.DEFAULT_FONT_SIZE.unit,\n                          size: DefaultTextStyle.DEFAULT_FONT_SIZE.size,\n                          backgroundSize: DefaultTextStyle.DEFAULT_FONT_SIZE.backgroundSize\n                      },\n            fontStyle:\n                params.fontStyle !== undefined\n                    ? params.fontStyle\n                    : DefaultTextStyle.DEFAULT_FONT_STYLE,\n            fontVariant:\n                params.fontVariant !== undefined\n                    ? params.fontVariant\n                    : DefaultTextStyle.DEFAULT_FONT_VARIANT,\n            rotation:\n                params.rotation !== undefined ? params.rotation : DefaultTextStyle.DEFAULT_ROTATION,\n            color:\n                params.color !== undefined\n                    ? params.color\n                    : new THREE.Color(DefaultTextStyle.DEFAULT_COLOR),\n            opacity:\n                params.opacity !== undefined ? params.opacity : DefaultTextStyle.DEFAULT_OPACITY,\n            backgroundColor:\n                params.backgroundColor !== undefined\n                    ? params.backgroundColor\n                    : new THREE.Color(DefaultTextStyle.DEFAULT_BACKGROUND_COLOR),\n            backgroundOpacity:\n                params.backgroundOpacity !== undefined\n                    ? params.backgroundOpacity\n                    : DefaultTextStyle.DEFAULT_BACKGROUND_OPACITY\n        };\n    }\n\n    /**\n     * Current [[TextRenderParameters]] for this style.\n     */\n    get params(): TextRenderParameters {\n        return this.m_params;\n    }\n    set params(value: TextRenderParameters) {\n        this.m_params = { ...this.m_params, ...value };\n    }\n\n    /**\n     * Name of the preferred [[Font]] to be used when rendering.\n     */\n    get fontName(): string {\n        return this.m_params.fontName!;\n    }\n    set fontName(value: string) {\n        this.m_params.fontName = value;\n    }\n\n    /**\n     * Collection of unit and sizes to apply for the currently active [[Font]].\n     */\n    get fontSize(): FontSize {\n        return this.m_params.fontSize!;\n    }\n    set fontSize(value: FontSize) {\n        this.m_params.fontSize = value;\n    }\n\n    /**\n     * Glyph style to apply for the currently active [[Font]].\n     */\n    get fontStyle(): FontStyle {\n        return this.m_params.fontStyle!;\n    }\n    set fontStyle(value: FontStyle) {\n        this.m_params.fontStyle = value;\n    }\n\n    /**\n     * Glyph variant to apply for the currently active [[Font]].\n     */\n    get fontVariant(): FontVariant {\n        return this.m_params.fontVariant!;\n    }\n    set fontVariant(value: FontVariant) {\n        this.m_params.fontVariant = value;\n    }\n\n    /**\n     * Glyph local rotation (radians).\n     */\n    get rotation(): number {\n        return this.m_params.rotation!;\n    }\n    set rotation(value: number) {\n        this.m_params.rotation = value;\n    }\n\n    /**\n     * Glyph color.\n     */\n    get color(): THREE.Color {\n        return this.m_params.color!;\n    }\n    set color(value: THREE.Color) {\n        this.m_params.color = value;\n    }\n\n    /**\n     * Glyph background color.\n     */\n    get backgroundColor(): THREE.Color {\n        return this.m_params.backgroundColor!;\n    }\n    set backgroundColor(value: THREE.Color) {\n        this.m_params.backgroundColor = value;\n    }\n\n    /**\n     * Glyph opacity.\n     */\n    get opacity(): number {\n        return this.m_params.opacity!;\n    }\n    set opacity(value: number) {\n        this.m_params.opacity = value;\n    }\n\n    /**\n     * Glyph background opacity.\n     */\n    get backgroundOpacity(): number {\n        return this.m_params.backgroundOpacity!;\n    }\n    set backgroundOpacity(value: number) {\n        this.m_params.backgroundOpacity = value;\n    }\n\n    /**\n     * Clone this `TextRenderStyle`.\n     *\n     * @param params Input [[TextRenderParameters]].\n     *\n     * @returns Cloned `TextRenderStyle`.\n     */\n    clone(params: TextRenderParameters = {}): TextRenderStyle {\n        return new TextRenderStyle({ ...this.m_params, ...params });\n    }\n}\n\n/**\n * [[TextCanvas]] text layout parameters.\n */\nexport interface TextLayoutParameters {\n    tracking?: number;\n    leading?: number;\n    maxLines?: number;\n    lineWidth?: number;\n    canvasRotation?: number;\n    lineRotation?: number;\n    wrappingMode?: WrappingMode;\n    verticalAlignment?: VerticalAlignment;\n    horizontalAlignment?: HorizontalAlignment;\n}\n\n/**\n * [[TextCanvas]] text rendering style.\n */\nexport class TextLayoutStyle {\n    private m_params: TextLayoutParameters;\n\n    /**\n     * Creates a new `TextLayoutStyle`.\n     *\n     * @param params Input [[TextLayoutParameters]].\n     *\n     * @returns New `TextLayoutStyle`.\n     */\n    constructor(params: TextLayoutParameters = {}) {\n        this.m_params = {\n            tracking:\n                params.tracking !== undefined ? params.tracking : DefaultTextStyle.DEFAULT_TRACKING,\n            leading:\n                params.leading !== undefined ? params.leading : DefaultTextStyle.DEFAULT_LEADING,\n            maxLines:\n                params.maxLines !== undefined\n                    ? params.maxLines\n                    : DefaultTextStyle.DEFAULT_MAX_LINES,\n            lineWidth:\n                params.lineWidth !== undefined\n                    ? params.lineWidth\n                    : DefaultTextStyle.DEFAULT_LINE_WIDTH,\n            canvasRotation:\n                params.canvasRotation !== undefined\n                    ? params.canvasRotation\n                    : DefaultTextStyle.DEFAULT_CANVAS_ROTATION,\n            lineRotation:\n                params.lineRotation !== undefined\n                    ? params.lineRotation\n                    : DefaultTextStyle.DEFAULT_LINE_ROTATION,\n            wrappingMode:\n                params.wrappingMode !== undefined\n                    ? params.wrappingMode\n                    : DefaultTextStyle.DEFAULT_WRAPPING_MODE,\n            verticalAlignment:\n                params.verticalAlignment !== undefined\n                    ? params.verticalAlignment\n                    : DefaultTextStyle.DEFAULT_VERTICAL_ALIGNMENT,\n            horizontalAlignment:\n                params.horizontalAlignment !== undefined\n                    ? params.horizontalAlignment\n                    : DefaultTextStyle.DEFAULT_HORIZONTAL_ALIGNMENT\n        };\n    }\n\n    /**\n     * Current [[TextLayoutParameters]] for this style.\n     */\n    get params(): TextLayoutParameters {\n        return this.m_params;\n    }\n    set params(value: TextLayoutParameters) {\n        this.m_params = { ...this.m_params, ...value };\n    }\n\n    /**\n     * Inter-glyph spacing (pixels). Scaled by [[FontSize]].\n     */\n    get tracking(): number {\n        return this.m_params.tracking!;\n    }\n    set tracking(value: number) {\n        this.m_params.tracking = value;\n    }\n\n    /**\n     * Inter-line spacing (pixels). Scaled by [[FontSize]].\n     */\n    get leading(): number {\n        return this.m_params.leading!;\n    }\n    set leading(value: number) {\n        this.m_params.leading = value;\n    }\n\n    /**\n     * Maximum number of lines to be considered when using [[TextCanvas]].\n     */\n    get maxLines(): number {\n        return this.m_params.maxLines!;\n    }\n    set maxLines(value: number) {\n        this.m_params.maxLines = value;\n    }\n\n    /**\n     * Maximum line width (pixels).\n     */\n    get lineWidth(): number {\n        return this.m_params.lineWidth!;\n    }\n    set lineWidth(value: number) {\n        this.m_params.lineWidth = value;\n    }\n\n    /**\n     * [[TextCanvas]] rotation (radians).\n     */\n    get canvasRotation(): number {\n        return this.m_params.canvasRotation!;\n    }\n    set canvasRotation(value: number) {\n        this.m_params.canvasRotation = value;\n    }\n\n    /**\n     * Line typesetting rotation (radians).\n     */\n    get lineRotation(): number {\n        return this.m_params.lineRotation!;\n    }\n    set lineRotation(value: number) {\n        this.m_params.lineRotation = value;\n    }\n\n    /**\n     * Wrapping (line-breaking) mode.\n     */\n    get wrappingMode(): WrappingMode {\n        return this.m_params.wrappingMode!;\n    }\n    set wrappingMode(value: WrappingMode) {\n        this.m_params.wrappingMode = value;\n    }\n\n    /**\n     * Text position regarding the baseline.\n     */\n    get verticalAlignment(): VerticalAlignment {\n        return this.m_params.verticalAlignment!;\n    }\n    set verticalAlignment(value: VerticalAlignment) {\n        this.m_params.verticalAlignment = value;\n    }\n\n    /**\n     * Text position inside a line.\n     */\n    get horizontalAlignment(): HorizontalAlignment {\n        return this.m_params.horizontalAlignment!;\n    }\n    set horizontalAlignment(value: HorizontalAlignment) {\n        this.m_params.horizontalAlignment = value;\n    }\n\n    /**\n     * Clone this `TextLayoutStyle`.\n     *\n     * @param params Input [[TextLayoutParameters]].\n     *\n     * @returns Cloned `TextLayoutStyle`.\n     */\n    clone(params: TextLayoutParameters = {}): TextLayoutStyle {\n        return new TextLayoutStyle({ ...this.m_params, ...params });\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport * from \"./lib/AnimatedExtrusionHandler\";\nexport * from \"./lib/CameraMovementDetector\";\nexport * from \"./lib/ClipPlanesEvaluator\";\nexport * from \"./lib/ColorCache\";\nexport * from \"./lib/composing\";\nexport * from \"./lib/ConcurrentDecoderFacade\";\nexport * from \"./lib/ConcurrentDecoderFacade\";\nexport * from \"./lib/ConcurrentTilerFacade\";\nexport * from \"./lib/ConcurrentTilerFacade\";\nexport * from \"./lib/copyrights/CopyrightElementHandler\";\nexport * from \"./lib/copyrights/CopyrightInfo\";\nexport * from \"./lib/copyrights/CopyrightProvider\";\nexport * from \"./lib/copyrights/CopyrightCoverageProvider\";\nexport * from \"./lib/copyrights/UrlCopyrightProvider\";\nexport * from \"./lib/DataSource\";\nexport * from \"./lib/PolarTileDataSource\";\nexport * from \"./lib/DecodedTileHelpers\";\nexport * from \"./lib/DepthPrePass\";\nexport * from \"./lib/DisplacementMap\";\nexport * from \"./lib/ElevationProvider\";\nexport * from \"./lib/ElevationRangeSource\";\nexport * from \"./lib/image/Image\";\nexport * from \"./lib/image/ImageCache\";\nexport * from \"./lib/image/MapViewImageCache\";\nexport * from \"./lib/MapView\";\nexport * from \"./lib/MapViewFog\";\nexport * from \"./lib/MapViewPoints\";\nexport * from \"./lib/PickHandler\";\nexport * from \"./lib/poi/Poi\";\nexport * from \"./lib/poi/PoiManager\";\nexport * from \"./lib/poi/PoiTableManager\";\nexport * from \"./lib/RoadPicker\";\nexport * from \"./lib/Statistics\";\nexport * from \"./lib/text/TextElement\";\nexport * from \"./lib/text/TextElementsRenderer\";\nexport * from \"./lib/text/TextStyleCache\";\nexport * from \"./lib/ThemeLoader\";\nexport * from \"./lib/Tile\";\nexport * from \"./lib/geometry/TileDataAccessor\";\nexport * from \"./lib/geometry/TileGeometry\";\nexport * from \"./lib/Utils\";\nexport * from \"./lib/VisibleTileSet\";\nexport * from \"./lib/WorkerBasedDecoder\";\nexport * from \"./lib/WorkerBasedTiler\";\nexport * from \"./lib/workers/WorkerLoader\";\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\n/**\n * Insert shader includes after another shader include.\n *\n * @param shaderContent Original string.\n * @param shaderName String to append to.\n * @param insertedShaderName String to append after string `shaderA`.\n * @param addTab If `true`, a tab character will be inserted before `shaderB`.\n */\nexport function insertShaderInclude(\n    shaderContent: string,\n    shaderName: string,\n    insertedShaderName: string,\n    addTab?: boolean\n): string {\n    const tabChar = addTab === true ? \"\\t\" : \"\";\n\n    const result = shaderContent.replace(\n        `#include <${shaderName}>`,\n        `#include <${shaderName}>\n${tabChar}#include <${insertedShaderName}>`\n    );\n    return result;\n}\n\nexport interface ForcedBlending {\n    /**\n     * This material has `blending` always enabled regardless of `opacity` setting.s\n     */\n    forcedBlending?: true;\n}\n\n/**\n * THREE.js is enabling blending only when transparent is `true` or when a blend mode\n * different than `NormalBlending` is set.\n * Since we don't want to set transparent to true and mess up the render order we set\n * `CustomBlending` with the same parameters as the `NormalBlending`.\n\n * @param material `Material` that should use blending\n * @note This function should not be used in frame update after material has been passed to WebGL.\n * In such cases use [[enableBlending]] instead.\n */\nexport function enforceBlending(\n    material: (THREE.Material | THREE.ShaderMaterialParameters) & ForcedBlending\n) {\n    if (material.transparent) {\n        // Nothing to do\n        return;\n    }\n\n    enableBlending(material);\n    material.forcedBlending = true;\n}\n\n/**\n * Enable alpha blending using THREE.CustomBlending setup.\n *\n * Function enables blending using one of predefined modes, for both color and alpha components:\n * - Src: [[THREE.SrcAlphaFactor]], Dst: [[THREE.OneMinusSrcAlphaFactor]]\n * - Src: [[THREE.OneFactor]], Dst: [[THREE.OneMinusSrcAlphaFactor]]\n * The second blending equation is used when [[THREE.Material.premultipliedAlpha]] is enabled\n * for this material.\n * @note Blending mode change does not require material update.\n * @see THREE.Material.needsUpdate.\n * @param material The material or material parameters to modify.\n */\nexport function enableBlending(\n    material: (THREE.Material | THREE.ShaderMaterialParameters) & ForcedBlending\n) {\n    if (material.transparent || material.forcedBlending) {\n        // Nothing to do\n        return;\n    }\n\n    material.blending = THREE.CustomBlending;\n    if (material.premultipliedAlpha === true) {\n        material.blendSrc = THREE.OneFactor;\n        material.blendDst = THREE.OneMinusSrcAlphaFactor;\n        material.blendSrcAlpha = THREE.OneFactor;\n        material.blendDstAlpha = THREE.OneMinusSrcAlphaFactor;\n    } else {\n        material.blendSrc = THREE.SrcAlphaFactor;\n        material.blendDst = THREE.OneMinusSrcAlphaFactor;\n        material.blendSrcAlpha = THREE.OneFactor;\n        material.blendDstAlpha = THREE.OneMinusSrcAlphaFactor;\n    }\n}\n\n/**\n * Disable alpha blending using THREE.CustomBlending mode, switches to [[THREE.NormalBlending]].\n *\n * @note Blending mode change does not require material update.\n * @see THREE.Material.needsUpdate.\n * @see enableBlending.\n * @param material The material or material parameters to modify.\n */\nexport function disableBlending(\n    material: (THREE.Material | THREE.ShaderMaterialParameters) & ForcedBlending\n) {\n    if (material.transparent || material.forcedBlending) {\n        // Nothing to do\n        return;\n    }\n\n    material.blending = THREE.NormalBlending;\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { assert } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nconst SHIFT_TRANSPARENCY: number = 24;\nconst SHIFT_RED: number = 16;\nconst SHIFT_GREEN: number = 8;\nconst SHIFT_BLUE: number = 0;\n\n// tslint:disable: no-bitwise\n//    Allow bitwise operations for colors decoding\n\n// tslint:disable-next-line: no-bitwise\nconst HEX_FULL_CHANNEL: number = 0xff;\nconst HEX_RGB_MASK: number = 0xffffff;\nconst HEX_TRGB_MASK: number = 0xffffffff;\n\nconst tmpColor = new THREE.Color();\n\n/**\n * Utilities to convert RGBA colors encoded in custom number (hex) format to THREE.Color objects.\n *\n * The functions provided allows for conversion from and to our custom number based color format,\n * which contains transparency, red, green and blue color channels in a way that each channel\n * occupies 8 bits of resulting number (color format 0xTTRRGGBB).\n * In order to preserve compatibility with THREE.Color class and its hexadecimal color\n * representation, we do not store __alpha__ channel in encoded color's number, but replace it\n * with __transparency__ channel, which is simply opposite to alpha:\n * ```transparency = 0xFF - alpha```\n * Such channel value is stored on the oldest bits (octet) in the integral color (numeric) value,\n * so it is fully compatible with THREE.Color numerical representation (@see [[THREE.Color.getHex]],\n * [[THREE.Color.setHex]]).\n * See also [[getHexFromRgba]] and [[getRgbaFromHex]] for more info about conversion.\n */\nexport namespace ColorUtils {\n    /**\n     * Encodes RGBA channels in custom number coded format (represented in hex as 0xTTRRGGBB).\n     *\n     * We do not use direct alpha channel mapping to hex in order to preserve compatibility\n     * with THREE.js color format (0xRRGGBB). This is done by encoding transparency\n     * (255 - alpha) instead of alpha on the oldest bits, shifted by [[SHIFT_TRANSPARENCY]].\n     * This way simple 0xRRGGBB color is equal to 0x00RRGGBB without transparency and\n     * color defining transparency (alpha < 255) is always recognizable by the oldest\n     * bit set:\n     * ```typescript\n     * (color >> SHIFT_TRANSPARENCY) !== 0.\n     * ```\n     * @note All input components are floating points in <0, 1> range (inclusively).\n     * @note Although method encodes transparency channel in single number value, it is still\n     * compatible with THREE.js number based color coding (0xRRGGBB), so you may pass this value to\n     * [[THREE.Color]] c-tor, but keep in mind that transparency will be silently ignored.\n     */\n    export function getHexFromRgba(r: number, g: number, b: number, a: number): number {\n        assert(a >= 0 && a <= 1);\n        const t = HEX_FULL_CHANNEL - Math.floor(a * HEX_FULL_CHANNEL);\n        return (\n            (t << SHIFT_TRANSPARENCY) ^\n            ((r * HEX_FULL_CHANNEL) << SHIFT_RED) ^\n            ((g * HEX_FULL_CHANNEL) << SHIFT_GREEN) ^\n            ((b * HEX_FULL_CHANNEL) << SHIFT_BLUE)\n        );\n    }\n\n    /**\n     * Encodes RGB all color channels in single number with format 0xRRGGBB.\n     *\n     * All input channels should be in <0, 1> range (inclusively).\n     * See also [[getHexFromRgba]] for more information about [[THREE.Color]] compatibility.\n     *\n     * @note This method is fully compatible with THREE.js color encoding, so\n     * you may pass this value directly to THREE.Color c-tor.\n     */\n    export function getHexFromRgb(r: number, g: number, b: number): number {\n        assert(r >= 0 && r <= 1);\n        assert(g >= 0 && g <= 1);\n        assert(b >= 0 && b <= 1);\n        return (\n            ((r * HEX_FULL_CHANNEL) << SHIFT_RED) ^\n            ((g * HEX_FULL_CHANNEL) << SHIFT_GREEN) ^\n            ((b * HEX_FULL_CHANNEL) << SHIFT_BLUE)\n        );\n    }\n\n    /**\n     * Encode and convert HSL value to number coded color format (0xRRGGBB).\n     *\n     * @see getHexFromRgb.\n     * @param h Hue component value between 0 and 1.\n     * @param s Saturation value between 0 and 1.\n     * @param l Lightness channel between 0 and 1.\n     */\n    export function getHexFromHsl(h: number, s: number, l: number): number {\n        assert(h >= 0 && h <= 1);\n        assert(s >= 0 && s <= 1);\n        assert(l >= 0 && l <= 1);\n        return tmpColor.setHSL(h, s, l).getHex();\n    }\n\n    /**\n     * Retrieve RGBA channels separately from number encoded custom color format.\n     *\n     * Provides an easy way for channels extraction (r, g, b, a) from custom number coded color\n     * format.\n     *\n     * @see getHexFromRgba.\n     * @param hex The number encoded color value (0xRRGGBB or 0xTTRRGGBB in hex).\n     * @returns r, g, b, a channels in simple object, where each channel value is saved as floating\n     * point from 0 to 1 inclusively.\n     */\n    export function getRgbaFromHex(hex: number): { r: number; g: number; b: number; a: number } {\n        assert((hex & ~HEX_TRGB_MASK) === 0, \"Wrong hex format: #\" + hex.toString(16));\n        return {\n            r: ((hex >> SHIFT_RED) & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL,\n            g: ((hex >> SHIFT_GREEN) & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL,\n            b: ((hex >> SHIFT_BLUE) & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL,\n            a:\n                (HEX_FULL_CHANNEL - ((hex >> SHIFT_TRANSPARENCY) & HEX_FULL_CHANNEL)) /\n                HEX_FULL_CHANNEL\n        };\n    }\n\n    /**\n     * Determines if number encoded color contains alpha (opacity) defined and different then 255.\n     *\n     * @param hex The number encoded color (0xRRGGBB or 0xTTRRGGBB in hex).\n     * @returns True if color has transparency defined.\n     */\n    export function hasAlphaInHex(hex: number): boolean {\n        assert((hex & ~HEX_TRGB_MASK) === 0, \"Wrong hex format: #\" + hex.toString(16));\n        return hex >> SHIFT_TRANSPARENCY !== 0;\n    }\n\n    /**\n     * Retrieves alpha color channel from hex encoded color value.\n     *\n     * @see getHexFromRgba.\n     * @param hex The number encoded color value (representable as 0xRRGGBB or 0xTTRRGGBB in hex).\n     * @returns The floating point alpha component in <0, 1> range.\n     */\n    export function getAlphaFromHex(hex: number): number {\n        assert((hex & ~HEX_TRGB_MASK) === 0, \"Wrong hex format: #\" + hex.toString(16));\n        return (\n            ((HEX_FULL_CHANNEL - (hex >> SHIFT_TRANSPARENCY)) & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL\n        );\n    }\n\n    /**\n     * Remove transparency info from the number coded color, makes it compatible with external libs.\n     *\n     * @see getAlphaFromHex.\n     * @param hex The number encoded color value (representable as 0xRRGGBB or 0xTTRRGGBB in hex).\n     * @returns number coded color value representable as 0xRRGGBB in hex.\n     */\n    export function removeAlphaFromHex(hex: number): number {\n        assert((hex & ~HEX_TRGB_MASK) === 0, \"Wrong hex format: #\" + hex.toString(16));\n        return hex & HEX_RGB_MASK;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { assert, LoggerManager } from \"@here/harp-utils\";\nimport { ColorUtils } from \"./ColorUtils\";\nimport { Env, MapEnv } from \"./Env\";\nimport { ExponentialInterpolant } from \"./ExponentialInterpolant\";\nimport { Expr, ExprScope, Value } from \"./Expr\";\nimport {\n    InterpolatedProperty,\n    InterpolatedPropertyDefinition,\n    InterpolationMode\n} from \"./InterpolatedPropertyDefs\";\nimport {\n    parseStringEncodedNumeral,\n    StringEncodedColorFormats,\n    StringEncodedMetricFormats,\n    StringEncodedNumeralFormat,\n    StringEncodedNumeralFormatMaxSize,\n    StringEncodedNumeralFormats,\n    StringEncodedNumeralType\n} from \"./StringEncodedNumeral\";\n\nconst logger = LoggerManager.instance.create(\"InterpolatedProperty\");\n\nconst interpolants = [\n    THREE.DiscreteInterpolant,\n    THREE.LinearInterpolant,\n    THREE.CubicInterpolant,\n    ExponentialInterpolant\n];\n\nconst tmpBuffer = new Array<number>(StringEncodedNumeralFormatMaxSize);\n\n/**\n * Checks if a property is interpolated.\n * @param p property to be checked\n */\nexport function isInterpolatedPropertyDefinition<T>(\n    p: any\n): p is InterpolatedPropertyDefinition<T> {\n    if (\n        p &&\n        p.interpolationMode === undefined &&\n        Array.isArray(p.values) &&\n        p.values.length > 0 &&\n        p.values[0] !== undefined &&\n        Array.isArray(p.zoomLevels) &&\n        p.zoomLevels.length > 0 &&\n        p.zoomLevels[0] !== undefined &&\n        p.values.length === p.zoomLevels.length\n    ) {\n        return true;\n    }\n    return false;\n}\n\n/**\n * Type guard to check if an object is an instance of `InterpolatedProperty`.\n */\nexport function isInterpolatedProperty(p: any): p is InterpolatedProperty {\n    if (\n        p !== undefined &&\n        p.interpolationMode !== undefined &&\n        p.zoomLevels instanceof Float32Array &&\n        p.values !== undefined &&\n        p.values.length > 0 &&\n        (p.zoomLevels.length === p.values.length / 4 ||\n            p.zoomLevels.length === p.values.length / 3 ||\n            p.zoomLevels.length === p.values.length)\n    ) {\n        return true;\n    }\n    return false;\n}\n\n/**\n * A temp [[Env]] containing the arguments passed to `getPropertyValue`.\n *\n * [[dynamicPropertiesTempEnv]] is used when `getPropertyValue` is\n * invoked with explicit values for `zoom` and `pixelToMeters` instead\n * of with an [[Env]].\n *\n * @hidden\n */\nconst dynamicPropertiesTempEnv = new MapEnv({\n    $zoom: 0,\n    $pixelToMeters: 1\n});\n\n/**\n * Get the value of the specified property at the given zoom level.\n *\n * @param property Property of a technique.\n * @param env The [[Env]] used to evaluate the property.\n */\nexport function getPropertyValue(\n    property: Value | Expr | InterpolatedProperty | undefined,\n    env: Env\n): any;\n\n/**\n * Get the value of the specified property at the given zoom level.\n *\n * @param property Property of a technique.\n * @param level Display level the property should be rendered at.\n * @param pixelToMeters Optional pixels to meters conversion factor (needed for proper\n * interpolation of `length` values).\n *\n */\nexport function getPropertyValue(\n    property: Value | Expr | InterpolatedProperty | undefined,\n    level: number,\n    pixelToMeters?: number\n): any;\n\nexport function getPropertyValue(\n    property: Value | Expr | InterpolatedProperty | undefined,\n    envOrLevel: number | Env,\n    pixelToMeters: number = 1.0\n): any {\n    if (Expr.isExpr(property)) {\n        let env: Env;\n\n        if (typeof envOrLevel === \"number\") {\n            dynamicPropertiesTempEnv.entries.$zoom = envOrLevel;\n            dynamicPropertiesTempEnv.entries.$pixelToMeters = pixelToMeters;\n            env = dynamicPropertiesTempEnv;\n        } else {\n            env = envOrLevel;\n        }\n\n        return property.evaluate(env, ExprScope.Dynamic);\n    }\n\n    let level: number;\n\n    if (typeof envOrLevel === \"number\") {\n        level = envOrLevel;\n    } else {\n        level = envOrLevel.lookup(\"$zoom\") as number;\n        pixelToMeters = envOrLevel.lookup(\"$pixelToMeters\") as number;\n    }\n\n    // Non-interpolated property parsing\n    if (!isInterpolatedProperty(property)) {\n        if (typeof property !== \"string\") {\n            // Property in numeric or array, etc. format\n            return property;\n        } else {\n            const value = parseStringEncodedNumeral(property, pixelToMeters);\n            return value !== undefined ? value : property;\n        }\n        // Interpolated property\n    } else if (property._stringEncodedNumeralType !== undefined) {\n        switch (property._stringEncodedNumeralType) {\n            case StringEncodedNumeralType.Meters:\n            case StringEncodedNumeralType.Pixels:\n                return getInterpolatedMetric(property, level, pixelToMeters);\n            case StringEncodedNumeralType.Hex:\n            case StringEncodedNumeralType.RGB:\n            case StringEncodedNumeralType.RGBA:\n            case StringEncodedNumeralType.HSL:\n                return getInterpolatedColor(property, level);\n        }\n    }\n    return getInterpolatedMetric(property, level, pixelToMeters);\n}\n\nfunction getInterpolatedMetric(\n    property: InterpolatedProperty,\n    level: number,\n    pixelToMeters: number\n): number {\n    const nChannels = property.values.length / property.zoomLevels.length;\n    const interpolant = new interpolants[property.interpolationMode](\n        property.zoomLevels,\n        property.values,\n        nChannels\n    );\n    if (\n        property.interpolationMode === InterpolationMode.Exponential &&\n        property.exponent !== undefined\n    ) {\n        (interpolant as ExponentialInterpolant).exponent = property.exponent;\n    }\n    interpolant.evaluate(level);\n\n    if (property._stringEncodedNumeralDynamicMask === undefined) {\n        return interpolant.resultBuffer[0];\n    } else {\n        const maskInterpolant = new interpolants[property.interpolationMode](\n            property.zoomLevels,\n            property._stringEncodedNumeralDynamicMask,\n            1\n        );\n        if (\n            property.interpolationMode === InterpolationMode.Exponential &&\n            property.exponent !== undefined\n        ) {\n            (maskInterpolant as ExponentialInterpolant).exponent = property.exponent;\n        }\n        maskInterpolant.evaluate(level);\n\n        return (\n            interpolant.resultBuffer[0] *\n            (1 + maskInterpolant.resultBuffer[0] * (pixelToMeters - 1))\n        );\n    }\n}\n\nfunction getInterpolatedColor(property: InterpolatedProperty, level: number): number {\n    const nChannels = property.values.length / property.zoomLevels.length;\n    const interpolant = new interpolants[property.interpolationMode](\n        property.zoomLevels,\n        property.values,\n        nChannels\n    );\n    if (\n        property.interpolationMode === InterpolationMode.Exponential &&\n        property.exponent !== undefined\n    ) {\n        (interpolant as ExponentialInterpolant).exponent = property.exponent;\n    }\n    interpolant.evaluate(level);\n\n    assert(nChannels === 3 || nChannels === 4);\n    // ColorUtils.getHexFromRgba() does not clamp the values which may be out of\n    // color channels range (0 <= c <= 1) after interpolation.\n    if (nChannels === 4) {\n        return ColorUtils.getHexFromRgba(\n            THREE.Math.clamp(interpolant.resultBuffer[0], 0, 1),\n            THREE.Math.clamp(interpolant.resultBuffer[1], 0, 1),\n            THREE.Math.clamp(interpolant.resultBuffer[2], 0, 1),\n            THREE.Math.clamp(interpolant.resultBuffer[3], 0, 1)\n        );\n    } else {\n        return ColorUtils.getHexFromRgb(\n            THREE.Math.clamp(interpolant.resultBuffer[0], 0, 1),\n            THREE.Math.clamp(interpolant.resultBuffer[1], 0, 1),\n            THREE.Math.clamp(interpolant.resultBuffer[2], 0, 1)\n        );\n    }\n}\n\n/**\n * Convert JSON representation of interpolated property to internal, normalized version that\n * can be evaluated by [[getPropertyValue]].\n */\nexport function createInterpolatedProperty(\n    prop: InterpolatedPropertyDefinition<unknown>\n): InterpolatedProperty | undefined {\n    removeDuplicatePropertyValues(prop);\n\n    const interpolationMode =\n        prop.interpolation !== undefined\n            ? InterpolationMode[prop.interpolation]\n            : InterpolationMode.Discrete;\n\n    const zoomLevels = new Float32Array(prop.zoomLevels);\n\n    const firstValue = prop.values[0];\n    switch (typeof firstValue) {\n        default:\n        case \"number\":\n        case \"boolean\":\n            return {\n                interpolationMode,\n                zoomLevels,\n                values: new Float32Array(prop.values as any),\n                exponent: prop.exponent\n            };\n        case \"string\":\n            // TODO: Minimize effort for pre-matching the numeral format.\n            const matchedFormat = StringEncodedNumeralFormats.find(format =>\n                format.regExp.test(firstValue)\n            );\n\n            if (matchedFormat === undefined) {\n                if (interpolationMode === InterpolationMode.Discrete) {\n                    return {\n                        interpolationMode,\n                        zoomLevels,\n                        values: prop.values\n                    };\n                }\n\n                logger.error(`No StringEncodedNumeralFormat matched ${firstValue}.`);\n                return undefined;\n            }\n\n            let needsMask = false;\n\n            const propValues = new Float32Array(prop.values.length * matchedFormat.size);\n            const maskValues = new Float32Array(prop.values.length);\n            needsMask = procesStringEnocodedNumeralInterpolatedProperty(\n                matchedFormat,\n                prop as InterpolatedPropertyDefinition<string>,\n                propValues,\n                maskValues\n            );\n\n            return {\n                interpolationMode,\n                zoomLevels,\n                values: propValues,\n                exponent: prop.exponent,\n                _stringEncodedNumeralType: matchedFormat.type,\n                _stringEncodedNumeralDynamicMask: needsMask ? maskValues : undefined\n            };\n    }\n}\n\nfunction removeDuplicatePropertyValues<T>(p: InterpolatedPropertyDefinition<T>) {\n    const eps = 0.001;\n\n    // detect cubic interpolations and remove stops\n    // closer than `eps`, this is needed to avoid\n    // possible NaN generated by the cubic interpolator.\n    const isCubic = p.interpolation === \"Cubic\";\n\n    for (let i = 0; i < p.values.length; ++i) {\n        const firstIdx = p.zoomLevels.findIndex(a => {\n            return isCubic ? Math.abs(a - p.zoomLevels[i]) < eps : a === p.zoomLevels[i];\n        });\n        if (firstIdx !== i) {\n            p.zoomLevels.splice(--i, 1);\n            p.values.splice(--i, 1);\n        }\n    }\n}\n\nfunction procesStringEnocodedNumeralInterpolatedProperty(\n    baseFormat: StringEncodedNumeralFormat,\n    prop: InterpolatedPropertyDefinition<string>,\n    propValues: Float32Array,\n    maskValues: Float32Array\n): boolean {\n    let needsMask = false;\n    const allowedValueFormats =\n        baseFormat.type === StringEncodedNumeralType.Meters ||\n        baseFormat.type === StringEncodedNumeralType.Pixels\n            ? StringEncodedMetricFormats\n            : StringEncodedColorFormats;\n\n    for (let valueIdx = 0; valueIdx < prop.values.length; ++valueIdx) {\n        let matched = false;\n        for (const valueFormat of allowedValueFormats) {\n            const value = prop.values[valueIdx];\n            matched = valueFormat.decoder(value, tmpBuffer);\n            if (!matched) {\n                continue;\n            }\n\n            if (valueFormat.mask !== undefined) {\n                maskValues[valueIdx] = valueFormat.mask;\n                needsMask = true;\n            }\n\n            for (let i = 0; i < valueFormat.size; ++i) {\n                propValues[valueIdx * valueFormat.size + i] = tmpBuffer[i];\n            }\n            break;\n        }\n        if (!matched) {\n            throw Error(\n                `Not all interpolation values match the same format: ${JSON.stringify(prop)}`\n            );\n        }\n    }\n\n    return needsMask;\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeoCoordinates } from \"./GeoCoordinates\";\n\nimport * as THREE from \"three\";\n\n/**\n * `GeoBox` is used to represent a bounding box in geo coordinates.\n */\nexport class GeoBox {\n    /**\n     * Returns a `GeoBox` with the given geo coordinates.\n     *\n     * @param southWest The south west position in geo coordinates.\n     * @param northEast The north east position in geo coordinates.\n     */\n    static fromCoordinates(southWest: GeoCoordinates, northEast: GeoCoordinates): GeoBox {\n        return new GeoBox(southWest, northEast);\n    }\n\n    /**\n     * Constructs a new `GeoBox` with the given geo coordinates.\n     *\n     * @param southWest The south west position in geo coordinates.\n     * @param northEast The north east position in geo coordinates.\n     */\n    constructor(readonly southWest: GeoCoordinates, readonly northEast: GeoCoordinates) {}\n\n    /**\n     * Returns the minimum altitude or `undefined`.\n     */\n    get minAltitude(): number | undefined {\n        if (this.southWest.altitude === undefined || this.northEast.altitude === undefined) {\n            return undefined;\n        }\n        return Math.min(this.southWest.altitude, this.northEast.altitude);\n    }\n\n    /**\n     * Returns the maximum altitude or `undefined`.\n     */\n    get maxAltitude(): number | undefined {\n        if (this.southWest.altitude === undefined || this.northEast.altitude === undefined) {\n            return undefined;\n        }\n        return Math.max(this.southWest.altitude, this.northEast.altitude);\n    }\n\n    /**\n     * Returns the south latitude in degrees of this `GeoBox`.\n     */\n    get south(): number {\n        return this.southWest.latitude;\n    }\n\n    /**\n     * Returns the north altitude in degrees of this `GeoBox`.\n     */\n    get north(): number {\n        return this.northEast.latitude;\n    }\n\n    /**\n     * Returns the west longitude in degrees of this `GeoBox`.\n     */\n    get west(): number {\n        return this.southWest.longitude;\n    }\n\n    /**\n     * Returns the east longitude in degrees of this `GeoBox`.\n     */\n    get east(): number {\n        return this.northEast.longitude;\n    }\n\n    /**\n     * Returns the center of this `GeoBox`.\n     */\n    get center(): GeoCoordinates {\n        const latitude = (this.south + this.north) * 0.5;\n        const { west, east } = this;\n        const { minAltitude, altitudeSpan } = this;\n\n        let altitude: number | undefined;\n\n        if (minAltitude !== undefined && altitudeSpan !== undefined) {\n            altitude = minAltitude + altitudeSpan * 0.5;\n        }\n\n        if (west < east) {\n            return new GeoCoordinates(latitude, (west + east) * 0.5, altitude);\n        }\n\n        let longitude = (360 + east + west) * 0.5;\n\n        if (longitude > 360) {\n            longitude -= 360;\n        }\n\n        return new GeoCoordinates(latitude, longitude, altitude);\n    }\n\n    /**\n     * Returns the latitude span in radians.\n     */\n    get latitudeSpanInRadians(): number {\n        return THREE.Math.degToRad(this.latitudeSpan);\n    }\n\n    /**\n     * Returns the longitude span in radians.\n     */\n    get longitudeSpanInRadians(): number {\n        return THREE.Math.degToRad(this.longitudeSpan);\n    }\n\n    /**\n     * Returns the latitude span in degrees.\n     */\n    get latitudeSpan(): number {\n        return this.north - this.south;\n    }\n\n    get altitudeSpan(): number | undefined {\n        if (this.maxAltitude === undefined || this.minAltitude === undefined) {\n            return undefined;\n        }\n        return this.maxAltitude - this.minAltitude;\n    }\n\n    /**\n     * Returns the longitude span in degrees.\n     */\n    get longitudeSpan(): number {\n        let width = this.northEast.longitude - this.southWest.longitude;\n\n        if (width < 0) {\n            width += 360;\n        }\n\n        return width;\n    }\n\n    /**\n     * Returns the latitude span in degrees.\n     * @deprecated Use [[latitudeSpan]] instead.\n     */\n    get latitudeSpanInDegrees(): number {\n        return this.latitudeSpan;\n    }\n\n    /**\n     * Returns the longitude span in degrees.\n     * @deprecated Use [[longitudeSpan]] instead.\n     */\n    get longitudeSpanInDegrees(): number {\n        return this.longitudeSpan;\n    }\n\n    /**\n     * Returns `true` if the given geo coordinates are contained in this `GeoBox`.\n     *\n     * @param point The geo coordinates.\n     */\n    contains(point: GeoCoordinates): boolean {\n        if (\n            point.altitude === undefined ||\n            this.minAltitude === undefined ||\n            this.maxAltitude === undefined\n        ) {\n            return this.containsHelper(point);\n        }\n\n        const isFlat = this.minAltitude === this.maxAltitude;\n        const isSameAltitude = this.minAltitude === point.altitude;\n        const isWithinAltitudeRange =\n            this.minAltitude <= point.altitude && this.maxAltitude > point.altitude;\n\n        // If box is flat, we should check the altitude and containment,\n        // otherwise we should check also altitude difference where we consider\n        // point to be inside if alt is from [m_minAltitude, m_maxAltitude) range!\n        if (isFlat ? isSameAltitude : isWithinAltitudeRange) {\n            return this.containsHelper(point);\n        }\n\n        return false;\n    }\n\n    /**\n     * Clones this `GeoBox` instance.\n     */\n    clone(): GeoBox {\n        return new GeoBox(this.southWest, this.northEast);\n    }\n\n    /**\n     * Update the bounding box by considering a given point.\n     *\n     * @param point The point that may expand the bounding box.\n     */\n    growToContain(point: GeoCoordinates) {\n        this.southWest.latitude = Math.min(this.southWest.latitude, point.latitude);\n        this.southWest.longitude = Math.min(this.southWest.longitude, point.longitude);\n        this.southWest.altitude =\n            this.southWest.altitude !== undefined && point.altitude !== undefined\n                ? Math.min(this.southWest.altitude, point.altitude)\n                : this.southWest.altitude !== undefined\n                ? this.southWest.altitude\n                : point.altitude !== undefined\n                ? point.altitude\n                : undefined;\n\n        this.northEast.latitude = Math.max(this.northEast.latitude, point.latitude);\n        this.northEast.longitude = Math.max(this.northEast.longitude, point.longitude);\n        this.northEast.altitude =\n            this.northEast.altitude !== undefined && point.altitude !== undefined\n                ? Math.max(this.northEast.altitude, point.altitude)\n                : this.northEast.altitude !== undefined\n                ? this.northEast.altitude\n                : point.altitude !== undefined\n                ? point.altitude\n                : undefined;\n    }\n\n    private containsHelper(point: GeoCoordinates): boolean {\n        if (point.latitude < this.southWest.latitude || point.latitude >= this.northEast.latitude) {\n            return false;\n        }\n\n        const { west, east } = this;\n\n        if (east > west) {\n            return point.longitude >= west && point.longitude < east;\n        }\n\n        return point.longitude > east || point.longitude <= west;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeoBox } from \"../coordinates/GeoBox\";\nimport { GeoCoordinatesLike } from \"../coordinates/GeoCoordinatesLike\";\nimport { Box3Like } from \"../math/Box3Like\";\nimport { Projection } from \"../projection/Projection\";\nimport { FlatTileBoundingBoxGenerator } from \"./FlatTileBoundingBoxGenerator\";\nimport { SubdivisionScheme } from \"./SubdivisionScheme\";\nimport { TileKey } from \"./TileKey\";\nimport { TileKeyUtils } from \"./TileKeyUtils\";\nimport { TileTreeTraverse } from \"./TileTreeTraverse\";\n\n/**\n * The `TilingScheme` represents how the data is tiled.\n */\nexport class TilingScheme {\n    readonly boundingBoxGenerator: FlatTileBoundingBoxGenerator;\n    readonly tileTreeTraverse: TileTreeTraverse;\n\n    /**\n     * Constructs a new `TilingScheme` with the given subdivision scheme and projection.\n     *\n     * @param subdivisionScheme The subdivision scheme used by this `TilingScheme`.\n     * @param projection The projection used by this `TilingScheme`.\n     */\n    constructor(readonly subdivisionScheme: SubdivisionScheme, readonly projection: Projection) {\n        this.boundingBoxGenerator = new FlatTileBoundingBoxGenerator(this);\n        this.tileTreeTraverse = new TileTreeTraverse(subdivisionScheme);\n    }\n\n    /**\n     * Returns the sub tile keys of the given tile.\n     *\n     * @param tileKey The [[TileKey]].\n     * @returns The list of the sub tile keys.\n     */\n    getSubTileKeys(tileKey: TileKey): Iterable<TileKey> {\n        return this.tileTreeTraverse.subTiles(tileKey);\n    }\n\n    /**\n     * Gets the [[TileKey]] from the given geo position and level.\n     *\n     * @param geoPoint The position in geo coordinates.\n     * @param level The level of the resulting `TileKey`.\n     */\n    getTileKey(geoPoint: GeoCoordinatesLike, level: number): TileKey | null {\n        return TileKeyUtils.geoCoordinatesToTileKey(this, geoPoint, level);\n    }\n\n    /**\n     * Gets the list of [[TileKey]]s contained in the given [[GeoBox]].\n     *\n     * @param geoBox The bounding box in geo coordinates.\n     * @param level The level of the resulting `TileKey`.\n     */\n    getTileKeys(geoBox: GeoBox, level: number): TileKey[] {\n        return TileKeyUtils.geoRectangleToTileKeys(this, geoBox, level);\n    }\n\n    /**\n     * Returns the bounding box in geo coordinates for the given [[TileKey]].\n     *\n     * @param tileKey The `TileKey`.\n     */\n    getGeoBox(tileKey: TileKey): GeoBox {\n        return this.boundingBoxGenerator.getGeoBox(tileKey);\n    }\n\n    /**\n     * Returns the bounding box in world coordinates.\n     *\n     * @param tileKey The `TileKey`.\n     * @param result The optional object that will contain the resulting bounding box.\n     */\n    getWorldBox(tileKey: TileKey, result?: Box3Like): Box3Like {\n        return this.boundingBoxGenerator.getWorldBox(tileKey, result);\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Namespace containing useful information when dealing with Unicode's code points.\n */\nexport namespace UnicodeUtils {\n    /**\n     * Range of Unicode code points considered as white space.\n     * https://en.wikipedia.org/wiki/Whitespace_character\n     */\n    export const whiteSpaceRanges = [\n        [0x0009, 0x0009],\n        [0x0020, 0x0020],\n        [0x1680, 0x1680],\n        [0x2000, 0x2006],\n        [0x2008, 0x200a],\n        [0x205f, 0x3000],\n        [0x180e, 0x180e],\n        [0x200b, 0x200d]\n    ];\n\n    /**\n     * Checks if a character should be considered as a white space.\n     *\n     * @param codePoint Character's Unicode code point.\n     *\n     * @returns Result of the test.\n     */\n    export function isWhiteSpace(codePoint: number) {\n        for (const range of whiteSpaceRanges) {\n            if (codePoint >= range[0] && codePoint <= range[1]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Range of Unicode code points considered as `NewLine`.\n     * https://en.wikipedia.org/wiki/Newline#Unicode\n     */\n    export const newLineRanges = [\n        [0x000a, 0x000d],\n        [0x0085, 0x0085],\n        [0x2028, 0x2029]\n    ];\n\n    /**\n     * Checks if a character should be considered as a new line.\n     *\n     * @param codePoint Character's Unicode code point.\n     *\n     * @returns Result of the test.\n     */\n    export function isNewLine(codePoint: number) {\n        for (const range of newLineRanges) {\n            if (codePoint >= range[0] && codePoint <= range[1]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Range of Unicode code points considered as non-printable.\n     * https://en.wikipedia.org/wiki/Unicode_control_characters\n     */\n    export const nonPrintableRanges = [\n        [0x0000, 0x001f],\n        [0x007f, 0x009f]\n    ];\n\n    /**\n     * Checks if a character's can be printed (rendered).\n     *\n     * @param codePoint Character's Unicode code point.\n     *\n     * @returns Result of the test.\n     */\n    export function isPrintable(codePoint: number) {\n        for (const range of nonPrintableRanges) {\n            if (codePoint >= range[0] && codePoint <= range[1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Unicode code point direction.\n     */\n    export enum Direction {\n        Neutral = 0.0,\n        Weak = 0.5,\n        LTR = 1.0,\n        RTL = -1.0\n    }\n\n    // TODO: Review/Remove/Add any additional needed blocks (HARP-3330).\n    /**\n     * Unicode Blocks which have inherent RTL direction.\n     * These blocks correspond to the scripts described here:\n     * https://en.wikipedia.org/wiki/Right-to-left#List_of_RTL_scripts\n     */\n    export const rtlBlocks: string[] = [\n        \"Hebrew\",\n        \"Alphabetic Presentation Forms\",\n        \"Arabic\",\n        \"Arabic Supplement\",\n        \"Arabic Extended-A\",\n        \"Arabic Presentation Forms-A\",\n        \"Arabic Presentation Forms-B\",\n        \"Arabic Mathematical Alphabetic Symbols\",\n        \"Indic Siyaq Numbers\",\n        \"Rumi Numeral Symbols\",\n        \"Syriac\",\n        \"Syriac Supplement\",\n        \"Samaritan\",\n        \"Mandaic\",\n        \"Thaana\",\n        \"Mende Kikakui\",\n        \"NKo\",\n        \"Adlam\",\n        \"Hanifi Rohingya\"\n    ];\n\n    /**\n     * ASCII punctuation is considered to have neutral direction:\n     * https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)#Table_of_characters\n     */\n    export const neutralBidirectionalRanges = [\n        [0x0020, 0x002f],\n        [0x003a, 0x0040],\n        [0x005b, 0x0060],\n        [0x007b, 0x007e]\n    ];\n\n    /**\n     * Latin and arabic numerals are considered to have weak directionality:\n     * https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)#Table_of_characters\n     * https://en.wikipedia.org/wiki/Arabic_(Unicode_block)#Block\n     */\n    export const weakBidirectionalRanges = [\n        [0x0030, 0x0039],\n        [0x0660, 0x0669],\n        [0x06f0, 0x06f9]\n    ];\n\n    /**\n     * Returns the Unicode's character direction.\n     *\n     * @param codePoint Character's Unicode code point.\n     * @param block Character's Unicode block.\n     *\n     * @returns Character's direction.\n     */\n    export function getDirection(codePoint: number, block: string): Direction {\n        // Test for neutral and weak code points first (they're inside LTR/RTL ranges).\n        for (const weakRange of weakBidirectionalRanges) {\n            if (codePoint >= weakRange[0] && codePoint <= weakRange[1]) {\n                return Direction.Weak;\n            }\n        }\n        for (const neutralRange of neutralBidirectionalRanges) {\n            if (codePoint >= neutralRange[0] && codePoint <= neutralRange[1]) {\n                return Direction.Neutral;\n            }\n        }\n\n        // Check for RTL/LTR.\n        const rtl = rtlBlocks.find(element => {\n            return element === block;\n        });\n        if (rtl !== undefined) {\n            return Direction.RTL;\n        } else {\n            return Direction.LTR;\n        }\n    }\n\n    /**\n     * Some punctuation characters (like: (, ), <, >, [,], {, }) need to be mirrored when rendering\n     * a RTL string to preserve their intrinsic meaning.\n     * https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)#Table_of_characters\n     */\n    export const rtlMirroredCodePoints = [\n        0x0028,\n        0x0029,\n        0x003c,\n        0x003e,\n        0x005b,\n        0x005d,\n        0x007b,\n        0x007d\n    ];\n\n    /**\n     * Checks if a character should be mirrored on an RTL run.\n     *\n     * @param codePoint Character's Unicode code point.\n     *\n     * @returns Result of the test.\n     */\n    export function isRtlMirrored(codePoint: number): boolean {\n        return (\n            rtlMirroredCodePoints.find(element => {\n                return element === codePoint;\n            }) !== undefined\n        );\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    BufferAttribute,\n    ColorUtils,\n    Expr,\n    getPropertyValue,\n    InterpolatedProperty,\n    isExtrudedLineTechnique,\n    isExtrudedPolygonTechnique,\n    isInterpolatedProperty,\n    isShaderTechnique,\n    isStandardTechnique,\n    isTerrainTechnique,\n    isTextureBuffer,\n    parseStringEncodedColor,\n    ShaderTechnique,\n    Technique,\n    techniqueDescriptors,\n    TEXTURE_PROPERTY_KEYS,\n    TextureProperties,\n    TRANSPARENCY_PROPERTY_KEYS,\n    Value\n} from \"@here/harp-datasource-protocol\";\nimport {\n    CirclePointsMaterial,\n    disableBlending,\n    enableBlending,\n    // HighPrecisionLineMaterial,\n    MapMeshBasicMaterial,\n    MapMeshStandardMaterial,\n    SolidLineMaterial\n} from \"@here/harp-materials\";\nimport { LoggerManager } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\nimport { Circles, Squares } from \"./MapViewPoints\";\nimport { toPixelFormat, toTextureDataType, toTextureFilter, toWrappingMode } from \"./ThemeHelpers\";\n\nconst logger = LoggerManager.instance.create(\"DecodedTileHelpers\");\n\nconst DEFAULT_SKIP_PROPERTIES = [\n    ...TEXTURE_PROPERTY_KEYS,\n    \"mapProperties\",\n    \"normalMapProperties\",\n    \"displacementMapProperties\",\n    \"roughnessMapProperties\",\n    \"emissiveMapProperties\",\n    \"alphaMapProperties\",\n    \"metalnessMapProperties\",\n    \"bumpMapProperties\"\n];\n\n/**\n * The structure of the options to pass into [[createMaterial]].\n */\nexport interface MaterialOptions {\n    /**\n     * The shader [[Technique]] to choose.\n     */\n    technique: Technique;\n\n    /**\n     * The active zoom level at material creation for zoom-dependent properties.\n     */\n    level: number;\n\n    /**\n     * Properties to skip.\n     *\n     * @see [[applyTechniqueToMaterial]]\n     */\n    skipExtraProps?: string[];\n\n    /**\n     * `RawShaderMaterial` instances need to know about the fog at instantiation in order to avoid\n     * recompiling them manually later (ThreeJS does not update fog for `RawShaderMaterial`s).\n     */\n    fog?: boolean;\n}\n\n/**\n * Create a material, depending on the rendering technique provided in the options.\n *\n * @param options The material options the subsequent functions need.\n * @param materialUpdateCallback Optional callback when the material gets updated,\n *                               e.g. after texture loading.\n *\n * @returns new material instance that matches `technique.name`\n */\nexport function createMaterial(\n    options: MaterialOptions,\n    textureReadyCallback?: (texture: THREE.Texture) => void\n): THREE.Material | undefined {\n    const technique = options.technique;\n    const Constructor = getMaterialConstructor(technique);\n\n    const settings: { [key: string]: any } = {};\n\n    if (Constructor === undefined) {\n        return undefined;\n    }\n\n    if (\n        Constructor.prototype instanceof THREE.RawShaderMaterial // &&\n        //Constructor !== HighPrecisionLineMaterial\n    ) {\n        settings.fog = options.fog;\n    }\n\n    const material = new Constructor(settings);\n\n    if (technique.id !== undefined) {\n        material.name = technique.id;\n    }\n\n    if (isExtrudedPolygonTechnique(technique)) {\n        material.flatShading = true;\n        // We do not support mixing vertex colors (static) and material colors (may be dynamic)\n        // mixture. Vertex colors are stored in VBO and are not modifiable - some solution for\n        // this problem is proposed in the HARP-8289 and PR #1164.\n        // TODO: Remove when problem with substitute (vertex & material) colors will be solved.\n        if (technique.vertexColors === true) {\n            delete technique.color;\n        }\n    }\n\n    material.depthTest = isExtrudedPolygonTechnique(technique) && technique.depthTest !== false;\n\n    if (\n        isStandardTechnique(technique) ||\n        isTerrainTechnique(technique) ||\n        isExtrudedPolygonTechnique(technique)\n    ) {\n        TEXTURE_PROPERTY_KEYS.forEach((texturePropertyName: string) => {\n            const textureProperty = (technique as any)[texturePropertyName];\n            if (textureProperty === undefined) {\n                return;\n            }\n\n            const onLoad = (texture: THREE.Texture) => {\n                const properties = (technique as any)[\n                    texturePropertyName + \"Properties\"\n                ] as TextureProperties;\n                if (properties !== undefined) {\n                    if (properties.wrapS !== undefined) {\n                        texture.wrapS = toWrappingMode(properties.wrapS);\n                    }\n                    if (properties.wrapT !== undefined) {\n                        texture.wrapT = toWrappingMode(properties.wrapT);\n                    }\n                    if (properties.magFilter !== undefined) {\n                        texture.magFilter = toTextureFilter(properties.magFilter);\n                    }\n                    if (properties.minFilter !== undefined) {\n                        texture.minFilter = toTextureFilter(properties.minFilter);\n                    }\n                    if (properties.flipY !== undefined) {\n                        texture.flipY = properties.flipY;\n                    }\n                    if (properties.repeatU !== undefined) {\n                        texture.repeat.x = properties.repeatU;\n                    }\n                    if (properties.repeatV !== undefined) {\n                        texture.repeat.y = properties.repeatV;\n                    }\n                }\n                (material as any)[texturePropertyName] = texture;\n                texture.needsUpdate = true;\n                material.needsUpdate = true;\n\n                if (textureReadyCallback) {\n                    textureReadyCallback(texture);\n                }\n            };\n\n            const onError = (error: ErrorEvent | string) => {\n                logger.error(\"#createMaterial: Failed to load texture: \", error);\n            };\n\n            let textureUrl: string | undefined;\n            if (typeof textureProperty === \"string\") {\n                textureUrl = textureProperty;\n            } else if (isTextureBuffer(textureProperty)) {\n                if (textureProperty.type === \"image/raw\") {\n                    const properties = textureProperty.dataTextureProperties;\n                    if (properties !== undefined) {\n                        const textureDataType: THREE.TextureDataType | undefined = properties.type\n                            ? toTextureDataType(properties.type)\n                            : undefined;\n                        const textureBuffer = getTextureBuffer(\n                            textureProperty.buffer,\n                            textureDataType\n                        );\n\n                        const texture = new THREE.DataTexture(\n                            textureBuffer,\n                            properties.width,\n                            properties.height,\n                            properties.format ? toPixelFormat(properties.format) : undefined,\n                            textureDataType\n                        );\n                        onLoad(texture);\n                    } else {\n                        onError(\"no data texture properties provided.\");\n                    }\n                } else {\n                    const textureBlob = new Blob([textureProperty.buffer], {\n                        type: textureProperty.type\n                    });\n                    textureUrl = URL.createObjectURL(textureBlob);\n                }\n            }\n\n            if (textureUrl) {\n                new THREE.TextureLoader().load(\n                    textureUrl,\n                    onLoad,\n                    undefined, // onProgress\n                    onError\n                );\n            }\n        });\n    }\n\n    if (isShaderTechnique(technique)) {\n        // Special case for ShaderTechnique.\n        applyShaderTechniqueToMaterial(technique, material);\n    } else {\n        // Generic technique.\n        applyTechniqueToMaterial(technique, material, options.level, options.skipExtraProps);\n    }\n\n    return material;\n}\n\n/**\n * Returns a [[THREE.BufferAttribute]] created from a provided [[BufferAttribute]] object.\n *\n * @param attribute BufferAttribute a WebGL compliant buffer\n */\nexport function getBufferAttribute(attribute: BufferAttribute): THREE.BufferAttribute {\n    switch (attribute.type) {\n        case \"float\":\n            return new THREE.BufferAttribute(\n                new Float32Array(attribute.buffer),\n                attribute.itemCount\n            );\n        case \"uint8\":\n            return new THREE.BufferAttribute(\n                new Uint8Array(attribute.buffer),\n                attribute.itemCount,\n                attribute.normalized\n            );\n        case \"uint16\":\n            return new THREE.BufferAttribute(\n                new Uint16Array(attribute.buffer),\n                attribute.itemCount,\n                attribute.normalized\n            );\n        case \"uint32\":\n            return new THREE.BufferAttribute(\n                new Uint32Array(attribute.buffer),\n                attribute.itemCount,\n                attribute.normalized\n            );\n        case \"int8\":\n            return new THREE.BufferAttribute(\n                new Int8Array(attribute.buffer),\n                attribute.itemCount,\n                attribute.normalized\n            );\n        case \"int16\":\n            return new THREE.BufferAttribute(\n                new Int16Array(attribute.buffer),\n                attribute.itemCount,\n                attribute.normalized\n            );\n        case \"int32\":\n            return new THREE.BufferAttribute(\n                new Int32Array(attribute.buffer),\n                attribute.itemCount,\n                attribute.normalized\n            );\n        default:\n            throw new Error(`unsupported buffer of type ${attribute.type}`);\n    } // switch\n}\n\n/**\n * The default `three.js` object used with a specific technique.\n */\nexport type ObjectConstructor = new (\n    geometry?: THREE.Geometry | THREE.BufferGeometry,\n    material?: THREE.Material\n) => THREE.Object3D;\n/**\n * Gets the default `three.js` object constructor associated with the given technique.\n *\n * @param technique The technique.\n */\nexport function getObjectConstructor(technique: Technique): ObjectConstructor | undefined {\n    if (technique.name === undefined) {\n        return undefined;\n    }\n    switch (technique.name) {\n        case \"extruded-line\":\n        case \"standard\":\n        case \"terrain\":\n        case \"extruded-polygon\":\n        case \"fill\":\n        case \"dashed-line\":\n        case \"solid-line\":\n            return THREE.Mesh as ObjectConstructor;\n\n        case \"circles\":\n            return Circles as ObjectConstructor;\n        case \"squares\":\n            return Squares as ObjectConstructor;\n\n        case \"line\":\n            return THREE.LineSegments as ObjectConstructor;\n\n        case \"segments\":\n            return THREE.LineSegments as ObjectConstructor;\n\n        case \"shader\": {\n            if (!isShaderTechnique(technique)) {\n                throw new Error(\"Invalid technique\");\n            }\n            switch (technique.primitive) {\n                case \"line\":\n                    return THREE.Line as ObjectConstructor;\n                case \"segments\":\n                    return THREE.LineSegments as ObjectConstructor;\n                case \"point\":\n                    return THREE.Points as ObjectConstructor;\n                case \"mesh\":\n                    return THREE.Mesh as ObjectConstructor;\n                default:\n                    return undefined;\n            }\n        }\n\n        case \"text\":\n        case \"labeled-icon\":\n        case \"line-marker\":\n        case \"label-rejection-line\":\n            return undefined;\n    }\n}\n\n/**\n * Non material properties of [[BaseTechnique]]\n */\nexport const BASE_TECHNIQUE_NON_MATERIAL_PROPS = [\"name\", \"id\", \"renderOrder\", \"transient\"];\n\n/**\n * Generic material type constructor.\n */\nexport type MaterialConstructor = new (params?: {}) => THREE.Material;\n\n/**\n * Returns a [[MaterialConstructor]] basing on provided technique object.\n *\n * @param technique [[Technique]] object which the material will be based on.\n */\nexport function getMaterialConstructor(technique: Technique): MaterialConstructor | undefined {\n    if (technique.name === undefined) {\n        return undefined;\n    }\n\n    switch (technique.name) {\n        case \"extruded-line\":\n            if (!isExtrudedLineTechnique(technique)) {\n                throw new Error(\"Invalid extruded-line technique\");\n            }\n            return technique.shading === \"standard\"\n                ? MapMeshStandardMaterial\n                : MapMeshBasicMaterial;\n\n        case \"standard\":\n        case \"terrain\":\n        case \"extruded-polygon\":\n            return MapMeshStandardMaterial;\n\n        case \"dashed-line\":\n        case \"solid-line\":\n            return SolidLineMaterial;\n\n        case \"fill\":\n            return MapMeshBasicMaterial;\n\n        case \"squares\":\n            return THREE.PointsMaterial;\n\n        case \"circles\":\n            return CirclePointsMaterial;\n\n        case \"line\":\n        case \"segments\":\n            return THREE.LineBasicMaterial;\n\n        case \"shader\":\n            return THREE.ShaderMaterial;\n\n        case \"text\":\n        case \"labeled-icon\":\n        case \"line-marker\":\n        case \"label-rejection-line\":\n            return undefined;\n    }\n}\n\n/**\n * Allows to easy parse/encode technique's base color property value as number coded color.\n *\n * Function takes care about property parsing, interpolation and encoding if neccessary. If\n * you wish to get default value without interpolation simply ignore @param zoom when calling.\n *\n * @see ColorUtils\n * @param technique the technique where we search for base (transparency) color value\n * @param zoomLevel zoom level used for value interpolation.\n * @returns [[number]] encoded color value (in custom #TTRRGGBB) format or [[undefined]] if\n * base color property is not defined in the technique passed.\n */\nexport function evaluateBaseColorProperty(\n    technique: Technique,\n    zoomLevel?: number\n): number | undefined {\n    const baseColorProp = getBaseColorProp(technique);\n    if (baseColorProp !== undefined) {\n        return evaluateColorProperty(baseColorProp, zoomLevel);\n    }\n    return undefined;\n}\n\n/**\n * Apply [[ShaderTechnique]] parameters to material.\n *\n * @param technique the [[ShaderTechnique]] which requires special handling\n * @param material material to which technique will be applied\n */\nfunction applyShaderTechniqueToMaterial(technique: ShaderTechnique, material: THREE.Material) {\n    // The shader technique takes the argument from its `params' member.\n    const params = technique.params as { [key: string]: any };\n    // Remove base color and transparency properties from the processed set.\n    const baseColorPropName = getBaseColorPropName(technique);\n    const hasBaseColor = baseColorPropName && baseColorPropName in technique.params;\n    const props = Object.getOwnPropertyNames(params).filter(propertyName => {\n        // Omit base color and related transparency attributes if its defined in technique\n        if (\n            baseColorPropName === propertyName ||\n            (hasBaseColor && TRANSPARENCY_PROPERTY_KEYS.indexOf(propertyName) !== -1)\n        ) {\n            return false;\n        }\n        const prop = propertyName as keyof typeof params;\n        if (prop === \"name\") {\n            // skip reserved property names\n            return false;\n        }\n        return true;\n    });\n\n    // Apply all technique properties omitting base color and transparency attributes.\n    props.forEach(propertyName => {\n        // TODO: Check if properties values should not be interpolated, possible bug in old code!\n        // This behavior is kept in the new version too, level is set to undefined.\n        applyTechniquePropertyToMaterial(material, propertyName, params[propertyName]);\n    });\n\n    if (hasBaseColor) {\n        const propColor = baseColorPropName as keyof THREE.Material;\n        // Finally apply base color and related properties to material (opacity, transparent)\n        applyBaseColorToMaterial(material, material[propColor], technique, params[propColor]);\n    }\n}\n\n/**\n * Apply generic technique parameters to material.\n *\n * Skips non-material [[Technique]] props:\n *  * [[BaseTechnique]] props,\n *  * `name` which is used as discriminator for technique types,\n *  * props starting with `_`\n *  * props found `skipExtraProps`\n *\n * `THREE.Color` properties are supported.\n *\n * @param technique technique from where params are copied\n * @param material target material\n * @param zoomLevel tile zoom level for zoom-level dependent props\n * @param skipExtraProps optional, skipped props.\n */\nfunction applyTechniqueToMaterial(\n    technique: Technique,\n    material: THREE.Material,\n    zoomLevel: number,\n    skipExtraProps?: string[]\n) {\n    // Remove transparent color from the firstly processed properties set.\n    const baseColorPropName = getBaseColorPropName(technique);\n    const hasBaseColor = baseColorPropName && baseColorPropName in technique;\n    const genericProps = Object.getOwnPropertyNames(technique).filter(propertyName => {\n        if (\n            propertyName.startsWith(\"_\") ||\n            BASE_TECHNIQUE_NON_MATERIAL_PROPS.indexOf(propertyName) !== -1 ||\n            DEFAULT_SKIP_PROPERTIES.indexOf(propertyName) !== -1 ||\n            (skipExtraProps !== undefined && skipExtraProps.indexOf(propertyName) !== -1)\n        ) {\n            return false;\n        }\n        // Omit base color and related transparency attributes if its defined in technique.\n        if (\n            baseColorPropName === propertyName ||\n            (hasBaseColor && TRANSPARENCY_PROPERTY_KEYS.indexOf(propertyName) !== -1)\n        ) {\n            return false;\n        }\n        const prop = propertyName as keyof typeof technique;\n        const m = material as any;\n        if (typeof m[prop] === \"undefined\") {\n            return false;\n        }\n        return true;\n    });\n\n    // Apply all other properties (even colors), but not transparent (base) ones.\n    genericProps.forEach(propertyName => {\n        const value = technique[propertyName as keyof Technique];\n        if (value !== undefined) {\n            applyTechniquePropertyToMaterial(material, propertyName, value, zoomLevel);\n        }\n    });\n\n    // Finally apply base (possibly transparent) color itself, using blend modes to\n    // provide transparency if needed.\n    if (hasBaseColor) {\n        applyBaseColorToMaterial(\n            material,\n            material[baseColorPropName as keyof THREE.Material],\n            technique,\n            technique[baseColorPropName as keyof Technique] as Value,\n            zoomLevel\n        );\n    }\n}\n\n/**\n * Apply single and generic technique property to corresponding material parameter.\n *\n * @note Special handling for material attributes of [[THREE.Color]] type is provided thus it\n * does not provide constructor that would take [[string]] or [[number]] values.\n *\n * @param material target material\n * @param propertyName material and technique parameter name (or index) that is to be transferred\n * @param techniqueAttrValue technique property value which will be applied to material attribute\n * @param zoomLevel optional tile zoom level.\n */\nfunction applyTechniquePropertyToMaterial(\n    material: THREE.Material,\n    propertyName: string,\n    techniqueAttrValue: Value,\n    zoomLevel?: number\n) {\n    const m = material as any;\n    if (m[propertyName] instanceof THREE.Color) {\n        applySecondaryColorToMaterial(\n            material[propertyName as keyof THREE.Material],\n            techniqueAttrValue,\n            zoomLevel\n        );\n    } else {\n        m[propertyName] = evaluateProperty(techniqueAttrValue, zoomLevel);\n    }\n}\n\n/**\n * Apply technique color to material taking special care with transparent (RGBA) colors.\n *\n * @note This function is intended to be used with secondary, triary etc. technique colors,\n * not the base ones that may contain transparency information. Such colors should be processed\n * with [[applyTechniqueBaseColorToMaterial]] function.\n *\n * @param technique an technique the applied color comes from\n * @param material the material to which color is applied\n * @param prop technique property (color) name\n * @param value color value\n * @param zoomLevel optional tile zoom level for zoom-level dependent properties are evaluated.\n */\nexport function applySecondaryColorToMaterial(\n    materialColor: THREE.Color,\n    techniqueColor: Value | Expr | InterpolatedProperty,\n    zoomLevel?: number\n) {\n    let value = evaluateColorProperty(techniqueColor, zoomLevel);\n\n    if (ColorUtils.hasAlphaInHex(value)) {\n        logger.warn(\"Used RGBA value for technique color without transparency support!\");\n        // Just for clarity remove transparency component, even if that would be ignored\n        // by THREE.Color.setHex() function.\n        value = ColorUtils.removeAlphaFromHex(value);\n    }\n\n    materialColor.setHex(value);\n}\n\n/**\n * Apply technique base color (transparency support) to material with modifying material opacity.\n *\n * This method applies main (or base) technique color with transparency support to the corresponding\n * material color, with an effect on entire [[THREE.Material]] __opacity__ and __transparent__\n * attributes.\n *\n * @note Transparent colors should be processed as the very last technique attributes,\n * since their effect on material properties like [[THREE.Material.opacity]] and\n * [[THREE.Material.transparent]] could be overridden by corresponding technique params.\n *\n * @param technique an technique the applied color comes from\n * @param material the material to which color is applied\n * @param prop technique property (color) name\n * @param value color value in custom number format\n * @param zoomLevel optional, tile zoom level for zoom-level dependent properties are evaluated.\n */\nexport function applyBaseColorToMaterial(\n    material: THREE.Material,\n    materialColor: THREE.Color,\n    technique: Technique,\n    techniqueColor: Value,\n    zoomLevel?: number\n) {\n    const colorValue = evaluateColorProperty(techniqueColor, zoomLevel);\n\n    const { r, g, b, a } = ColorUtils.getRgbaFromHex(colorValue);\n    // Override material opacity and blending by mixing technique defined opacity\n    // with main color transparency\n    const tech = technique as any;\n    let opacity = a;\n    if (tech.opacity !== undefined) {\n        opacity *= evaluateProperty(tech.opacity, zoomLevel);\n    }\n\n    opacity = THREE.Math.clamp(opacity, 0, 1);\n    material.opacity = opacity;\n    materialColor.setRGB(r, g, b);\n\n    const opaque = opacity >= 1.0;\n    if (!opaque) {\n        enableBlending(material);\n    } else {\n        disableBlending(material);\n    }\n}\n\n/**\n * Calculates the value of the technique defined property.\n *\n * Function takes care about property interpolation (when @param zoom is set) as also parsing\n * string encoded numbers.\n *\n * @note Use with care, because function does not recognize property type.\n * @param value the value of color property defined in technique\n * @param zoomLevel zoom level used for interpolation.\n */\nfunction evaluateProperty(value: any, zoomLevel?: number): any {\n    if (zoomLevel !== undefined && (isInterpolatedProperty(value) || Expr.isExpr(value))) {\n        value = getPropertyValue(value, zoomLevel);\n    }\n    return value;\n}\n\n/**\n * Calculates the numerical value of the technique defined color property.\n *\n * Function takes care about color interpolation (when @param zoom is set) as also parsing\n * string encoded colors.\n *\n * @note Use with care, because function does not recognize property type.\n * @param value the value of color property defined in technique\n * @param zoomLevel zoom level used for interpolation.\n */\nexport function evaluateColorProperty(value: Value, zoomLevel?: number): number {\n    value = evaluateProperty(value, zoomLevel);\n\n    if (typeof value === \"number\") {\n        return value;\n    }\n\n    if (typeof value === \"string\") {\n        const parsed = parseStringEncodedColor(value);\n        if (parsed !== undefined) {\n            return parsed;\n        }\n    }\n\n    throw new Error(`Unsupported color format: '${value}'`);\n}\n\n/**\n * Allows to access base color property value for given technique.\n *\n * The color value may be encoded in [[number]], [[string]] or even as\n * [[InterpolateProperty]].\n *\n * @param technique The techniqe where we seach for base color property.\n * @returns The value of technique color used to apply transparency.\n */\nfunction getBaseColorProp(technique: Technique): any {\n    const baseColorPropName = getBaseColorPropName(technique);\n    if (baseColorPropName !== undefined) {\n        if (!isShaderTechnique(technique)) {\n            const propColor = baseColorPropName as keyof typeof technique;\n            return technique[propColor];\n        } else {\n            const params = technique.params as { [key: string]: any };\n            const propColor = baseColorPropName as keyof typeof params;\n            return params[propColor];\n        }\n    }\n    return undefined;\n}\n\nfunction getBaseColorPropName(technique: Technique): string | undefined {\n    const techDescriptor = techniqueDescriptors[technique.name];\n    return techDescriptor !== undefined ? techDescriptor.attrTransparencyColor : undefined;\n}\n\nfunction getTextureBuffer(\n    buffer: ArrayBuffer,\n    textureDataType: THREE.TextureDataType | undefined\n): THREE.TypedArray {\n    if (textureDataType === undefined) {\n        return new Uint8Array(buffer);\n    }\n\n    switch (textureDataType) {\n        case THREE.UnsignedByteType:\n            return new Uint8Array(buffer);\n        case THREE.ByteType:\n            return new Int8Array(buffer);\n        case THREE.ShortType:\n            return new Int16Array(buffer);\n        case THREE.UnsignedShortType:\n            return new Uint16Array(buffer);\n        case THREE.IntType:\n            return new Int32Array(buffer);\n        case THREE.UnsignedIntType:\n            return new Uint32Array(buffer);\n        case THREE.FloatType:\n            return new Float32Array(buffer);\n        case THREE.HalfFloatType:\n            return new Uint16Array(buffer);\n    }\n\n    throw new Error(\"Unsupported texture data type\");\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    GeometryKind,\n    GeometryKindSet,\n    ImageTexture,\n    LineMarkerTechnique,\n    PoiStackMode,\n    PoiTechnique\n} from \"@here/harp-datasource-protocol\";\nimport {\n    GlyphData,\n    TextBufferObject,\n    TextLayoutParameters,\n    TextLayoutStyle,\n    TextRenderParameters,\n    TextRenderStyle\n} from \"@here/harp-text-canvas\";\nimport { Math2D, MathUtils } from \"@here/harp-utils\";\n\nimport * as THREE from \"three\";\n\nimport { ImageItem } from \"../image/Image\";\nimport { PickResult } from \"../PickHandler\";\nimport { TextElementType } from \"./TextElementType\";\n\n/**\n * Additional information for an icon that is to be rendered along with a [[TextElement]].\n */\nexport interface PoiInfo {\n    /**\n     * Technique defining the POI or LineMarker\n     */\n    technique: PoiTechnique | LineMarkerTechnique;\n\n    /**\n     * Name of the [[ImageTexture]].\n     */\n    imageTextureName: string;\n\n    /**\n     * Name of the POI table [[PoiTable]].\n     */\n    poiTableName?: string;\n\n    /**\n     * Name of the POI description in the [[PoiTable]].\n     */\n    poiName?: string;\n\n    /**\n     * Specify stack mode. Defaults to `ShowInStack`.\n     */\n    stackMode?: PoiStackMode;\n\n    /**\n     * Minimum zoomLevel at which to display the label icon. No default.\n     */\n    iconMinZoomLevel?: number;\n\n    /**\n     * Maximum zoomLevel at which to display the label icon. No default.\n     */\n    iconMaxZoomLevel?: number;\n\n    /**\n     * Minimum zoomLevel at which to display the label text. No default.\n     */\n    textMinZoomLevel?: number;\n\n    /**\n     * Maximum zoomLevel at which to display the label text. No default.\n     */\n    textMaxZoomLevel?: number;\n\n    /**\n     * If true, the text icon will appear even if the text part is blocked by other labels. Defaults\n     * to `false`.\n     */\n    textIsOptional?: boolean;\n\n    /**\n     * If true, the text will appear even if the icon cannot be rendered because of missing icon\n     * graphics. Defaults to `true`.\n     */\n    iconIsOptional?: boolean;\n\n    /**\n     * If `true`, icon is allowed to overlap other labels or icons of lower priority.\n     */\n    mayOverlap?: boolean;\n\n    /**\n     * If `true`, icon will reserve screen space, other markers of lower priority will not be\n     * able to overlap.\n     */\n    reserveSpace?: boolean;\n\n    /**\n     * If isValid is `false`, the icon will no longer be placed or rendered. The reason may be a\n     * missing resource.\n     */\n    isValid?: boolean;\n\n    /**\n     * ID to identify the (POI) icon.\n     */\n    featureId?: number;\n\n    /**\n     * Reference back to owning [[TextElement]].\n     */\n    textElement: TextElement;\n\n    /**\n     * @hidden\n     * If false, text will not be rendered during camera movements. Defaults to `true`;\n     */\n    renderTextDuringMovements?: boolean;\n\n    /**\n     * @hidden\n     * Direct access to [[ImageItem]] once it is resolved.\n     */\n    imageItem?: ImageItem;\n\n    /**\n     * @hidden\n     * Direct access to [[ImageTexture]] once it is resolved.\n     */\n    imageTexture?: ImageTexture;\n\n    /**\n     * @hidden\n     * Layout help: A shield group is for all [[LineMarker]]s that have the same icon and text,\n     * making them the same road shield icon.\n     */\n    shieldGroupIndex?: number;\n\n    /**\n     * @hidden\n     * Internal reference to a render batch, made up of all icons that use the same Material.\n     */\n    poiRenderBatch?: number;\n\n    /**\n     * @hidden\n     * Should be computed during loading/initializing of `ImageTexture`.\n     */\n    computedWidth?: number;\n\n    /**\n     * @hidden\n     * Should be computed during loading/initializing of `ImageTexture`.\n     */\n    computedHeight?: number;\n\n    /**\n     * @hidden\n     * Should be computed during loading/initializing of `ImageTexture`.\n     */\n    uvBox?: Math2D.UvBox;\n\n    /**\n     * @hidden\n     * Computed from owning [[TextElement]]. Value is set when `PoiInfo` is assigned to\n     * [[TextElement]].\n     */\n    renderOrder?: number;\n}\n\n/**\n * Return 'true' if the POI has been successfully prepared for rendering.\n *\n * @param poiInfo PoiInfo containing information for rendering the POI icon.\n */\nexport function poiIsRenderable(poiInfo: PoiInfo): boolean {\n    return poiInfo.poiRenderBatch !== undefined;\n}\n\nexport interface TextPickResult extends PickResult {\n    /**\n     * Text of the picked [[TextElement]]\n     */\n    text?: string;\n}\n\n/**\n * State of loading.\n */\nexport enum LoadingState {\n    Requested,\n    Loaded,\n    Initialized\n}\n\n/**\n * `TextElement` is used to create 2D text elements (for example, labels).\n */\nexport class TextElement {\n    /**\n     * Determines visibility. If set to `false`, it will not be rendered.\n     */\n    visible: boolean = true;\n\n    /**\n     * Determines minimum zoom level for visibility. Can be used to reduce the number of visible\n     * `TextElement`s based on zoom level.\n     */\n    minZoomLevel?: number;\n    /**\n     * Determines maximum zoom level for visibility. Can be used to reduce the number of visible\n     * `TextElement`s based on zoom level.\n     */\n    maxZoomLevel?: number;\n\n    /**\n     * If `true`, label is allowed to overlap other labels or icons of lower priority.\n     * @default `false`\n     */\n    mayOverlap?: boolean;\n\n    /**\n     * If `true`, label will reserve screen space, other markers of lower priority will not be\n     * able to overlap.\n     * @default `true`\n     */\n    reserveSpace?: boolean;\n\n    /**\n     * If `true`, the label will always be rendered on top. If overlapping with other labels, the\n     * render order is undefined;\n     * @default `false`\n     */\n    alwaysOnTop?: boolean;\n\n    /**\n     * Ignore distance limit. Used for label in labeled-icons.\n     */\n    ignoreDistance?: boolean;\n\n    /**\n     * Scaling factor of text. Defaults to 0.5, reducing the size ot 50% in the distance.\n     */\n    distanceScale: number = 0.5;\n\n    /**\n     * Optional user data. Will be retrieved during picking.\n     */\n    userData?: any;\n\n    /**\n     * If specified, determines the render order between `TextElement`s. The number different\n     * renderOrders should be as small as possible, because every specific `renderOrder` may result\n     * in one or more draw calls.\n     *\n     * TextElements with the same integer `renderOrder` will be rendered in the same batch.\n     *\n     * The `renderOrder` of `TextElement`s are only relative to other `TextElement`s, and not other\n     * map elements.\n     *\n     * A `TextElement` with a higher `renderOrder` will be rendered after a `TextElement` with a\n     * lower `renderOrder`.\n     */\n    renderOrder?: number = 0;\n\n    /**\n     * Specified kind of geometry. One kind is set as default in the technique, and can be\n     * overridden in the style.\n     */\n    kind?: GeometryKind | GeometryKindSet;\n\n    /**\n     * @hidden\n     * Used during rendering.\n     */\n    loadingState?: LoadingState;\n\n    /**\n     * @hidden\n     * Array storing the style [[GlyphData]] for this `TextElement` to speed up label placement in\n     * [[TextElementsRenderer]]. Valid after `loadingState` is `Initialized`.\n     */\n    glyphs?: GlyphData[];\n\n    /**\n     * @hidden\n     * Array storing the casing (`true`: uppercase, `false`: lowercase) for this `TextElement`.\n     * Used by labels in [[TextElementsRenderer]] to support `SmallCaps`. Valid after `loadingState`\n     * is `Initialized`.\n     */\n    glyphCaseArray?: boolean[];\n\n    /**\n     * Screen space bounds for this `TextElement`. Used by point labels in [[TextElementsRenderer]].\n     * Valid after `loadingState` is `Initialized`.\n     */\n    bounds?: THREE.Box2;\n\n    /**\n     * @hidden\n     * Pre-computed text vertex buffer. Used by point labels in [[TextElementsRenderer]]. Valid\n     * after label becomes visible for the first time.\n     */\n    textBufferObject?: TextBufferObject;\n\n    /**\n     * @hidden\n     * If `true`, the estimated bounding box of the path is too small for the label to fit, so it is\n     * being ignored for rendering in the latest frame.\n     */\n    dbgPathTooSmall?: boolean;\n\n    type: TextElementType;\n\n    private m_poiInfo?: PoiInfo;\n\n    private m_renderStyle?: TextRenderStyle;\n\n    private m_layoutStyle?: TextLayoutStyle;\n\n    /**\n     * Creates a new `TextElement`.\n     *\n     * @param text The text to display.\n     * @param points The position or a list of points for a curved text, both in local tile space.\n     * @param renderParams `TextElement` text rendering parameters.\n     * @param layoutParams `TextElement` text layout parameters.\n     * @param priority The priority of the `TextElement. Elements with the highest priority get\n     *              placed first, elements with priority of `0` are placed last, elements with a\n     *              negative value are always rendered, ignoring priorities and allowing\n     *              overrides.\n     * @param xOffset Optional X offset of this `TextElement` in screen coordinates.\n     * @param yOffset Optional Y offset of this `TextElement` in screen coordinates.\n     * @param featureId Optional number to identify feature (originated from `OmvDataSource`).\n     * @param fadeNear Distance to the camera (0.0 = camera position, 1.0 = farPlane) at which the\n     *              label starts fading out (opacity decreases).\n     * @param fadeFar Distance to the camera (0.0 = camera position, 1.0 = farPlane) at which the\n     *              label becomes transparent. A value of <= 0.0 disables fading.\n     */\n    constructor(\n        readonly text: string,\n        readonly points: THREE.Vector3[] | THREE.Vector3,\n        readonly renderParams: TextRenderParameters | TextRenderStyle,\n        readonly layoutParams: TextLayoutParameters | TextLayoutStyle,\n        public priority = 0,\n        public xOffset: number = 0,\n        public yOffset: number = 0,\n        public featureId?: number,\n        public style?: string,\n        public fadeNear?: number,\n        public fadeFar?: number,\n        readonly tileOffset?: number\n    ) {\n        if (renderParams instanceof TextRenderStyle) {\n            this.renderStyle = renderParams;\n        }\n        if (layoutParams instanceof TextLayoutStyle) {\n            this.layoutStyle = layoutParams;\n        }\n\n        this.type =\n            points instanceof THREE.Vector3 ? TextElementType.PoiLabel : TextElementType.PathLabel;\n    }\n\n    /**\n     * The text element position or the first point of the path used to render a curved text, both\n     * in local tile space.\n     */\n    get position(): THREE.Vector3 {\n        if (this.points instanceof Array) {\n            const p = this.points[0];\n            return p;\n        }\n        return this.points as THREE.Vector3;\n    }\n\n    /**\n     * The list of points in local tile space used to render the text along a path or `undefined`.\n     */\n    get path(): THREE.Vector3[] | undefined {\n        if (this.points instanceof Array) {\n            return this.points;\n        }\n        return undefined;\n    }\n\n    /**\n     * If `true`, `TextElement` is allowed to overlap other labels or icons of lower priority.\n     *\n     * @default `false`\n     */\n    get textMayOverlap(): boolean {\n        return this.mayOverlap === true;\n    }\n\n    set textMayOverlap(mayOverlap: boolean) {\n        this.mayOverlap = mayOverlap;\n    }\n\n    /**\n     * If `true`, `TextElement` will reserve screen space, other markers of lower priority will not\n     * be able to overlap.\n     *\n     * @default `true`\n     */\n    get textReservesSpace(): boolean {\n        return this.reserveSpace !== false;\n    }\n\n    set textReservesSpace(reserveSpace: boolean) {\n        this.reserveSpace = reserveSpace;\n    }\n\n    /**\n     * Contains additional information about icon to be rendered along with text.\n     */\n    get poiInfo(): PoiInfo | undefined {\n        return this.m_poiInfo;\n    }\n\n    set poiInfo(poiInfo: PoiInfo | undefined) {\n        this.m_poiInfo = poiInfo;\n        if (poiInfo !== undefined) {\n            if (this.path !== undefined) {\n                this.type = TextElementType.LineMarker;\n            }\n            const poiRenderOrder = this.renderOrder !== undefined ? this.renderOrder : 0;\n            poiInfo.renderOrder = poiRenderOrder;\n        }\n    }\n\n    /**\n     * @returns The style used to render this text element, undefined if not set yet.\n     */\n    get renderStyle(): TextRenderStyle | undefined {\n        return this.m_renderStyle;\n    }\n\n    /**\n     * Sets style used for text rendering.\n     * @param style The style to use.\n     */\n    set renderStyle(style: TextRenderStyle | undefined) {\n        this.m_renderStyle = style;\n    }\n\n    /**\n     * @returns The style used to layout this text element, undefined if not set yet.\n     */\n    get layoutStyle(): TextLayoutStyle | undefined {\n        return this.m_layoutStyle;\n    }\n\n    /**\n     * Sets the style used for text layout.\n     * @param style The style to use.\n     */\n    set layoutStyle(style: TextLayoutStyle | undefined) {\n        this.m_layoutStyle = style;\n    }\n\n    hasFeatureId(): boolean {\n        return this.featureId !== undefined && this.featureId !== 0;\n    }\n\n    /**\n     * Update the minZoomLevel and maxZoomLevel from the values set in [[PoiInfo]].\n     * Selects the smaller/larger one of the two min/max values for icon and text, because the\n     * TextElement is a container for both.\n     */\n    updateMinMaxZoomLevelsFromPoiInfo() {\n        if (this.poiInfo !== undefined) {\n            if (this.minZoomLevel === undefined) {\n                this.minZoomLevel = MathUtils.min2(\n                    this.poiInfo.iconMinZoomLevel,\n                    this.poiInfo.textMinZoomLevel\n                );\n            }\n            if (this.maxZoomLevel === undefined) {\n                this.maxZoomLevel = MathUtils.max2(\n                    this.poiInfo.iconMaxZoomLevel,\n                    this.poiInfo.textMaxZoomLevel\n                );\n            }\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { LoggerManager, PerformanceTimer } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nconst logger = LoggerManager.instance.create(\"Statistics\");\n\n/**\n * A simple ring buffer to store the last `n` values of the timer. The buffer works on\n * a First-In-First-Out (FIFO) basis.\n */\nexport class RingBuffer<T> {\n    buffer: T[];\n    size: number;\n    head: number;\n    tail: number;\n\n    /**\n     * Sets up the ring buffer.\n     *\n     * @param capacity The buffer's capacity.\n     */\n    constructor(readonly capacity: number) {\n        this.buffer = new Array(capacity);\n        this.capacity = capacity;\n        this.head = this.tail = this.size = 0;\n    }\n\n    /**\n     * Clears the contents, removes all elements.\n     */\n    clear(): void {\n        this.head = this.tail = this.size = 0;\n    }\n\n    /**\n     * Adds a single element to the ring buffer.\n     *\n     * @param data Data element.\n     */\n    enqOne(data: T): void {\n        let next = this.head + 1;\n        if (next >= this.capacity) {\n            next = 0;\n        }\n        if (this.size < this.capacity) {\n            this.size++;\n        }\n\n        this.buffer[this.head] = data;\n        this.head = next;\n\n        if (this.size === this.capacity) {\n            this.tail = this.head;\n        }\n    }\n\n    /**\n     * Adds one or more elements.\n     *\n     * @param data The elements to add.\n     */\n    enq(...data: T[]): void {\n        for (const v of data) {\n            this.enqOne(v);\n        }\n    }\n\n    /**\n     * Obtains the oldest element (FIFO). May throw an exception if a buffer underrun occurs.\n     * Before calling this method, make sure that `size > 0`.\n     */\n    deq(): T {\n        if (this.size === 0) {\n            throw new Error(\"Ringbuffer underrun\");\n        }\n\n        const data = this.buffer[this.tail];\n        let next = this.tail + 1;\n        if (next >= this.capacity) {\n            next = 0;\n        }\n        if (this.size > 0) {\n            this.size--;\n        }\n\n        this.tail = next;\n        return data;\n    }\n\n    /**\n     * Obtains the oldest element (FIFO) without removing it. Throws an exception if a buffer is\n     * empty. Before calling this method, make sure that `size > 0`.\n     */\n    get top(): T {\n        if (this.size === 0) {\n            throw new Error(\"Ringbuffer underrun\");\n        }\n\n        return this.buffer[this.tail];\n    }\n\n    /**\n     * Obtains the latest element (LIFO) without removing it. Throws an exception if a buffer is\n     * empty. Before calling this method, make sure that `size > 0`.\n     */\n    get bottom(): T {\n        if (this.size === 0) {\n            throw new Error(\"Ringbuffer underrun\");\n        }\n\n        let previous = this.head - 1;\n        if (previous < 0) {\n            previous = this.capacity - 1;\n        }\n        return this.buffer[previous];\n    }\n\n    /**\n     * Creates an iterator for the buffer.\n     */\n    iterator(): RingBuffer.Iterator<T> {\n        return new RingBuffer.Iterator<T>(this);\n    }\n\n    /**\n     * Returns a copy of the buffer, where the elements are properly sorted from oldest to newest.\n     */\n    asArray(): T[] {\n        const array = new Array<T>();\n        for (let i = 0; i < this.size; i++) {\n            array.push(this.buffer[(this.tail + i) % this.capacity]);\n        }\n        return array;\n    }\n}\n\nexport namespace RingBuffer {\n    /**\n     * A local class for RingBuffer<T>\n     */\n    export class Iterator<T> {\n        /**\n         * Creates an iterator for the ring buffer.\n         *\n         * @param m_buffer `Ringbuffer` to iterate over.\n         * @param m_index Start index.\n         */\n        constructor(private m_buffer: RingBuffer<T>, private m_index: number = 0) {}\n\n        /**\n         * Gets the iterator's current value. This function does not fail even if an overrun occurs.\n         * To detect an overrun, watch the result for [[next]].\n         */\n        get value(): T {\n            return this.m_buffer.buffer[\n                (this.m_buffer.tail + this.m_index) % this.m_buffer.capacity\n            ];\n        }\n\n        /**\n         * Advances the iterator to the next element.\n         *\n         * @returns `true` if the iterator is still valid; `false` if an overrun occurs.\n         */\n        next(): boolean {\n            this.m_index++;\n            return this.m_index < this.m_buffer.size;\n        }\n    }\n}\n\n/**\n * An interface for a Timer class, that abstracts the basic functions of a Timer. Implemented\n * by SimpleTimer, SampledTimer, and MultiStageTimer.\n */\nexport interface Timer {\n    readonly name: string;\n    readonly value?: number;\n\n    /**\n     * Resets value to be able to start again.\n     */\n    reset(): void;\n\n    /**\n     * Starts the timer. Returns the current time, based on `Performance.now()`.\n     */\n    start(): number;\n\n    /**\n     * Stops the timer. Requires that the timer has started.\n     */\n    stop(): number;\n\n    /**\n     * Samples the timer. Requires that the timer has started. This function does not modify\n     * the timer's internal state.\n     *\n     * @returns Current timer value. `-1` if statistics are disabled.\n     */\n    now(): number;\n\n    /**\n     * Sets the measurement value for the amount of time that has elapsed from start() to stop().\n     * Use this function to override the timer's duration.\n     *\n     * @param val The timer's duration.\n     */\n    setValue(val: number | undefined): void;\n}\n\n/**\n * A simple timer that stores only the latest measurement.\n */\nexport class SimpleTimer implements Timer {\n    /** `true` if timer has been started. */\n    running = false;\n\n    private m_currentValue?: number;\n\n    constructor(public statistics: Statistics, readonly name: string) {}\n\n    /**\n     * Gets the latest measurement. This function may return `undefined` if no measurement\n     * was done.\n     */\n    get value(): number | undefined {\n        return this.m_currentValue;\n    }\n\n    /**\n     * Sets the measurement value for the amount of time that has elapsed from start() to stop().\n     * Use this function to override the timer's duration.\n     *\n     * @param val The timer's duration.\n     */\n    setValue(val: number | undefined) {\n        this.m_currentValue = val;\n    }\n\n    /**\n     * Resets the value to be able to start again.\n     */\n    reset() {\n        this.m_currentValue = undefined;\n    }\n\n    /**\n     * Starts the timer. Returns the current time, based on `Performance.now()`.\n     */\n    start(): number {\n        if (!this.statistics.enabled) {\n            return -1;\n        }\n        if (this.running) {\n            throw new Error(\"Timer '\" + this.name + \"' is already running\");\n        }\n        this.running = true;\n        return (this.m_currentValue = PerformanceTimer.now());\n    }\n\n    /**\n     * Stops the timer. Requires that the timer has started.\n     */\n    stop(): number {\n        if (!this.statistics.enabled) {\n            return -1;\n        }\n        if (!this.running) {\n            throw new Error(\"Timer '\" + this.name + \"' has not been started\");\n        } else {\n            // this.currentValue is a number now!\n            const t = PerformanceTimer.now() - (this.m_currentValue || 0);\n            this.m_currentValue = t;\n            this.setValue(t);\n            this.running = false;\n            return t;\n        }\n    }\n\n    /**\n     * Samples the timer. Requires that the timer has started.\n     *\n     * @returns the current timer value; `-1` if statistics are disabled.\n     */\n    now(): number {\n        if (!this.statistics.enabled) {\n            return -1;\n        }\n        if (!this.running) {\n            throw new Error(\"Timer '\" + this.name + \"' has not been started\");\n        } else {\n            const t = PerformanceTimer.now() - (this.m_currentValue || 0);\n            return t;\n        }\n    }\n}\n\n/**\n * Simple statistics about the values in an array.\n */\nexport interface Stats {\n    /**\n     * The lowest value in the array.\n     */\n    min: number;\n\n    /**\n     * The highest value in the array.\n     */\n    max: number;\n\n    /**\n     * The average duration of all values in the array.\n     */\n    avg: number;\n\n    /**\n     * The median duration of all values in the array.\n     */\n    median: number;\n\n    /**\n     * The 75th percentile median of all values in the array.\n     */\n    median75: number;\n\n    /**\n     * The 90th percentile median of all values in the array.\n     */\n    median90: number;\n\n    /**\n     * The 95th percentile median of all values in the array.\n     */\n    median95: number;\n\n    /**\n     * The 97th percentile median of all values in the array.\n     */\n    median97: number;\n\n    /**\n     * The 99th percentile median of all values in the array.\n     */\n    median99: number;\n\n    /**\n     * The 99.9th percentile median of all values in the array.\n     */\n    median999: number;\n\n    /**\n     * The number of values in the array.\n     */\n    numSamples: number;\n}\n\n/**\n * A timer that stores the last `n` samples in a ring buffer.\n */\nexport class SampledTimer extends SimpleTimer {\n    /**\n     * The number of times the timer has reset.\n     */\n    numResets = 0;\n\n    /**\n     * Maximum samples until the statistics are reset and updated, which may destroy a median\n     * computation.\n     */\n    maxNumSamples = 1000;\n\n    /**\n     * The array of sampled values, its length cannot exceed `maxNumSamples`.\n     */\n    samples = new RingBuffer<number>(this.maxNumSamples);\n\n    /**\n     * Creates a `SampledTimer` instance. Must still be added to statistics if it should be logged!\n     *\n     * @param statistics Statistics to use for management.\n     * @param name Name of the timer. Use colons to build a hierarchy.\n     */\n    constructor(public statistics: Statistics, readonly name: string) {\n        super(statistics, name);\n    }\n\n    /**\n     * Resets the timer and clears all of its historical values.\n     */\n    reset() {\n        super.reset();\n        this.getStats();\n        this.samples.clear();\n        this.numResets++;\n    }\n\n    /**\n     * Add a single measurement to the sample.\n     *\n     * @param val A measurement to add.\n     */\n    setValue(val: number | undefined) {\n        super.setValue(val);\n\n        if (val !== undefined) {\n            this.samples.enqOne(val);\n        }\n    }\n\n    /**\n     * Updates the `min`, `max`, `avg`, and `median` values. Currently, this function is expensive,\n     * as it requires a copy of the sampled values.\n     */\n    getStats(): Stats | undefined {\n        return computeArrayStats(this.samples.asArray());\n    }\n}\n\n/**\n * Only exported for testing\n * @ignore\n *\n * Compute the [[ArrayStats]] for the passed in array of numbers.\n *\n * @param {number[]} samples Array containing sampled values. Will be modified (!) by sorting the\n *      entries.\n * @returns {(Stats | undefined)}\n */\nexport function computeArrayStats(samples: number[]): Stats | undefined {\n    if (samples.length === 0) {\n        return undefined;\n    }\n\n    samples.sort((a: number, b: number) => {\n        return a - b;\n    });\n\n    const min: number = samples[0];\n    const max: number = samples[samples.length - 1];\n    let median: number;\n    let median75: number;\n    let median90: number;\n    let median95: number;\n    let median97: number;\n    let median99: number;\n    let median999: number;\n\n    if (samples.length === 1) {\n        median75 = median90 = median95 = median97 = median99 = median999 = median = samples[0];\n    } else if (samples.length === 2) {\n        median = samples[0] * 0.5 + samples[1] * 0.5;\n        median75 = median90 = median95 = median97 = median99 = median999 = samples[1];\n    } else {\n        const mid = Math.floor(samples.length / 2);\n        median =\n            samples.length % 2 === 0 ? samples[mid - 1] * 0.5 + samples[mid] * 0.5 : samples[mid];\n\n        const mid75 = Math.round(samples.length * 0.75) - 1;\n        median75 = samples[mid75];\n        const mid90 = Math.round(samples.length * 0.9) - 1;\n        median90 = samples[mid90];\n        const mid95 = Math.round(samples.length * 0.95) - 1;\n        median95 = samples[mid95];\n        const mid97 = Math.round(samples.length * 0.97) - 1;\n        median97 = samples[mid97];\n        const mid99 = Math.round(samples.length * 0.99) - 1;\n        median99 = samples[mid99];\n        const mid999 = Math.round(samples.length * 0.999) - 1;\n        median999 = samples[mid999];\n    }\n\n    let sum = 0;\n\n    for (let i = 0, l = samples.length; i < l; i++) {\n        sum += samples[i];\n    }\n\n    const avg = sum / samples.length;\n\n    return {\n        min,\n        max,\n        avg,\n        median,\n        median75,\n        median90,\n        median95,\n        median97,\n        median99,\n        median999,\n        numSamples: samples.length\n    };\n}\n\n/**\n * Only exported for testing\n * @ignore\n *\n * Compute the averages for the passed in array of numbers.\n *\n * @param {number[]} samples Array containing sampled values.\n * @returns {(Stats | undefined)}\n */\nexport function computeArrayAverage(samples: number[]): number | undefined {\n    if (samples.length === 0) {\n        return undefined;\n    }\n\n    let sum = 0;\n\n    for (let i = 0, l = samples.length; i < l; i++) {\n        sum += samples[i];\n    }\n\n    const avg = sum / samples.length;\n\n    return avg;\n}\n\n/**\n * Measures a sequence of connected events, such as multiple processing stages in a function.\n * Each stage is identified with a timer name, that must be a valid timer in the statistics\n * object. Additionally, all timers within a `MultiStageTimer` must be unique.\n *\n * Internally, the `MultiStageTimer` manages a list of timers where at the end of each stage,\n * one timer stops and the next timer starts.\n */\nexport class MultiStageTimer {\n    private currentStage: string | undefined;\n\n    /**\n     * Defines the `MultiStageTimer` with a list of timer names that represent its stages.\n     *\n     * @param statistics The statistics object that manages the timers.\n     * @param name Name of this `MultiStageTimer`.\n     * @param stages List of timer names.\n     */\n    constructor(private statistics: Statistics, readonly name: string, public stages: string[]) {\n        if (stages.length < 1) {\n            throw new Error(\"MultiStageTimer needs stages\");\n        }\n\n        stages.forEach(stage => {\n            if (!statistics.hasTimer(stage)) {\n                throw new Error(\"Unknown timer: \" + stage);\n            }\n        });\n    }\n\n    /**\n     * Gets the timer value for the last stage. If the `MultiStageTimer` did not finish its\n     * last stage, the value is `undefined`.\n     */\n    get value(): number | undefined {\n        return this.statistics.getTimer(this.stages[this.stages.length - 1]).value;\n    }\n\n    /**\n     * Resets the timers across all stages.\n     */\n    reset(): void {\n        if (!this.statistics.enabled) {\n            return;\n        }\n        this.stages.forEach(stage => {\n            this.statistics.getTimer(stage).reset();\n        });\n    }\n\n    /**\n     * Starts the `MultiStageTimer` at its first stage.\n     */\n    start(): number {\n        this.stage = this.stages[0];\n\n        return this.statistics.getTimer(this.stages[0]).value || -1;\n    }\n\n    /**\n     * Stops the `MultiStageTimer`. Returns the measurement of the last stage, which may be\n     * `undefined` if not all stages started.\n     */\n    stop(): number {\n        this.stage = undefined;\n        return this.value !== undefined ? this.value : -1;\n    }\n\n    /**\n     * Gets the current stage.\n     */\n    get stage(): string | undefined {\n        return this.currentStage;\n    }\n\n    /**\n     * Sets the current stage. If a new stage is provided, the current timer (if available) is\n     * stopped, and the next timer is started. If the timer in the next stage is `undefined`,\n     * this is equivalent to calling `stop` on the `MultiStageTimer`.\n     *\n     * @param stage The next stage to start.\n     */\n    set stage(stage: string | undefined) {\n        if (this.currentStage === stage) {\n            return;\n        }\n\n        if (this.statistics.enabled && this.currentStage !== undefined) {\n            this.statistics.getTimer(this.currentStage).stop();\n        }\n\n        this.currentStage = stage;\n\n        if (this.statistics.enabled && this.currentStage !== undefined) {\n            this.statistics.getTimer(this.currentStage).start();\n        }\n    }\n}\n\n/**\n * Manages a set of timers. The main objective of `Statistics` is to log these timers. You can\n * disable statistics to minimize their impact on performance.\n */\nexport class Statistics {\n    private timers: Map<string, Timer>;\n\n    private nullTimer: Timer;\n\n    /**\n     * Sets up a group of timers.\n     *\n     * @param name The statistics name, for logging purposes.\n     * @param enabled If `false`, the timers do not measure the performance.\n     */\n    constructor(public name?: string, public enabled = false) {\n        this.timers = new Map<string, Timer>();\n        this.nullTimer = new SimpleTimer(this, \"<null>\");\n    }\n\n    /**\n     * Adds a timer, based on the name specified.\n     *\n     * @param name The timer's name; must be unique.\n     */\n    createTimer(name: string, keepSamples = true): Timer {\n        const timer = keepSamples ? new SampledTimer(this, name) : new SimpleTimer(this, name);\n\n        return this.addTimer(timer);\n    }\n\n    /**\n     * Adds the timer specified.\n     *\n     * @param timer The timer's name, which must be unique within this statistics object.\n     */\n    addTimer(timer: Timer): Timer {\n        if (this.timers.get(timer.name) !== undefined) {\n            throw new Error(\"Duplicate timer name: '\" + timer.name + \"'\");\n        }\n\n        this.timers.set(timer.name, timer);\n\n        return timer;\n    }\n\n    /**\n     * Gets a timer by name.\n     *\n     * @param name The timer's name.\n     */\n    getTimer(name: string): Timer {\n        if (!this.enabled) {\n            return this.nullTimer;\n        }\n\n        const t = this.timers.get(name);\n        return t === undefined ? this.nullTimer : t;\n    }\n\n    /**\n     * Checks if a timer with the specified name already exists.\n     *\n     * @param name The timer's name.\n     * @returns `true` if a timer with `name` already exists; `false` otherwise.\n     */\n    hasTimer(name: string): boolean {\n        const t = this.timers.get(name);\n        return t !== undefined;\n    }\n\n    /**\n     * Resets all timers.\n     */\n    reset() {\n        this.timers.forEach((timer: Timer) => {\n            timer.reset();\n        });\n    }\n\n    /**\n     * Prints all values to the console.\n     *\n     * @param header Optional header line.\n     * @param footer Optional footer line.\n     */\n    log(header?: string, footer?: string) {\n        if (header !== undefined || this.name !== undefined) {\n            logger.log(header !== undefined ? header : this.name);\n        }\n\n        let maxNameLength = 0;\n\n        this.timers.forEach((timer: Timer) => {\n            maxNameLength = Math.max(maxNameLength, timer.name.length);\n        });\n\n        // simple printing function for number limits the number of decimal points.\n        const print = (v: number | undefined) => {\n            return v !== undefined ? v.toFixed(5) : \"?\";\n        };\n\n        this.timers.forEach((timer: Timer) => {\n            let s = timer.name + \": \" + \" \".repeat(maxNameLength - timer.name.length);\n            s += print(timer.value);\n\n            // sampled timers also update their stats and log them\n            if (timer instanceof SampledTimer) {\n                const simpleStats = timer.getStats();\n                if (simpleStats !== undefined) {\n                    s +=\n                        `  [ min=${print(simpleStats.min)}, max=${print(simpleStats.max)}, ` +\n                        `avg=${print(simpleStats.avg)}, med=${print(simpleStats.median)}, ` +\n                        `med95=${print(simpleStats.median95)}, med99=${print(\n                            simpleStats.median99\n                        )}, ` +\n                        `N=${print(simpleStats.numSamples)} ]`;\n                }\n            }\n            logger.log(s);\n        });\n\n        if (footer !== undefined) {\n            logger.log(footer);\n        }\n    }\n}\n\n/**\n * Class containing all counters, timers and events of the current frame.\n */\nexport class FrameStats {\n    readonly entries: Map<string, number> = new Map();\n    messages?: string[] = undefined;\n\n    /**\n     * Retrieve the value of the performance number.\n     *\n     * @param name Name of the performance number.\n     * @returns The value of the performance number or `undefined` if it has not been declared by\n     *      `setValue` before.\n     */\n    getValue(name: string): number | undefined {\n        return this.entries.get(name);\n    }\n\n    /**\n     * Set the value of the performance number.\n     *\n     * @param name Name of the performance number.\n     * @param name New value of the performance number.\n     */\n    setValue(name: string, value: number) {\n        this.entries.set(name, value);\n    }\n\n    /**\n     * Add a value to the current value of the performance number. If the performance is not known,\n     * it will be initialized with `value`.\n     *\n     * @param name Name of the performance number.\n     * @param name Value to be added to the performance number.\n     */\n    addValue(name: string, value: number) {\n        const oldValue = this.entries.get(name);\n        this.entries.set(name, value + (oldValue === undefined ? 0 : oldValue));\n    }\n\n    /**\n     * Add a text message to the frame, like \"Font XYZ has been loaded\"\n     *\n     * @param message The message to add.\n     */\n    addMessage(message: string) {\n        if (this.messages === undefined) {\n            this.messages = [];\n        }\n        this.messages.push(message);\n    }\n\n    /**\n     * Reset all known performance values to `0` and the messages to `undefined`.\n     */\n    reset() {\n        this.entries.forEach((value: number, name: string) => {\n            this.entries.set(name, 0);\n        });\n\n        this.messages = undefined;\n    }\n}\n\n/**\n * @ignore\n * Only exported for testing.\n *\n * Instead of passing around an array of objects, we store the frame statistics as an object of\n * arrays. This allows convenient computations from [[RingBuffer]],\n */\nexport class FrameStatsArray {\n    readonly frameEntries: Map<string, RingBuffer<number>> = new Map();\n    readonly messages: RingBuffer<string[] | undefined>;\n\n    constructor(readonly capacity: number = 0) {\n        this.messages = new RingBuffer<string[] | undefined>(capacity);\n    }\n\n    get length(): number {\n        return this.messages.size;\n    }\n\n    reset() {\n        this.frameEntries.forEach((buffer: RingBuffer<number>, name: string) => {\n            buffer.clear();\n        });\n        this.messages.clear();\n    }\n\n    addFrame(frameStats: FrameStats) {\n        const currentSize = this.length;\n        const frameEntries = this.frameEntries;\n\n        frameStats.entries.forEach((value: number, name: string) => {\n            let buffer = frameEntries.get(name);\n\n            if (buffer === undefined) {\n                // If there is a buffer that has not been known before, add it to the known buffers,\n                // fill it up with with 0 to the size of all the other buffers to make them of equal\n                // size to make PerfViz happy.\n                buffer = new RingBuffer<number>(this.capacity);\n                for (let i = 0; i < currentSize; i++) {\n                    buffer.enqOne(0);\n                }\n                this.frameEntries.set(name, buffer);\n            }\n            buffer.enqOne(value);\n        });\n\n        this.messages.enq(frameStats.messages);\n    }\n\n    /**\n     * Prints all values to the console.\n     */\n    log() {\n        let maxNameLength = 0;\n        this.frameEntries.forEach((buffer: RingBuffer<number>, name: string) => {\n            maxNameLength = Math.max(maxNameLength, name.length);\n        });\n\n        // simple printing function for number limits the number of decimal points.\n        const print = (v: number | undefined) => {\n            return v !== undefined ? v.toFixed(5) : \"?\";\n        };\n\n        this.frameEntries.forEach((buffer: RingBuffer<number>, name: string) => {\n            let s = name + \": \" + \" \".repeat(maxNameLength - name.length);\n\n            const simpleStats = computeArrayStats(buffer.asArray());\n            if (simpleStats !== undefined) {\n                s +=\n                    `  [ min=${print(simpleStats.min)}, max=${print(simpleStats.max)}, ` +\n                    `avg=${print(simpleStats.avg)}, med=${print(simpleStats.median)}, ` +\n                    `med95=${print(simpleStats.median95)}, med99=${print(simpleStats.median99)}, ` +\n                    `N=${print(simpleStats.numSamples)} ]`;\n            }\n            logger.log(s);\n        });\n    }\n}\n\n/**\n * Chrome's MemoryInfo interface.\n */\ninterface ChromeMemoryInfo {\n    totalJSHeapSize: number;\n    usedJSHeapSize: number;\n    jsHeapSizeLimit: number;\n}\n\nexport interface SimpleFrameStatistics {\n    configs: Map<string, string>;\n    appResults: Map<string, number>;\n    frames: Map<string, number | number[]>;\n    messages: Array<string[] | undefined>;\n    frameStats?: Map<string, Stats | undefined>;\n    zoomLevelLabels?: string[];\n    zoomLevelData?: Map<string, number | number[]>;\n}\n\n/**\n * Performance measurement central. Maintains the current [[FrameStats]], which holds all individual\n * performance numbers.\n *\n * Implemented as an instance for easy access.\n */\nexport class PerformanceStatistics {\n    /**\n     * Returns `true` when the maximum number of storable frames is reached.\n     *\n     * @readonly\n     * @type {boolean}\n     * @memberof PerformanceStatistics\n     */\n    get isFull(): boolean {\n        return this.m_frameEvents.length >= this.maxNumFrames;\n    }\n    /**\n     * Global instance to the instance. The current instance can be overridden by creating a new\n     * `PerformanceStatistics`.\n     */\n    static get instance(): PerformanceStatistics {\n        if (PerformanceStatistics.m_instance === undefined) {\n            PerformanceStatistics.m_instance = new PerformanceStatistics(false, 0);\n        }\n        return PerformanceStatistics.m_instance;\n    }\n\n    private static m_instance?: PerformanceStatistics = undefined;\n\n    /**\n     * Current frame statistics. Contains all values for the current frame. Will be cleared when\n     * [[PerformanceStatistics#storeFrameInfo]] is called.\n     *\n     * @type {FrameStats}\n     * @memberof PerformanceStatistics\n     */\n    readonly currentFrame: FrameStats = new FrameStats();\n\n    /**\n     * @ignore\n     * Only exported for testing.\n     *\n     * Return the array of frame events.\n     */\n    get frameEvents(): FrameStatsArray {\n        return this.m_frameEvents;\n    }\n\n    /**\n     * Additional results stored for the current application run, not per frame. Only the last value\n     * is stored.\n     *\n     * @type {(Map<string, number>)}\n     */\n    readonly appResults: Map<string, number> = new Map();\n\n    /**\n     * Additional configuration values stored for the current application run, not per frame. Only\n     * the last value is stored.\n     *\n     * @type {(Map<string, string>)}\n     * @memberof PerformanceStatistics\n     */\n    readonly configs: Map<string, string> = new Map();\n\n    // Current array of frame events.\n    private m_frameEvents: FrameStatsArray;\n\n    /**\n     * Creates an instance of PerformanceStatistics. Overrides the current `instance`.\n     *\n     * @param {boolean} [enabled=true] If `false` the performance values will not be stored.\n     * @param {number} [maxNumFrames=1000] The maximum number of frames that are to be stored.\n     * @memberof PerformanceStatistics\n     */\n    constructor(public enabled = true, public maxNumFrames = 1000) {\n        PerformanceStatistics.m_instance = this;\n        this.m_frameEvents = new FrameStatsArray(maxNumFrames);\n    }\n\n    /**\n     * Clears all settings, all stored frame events as well as the current frame values.\n     *\n     * @memberof PerformanceStatistics\n     */\n    clear() {\n        this.clearFrames();\n        this.configs.clear();\n        this.appResults.clear();\n    }\n\n    /**\n     * Clears only all stored frame events as well as the current frame values.\n     *\n     * @memberof PerformanceStatistics\n     */\n    clearFrames() {\n        this.m_frameEvents.reset();\n        this.currentFrame.reset();\n    }\n\n    /**\n     * Stores the current frame events into the array of events. Uses [[THREE.WebGLInfo]] to add the\n     * render state information to the current frame.\n     *\n     * @param {THREE.WebGLInfo} webGlInfo\n     * @returns {boolean} Returns `false` if the maximum number of storable frames has been reached.\n     * @memberof PerformanceStatistics\n     */\n    storeFrameInfo(webGlInfo?: THREE.WebGLInfo): boolean {\n        if (this.m_frameEvents.length >= this.maxNumFrames) {\n            return false;\n        }\n\n        if (webGlInfo !== undefined) {\n            if (webGlInfo.render !== undefined) {\n                this.currentFrame.setValue(\n                    \"gl.numCalls\",\n                    webGlInfo.render.calls === null ? 0 : webGlInfo.render.calls\n                );\n                this.currentFrame.setValue(\n                    \"gl.numPoints\",\n                    webGlInfo.render.points === null ? 0 : webGlInfo.render.points\n                );\n                this.currentFrame.setValue(\n                    \"gl.numLines\",\n                    webGlInfo.render.lines === null ? 0 : webGlInfo.render.lines\n                );\n                this.currentFrame.setValue(\n                    \"gl.numTriangles\",\n                    webGlInfo.render.triangles === null ? 0 : webGlInfo.render.triangles\n                );\n            }\n            if (webGlInfo.memory !== undefined) {\n                this.currentFrame.setValue(\n                    \"gl.numGeometries\",\n                    webGlInfo.memory.geometries === null ? 0 : webGlInfo.memory.geometries\n                );\n                this.currentFrame.setValue(\n                    \"gl.numTextures\",\n                    webGlInfo.memory.textures === null ? 0 : webGlInfo.memory.textures\n                );\n            }\n            if (webGlInfo.programs !== undefined) {\n                this.currentFrame.setValue(\n                    \"gl.numPrograms\",\n                    webGlInfo.programs === null ? 0 : webGlInfo.programs.length\n                );\n            }\n        }\n\n        if (window !== undefined && window.performance !== undefined) {\n            const memory = (window.performance as any).memory as ChromeMemoryInfo;\n            if (memory !== undefined) {\n                this.currentFrame.setValue(\"memory.totalJSHeapSize\", memory.totalJSHeapSize);\n                this.currentFrame.setValue(\"memory.usedJSHeapSize\", memory.usedJSHeapSize);\n                this.currentFrame.setValue(\"memory.jsHeapSizeLimit\", memory.jsHeapSizeLimit);\n            }\n        }\n\n        this.m_frameEvents.addFrame(this.currentFrame);\n\n        this.currentFrame.reset();\n        return true;\n    }\n\n    /**\n     * Logs all values to the logger.\n     *\n     * @param header Optional header line.\n     * @param footer Optional footer line.\n     */\n    log(header?: string, footer?: string) {\n        logger.log(header !== undefined ? header : \"PerformanceStatistics\");\n\n        const appResults = this.appResults;\n        appResults.forEach((value: number, name: string) => {\n            logger.log(name, value);\n        });\n        const configs = this.configs;\n        configs.forEach((value: string, name: string) => {\n            logger.log(name, value);\n        });\n        this.m_frameEvents.log();\n\n        if (footer !== undefined) {\n            logger.log(footer);\n        }\n    }\n\n    /**\n     * Convert to a plain object that can be serialized. Required to copy the test results over to\n     * nightwatch.\n     */\n    getAsPlainObject(onlyLastFrame: boolean = false): any {\n        const appResults: any = {};\n        const configs: any = {};\n        const frames: any = {};\n        const plainObject: any = {\n            configs,\n            appResults,\n            frames\n        };\n\n        const appResultValues = this.appResults;\n        appResultValues.forEach((value: number, name: string) => {\n            appResults[name] = value;\n        });\n\n        const configValues = this.configs;\n        configValues.forEach((value: string, name: string) => {\n            configs[name] = value;\n        });\n\n        if (onlyLastFrame) {\n            for (const [name, buffer] of this.m_frameEvents.frameEntries) {\n                frames[name] = buffer.bottom;\n            }\n        } else {\n            for (const [name, buffer] of this.m_frameEvents.frameEntries) {\n                frames[name] = buffer.asArray();\n            }\n        }\n        plainObject.messages = this.m_frameEvents.messages.asArray();\n        return plainObject;\n    }\n\n    /**\n     * Convert the last frame values to a plain object that can be serialized. Required to copy the\n     * test results over to nightwatch.\n     */\n    getLastFrameStatistics(): any {\n        return this.getAsPlainObject(true);\n    }\n\n    /**\n     * Convert to a plain object that can be serialized. Required to copy the test results over to\n     * nightwatch.\n     */\n    getAsSimpleFrameStatistics(onlyLastFrame: boolean = false): SimpleFrameStatistics {\n        const configs: Map<string, string> = new Map();\n        const appResults: Map<string, number> = new Map();\n        const frames: Map<string, number | number[]> = new Map();\n\n        const simpleStatistics: SimpleFrameStatistics = {\n            configs,\n            appResults,\n            frames,\n            messages: this.m_frameEvents.messages.asArray()\n        };\n\n        const appResultValues = this.appResults;\n        appResultValues.forEach((value: number, name: string) => {\n            appResults.set(name, value);\n        });\n\n        const configValues = this.configs;\n        configValues.forEach((value: string, name: string) => {\n            configs.set(name, value);\n        });\n\n        if (onlyLastFrame) {\n            for (const [name, buffer] of this.m_frameEvents.frameEntries) {\n                frames.set(name, buffer.bottom);\n            }\n        } else {\n            for (const [name, buffer] of this.m_frameEvents.frameEntries) {\n                frames.set(name, buffer.asArray());\n            }\n        }\n        return simpleStatistics;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\n/**\n * The interface for the [[Pass]] class.\n */\nexport interface IPass {\n    /**\n     * Whether the [[Pass]] instance is active or not.\n     * @default `true`.\n     */\n    enabled: boolean;\n\n    /**\n     * Whether the render method should target a WebGLRenderTarget instance, or the frame buffer.\n     * @default `false`.\n     */\n    renderToScreen: boolean;\n\n    /**\n     * The resize method to extend in [[Pass]] implementations. It resizes the render targets. Call\n     * on resize events.\n     *\n     * @param width Width to resize to.\n     * @param height Height to resize to.\n     */\n    setSize(width: number, height: number): void;\n\n    /**\n     * The render method to extend in [[Pass]] implementations. This is the place where the desired\n     * effects or render operations are executed.\n     *\n     * @param renderer The WebGLRenderer instance in use.\n     * @param scene The scene to render.\n     * @param camera The camera to render the scene through.\n     * @param writeBuffer The optional WebGLRenderTarget instance to write to.\n     * @param readBuffer The optional WebGLRenderTarget instance of a previous pass to write onto.\n     * @param delta The time argument from the requestAnimationFrame.\n     */\n    render(\n        renderer: THREE.WebGLRenderer,\n        scene: THREE.Scene,\n        camera: THREE.Camera,\n        writeBuffer: THREE.WebGLRenderTarget | null,\n        readBuffer: THREE.WebGLRenderTarget | null,\n        delta?: number\n    ): void;\n}\n\n/**\n * The base class to extend for further passes in [[MapView]], like the [[MSAARenderPass]], possibly\n * a text pass, an AO effect etc. `Pass` provides the core logic for both :\n * - render passes (proper scene renders),\n * - and shader passes (quad renders, i.e. effects added on top of the render output as a\n * postprocess).\n *\n * Even some shader passes still actually fall within the render pass category as they need to\n * re-render the scene to then deduce an effect, such as masking, AO, DoF etc. Others just need the\n * previous input image to apply a shader on top of it, as for bloom or NVIDIA's FXAA for example.\n * These only are proper shader passes.\n */\nexport class Pass implements IPass {\n    enabled: boolean = false;\n    renderToScreen: boolean = false;\n    // tslint:disable-next-line:no-unused-variable\n    setSize(width: number, height: number) {\n        // Implemented in sub-classes.\n    }\n    // tslint:disable:no-unused-variable\n    render(\n        renderer: THREE.WebGLRenderer,\n        scene: THREE.Scene,\n        camera: THREE.Camera,\n        writeBuffer: THREE.WebGLRenderTarget | null,\n        readBuffer: THREE.WebGLRenderTarget | null,\n        delta?: number\n    ) {\n        // Implemented in sub-classes.\n    }\n    // tslint:enable:no-unused-variable\n}\n\n/**\n * The pass that does a default normal scene rendering for further post-effects.\n */\nexport class RenderPass extends Pass {\n    constructor() {\n        super();\n    }\n\n    render(\n        renderer: THREE.WebGLRenderer,\n        scene: THREE.Scene,\n        camera: THREE.Camera,\n        writeBuffer: THREE.WebGLRenderTarget | null,\n        readBuffer: THREE.WebGLRenderTarget | null\n    ) {\n        renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);\n        renderer.render(scene, camera);\n    }\n}\n\n/**\n * The base class to extend for post-effects on the final render (like Vignette, Sepia, color\n * correction...)\n */\nexport class ShaderPass extends Pass {\n    uniforms: { [uniform: string]: THREE.IUniform };\n    material: THREE.Material;\n    fsQuad: FullScreenQuad;\n    constructor(shader: THREE.Shader, private textureID: string = \"tDiffuse\") {\n        super();\n        if (shader instanceof THREE.ShaderMaterial) {\n            this.uniforms = shader.uniforms;\n            this.material = shader;\n        } else {\n            this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);\n            this.material = new THREE.ShaderMaterial({\n                defines: { ...(shader as any).defines },\n                uniforms: this.uniforms,\n                vertexShader: shader.vertexShader,\n                fragmentShader: shader.fragmentShader\n            });\n        }\n        this.fsQuad = new FullScreenQuad(this.material);\n    }\n    render(\n        renderer: THREE.WebGLRenderer,\n        scene: THREE.Scene,\n        camera: THREE.Camera,\n        writeBuffer: THREE.WebGLRenderTarget,\n        readBuffer: THREE.WebGLRenderTarget,\n        delta?: number\n    ) {\n        if (this.uniforms[this.textureID]) {\n            this.uniforms[this.textureID].value = readBuffer.texture;\n        }\n        this.fsQuad.material = this.material;\n        renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);\n        this.fsQuad.render(renderer);\n    }\n}\n\nclass FullScreenQuad {\n    private m_mesh: THREE.Mesh;\n    private m_camera: THREE.Camera;\n    constructor(material: THREE.Material) {\n        this.m_camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n        const geometry = new THREE.PlaneBufferGeometry(2, 2);\n        this.m_mesh = new THREE.Mesh(geometry, material);\n    }\n    get material(): THREE.Material {\n        return this.m_mesh.material as THREE.Material;\n    }\n    set material(value: THREE.Material) {\n        this.m_mesh.material = value;\n    }\n    render(renderer: THREE.WebGLRenderer) {\n        renderer.render((this.m_mesh as any) as THREE.Scene, this.m_camera);\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {\n    GeometryKind,\n    GradientSky,\n    ImageTexture,\n    Light,\n    PostEffects,\n    Sky,\n    Theme\n} from \"@here/harp-datasource-protocol\";\nimport {\n    EarthConstants,\n    GeoCoordinates,\n    GeoCoordLike,\n    mercatorProjection,\n    Projection,\n    ProjectionType,\n    TilingScheme\n} from \"@here/harp-geoutils\";\nimport {\n    assert,\n    getOptionValue,\n    LoggerManager,\n    LogLevel,\n    PerformanceTimer,\n    UriResolver\n} from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { ViewRanges } from \"@here/harp-datasource-protocol/lib/ViewRanges\";\nimport { AnimatedExtrusionHandler } from \"./AnimatedExtrusionHandler\";\nimport { BackgroundDataSource } from \"./BackgroundDataSource\";\nimport { CameraMovementDetector } from \"./CameraMovementDetector\";\nimport { ClipPlanesEvaluator, createDefaultClipPlanesEvaluator } from \"./ClipPlanesEvaluator\";\nimport { IMapAntialiasSettings, IMapRenderingManager, MapRenderingManager } from \"./composing\";\nimport { ConcurrentDecoderFacade } from \"./ConcurrentDecoderFacade\";\nimport { CopyrightInfo } from \"./copyrights/CopyrightInfo\";\nimport { DataSource } from \"./DataSource\";\nimport { ElevationProvider } from \"./ElevationProvider\";\nimport { ElevationRangeSource } from \"./ElevationRangeSource\";\nimport { FrustumIntersection } from \"./FrustumIntersection\";\nimport { overlayOnElevation } from \"./geometry/overlayOnElevation\";\nimport { PhasedTileGeometryManager } from \"./geometry/PhasedTileGeometryManager\";\nimport { SimpleTileGeometryManager, TileGeometryManager } from \"./geometry/TileGeometryManager\";\nimport { MapViewImageCache } from \"./image/MapViewImageCache\";\nimport { MapViewFog } from \"./MapViewFog\";\nimport { PickHandler, PickResult } from \"./PickHandler\";\nimport { PoiManager } from \"./poi/PoiManager\";\nimport { PoiRendererFactory } from \"./poi/PoiRendererFactory\";\nimport { PoiTableManager } from \"./poi/PoiTableManager\";\nimport { PolarTileDataSource } from \"./PolarTileDataSource\";\nimport { ScreenCollisions, ScreenCollisionsDebug } from \"./ScreenCollisions\";\nimport { ScreenProjector } from \"./ScreenProjector\";\nimport { SkyBackground } from \"./SkyBackground\";\nimport { FrameStats, PerformanceStatistics } from \"./Statistics\";\nimport { FontCatalogLoader } from \"./text/FontCatalogLoader\";\nimport { MapViewState } from \"./text/MapViewState\";\nimport { TextCanvasFactory } from \"./text/TextCanvasFactory\";\nimport { TextElement } from \"./text/TextElement\";\nimport { TextElementsRenderer, ViewUpdateCallback } from \"./text/TextElementsRenderer\";\nimport { TextElementsRendererOptions } from \"./text/TextElementsRendererOptions\";\nimport { createLight } from \"./ThemeHelpers\";\nimport { ThemeLoader } from \"./ThemeLoader\";\nimport { Tile } from \"./Tile\";\nimport { MapViewUtils } from \"./Utils\";\nimport { ResourceComputationType, VisibleTileSet, VisibleTileSetOptions } from \"./VisibleTileSet\";\n\ndeclare const process: any;\n\n// Cache value, because access to process.env.NODE_ENV is SLOW!\nconst isProduction = process.env.NODE_ENV === \"production\";\nif (isProduction) {\n    // In production: silence logging below error.\n    LoggerManager.instance.setLogLevelForAll(LogLevel.Error);\n} else {\n    // In dev: silence logging below log (silences \"debug\" and \"trace\" levels).\n    LoggerManager.instance.setLogLevelForAll(LogLevel.Log);\n}\n/**\n * An interface describing [[THREE.Object3D]]s anchored on given [[GeoCoordinates]].\n *\n * Example:\n * ```typescript\n * const mesh: MapObject<THREE.Mesh> = new THREE.Mesh(geometry, material);\n * mesh.geoPosition = new GeoCoordinates(latitude, longitude, altitude);\n * mapView.mapAnchors.add(mesh);\n * ```\n *\n */\nexport type MapAnchor<T extends THREE.Object3D = THREE.Object3D> = T & {\n    /**\n     * The position of this [[MapObject]] in [[GeoCoordinates]].\n     */\n    geoPosition?: GeoCoordinates;\n};\n\nexport enum MapViewEventNames {\n    /** Called before this `MapView` starts to render a new frame. */\n    Update = \"update\",\n    /** Called when the WebGL canvas is resized. */\n    Resize = \"resize\",\n    /** Called when the frame is about to be rendered. */\n    Render = \"render\",\n    /** Called after a frame has been rendered. */\n    AfterRender = \"didrender\",\n    /** Called after the first frame has been rendered. */\n    FirstFrame = \"first-render\",\n    /** Called when the first view has all the necessary tiles loaded and rendered. */\n    FrameComplete = \"frame-complete\",\n    /** Called when the theme has been loaded with the internal [[ThemeLoader]]. */\n    ThemeLoaded = \"theme-loaded\",\n    /** Called when the animation mode has started. */\n    AnimationStarted = \"animation-started\",\n    /** Called when the animation mode has stopped. */\n    AnimationFinished = \"animation-finished\",\n    /** Called when a camera interaction has been detected. */\n    MovementStarted = \"movement-started\",\n    /** Called when a camera interaction has been stopped. */\n    MovementFinished = \"movement-finished\",\n    /** Called when a data source has been connected or failed to connect. */\n    DataSourceConnect = \"datasource-connect\",\n    /** Emitted when copyright info of rendered map has been changed. */\n    CopyrightChanged = \"copyright-changed\",\n    /** Called when the WebGL context is lost. */\n    ContextLost = \"webglcontext-lost\",\n    /** Called when the WebGL context is restored. */\n    ContextRestored = \"webglcontext-restored\",\n    /** Called when camera position has been changed. */\n    CameraPositionChanged = \"camera-changed\"\n}\n\nconst logger = LoggerManager.instance.create(\"MapView\");\nconst DEFAULT_CLEAR_COLOR = 0xefe9e1;\nconst DEFAULT_FOV_CALCULATION: FovCalculation = { type: \"dynamic\", fov: 40 };\nconst DEFAULT_CAM_NEAR_PLANE = 0.1;\nconst DEFAULT_CAM_FAR_PLANE = 4000000;\nconst MAX_FIELD_OF_VIEW = 140;\nconst MIN_FIELD_OF_VIEW = 10;\n// All objects in fallback tiles are reduced by this amount.\nexport const FALLBACK_RENDER_ORDER_OFFSET = 20000;\n\nconst DEFAULT_MIN_ZOOM_LEVEL = 1;\n\n/**\n * Default maximum zoom level.\n */\nconst DEFAULT_MAX_ZOOM_LEVEL = 20;\n\n/**\n * Default minimum camera height.\n */\nconst DEFAULT_MIN_CAMERA_HEIGHT = 20;\n\n/**\n * Amount of framerate values to pick average from\n */\nconst FRAME_RATE_RING_SIZE = 12;\n\n/**\n * Default starting value for FPS computation.\n */\nconst FALLBACK_FRAME_RATE = 30;\n\n/**\n * Zoom level to request terrain tiles for getting the height of the camera above terrain.\n */\nconst TERRAIN_ZOOM_LEVEL = 4;\n\n/**\n * Style set used by [[PolarTileDataSource]] by default.\n */\nconst DEFAULT_POLAR_STYLE_SET_NAME = \"polar\";\n\n/**\n * The type of `RenderEvent`.\n */\nexport interface RenderEvent extends THREE.Event {\n    type:\n        | MapViewEventNames.Render\n        | MapViewEventNames.FirstFrame\n        | MapViewEventNames.FrameComplete\n        | MapViewEventNames.ThemeLoaded\n        | MapViewEventNames.AnimationStarted\n        | MapViewEventNames.AnimationFinished\n        | MapViewEventNames.MovementStarted\n        | MapViewEventNames.MovementFinished\n        | MapViewEventNames.ContextLost\n        | MapViewEventNames.ContextRestored\n        | MapViewEventNames.CopyrightChanged;\n    time?: number;\n}\n\n// Event type: cast needed to workaround wrong THREE.js typings.\nconst UPDATE: RenderEvent = { type: MapViewEventNames.Update } as any;\nconst RENDER_EVENT: RenderEvent = { type: MapViewEventNames.Render } as any;\nconst DID_RENDER_EVENT: RenderEvent = { type: MapViewEventNames.AfterRender } as any;\nconst FIRST_FRAME_EVENT: RenderEvent = { type: MapViewEventNames.FirstFrame } as any;\nconst FRAME_COMPLETE_EVENT: RenderEvent = { type: MapViewEventNames.FrameComplete } as any;\nconst THEME_LOADED_EVENT: RenderEvent = { type: MapViewEventNames.ThemeLoaded } as any;\nconst ANIMATION_STARTED_EVENT: RenderEvent = { type: MapViewEventNames.AnimationStarted } as any;\nconst ANIMATION_FINISHED_EVENT: RenderEvent = { type: MapViewEventNames.AnimationFinished } as any;\nconst MOVEMENT_STARTED_EVENT: RenderEvent = { type: MapViewEventNames.MovementStarted } as any;\nconst MOVEMENT_FINISHED_EVENT: RenderEvent = { type: MapViewEventNames.MovementFinished } as any;\nconst CONTEXT_LOST_EVENT: RenderEvent = { type: MapViewEventNames.ContextLost } as any;\nconst CONTEXT_RESTORED_EVENT: RenderEvent = { type: MapViewEventNames.ContextRestored } as any;\nconst COPYRIGHT_CHANGED_EVENT: RenderEvent = { type: MapViewEventNames.CopyrightChanged } as any;\n\nconst cache = {\n    vector2: [new THREE.Vector2()],\n    vector3: [new THREE.Vector3()]\n};\n\n/**\n * Specifies how the FOV (Field of View) should be calculated.\n */\nexport interface FovCalculation {\n    /**\n     * How to interpret the [[fov]], can be either `fixed` or `dynamic`.\n     *\n     * `fixed` means that the FOV is fixed regardless of the [[viewportHeight]], such that shrinking\n     * the height causes the map to shrink to keep the content in view. The benefit is that,\n     * regardless of any resizes, the field of view is constant, which means there is no change in\n     * the distortion of buildings near the edges. However the trade off is that the zoom level\n     * changes, which means that the map will pull in new tiles, hence causing some flickering.\n     *\n     * `dynamic` means that the focal length is calculated based on the supplied [[fov]] and\n     * [[viewportHeight]], this means that the map doesn't scale (the image is essentially cropped\n     * but not shrunk) when the [[viewportHeight]] or [[viewportWidth]] is changed. The benefit is\n     * that the zoom level is (currently) stable during resize, because the focal length is used,\n     * however the tradeoff is that changing from a small to a big height will cause the fov to\n     * change a lot, and thus introduce distortion.\n     */\n    type: \"fixed\" | \"dynamic\";\n\n    /**\n     * If [[type]] is `fixed` then the supplied [[fov]] is fixed regardless of\n     * [[viewportHeight]] or [[viewportWidth]].\n     *\n     * If [[type]] is `dynamic` then the supplied [[fov]] is applied to the\n     * first frame, and the focal length calculated. Changes to the viewport\n     * height no longer shrink the content because the field of view is updated\n     * dynamically.\n     */\n    fov: number;\n}\n\n/**\n * Hint for the WebGL implementation on which power mode to prefer.\n *\n * @see https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14.12\n */\nexport enum MapViewPowerPreference {\n    /** Default value. */\n    Default = \"default\",\n    /** Lower power mode, used to conserve energy. */\n    LowPower = \"low-power\",\n    /** Maximum performance. */\n    HighPerformance = \"high-performance\"\n}\n\n/**\n * User configuration for the [[MapView]].\n */\nexport interface MapViewOptions extends TextElementsRendererOptions {\n    /**\n     * The canvas element used to render the scene.\n     */\n    canvas: HTMLCanvasElement;\n\n    /**\n     * `true` if the canvas contains an alpha (transparency) buffer or not. Default is `false`.\n     */\n    alpha?: boolean;\n\n    /**\n     * Whether the native WebGL antialiasing should be enabled. It is better to disable it if the\n     * MapView's MSAA is enabled.\n     *\n     * @default `true` for `pixelRatio` < `2.0`, `false` otherwise.\n     */\n    enableNativeWebglAntialias?: boolean;\n\n    /**\n     * Antialias settings for the map rendering. It is better to disable the native antialising if\n     * the custom antialiasing is enabled.\n     */\n    customAntialiasSettings?: IMapAntialiasSettings;\n\n    /**\n     * `Projection` used by the `MapView`.\n     *\n     * The default value is [[mercatorProjection]].\n     */\n    projection?: Projection;\n\n    /**\n     * The URL of the script that the decoder worker runs. The default URL is\n     * `./decoder.bundle.js`.\n     *\n     * Relative URIs are resolved to full URL using the document's base URL\n     * (see: https://www.w3.org/TR/WD-html40-970917/htmlweb.html#h-5.1.2).\n     */\n    decoderUrl?: string;\n\n    /**\n     * The number of Web Workers used to decode data. The default is\n     * CLAMP(`navigator.hardwareConcurrency` - 1, 1, 2).\n     */\n    decoderCount?: number;\n\n    /**\n     * The [[Theme]] used by Mapview.\n     *\n     * This Theme can be one of the following:\n     *  - `string` : the URI of the theme file used to style this map\n     *  - `Theme` : the `Theme` object already loaded\n     *  - `Promise<Theme>` : the future `Theme` object\n     *  - `undefined` : the theme is not yet set up, but can be set later. Rendering waits until\n     *     the theme is set.\n     *\n     * **Note:** Layers that use a theme do not render any content until that theme is available.\n     *\n     * Relative URIs are resolved to full URL using the document's base URL\n     * (see: https://www.w3.org/TR/WD-html40-970917/htmlweb.html#h-5.1.2).\n     *\n     * Custom URIs (of theme itself and of resources referenced by theme) may be resolved with help\n     * of [[uriResolver]].\n     *\n     * @see [[ThemeLoader.load]] for details how theme is loaded\n     */\n    theme?: string | Theme | Promise<Theme>;\n\n    /**\n     * Resolve `URI` referenced in `MapView` assets using this resolver.\n     *\n     * Use, to support application/deployment specific `URI`s into actual `URLs` that can be loaded\n     * with `fetch`.\n     *\n     * Example:\n     * ```\n     * uriResolver: new PrefixMapUriResolver({\n     *     \"local://poiMasterList\": \"/assets/poiMasterList.json\",\n     *        // will match only 'local//:poiMasterList' and\n     *        // resolve to `/assets/poiMasterList.json`\n     *     \"local://icons/\": \"/assets/icons/\"\n     *        // will match only 'local//:icons/ANYPATH' (and similar) and\n     *        // resolve to `/assets/icons/ANYPATH`\n     * })\n     * ```\n     *\n     * @see [[UriResolver]]\n     * @See [[PrefixMapUriResolver]]\n     */\n    uriResolver?: UriResolver;\n\n    /**\n     * The minimum zoom level; default is `1`.\n     */\n    minZoomLevel?: number;\n\n    /**\n     * Determines the minimum camera height, in meters.\n     */\n    minCameraHeight?: number;\n\n    /**\n     * The maximum zoom level. The default is `14`.\n     */\n    maxZoomLevel?: number;\n\n    /**\n     * User-defined camera clipping planes distance evaluator.\n     * If not defined, [[TiltViewClipPlanesEvaluator]] will be used by [[MapView]].\n     *\n     * @default [[TiltViewClipPlanesEvaluator]]\n     */\n    clipPlanesEvaluator?: ClipPlanesEvaluator;\n\n    /**\n     * Set to true to extend the frustum culling. This improves the rejection of some tiles, which\n     * normal frustum culling cannot detect. You can disable this property to measure performance.\n     *\n     * @default true\n     */\n    extendedFrustumCulling?: boolean;\n\n    /**\n     * The maximum number of tiles rendered from one data source at a time.\n     *\n     * @default See [[MapViewDefaults.maxVisibleDataSourceTiles]].\n     */\n    maxVisibleDataSourceTiles?: number;\n\n    /**\n     * Size of a tile cache for one data source.\n     *\n     * @default See [[MapViewDefaults.tileCacheSize]].\n     */\n    tileCacheSize?: number;\n\n    /**\n     * Specify if the cache should be counted in tiles or in megabytes.\n     *\n     * @see [[MapViewDefaults.resourceComputationType]].\n     */\n    resourceComputationType?: ResourceComputationType;\n\n    /**\n     * Limits the number of reduced zoom levels (lower detail) to be searched for fallback tiles.\n     *\n     * When zooming in, newly elected tiles may have not yet loaded. [[MapView]] searches through\n     * the tile cache for tiles ready to be displayed in lower zoom levels. The tiles may be\n     * located shallower in the quadtree.\n     *\n     * To disable a cache search, set the value to `0`.\n     *\n     * @default [[MapViewDefaults.tileLowLevelDetailFallback]]\n     */\n    quadTreeSearchDistanceUp?: number;\n\n    /**\n     * Limits the number of higher zoom levels (more detailed) to be searched for fallback tiles.\n     *\n     * When zooming out, newly elected tiles may have not yet loaded. [[MapView]] searches through\n     * the tile cache for tiles ready to be displayed in higher zoom levels. These tiles may be\n     * located deeper in the quadtree.\n     *\n     * To disable a cache search, set the value to `0`.\n     *\n     * @default [[MapViewDefaults.tileHighLevelDetailFallback]]\n     */\n    quadTreeSearchDistanceDown?: number;\n\n    /**\n     * Set to `true` to measure performance statistics.\n     */\n    enableStatistics?: boolean;\n\n    /**\n     * Preserve the buffers until they are cleared manually or overwritten.\n     *\n     * Set to `true` in order to copy [[MapView]] canvas contents to an image or another canvas.\n     *\n     * @default `false`.\n     * @see https://threejs.org/docs/#api/renderers/WebGLRenderer.preserveDrawingBuffer\n     */\n    preserveDrawingBuffer?: boolean;\n\n    /**\n     * Set to `true` to allow picking of roads. If set to `true`, additional memory is used to\n     * store road data.\n     */\n    enableRoadPicking?: boolean;\n\n    /**\n     * An optional canvas element that renders 2D collision debug information.\n     */\n    collisionDebugCanvas?: HTMLCanvasElement;\n\n    /**\n     * Maximum timeout, in milliseconds, before a [[MOVEMENT_FINISHED_EVENT]] is sent after the\n     * latest frame with a camera movement. The default is 300ms.\n     */\n    movementThrottleTimeout?: number;\n\n    /**\n     * How to calculate the Field of View, if not specified, then\n     * [[DEFAULT_FOV_CALCULATION]] is used.\n     */\n    fovCalculation?: FovCalculation;\n\n    /*\n     * An array of ISO 639-1 language codes for data sources.\n     */\n    languages?: string[];\n\n    /**\n     * Set fixed pixel ratio for rendering. Useful when rendering on high resolution displays with\n     * low performance GPUs that may be fill-rate limited.\n     * @default `window.devicePixelRatio`\n     */\n    pixelRatio?: number;\n\n    /**\n     * Set fixed pixel ratio for rendering when the camera is moving or an animation is running.\n     * Useful when rendering on high resolution displays with low performance GPUs that may be\n     * fill-rate limited.\n     *\n     * If a value is specified, a low resolution render pass is used to render the scene into a\n     * low resolution render target, before it is copied to the screen.\n     *\n     * A value of `undefined` disables the low res render pass. Values between 0.5 and\n     * `window.devicePixelRatio` can be tried to give  good results. The value should not be larger\n     * than `window.devicePixelRatio`.\n     *\n     * @note Since no anti-aliasing is applied during dynamic rendering with `dynamicPixelRatio`\n     * defined, visual artifacts may occur, especially with thin lines..\n     *\n     * @note The resolution of icons and text labels is not affected.\n     *\n     * @default `undefined`\n     */\n    dynamicPixelRatio?: number;\n\n    /**\n     * Set maximum FPS (Frames Per Second). If VSync in enabled, the specified number may not be\n     * reached, but instead the next smaller number than `maxFps` that is equal to the refresh rate\n     * divided by an integer number.\n     *\n     * E.g.: If the monitors refresh rate is set to 60hz, and if `maxFps` is set to a value of `40`\n     * (60hz/1.5), the actual used FPS may be 30 (60hz/2). For displays that have a refresh rate of\n     * 60hz, good values for `maxFps` are 30, 20, 15, 12, 10, 6, 3 and 1. A value of `0` is ignored.\n     */\n    maxFps?: number;\n\n    /**\n     * Enable phased loading. If `false`, the geometry on a [[Tile]] is always being created in a\n     * single step, instead of (potentially) over multiple frames to smoothen animations.\n     *\n     * @default `false`\n     */\n    enablePhasedLoading?: boolean;\n\n    /**\n     * Enable map repeat for planar projections.\n     * If `true`, map will be repeated in longitudinal direction continuously.\n     * If `false`, map will end on lon -180 & 180 deg.\n     *\n     * @default `true`\n     */\n    tileWrappingEnabled?: boolean;\n\n    /**\n     * Set tiling scheme for [[BackgroundDataSource]]\n     */\n    backgroundTilingScheme?: TilingScheme;\n\n    /**\n     * Should be the [[PolarTileDataSource]] used on spherical projection.\n     * Default is `true`.\n     */\n    enablePolarDataSource?: boolean;\n\n    /**\n     * The name of the [[StyleSet]] used by [[PolarTileDataSource]] to evaluate for the decoding.\n     * Default is `\"polar\"`.\n     */\n    polarStyleSetName?: string;\n\n    /**\n     * Storage level offset of regular tiles from reference datasource to align\n     * [[PolarTileDataSource]] tiles to.\n     * Default is `-1`.\n     */\n    polarGeometryLevelOffset?: number;\n\n    /**\n     * Hint for the WebGL implementation on which power mode to prefer.\n     */\n    powerPreference?: MapViewPowerPreference;\n\n    /**\n     * Set to `true` to allow rendering scene synchronously.\n     *\n     * By calling `renderSync()` scene draws immediately, opposite to default case when\n     * `update` method requests redraw and waits for the next animation frame.\n     *\n     * You need to set up your own render loop controller.\n     * Event `MapViewEventNames.Update` fired when [[MapView]] requests for an redraw.\n     * E.g.: When tiles loaded asynchronously and ready for rendering.\n     *\n     * @note Internal `maxFps` will be overridden and may not work properly as `renderSync`\n     * intended to be called from external render loop.\n     *\n     * @default false.\n     */\n    synchronousRendering?: boolean;\n\n    /**\n     * Set initial camera target in geo coordinates.\n     *\n     * Longitude values outside of -180 and +180 are acceptable.\n     * @default new GeoCoordinates(25, 0)\n     */\n    target?: GeoCoordLike;\n\n    /**\n     * Set initial zoom level.\n     *\n     * @default 12\n     */\n    zoomLevel?: number;\n\n    /**\n     * Set initial camera heading in degrees.\n     *\n     * @default 0\n     */\n    heading?: number;\n\n    /**\n     * Set initial camera tilt in degrees.\n     *\n     * @default 0\n     */\n    tilt?: number;\n}\n\n/**\n * Default settings used by [[MapView]] collected in one place.\n */\nexport const MapViewDefaults = {\n    projection: mercatorProjection,\n\n    maxVisibleDataSourceTiles: 120,\n    extendedFrustumCulling: true,\n\n    tileCacheSize: 200,\n    resourceComputationType: ResourceComputationType.EstimationInMb,\n    quadTreeSearchDistanceUp: 3,\n    quadTreeSearchDistanceDown: 2,\n\n    pixelRatio:\n        typeof window !== \"undefined\" && window.devicePixelRatio !== undefined\n            ? window.devicePixelRatio\n            : 1.0,\n    geoCenter: new GeoCoordinates(25, 0, 30000000),\n    target: new GeoCoordinates(25, 0),\n    zoomLevel: 5,\n    tilt: 0,\n    heading: 0\n};\n\n/**\n * The core class of the library to call in order to create a map visualization. It needs to be\n * linked to datasources.\n */\nexport class MapView extends THREE.EventDispatcher {\n    dumpNext = false;\n\n    /**\n     * The instance of [[MapRenderingManager]] managing the rendering of the map. It is a public\n     * property to allow access and modification of some parameters of the rendering process at\n     * runtime.\n     */\n    readonly mapRenderingManager: IMapRenderingManager;\n\n    private m_renderLabels: boolean = true;\n\n    private m_movementFinishedUpdateTimerId?: any;\n    private m_postEffects?: PostEffects;\n\n    private m_skyBackground?: SkyBackground;\n    private m_createdLights?: THREE.Light[];\n\n    private readonly m_screenProjector: ScreenProjector;\n    private readonly m_screenCollisions:\n        | ScreenCollisions\n        | ScreenCollisionsDebug = new ScreenCollisions();\n\n    private m_visibleTiles: VisibleTileSet;\n\n    private m_elevationRangeSource?: ElevationRangeSource;\n    private m_elevationProvider?: ElevationProvider;\n    private m_visibleTileSetLock: boolean = false;\n    private m_tileGeometryManager: TileGeometryManager;\n\n    private m_tileWrappingEnabled: boolean = true;\n\n    private m_zoomLevel: number = DEFAULT_MIN_ZOOM_LEVEL;\n    private m_minZoomLevel: number = DEFAULT_MIN_ZOOM_LEVEL;\n    private m_maxZoomLevel: number = DEFAULT_MAX_ZOOM_LEVEL;\n    private m_minCameraHeight: number = DEFAULT_MIN_CAMERA_HEIGHT;\n\n    private readonly m_screenCamera = new THREE.OrthographicCamera(-1, 1, 1, -1);\n\n    private readonly m_camera: THREE.PerspectiveCamera;\n\n    /**\n     * Relative to eye camera.\n     *\n     * This camera is internal camera used to improve precision\n     * when rendering geometries.\n     */\n    private readonly m_rteCamera = new THREE.PerspectiveCamera();\n\n    private m_focalLength: number;\n    private m_lookAtDistance: number;\n    private readonly m_viewRanges: ViewRanges = {\n        near: DEFAULT_CAM_NEAR_PLANE,\n        far: DEFAULT_CAM_FAR_PLANE,\n        minimum: DEFAULT_CAM_NEAR_PLANE,\n        maximum: DEFAULT_CAM_FAR_PLANE\n    };\n    private m_pointOfView?: THREE.PerspectiveCamera;\n\n    private m_pixelToWorld?: number;\n    private m_pixelRatio?: number;\n\n    private readonly m_scene: THREE.Scene = new THREE.Scene();\n    private readonly m_fog: MapViewFog = new MapViewFog(this.m_scene);\n    private readonly m_mapTilesRoot = new THREE.Object3D();\n    private readonly m_mapAnchors = new THREE.Object3D();\n\n    private m_animationCount: number = 0;\n    private m_animationFrameHandle: number | undefined;\n    private m_drawing: boolean = false;\n    private m_updatePending: boolean = false;\n    private m_renderer: THREE.WebGLRenderer;\n    private m_frameNumber = 0;\n    private m_maxFps = 0;\n    private m_detectedFps: number = FALLBACK_FRAME_RATE;\n\n    private m_textElementsRenderer: TextElementsRenderer;\n\n    private m_forceCameraAspect: number | undefined = undefined;\n\n    //\n    // sources\n    //\n    private readonly m_tileDataSources: DataSource[] = [];\n    private readonly m_connectedDataSources = new Set<string>();\n    private readonly m_failedDataSources = new Set<string>();\n    private m_backgroundDataSource?: BackgroundDataSource;\n    private m_polarDataSource?: PolarTileDataSource;\n    private m_enablePolarDataSource: boolean = true;\n\n    // gestures\n    private readonly m_raycaster = new THREE.Raycaster();\n    private readonly m_plane = new THREE.Plane(new THREE.Vector3(0, 0, 1));\n    private readonly m_sphere = new THREE.Sphere(undefined, EarthConstants.EQUATORIAL_RADIUS);\n\n    private readonly m_options: MapViewOptions;\n    private readonly m_visibleTileSetOptions: VisibleTileSetOptions;\n\n    private m_theme: Theme = {};\n    private m_uriResolver?: UriResolver;\n    private m_themeIsLoading: boolean = false;\n\n    private m_previousFrameTimeStamp?: number;\n    private m_firstFrameRendered = false;\n    private m_firstFrameComplete = false;\n    private m_initialTextPlacementDone = false;\n    private m_previousRequestAnimationTime?: number;\n    private m_targetRequestAnimationTime?: number;\n    private m_frameTimeIndex: number = 0;\n    private readonly m_frameTimeRing: number[] = [];\n\n    private handleRequestAnimationFrame: any;\n    private handlePostponedAnimationFrame: any;\n\n    private m_pickHandler: PickHandler;\n\n    private m_imageCache: MapViewImageCache = new MapViewImageCache(this);\n\n    private m_poiManager: PoiManager = new PoiManager(this);\n\n    private m_poiTableManager: PoiTableManager = new PoiTableManager(this);\n\n    private m_collisionDebugCanvas: HTMLCanvasElement | undefined;\n\n    // Detection of camera movement and scene change:\n    private m_movementDetector: CameraMovementDetector;\n\n    private m_thisFrameTilesChanged: boolean | undefined;\n    private m_lastTileIds: string = \"\";\n    private m_languages: string[] | undefined;\n    private m_copyrightInfo: CopyrightInfo[] = [];\n    private m_animatedExtrusionHandler: AnimatedExtrusionHandler;\n\n    /**\n     * Constructs a new `MapView` with the given options or canvas element.\n     *\n     * @param options The `MapView` options or the HTML canvas element used to display the map.\n     */\n    constructor(options: MapViewOptions) {\n        super();\n\n        // make a copy to avoid unwanted changes to the original options.\n        this.m_options = { ...options };\n\n        this.m_uriResolver = this.m_options.uriResolver;\n\n        if (this.m_options.minZoomLevel !== undefined) {\n            this.m_minZoomLevel = this.m_options.minZoomLevel;\n        }\n\n        if (this.m_options.maxZoomLevel !== undefined) {\n            this.m_maxZoomLevel = this.m_options.maxZoomLevel;\n        }\n\n        if (this.m_options.minCameraHeight !== undefined) {\n            this.m_minCameraHeight = this.m_options.minCameraHeight;\n        }\n\n        if (this.m_options.decoderUrl !== undefined) {\n            ConcurrentDecoderFacade.defaultScriptUrl = this.m_uriResolver\n                ? this.m_uriResolver.resolveUri(this.m_options.decoderUrl)\n                : this.m_options.decoderUrl;\n        }\n\n        if (this.m_options.decoderCount !== undefined) {\n            ConcurrentDecoderFacade.defaultWorkerCount = this.m_options.decoderCount;\n        }\n\n        this.m_visibleTileSetOptions = {\n            ...MapViewDefaults,\n            clipPlanesEvaluator:\n                options.clipPlanesEvaluator !== undefined\n                    ? options.clipPlanesEvaluator\n                    : createDefaultClipPlanesEvaluator()\n        };\n\n        if (options.projection !== undefined) {\n            this.m_visibleTileSetOptions.projection = options.projection;\n        }\n\n        if (options.extendedFrustumCulling !== undefined) {\n            this.m_visibleTileSetOptions.extendedFrustumCulling = options.extendedFrustumCulling;\n        }\n\n        if (options.maxVisibleDataSourceTiles !== undefined) {\n            this.m_visibleTileSetOptions.maxVisibleDataSourceTiles =\n                options.maxVisibleDataSourceTiles;\n        }\n\n        if (options.tileCacheSize !== undefined) {\n            this.m_visibleTileSetOptions.tileCacheSize = options.tileCacheSize;\n        }\n\n        if (options.resourceComputationType !== undefined) {\n            this.m_visibleTileSetOptions.resourceComputationType = options.resourceComputationType;\n        }\n\n        if (options.quadTreeSearchDistanceUp !== undefined) {\n            this.m_visibleTileSetOptions.quadTreeSearchDistanceUp =\n                options.quadTreeSearchDistanceUp;\n        }\n\n        if (options.quadTreeSearchDistanceDown !== undefined) {\n            this.m_visibleTileSetOptions.quadTreeSearchDistanceDown =\n                options.quadTreeSearchDistanceDown;\n        }\n\n        if (options.enablePolarDataSource !== undefined) {\n            this.m_enablePolarDataSource = options.enablePolarDataSource;\n        }\n\n        this.m_pixelRatio = options.pixelRatio;\n\n        if (options.maxFps !== undefined) {\n            this.m_maxFps = Math.max(0, options.maxFps);\n        }\n\n        this.m_options.enableStatistics = this.m_options.enableStatistics === true;\n\n        this.m_languages = this.m_options.languages;\n\n        if (\n            !isProduction &&\n            this.m_options.collisionDebugCanvas !== undefined &&\n            this.m_options.collisionDebugCanvas !== null\n        ) {\n            this.m_collisionDebugCanvas = this.m_options.collisionDebugCanvas;\n            this.m_screenCollisions = new ScreenCollisionsDebug(this.m_collisionDebugCanvas);\n        }\n\n        this.handleRequestAnimationFrame = this.renderFunc.bind(this);\n        this.handlePostponedAnimationFrame = this.postponedAnimationFrame.bind(this);\n        this.m_pickHandler = new PickHandler(\n            this,\n            this.m_rteCamera,\n            this.m_options.enableRoadPicking === true\n        );\n\n        if (this.m_options.tileWrappingEnabled !== undefined) {\n            this.m_tileWrappingEnabled = this.m_options.tileWrappingEnabled;\n        }\n\n        // Initialization of the stats\n        this.setupStats(this.m_options.enableStatistics);\n\n        this.canvas.addEventListener(\"webglcontextlost\", this.onWebGLContextLost);\n        this.canvas.addEventListener(\"webglcontextrestored\", this.onWebGLContextRestored);\n\n        // Initialization of the renderer\n        this.m_renderer = new THREE.WebGLRenderer({\n            canvas: this.canvas,\n            antialias: this.nativeWebglAntialiasEnabled,\n            alpha: this.m_options.alpha,\n            preserveDrawingBuffer: this.m_options.preserveDrawingBuffer === true,\n            powerPreference:\n                this.m_options.powerPreference === undefined\n                    ? MapViewPowerPreference.Default\n                    : this.m_options.powerPreference\n        });\n        this.m_renderer.autoClear = false;\n\n        // This is a bit of a misnomer, this is required for the clipping planes\n        // to be enabled, and they are in world space, see:\n        // https://threejs.org/docs/#api/en/materials/Material.clippingPlanes\n        this.m_renderer.localClippingEnabled = true;\n\n        // This is detailed at https://threejs.org/docs/#api/renderers/WebGLRenderer.info\n        // When using several WebGLRenderer#render calls per frame, it is the only way to get\n        // correct rendering data from ThreeJS.\n        this.m_renderer.info.autoReset = false;\n\n        this.setupRenderer();\n\n        this.m_options.fovCalculation =\n            this.m_options.fovCalculation === undefined\n                ? DEFAULT_FOV_CALCULATION\n                : this.m_options.fovCalculation;\n        this.m_options.fovCalculation.fov = THREE.Math.clamp(\n            this.m_options.fovCalculation!.fov,\n            MIN_FIELD_OF_VIEW,\n            MAX_FIELD_OF_VIEW\n        );\n        // Initialization of mCamera and mVisibleTiles\n        const { width, height } = this.getCanvasClientSize();\n        const aspect = width / height;\n        this.m_camera = new THREE.PerspectiveCamera(\n            this.m_options.fovCalculation.fov,\n            aspect,\n            DEFAULT_CAM_NEAR_PLANE,\n            DEFAULT_CAM_FAR_PLANE\n        );\n        this.m_camera.up.set(0, 0, 1);\n        this.m_lookAtDistance = 0;\n        this.m_focalLength = 0;\n        this.m_scene.add(this.m_camera); // ensure the camera is added to the scene.\n        this.m_screenProjector = new ScreenProjector(this.m_camera);\n\n        // setup camera with initial position\n        this.setupCamera(options);\n\n        this.m_movementDetector = new CameraMovementDetector(\n            this.m_options.movementThrottleTimeout,\n            () => this.movementStarted(),\n            () => this.movementFinished()\n        );\n\n        const mapPassAntialiasSettings = this.m_options.customAntialiasSettings;\n        this.mapRenderingManager = new MapRenderingManager(\n            width,\n            height,\n            this.m_options.dynamicPixelRatio,\n            mapPassAntialiasSettings\n        );\n\n        this.m_tileGeometryManager =\n            this.m_options.enablePhasedLoading === true\n                ? new PhasedTileGeometryManager(this)\n                : new SimpleTileGeometryManager(this);\n\n        this.m_visibleTiles = new VisibleTileSet(\n            new FrustumIntersection(\n                this.m_camera,\n                this,\n                this.m_visibleTileSetOptions.extendedFrustumCulling,\n                this.m_tileWrappingEnabled\n            ),\n            this.m_tileGeometryManager,\n            this.m_visibleTileSetOptions\n        );\n\n        this.m_animatedExtrusionHandler = new AnimatedExtrusionHandler(this);\n\n        this.m_backgroundDataSource = new BackgroundDataSource();\n        this.addDataSource(this.m_backgroundDataSource);\n\n        if (this.m_enablePolarDataSource) {\n            const styleSetName =\n                options.polarStyleSetName !== undefined\n                    ? options.polarStyleSetName\n                    : DEFAULT_POLAR_STYLE_SET_NAME;\n\n            this.m_polarDataSource = new PolarTileDataSource({\n                styleSetName,\n                geometryLevelOffset: options.polarGeometryLevelOffset\n            });\n\n            this.updatePolarDataSource();\n        }\n\n        if (options.backgroundTilingScheme !== undefined) {\n            this.m_backgroundDataSource.setTilingScheme(options.backgroundTilingScheme);\n        }\n\n        this.initTheme();\n\n        this.m_textElementsRenderer = this.createTextRenderer();\n\n        this.drawFrame();\n    }\n\n    /**\n     * @returns Whether label rendering is enabled.\n     */\n    get renderLabels() {\n        return this.m_renderLabels;\n    }\n\n    /**\n     * Enables or disables rendering of labels.\n     * @param value `true` to enable labels `false` to disable them.\n     */\n    set renderLabels(value: boolean) {\n        this.m_renderLabels = value;\n    }\n\n    /**\n     * @hidden\n     * The [[TextElementsRenderer]] select the visible [[TextElement]]s and renders them.\n     */\n    get textElementsRenderer(): TextElementsRenderer {\n        return this.m_textElementsRenderer;\n    }\n\n    /**\n     * @hidden\n     * The [[CameraMovementDetector]] detects camera movements. Made available for performance\n     * measurements.\n     */\n    get cameraMovementDetector(): CameraMovementDetector {\n        return this.m_movementDetector;\n    }\n\n    /**\n     * The [[AnimatedExtrusionHandler]] controls animated extrusion effect\n     * of the extruded objects in the [[Tile]]\n     */\n    get animatedExtrusionHandler(): AnimatedExtrusionHandler {\n        return this.m_animatedExtrusionHandler;\n    }\n\n    /**\n     * The [[TileGeometryManager]] manages geometry during loading and handles hiding geometry of\n     * specified [[GeometryKind]]s.\n     */\n    get tileGeometryManager(): TileGeometryManager | undefined {\n        return this.m_tileGeometryManager;\n    }\n\n    /**\n     * Disposes this `MapView`.\n     *\n     * This function cleans the resources that are managed manually including those that exist in\n     * shared caches.\n     *\n     * Note: This function does not try to clean objects that can be disposed off easily by\n     * TypeScript's garbage collecting mechanism. Consequently, if you need to perform a full\n     * cleanup, you must ensure that all references to this `MapView` are removed.\n     */\n    dispose() {\n        if (this.m_movementFinishedUpdateTimerId) {\n            clearTimeout(this.m_movementFinishedUpdateTimerId);\n            this.m_movementFinishedUpdateTimerId = undefined;\n        }\n\n        if (this.m_animationFrameHandle !== undefined) {\n            cancelAnimationFrame(this.m_animationFrameHandle);\n            this.m_animationFrameHandle = undefined;\n        }\n\n        this.canvas.removeEventListener(\"webglcontextlost\", this.onWebGLContextLost);\n        this.canvas.removeEventListener(\"webglcontextrestored\", this.onWebGLContextRestored);\n\n        for (const dataSource of this.m_tileDataSources) {\n            dataSource.dispose();\n        }\n        this.m_visibleTiles.clearTileCache();\n        this.m_textElementsRenderer.clearRenderStates();\n        this.m_renderer.dispose();\n        this.m_imageCache.clear();\n\n        this.m_movementDetector.dispose();\n    }\n\n    /**\n     * The way the cache usage is computed, either based on size in MB (mega bytes) or in number of\n     * tiles.\n     */\n    get resourceComputationType(): ResourceComputationType {\n        return this.m_visibleTiles.resourceComputationType;\n    }\n\n    set resourceComputationType(value: ResourceComputationType) {\n        this.m_visibleTiles.resourceComputationType = value;\n    }\n\n    /**\n     * Returns the cache size.\n     */\n    getCacheSize(): number {\n        return this.m_visibleTiles.getDataSourceCacheSize();\n    }\n\n    /**\n     * Sets the cache size in number of tiles.\n     *\n     * @param size The cache size in tiles.\n     * @param numVisibleTiles The number of tiles visible, which is size/2 by default.\n     */\n    setCacheSize(size: number, numVisibleTiles?: number): void {\n        this.m_visibleTiles.setDataSourceCacheSize(size);\n        numVisibleTiles = numVisibleTiles !== undefined ? numVisibleTiles : size / 2;\n        this.m_visibleTiles.setNumberOfVisibleTiles(Math.floor(numVisibleTiles));\n        this.updateImages();\n        this.updateLighting();\n\n        this.m_textElementsRenderer.invalidateCache();\n\n        this.updateSkyBackground();\n        this.update();\n    }\n\n    /**\n     * Specfies whether extended frustum culling is enabled or disabled.\n     */\n    get extendedFrustumCulling(): boolean {\n        return this.m_options.extendedFrustumCulling !== undefined\n            ? this.m_visibleTileSetOptions.extendedFrustumCulling\n            : true;\n    }\n\n    /**\n     * Enable of disable extended frustum culling.\n     */\n    set extendedFrustumCulling(value: boolean) {\n        this.m_visibleTileSetOptions.extendedFrustumCulling = value;\n    }\n\n    /**\n     * Returns the status of frustum culling after each update.\n     */\n    get lockVisibleTileSet(): boolean {\n        return this.m_visibleTileSetLock;\n    }\n\n    /**\n     * Enable of disable frustum culling after each update.\n     */\n    set lockVisibleTileSet(value: boolean) {\n        this.m_visibleTileSetLock = value;\n    }\n\n    /**\n     * Gets the optional camera used to render the scene.\n     */\n    get pointOfView(): THREE.PerspectiveCamera | undefined {\n        return this.m_pointOfView;\n    }\n\n    /**\n     * Sets the optional camera used to render the scene.\n     */\n    set pointOfView(pointOfView: THREE.PerspectiveCamera | undefined) {\n        this.m_pointOfView = pointOfView;\n        this.update();\n    }\n\n    /**\n     * Loads a post effects definition file.\n     *\n     * @param postEffectsFile File URL describing the post effects.\n     */\n    loadPostEffects(postEffectsFile: string) {\n        fetch(postEffectsFile)\n            .then(response => response.json())\n            .then((postEffects: PostEffects) => {\n                this.m_postEffects = postEffects;\n                this.setPostEffects();\n            });\n    }\n\n    /**\n     * The abstraction of the [[MapRenderingManager]] API for post effects.\n     */\n    get postEffects(): PostEffects | undefined {\n        return this.m_postEffects;\n    }\n\n    set postEffects(postEffects: PostEffects | undefined) {\n        this.m_postEffects = postEffects;\n        this.setPostEffects();\n    }\n\n    /**\n     * Gets the current `Theme` used by this `MapView` to style map elements.\n     */\n    get theme(): Theme {\n        return this.m_theme;\n    }\n\n    /**\n     * Changes the `Theme` used by this `MapView` to style map elements.\n     */\n    set theme(theme: Theme) {\n        if (!ThemeLoader.isThemeLoaded(theme)) {\n            this.m_themeIsLoading = true;\n            // If theme is not yet loaded, let's set theme asynchronously\n            ThemeLoader.load(theme, { uriResolver: this.m_uriResolver })\n                .then(loadedTheme => {\n                    this.m_themeIsLoading = false;\n                    this.theme = loadedTheme;\n                })\n                .catch(error => {\n                    this.m_themeIsLoading = false;\n                    logger.error(`failed to set theme: ${error}`, error);\n                });\n            return;\n        }\n\n        // Fog and sky.\n        this.m_theme.fog = theme.fog;\n        this.m_theme.sky = theme.sky;\n        this.updateSkyBackground();\n        this.m_fog.reset(this.m_theme);\n\n        this.m_theme.lights = theme.lights;\n        this.updateLighting();\n\n        // Clear color.\n        this.m_theme.clearColor = theme.clearColor;\n        this.renderer.setClearColor(new THREE.Color(theme.clearColor));\n\n        // Images.\n        this.m_theme.images = theme.images;\n        this.m_theme.imageTextures = theme.imageTextures;\n        this.updateImages();\n\n        // POI tables.\n        this.m_theme.poiTables = theme.poiTables;\n        this.loadPoiTables();\n\n        // Text.\n        this.m_theme.textStyles = theme.textStyles;\n        this.m_theme.defaultTextStyle = theme.defaultTextStyle;\n        this.m_theme.fontCatalogs = theme.fontCatalogs;\n\n        this.resetTextRenderer();\n\n        if (this.m_theme.styles === undefined) {\n            this.m_theme.styles = {};\n        }\n        if (this.m_backgroundDataSource) {\n            this.m_backgroundDataSource.setTheme(this.m_theme);\n        }\n        this.m_theme.styles = theme.styles || {};\n        this.m_theme.definitions = theme.definitions;\n\n        for (const dataSource of this.m_tileDataSources) {\n            dataSource.setTheme(this.m_theme);\n        }\n        this.dispatchEvent(THEME_LOADED_EVENT);\n        this.update();\n    }\n\n    /**\n     * [[UriResolver]] used to resolve application/deployment specific `URI`s into actual `URLs`\n     * that can be loaded with `fetch`.\n     */\n    get uriResolver(): UriResolver | undefined {\n        return this.m_uriResolver;\n    }\n\n    /**\n     * Gets the value of the forced custom camera aspect.\n     * Every time a frame is rendered, `MapView` resets the camera aspect.\n     *\n     * You can disable this behavior by setting the value to `undefined`.\n     */\n    get forceCameraAspect(): number | undefined {\n        return this.m_forceCameraAspect;\n    }\n\n    /**\n     * Sets the custom forced camera aspect ratio to use while rendering.\n     */\n    set forceCameraAspect(aspect: number | undefined) {\n        this.m_forceCameraAspect = aspect;\n    }\n\n    /**\n     * Maximum FPS. If defined (and > 0) it is the maximum FPS that is used.\n     */\n    set maxFps(fps: number) {\n        this.m_maxFps = Math.max(0, fps);\n    }\n\n    get maxFps(): number {\n        return Math.max(0, this.m_maxFps);\n    }\n\n    /**\n     * Lists the ISO 639-1 language codes for DataSources to use.\n     */\n    get languages(): string[] | undefined {\n        return this.m_languages;\n    }\n\n    /**\n     * Sets the list of ISO 639-1 language codes for DataSources to use.\n     */\n    set languages(languages: string[] | undefined) {\n        this.m_languages = languages;\n        this.m_tileDataSources.forEach((dataSource: DataSource) => {\n            dataSource.setLanguages(this.m_languages);\n        });\n        this.update();\n    }\n\n    get copyrightInfo(): CopyrightInfo[] {\n        return this.m_copyrightInfo;\n    }\n\n    /**\n     * @hidden\n     * Disable all fading animations (for debugging and performance measurement). Defaults to\n     * `false`.\n     */\n    set disableFading(disable: boolean) {\n        this.m_textElementsRenderer.disableFading = disable;\n    }\n\n    get disableFading(): boolean {\n        return this.m_textElementsRenderer.disableFading;\n    }\n\n    /**\n     * @hidden\n     * Return current frame number.\n     */\n    get frameNumber(): number {\n        return this.m_frameNumber;\n    }\n\n    /**\n     * @hidden\n     * Reset the frame number to 0.\n     */\n    resetFrameNumber() {\n        this.m_frameNumber = 0;\n        this.m_previousFrameTimeStamp = undefined;\n    }\n\n    /**\n     * Adds an event listener. There are various events that are sent before or after a new frame\n     * is rendered.\n     *\n     * @see [[MapViewEventNames]].\n     *\n     * @example\n     * ```TypeScript\n     * let frameCount = 0;\n     * mapView.addEventListener(MapViewEventNames.Render, () => {\n     *     ++frameCount;\n     * });\n     * ```\n     *\n     * @param type One of the [[MapViewEventNames]] strings.\n     * @param listener The callback invoked when the `MapView` needs to render a new frame.\n     */\n    addEventListener(type: MapViewEventNames, listener: (event: RenderEvent) => void): void;\n\n    addEventListener(type: string, listener: any): void {\n        super.addEventListener(type, listener);\n    }\n\n    /**\n     * Removes an event listener. There are various events that are sent before or after a new frame\n     * is rendered.\n     *\n     * @see [[MapViewEventNames]].\n     *\n     * @example\n     * ```TypeScript\n     * mapView.removeEventListener(MapViewEventNames.Render, listener);\n     * ```\n     *\n     * @param type One of the [[MapViewEventNames]] strings.\n     * @param listener The callback invoked when the `MapView` needs to render a new frame.\n     */\n    removeEventListener(type: MapViewEventNames, listener: (event: RenderEvent) => void): void;\n\n    removeEventListener(type: string, listener: any): void {\n        super.removeEventListener(type, listener);\n    }\n\n    /**\n     * The HTML canvas element used by this `MapView`.\n     */\n    get canvas(): HTMLCanvasElement {\n        return this.m_options.canvas;\n    }\n\n    /**\n     * The HTML canvas element used by this `MapView`.\n     */\n    get collisionDebugCanvas(): HTMLCanvasElement | undefined {\n        return this.m_collisionDebugCanvas;\n    }\n\n    /**\n     * The THREE.js scene used by this `MapView`.\n     */\n    get scene(): THREE.Scene {\n        return this.m_scene;\n    }\n\n    /**\n     * The THREE.js camera used by this `MapView` to render the main scene.\n     */\n    get camera(): THREE.PerspectiveCamera {\n        return this.m_camera;\n    }\n\n    /**\n     * The THREE.js `WebGLRenderer` used by this scene.\n     */\n    get renderer(): THREE.WebGLRenderer {\n        return this.m_renderer;\n    }\n\n    /**\n     * The color used to clear the view.\n     */\n    get clearColor() {\n        const rendererClearColor = this.m_renderer.getClearColor();\n        return rendererClearColor !== undefined ? rendererClearColor.getHex() : 0;\n    }\n\n    /**\n     * The color used to clear the view.\n     */\n    set clearColor(color: number) {\n        this.m_renderer.setClearColor(color);\n    }\n\n    /**\n     * The projection used to project geo coordinates to world coordinates.\n     */\n    get projection(): Projection {\n        return this.m_visibleTileSetOptions.projection;\n    }\n\n    /**\n     * Changes the projection at run time.\n     *\n     * @param projection The [[Projection]] instance to use.\n     */\n    set projection(projection: Projection) {\n        // The geo center must be reset when changing the projection, because the\n        // camera's position is based on the projected geo center.\n        const target = MapViewUtils.rayCastWorldCoordinates(this, 0, 0);\n        if (target === null) {\n            throw new Error(\"MapView does not support a view pointing in the void.\");\n        }\n        const targetCoordinates = this.projection.unprojectPoint(target);\n        const targetDistance = this.camera.position.distanceTo(target);\n        const attitude = MapViewUtils.extractAttitude(this, this.camera);\n        const pitchDeg = THREE.Math.radToDeg(attitude.pitch);\n        const headingDeg = -THREE.Math.radToDeg(attitude.yaw);\n\n        this.m_visibleTileSetOptions.projection = projection;\n        this.updatePolarDataSource();\n        this.clearTileCache();\n        this.textElementsRenderer.clearRenderStates();\n        this.m_visibleTiles = new VisibleTileSet(\n            new FrustumIntersection(\n                this.m_camera,\n                this,\n                this.m_visibleTileSetOptions.extendedFrustumCulling,\n                this.m_tileWrappingEnabled\n            ),\n            this.m_tileGeometryManager,\n            this.m_visibleTileSetOptions\n        );\n\n        this.lookAt(targetCoordinates, targetDistance, pitchDeg, headingDeg);\n    }\n\n    /**\n     * Get camera clipping planes evaluator used.\n     */\n    get clipPlanesEvaluator(): ClipPlanesEvaluator {\n        return this.m_visibleTileSetOptions.clipPlanesEvaluator;\n    }\n\n    /**\n     * Changes the clip planes evaluator at run time.\n     */\n    set clipPlanesEvaluator(clipPlanesEvaluator: ClipPlanesEvaluator) {\n        this.m_visibleTileSetOptions.clipPlanesEvaluator = clipPlanesEvaluator;\n    }\n\n    /**\n     * The distance (in pixels) between the screen and the camera.\n     */\n    get focalLength(): number {\n        return this.m_focalLength;\n    }\n\n    /**\n     * Get distance from camera to the point of focus in world units.\n     */\n    get lookAtDistance(): number {\n        return this.m_lookAtDistance;\n    }\n\n    /**\n     * Get object describing frustum planes distances and min/max visibility range for actual\n     * camera setup.\n     * Near and far plane distance are self explanatory while minimum and maximum visibility range\n     * describes the extreme near/far planes distances that may be achieved with current camera\n     * settings, meaning at current zoom level (ground distance) and any possible orientation.\n     * @note Visibility is directly related to camera [[ClipPlaneEvaluator]] used and determines\n     * the maximum possible distance of camera far clipping plane regardless of tilt, but may change\n     * whenever zoom level changes. Distance is measured in world units which may be approximately\n     * equal to meters, but this depends on the distortion related to projection type used.\n     */\n    get viewRanges(): ViewRanges {\n        return this.m_viewRanges;\n    }\n\n    /**\n     * The position in geo coordinates of the center of the scene.\n     */\n    get geoCenter(): GeoCoordinates {\n        return this.projection.unprojectPoint(this.m_camera.position).normalized();\n    }\n\n    /**\n     * The position in geo coordinates of the center of the scene.\n     * Longitude values outside of -180 and +180 are acceptable.\n     */\n    set geoCenter(geoCenter: GeoCoordinates) {\n        if (geoCenter.altitude !== undefined) {\n            this.projection.projectPoint(geoCenter, this.m_camera.position);\n        } else {\n            // Preserve the current altitude\n            const altitude = this.geoCenter.altitude;\n\n            this.projection.projectPoint(\n                new GeoCoordinates(geoCenter.latitude, geoCenter.longitude, altitude),\n                this.m_camera.position\n            );\n        }\n\n        this.update();\n    }\n\n    /**\n     * The node in this MapView's scene containing the user [[MapAnchor]]s.\n     * All (first level) children of this node will be positioned in world space according to the\n     * [[MapAnchor.geoPosition]].\n     * Deeper level children can be used to position custom objects relative to the anchor node.\n     */\n    get mapAnchors(): THREE.Object3D {\n        return this.m_mapAnchors;\n    }\n\n    /**\n     * The position in world coordinates of the center of the scene.\n     */\n    get worldCenter(): THREE.Vector3 {\n        return this.m_camera.position;\n    }\n\n    /**\n     * The root object of the scene. Contains all `rootObjects` of the [[Tile]]s.\n     */\n    get worldRootObject(): THREE.Object3D {\n        return this.m_mapTilesRoot;\n    }\n\n    /**\n     * Get the [[PickHandler]] for this `mapView`.\n     */\n    get pickHandler(): PickHandler {\n        return this.m_pickHandler;\n    }\n\n    /**\n     * Get the [[ImageCache]] that belongs to this `MapView`.\n     */\n    get imageCache(): MapViewImageCache {\n        return this.m_imageCache;\n    }\n\n    /**\n     * @hidden\n     * Get the [[PoiManager]] that belongs to this `MapView`.\n     */\n    get poiManager(): PoiManager {\n        return this.m_poiManager;\n    }\n\n    /**\n     * @hidden\n     * Get the array of [[PoiTableManager]] that belongs to this `MapView`.\n     */\n    get poiTableManager(): PoiTableManager {\n        return this.m_poiTableManager;\n    }\n\n    /**\n     * The minimum camera height in meters.\n     */\n    get minCameraHeight(): number {\n        return this.m_minCameraHeight;\n    }\n\n    /**\n     * The minimum zoom level.\n     */\n    get minZoomLevel(): number {\n        return this.m_minZoomLevel;\n    }\n\n    /**\n     * The minimum zoom level.\n     */\n    set minZoomLevel(zoomLevel: number) {\n        this.m_minZoomLevel = zoomLevel;\n        this.update();\n    }\n\n    /**\n     * The maximum zoom level. Default is 14.\n     */\n    get maxZoomLevel(): number {\n        return this.m_maxZoomLevel;\n    }\n\n    /**\n     * The maximum zoom level.\n     */\n    set maxZoomLevel(zoomLevel: number) {\n        this.m_maxZoomLevel = zoomLevel;\n        this.update();\n    }\n\n    /**\n     * Returns the zoom level for the given camera setup.\n     */\n    get zoomLevel(): number {\n        return this.m_zoomLevel;\n    }\n    set zoomLevel(zoomLevel: number) {\n        this.m_zoomLevel = THREE.Math.clamp(zoomLevel, this.m_minZoomLevel, this.m_maxZoomLevel);\n        MapViewUtils.zoomOnTargetPosition(this, 0, 0, this.m_zoomLevel);\n        this.update();\n    }\n\n    /**\n     * Returns the storage level for the given camera setup.\n     * Actual storage level of the rendered data also depends on [[DataSource.storageLevelOffset]].\n     */\n    get storageLevel(): number {\n        return THREE.Math.clamp(\n            Math.floor(this.m_zoomLevel),\n            this.m_minZoomLevel,\n            this.m_maxZoomLevel\n        );\n    }\n\n    /**\n     * Returns height of the viewport in pixels.\n     */\n    get viewportHeight(): number {\n        return this.canvas.height;\n    }\n\n    /**\n     * Returns `true` if the native WebGL antialiasing is enabled.\n     *\n     * @default `true` for `pixelRatio` < `2.0`, `false` otherwise.\n     */\n    get nativeWebglAntialiasEnabled(): boolean {\n        return this.m_options.enableNativeWebglAntialias === undefined\n            ? this.pixelRatio < 2.0\n            : this.m_options.enableNativeWebglAntialias;\n    }\n\n    /**\n     * Returns 'true' if the phased loading is currently enabled.\n     *\n     * @default true.\n     */\n    get phasedLoadingEnabled(): boolean {\n        return this.m_options.enablePhasedLoading !== false;\n    }\n\n    /**\n     * Returns [[DataSource]]s displayed by this `MapView`.\n     */\n    get dataSources(): DataSource[] {\n        return this.m_tileDataSources;\n    }\n\n    /**\n     * Set's the way in which the fov is calculated on the map view. Note, for\n     * this to take visual effect, the map should be rendered after calling this\n     * function.\n     * @param fovCalculation How the FOV is calculated.\n     */\n    setFovCalculation(fovCalculation: FovCalculation) {\n        this.m_options.fovCalculation = fovCalculation;\n        this.calculateFocalLength(this.m_renderer.getSize(cache.vector2[0]).height);\n        this.updateCameras();\n    }\n\n    /**\n     * Returns the unique [[DataSource]] matching the given name.\n     */\n    getDataSourceByName(dataSourceName: string): DataSource | undefined {\n        return this.m_tileDataSources.find(ds => ds.name === dataSourceName);\n    }\n\n    /**\n     * Returns the array of [[DataSource]]s referring to the same [[StyleSet]].\n     */\n    getDataSourcesByStyleSetName(styleSetName: string): DataSource[] {\n        return this.m_tileDataSources.filter(ds => ds.styleSetName === styleSetName);\n    }\n\n    /**\n     * Returns true if the specified [[DataSource]] is enabled.\n     */\n    isDataSourceEnabled(dataSource: DataSource): boolean {\n        return (\n            dataSource.enabled &&\n            dataSource.ready() &&\n            this.m_connectedDataSources.has(dataSource.name)\n        );\n    }\n\n    /**\n     * Adds a new [[DataSource]] to this `MapView`. `MapView` needs at least one [[DataSource]] to\n     * display something.\n     *\n     * @param dataSource The data source.\n     */\n    addDataSource(dataSource: DataSource): Promise<void> {\n        const twinDataSource = this.getDataSourceByName(dataSource.name);\n        if (twinDataSource !== undefined) {\n            throw new Error(\n                `A DataSource with the name \"${dataSource.name}\" already exists in this MapView.`\n            );\n        }\n\n        dataSource.attach(this);\n        dataSource.setEnableElevationOverlay(this.m_elevationProvider !== undefined);\n        this.m_tileDataSources.push(dataSource);\n\n        if (this.m_backgroundDataSource) {\n            this.m_backgroundDataSource.updateStorageLevelOffset();\n        }\n\n        return dataSource\n            .connect()\n            .then(() => {\n                return new Promise(resolve => {\n                    if (this.theme !== undefined && this.theme.styles !== undefined) {\n                        resolve();\n                        return;\n                    }\n\n                    const resolveOnce = () => {\n                        this.removeEventListener(MapViewEventNames.ThemeLoaded, resolveOnce);\n                        resolve();\n                    };\n\n                    this.addEventListener(MapViewEventNames.ThemeLoaded, resolveOnce);\n                });\n            })\n            .then(() => {\n                const alreadyRemoved = this.m_tileDataSources.indexOf(dataSource) === -1;\n                if (alreadyRemoved) {\n                    return;\n                }\n                dataSource.addEventListener(MapViewEventNames.Update, () => {\n                    this.update();\n                });\n\n                dataSource.setTheme(this.m_theme);\n\n                this.m_connectedDataSources.add(dataSource.name);\n\n                this.dispatchEvent({\n                    type: MapViewEventNames.DataSourceConnect,\n                    dataSourceName: dataSource.name\n                });\n\n                this.update();\n            })\n            .catch(error => {\n                logger.error(\n                    `Failed to connect to datasource ${dataSource.name}: ${error.message}`\n                );\n\n                this.m_failedDataSources.add(dataSource.name);\n                this.dispatchEvent({\n                    type: MapViewEventNames.DataSourceConnect,\n                    dataSourceName: dataSource.name,\n                    error\n                });\n            });\n    }\n\n    /**\n     * Removes [[DataSource]] from this `MapView`.\n     *\n     * @param dataSource The data source to be removed\n     */\n    removeDataSource(dataSource: DataSource) {\n        const dsIndex = this.m_tileDataSources.indexOf(dataSource);\n        if (dsIndex === -1) {\n            return;\n        }\n        dataSource.detach(this);\n\n        this.m_visibleTiles.removeDataSource(dataSource);\n        this.m_tileDataSources.splice(dsIndex, 1);\n        this.m_connectedDataSources.delete(dataSource.name);\n        this.m_failedDataSources.delete(dataSource.name);\n\n        if (this.m_backgroundDataSource) {\n            this.m_backgroundDataSource.updateStorageLevelOffset();\n        }\n\n        this.update();\n    }\n\n    /**\n     * Access the `VisibleTileSet` to get access to all current datasources and their visible tiles.\n     */\n    get visibleTileSet(): VisibleTileSet {\n        return this.m_visibleTiles;\n    }\n\n    /**\n     * Adds new overlay text elements to this `MapView`.\n     *\n     * @param textElements Array of [[TextElement]] to be added.\n     */\n    addOverlayText(textElements: TextElement[]): void {\n        this.m_textElementsRenderer.addOverlayText(textElements);\n        this.update();\n    }\n\n    /**\n     * Adds new overlay text elements to this `MapView`.\n     *\n     * @param textElements Array of [[TextElement]] to be added.\n     */\n    clearOverlayText(): void {\n        this.m_textElementsRenderer.clearOverlayText();\n    }\n\n    /**\n     * The method that sets the camera to the desired angle (`tiltDeg`) and `distance` (in meters)\n     * to the `target` location, from a certain heading (`headingAngle`).\n     *\n     * @param target The location to look at.\n     * @param distance The distance of the camera to the target in meters.\n     * @param tiltDeg The camera tilt angle in degrees (0 is vertical), curbed below 89deg.\n     * @param headingDeg The camera heading angle in degrees and clockwise (as opposed to yaw),\n     * starting north.\n     */\n    lookAt(\n        target: GeoCoordinates,\n        distance: number,\n        tiltDeg: number = 0,\n        headingDeg: number = 0\n    ): void {\n        const limitedTilt = Math.min(89, tiltDeg);\n        // MapViewUtils#setRotation uses pitch, not tilt, which is different in sphere projection.\n        // But in sphere, in the tangent space of the target of the camera, pitch = tilt. So, put\n        // the camera on the target, so the tilt can be passed to getRotation as a pitch.\n        MapViewUtils.getCameraRotationAtTarget(\n            this.projection,\n            target,\n            -headingDeg,\n            limitedTilt,\n            this.camera.quaternion\n        );\n        MapViewUtils.getCameraPositionFromTargetCoordinates(\n            target,\n            distance,\n            -headingDeg,\n            limitedTilt,\n            this.projection,\n            this.camera.position\n        );\n        this.camera.updateMatrixWorld(true);\n    }\n\n    /**\n     * Moves the camera to the specified [[GeoCoordinates]], sets the desired `zoomLevel` and\n     * adjusts the yaw and pitch. The pitch of the camera is always curbed so that the camera cannot\n     * look above the horizon. This paradigm is necessary in [[MapControls]], where the center of \\\n     * the screen is used for the orbiting interaction (3 fingers / right mouse button).\n     *\n     * @param geoPos Geolocation to move the camera to.\n     * @param zoomLevel Desired zoom level.\n     * @param yawDeg Camera yaw in degrees, counter-clockwise (as opposed to heading), starting\n     * north.\n     * @param pitchDeg Camera pitch in degrees.\n     */\n    setCameraGeolocationAndZoom(\n        geoPos: GeoCoordinates,\n        zoomLevel: number,\n        yawDeg: number = 0,\n        pitchDeg: number = 0\n    ): void {\n        this.geoCenter = geoPos;\n        let limitedPitch = Math.min(89, pitchDeg); // 90 leads to imprecision issues.\n        if (this.projection.type === ProjectionType.Spherical) {\n            const maxPitchRadWithCurvature = Math.asin(\n                EarthConstants.EQUATORIAL_RADIUS /\n                    (MapViewUtils.calculateDistanceToGroundFromZoomLevel(this, zoomLevel) +\n                        EarthConstants.EQUATORIAL_RADIUS)\n            );\n            const maxPitchDegWithCurvature = THREE.Math.radToDeg(maxPitchRadWithCurvature);\n            limitedPitch = Math.min(limitedPitch, maxPitchDegWithCurvature);\n        }\n        MapViewUtils.zoomOnTargetPosition(this, 0, 0, zoomLevel);\n        MapViewUtils.setRotation(this, yawDeg, limitedPitch);\n        this.update();\n    }\n\n    /**\n     * Returns `true` if this `MapView` is constantly redrawing the scene.\n     */\n    get animating(): boolean {\n        return this.m_animationCount > 0;\n    }\n\n    /**\n     * Begin animating the scene.\n     */\n    beginAnimation() {\n        if (this.m_animationCount++ === 0) {\n            if (!this.m_updatePending) {\n                this.m_updatePending = true;\n                this.drawFrame();\n            }\n            ANIMATION_STARTED_EVENT.time = Date.now();\n            this.dispatchEvent(ANIMATION_STARTED_EVENT);\n        }\n    }\n\n    /**\n     * Stop animating the scene.\n     */\n    endAnimation() {\n        if (this.m_animationCount > 0) {\n            --this.m_animationCount;\n        }\n\n        if (this.m_animationCount === 0) {\n            ANIMATION_FINISHED_EVENT.time = Date.now();\n            this.dispatchEvent(ANIMATION_FINISHED_EVENT);\n        }\n    }\n\n    /**\n     * Returns `true` if the camera moved in the last frame.\n     */\n    get cameraIsMoving() {\n        return this.m_movementDetector.cameraIsMoving;\n    }\n\n    /**\n     * Returns `true` if the current frame will immediately be followed by another frame.\n     */\n    get isDynamicFrame(): boolean {\n        return (\n            this.cameraIsMoving ||\n            this.animating ||\n            this.m_updatePending ||\n            this.m_animatedExtrusionHandler.isAnimating\n        );\n    }\n\n    /**\n     * Returns the ratio between a pixel and a world unit for the current camera (in the center of\n     * the camera projection).\n     */\n    get pixelToWorld(): number {\n        if (this.m_pixelToWorld === undefined) {\n            // At this point fov calculation should be always defined.\n            assert(this.m_options.fovCalculation !== undefined);\n            // NOTE: Look at distance is the distance to camera focus (and pivot) point.\n            // In screen space this point is located in the center of canvas.\n            // Given that zoom level is not modified (clamped by camera pitch), the following\n            // formulas are all equivalent:\n            // lookAtDistance = (EQUATORIAL_CIRCUMFERENCE * focalLength) / (256 * zoomLevel^2);\n            // lookAtDistance = abs(cameraPos.z) / cos(cameraPitch);\n            // Here we may use precalculated distance (once pre frame):\n            const lookAtDistance = this.m_lookAtDistance;\n\n            // Find world space object size that corresponds to one pixel on screen.\n            this.m_pixelToWorld = MapViewUtils.calculateWorldSizeByFocalLength(\n                this.m_focalLength,\n                lookAtDistance,\n                1\n            );\n        }\n        return this.m_pixelToWorld;\n    }\n\n    /**\n     * Returns the ratio between a world and a pixel unit for the current camera (in the center of\n     * the camera projection).\n     */\n    get worldToPixel() {\n        return 1.0 / this.pixelToWorld;\n    }\n\n    get pixelRatio(): number {\n        if (this.m_pixelRatio !== undefined) {\n            return this.m_pixelRatio;\n        }\n        return typeof window !== \"undefined\" && window.devicePixelRatio !== undefined\n            ? window.devicePixelRatio\n            : 1.0;\n    }\n\n    /**\n     * PixelRatio in the WebGlRenderer. May contain values > 1.0 for high resolution screens\n     * (HiDPI).\n     *\n     * A value of `undefined` will make the getter return `window.devicePixelRatio`, setting a value\n     * of `1.0` will disable the use of HiDPI on all devices.\n     *\n     * @note Since the current pixelRatio may have been used in some calculations (e.g. the icons)\n     * they may appear in the wrong size now. To ensure proper display of data, a call to\n     * `clearTileCache()` is required if the pixelRatio is changed after tiles have been loaded.\n     *\n     * @memberof MapView\n     */\n    set pixelRatio(pixelRatio: number) {\n        this.m_pixelRatio = pixelRatio;\n        if (this.renderer.getPixelRatio() !== this.pixelRatio) {\n            this.renderer.setPixelRatio(this.pixelRatio);\n        }\n    }\n\n    /**\n     * PixelRatio ratio for rendering when the camera is moving or an animation is running. Useful\n     * when rendering on high resolution displays with low performance GPUs that may be\n     * fill-rate-limited.\n     *\n     * If a value is specified, a low resolution render pass is used to render the scene into a\n     * low resolution render target, before it is copied to the screen.\n     *\n     * A value of `undefined` disables the low res render pass. Values between 0.5 and\n     * `window.devicePixelRatio` can be tried to give  good results. The value should not be larger\n     * than `window.devicePixelRatio`.\n     *\n     * @note Since no anti-aliasing is applied during dynamic rendering with `dynamicPixelRatio`\n     * defined, visual artifacts may occur, especially with thin lines..\n     *\n     * @note The resolution of icons and text labels is not affected.\n     *\n     * @default `undefined`\n     */\n    set dynamicPixelRatio(ratio: number | undefined) {\n        this.mapRenderingManager.lowResPixelRatio = ratio;\n    }\n\n    get dynamicPixelRatio(): number | undefined {\n        return this.mapRenderingManager.lowResPixelRatio;\n    }\n\n    /**\n     * Returns the screen position of the given geo coordinates.\n     *\n     * @param geoPos The geo coordinates.\n     * @returns The screen position in CSS/client coordinates (no pixel ratio applied) or\n     * `undefined`.\n     */\n    getScreenPosition(geoPos: GeoCoordinates): THREE.Vector2 | undefined {\n        this.projection.projectPoint(geoPos, cache.vector3[0]);\n        const p = this.m_screenProjector.project(cache.vector3[0]);\n        if (p !== undefined) {\n            const { width, height } = this.getCanvasClientSize();\n            p.x = p.x + width / 2;\n            p.y = height - (p.y + height / 2);\n        }\n        return p;\n    }\n\n    /**\n     * Returns a ray caster using the supplied screen positions.\n     *\n     * @param x The X position in css/client coordinates (without applied display ratio).\n     * @param y The Y position in css/client coordinates (without applied display ratio).\n     *\n     * @alpha\n     *\n     * @return Raycaster with origin at the camera and direction based on the supplied x / y screen\n     * points.\n     */\n    raycasterFromScreenPoint(x: number, y: number): THREE.Raycaster {\n        this.m_raycaster.setFromCamera(this.getNormalizedScreenCoordinates(x, y), this.m_rteCamera);\n        return this.m_raycaster;\n    }\n\n    /**\n     * Returns the world space position from the given screen position. The return value can be\n     * `null`, in case the camera is facing the horizon and the given `(x, y)` value is not\n     * intersecting the ground plane.\n     *\n     * @param x The X position in css/client coordinates (without applied display ratio).\n     * @param y The Y position in css/client coordinates (without applied display ratio).\n     */\n    getWorldPositionAt(x: number, y: number): THREE.Vector3 | null {\n        this.m_raycaster.setFromCamera(this.getNormalizedScreenCoordinates(x, y), this.m_camera);\n        return this.projection.type === ProjectionType.Spherical\n            ? this.m_raycaster.ray.intersectSphere(this.m_sphere, cache.vector3[0])\n            : this.m_raycaster.ray.intersectPlane(this.m_plane, cache.vector3[0]);\n    }\n\n    /**\n     * Returns the [[GeoCoordinates]] from the given screen position. The return value can be\n     * `null`, in case the camera is facing the horizon and the given `(x, y)` value is not\n     * intersecting the ground plane.\n     *\n     * @param x The X position in css/client coordinates (without applied display ratio).\n     * @param y The Y position in css/client coordinates (without applied display ratio).\n     */\n    getGeoCoordinatesAt(x: number, y: number): GeoCoordinates | null {\n        const worldPosition = this.getWorldPositionAt(x, y);\n        if (!worldPosition) {\n            return null;\n        }\n        return this.projection.unprojectPoint(worldPosition);\n    }\n\n    /**\n     * Returns the normalized screen coordinates from the given pixel position.\n     *\n     * @param x The X position in css/client coordinates (without applied display ratio).\n     * @param y The Y position in css/client coordinates (without applied display ratio).\n     */\n    getNormalizedScreenCoordinates(x: number, y: number): THREE.Vector3 {\n        // use clientWidth and clientHeight as it does not apply the pixelRatio and\n        // therefore supports also HiDPI devices\n        const { width, height } = this.getCanvasClientSize();\n        return new THREE.Vector3((x / width) * 2 - 1, -((y / height) * 2) + 1, 0);\n    }\n\n    /**\n     * Do a raycast on all objects in the scene. Useful for picking. Limited to objects that\n     * THREE.js can raycast, the solid lines that get their geometry in the shader cannot be tested\n     * for intersection.\n     *\n     * Note, if a [[DataSource]] adds an [[Object3D]] to a [[Tile]], it will be only pickable once\n     * [[MapView.render]] has been called, this is because [[MapView.render]] method creates the\n     * internal three.js root [[Object3D]] which is used in the [[PickHandler]] internally.\n     * This method will not test for intersection custom objects added to the scene by for\n     * example calling directly the [[scene.add]] method from THREE.\n     *\n     * @param x The X position in css/client coordinates (without applied display ratio).\n     * @param y The Y position in css/client coordinates (without applied display ratio).\n     * @returns The list of intersection results.\n     */\n    intersectMapObjects(x: number, y: number): PickResult[] {\n        return this.m_pickHandler.intersectMapObjects(x, y);\n    }\n\n    /**\n     * Resize the HTML canvas element and the THREE.js `WebGLRenderer`.\n     *\n     * @param width The new width.\n     * @param height The new height.\n     */\n    resize(width: number, height: number) {\n        this.m_renderer.setSize(width, height, false);\n        if (this.m_renderer.getPixelRatio() !== this.pixelRatio) {\n            this.m_renderer.setPixelRatio(this.pixelRatio);\n        }\n\n        if (this.mapRenderingManager !== undefined) {\n            this.mapRenderingManager.setSize(width, height);\n        }\n\n        if (this.collisionDebugCanvas !== undefined) {\n            this.collisionDebugCanvas.width = width;\n            this.collisionDebugCanvas.height = height;\n        }\n\n        this.updateCameras();\n        this.update();\n\n        this.dispatchEvent({\n            type: MapViewEventNames.Resize,\n            size: {\n                width,\n                height\n            }\n        });\n    }\n\n    /**\n     * Redraws scene immediately\n     *\n     * @note Before using this method, set `synchronousRendering` to `true`\n     * in the [[MapViewOptions]]\n     */\n    renderSync() {\n        this.renderFunc(PerformanceTimer.now());\n    }\n\n    /**\n     * Requests a redraw of the scene.\n     */\n    update() {\n        this.dispatchEvent(UPDATE);\n\n        if (this.m_updatePending) {\n            return;\n        } // compress the update request\n\n        this.m_updatePending = true;\n\n        if (this.animating) {\n            return;\n        } // nothing to do\n\n        this.drawFrame();\n    }\n\n    /**\n     * Returns `true` if an update has already been requested, such that after a currently rendering\n     * frame, the next frame will be rendered immediately.\n     */\n    get updatePending(): boolean {\n        return this.m_updatePending;\n    }\n\n    /**\n     * Requests a redraw of the scene.\n     * @deprecated Use the [[update]] method instead.\n     */\n    requestUpdateIfNeeded() {\n        this.update();\n    }\n\n    /**\n     * Clear the tile cache.\n     *\n     * Remove the [[Tile]] objects created by cacheable [[DataSource]]s. If a [[DataSource]] name is\n     * provided, this method restricts the eviction the [[DataSource]] with the given name.\n     *\n     * @param dataSourceName The name of the [[DataSource]].\n     */\n    clearTileCache(dataSourceName?: string) {\n        if (dataSourceName !== undefined) {\n            const dataSource = this.getDataSourceByName(dataSourceName);\n            if (dataSource) {\n                this.m_visibleTiles.clearTileCache(dataSource);\n                dataSource.clearCache();\n            }\n        } else {\n            this.m_visibleTiles.clearTileCache();\n            this.m_tileDataSources.forEach(dataSource => dataSource.clearCache());\n        }\n\n        if (this.m_elevationProvider !== undefined) {\n            this.m_elevationProvider.clearCache();\n        }\n    }\n\n    /**\n     * Apply visitor to all visible tiles.\n     *\n     * @param fun Visitor function\n     */\n    forEachVisibleTile(fun: (tile: Tile) => void) {\n        this.m_visibleTiles.forEachVisibleTile(fun);\n    }\n\n    /**\n     * Apply a visitor function to all tiles in the cache.\n     *\n     * @param visitor Visitor function\n     */\n    forEachCachedTile(visitor: (tile: Tile) => void) {\n        this.m_visibleTiles.forEachCachedTile(visitor);\n    }\n\n    /**\n     * Visit each tile in visible, rendered, and cached sets.\n     *\n     *  * Visible and temporarily rendered tiles will be marked for update and retained.\n     *  * Cached but not rendered/visible will be evicted.\n     *\n     * @param dataSource If passed, only the tiles from this [[DataSource]] instance are processed.\n     * If `undefined`, tiles from all [[DataSource]]s are processed.\n     */\n    markTilesDirty(dataSource?: DataSource) {\n        this.m_visibleTiles.markTilesDirty(dataSource);\n    }\n\n    /**\n     * Sets the DataSource which contains the elevations, the elevation range source, and the\n     * elevation provider. Only a single elevation source is possible per [[MapView]]\n     *\n     * If the terrain-datasource is merged with this repository, we could internally construct\n     * the [[ElevationRangeSource]] and the [[ElevationProvider]] and access would be granted to\n     * the application when it asks for it, to simplify the API.\n     *\n     * @param elevationSource The datasource containing the terrain tiles.\n     * @param elevationRangeSource Allows access to the elevation min / max per tile.\n     * @param elevationProvider Allows access to the elevation at a given location or a ray\n     *      from the camera.\n     */\n    setElevationSource(\n        elevationSource: DataSource,\n        elevationRangeSource: ElevationRangeSource,\n        elevationProvider: ElevationProvider\n    ) {\n        // Try to remove incase this method was already called, will do nothing if it doesn't exist.\n        this.removeDataSource(elevationSource);\n        this.addDataSource(elevationSource);\n        this.m_elevationRangeSource = elevationRangeSource;\n        this.m_elevationRangeSource.connect();\n        this.m_elevationProvider = elevationProvider;\n        this.dataSources.forEach(dataSource => {\n            dataSource.setEnableElevationOverlay(true);\n        });\n        this.m_tileGeometryManager.setTileUpdateCallback((tile: Tile) => {\n            overlayOnElevation(tile);\n        });\n        this.clearTileCache();\n    }\n\n    /**\n     * Clears any elevation sources and provider previously set.\n     * @param elevationSource The datasource to be cleared.\n     */\n    clearElevationSource(elevationSource: DataSource) {\n        this.removeDataSource(elevationSource);\n        this.m_elevationRangeSource = undefined;\n        this.m_elevationProvider = undefined;\n        this.dataSources.forEach(dataSource => {\n            dataSource.setEnableElevationOverlay(false);\n        });\n        this.m_tileGeometryManager.setTileUpdateCallback(undefined);\n        this.clearTileCache();\n    }\n\n    /**\n     * Public access to [[MapViewFog]] allowing to toggle it by setting its `enabled` property.\n     */\n    get fog(): MapViewFog {\n        return this.m_fog;\n    }\n\n    private setPostEffects() {\n        // First clear all the effects, then enable them from what is specified.\n        this.mapRenderingManager.bloom.enabled = false;\n        this.mapRenderingManager.outline.enabled = false;\n        this.mapRenderingManager.vignette.enabled = false;\n        this.mapRenderingManager.sepia.enabled = false;\n\n        if (this.m_postEffects !== undefined) {\n            if (this.m_postEffects.bloom !== undefined) {\n                this.mapRenderingManager.bloom = this.m_postEffects.bloom;\n            }\n            if (this.m_postEffects.outline !== undefined) {\n                this.mapRenderingManager.outline.enabled = this.m_postEffects.outline.enabled;\n                this.mapRenderingManager.updateOutline(this.m_postEffects.outline);\n            }\n            if (this.m_postEffects.vignette !== undefined) {\n                this.mapRenderingManager.vignette = this.m_postEffects.vignette;\n            }\n            if (this.m_postEffects.sepia !== undefined) {\n                this.mapRenderingManager.sepia = this.m_postEffects.sepia;\n            }\n        }\n    }\n\n    /**\n     * Returns the elevation provider.\n     */\n    get elevationProvider(): ElevationProvider | undefined {\n        return this.m_elevationProvider;\n    }\n\n    /**\n     * Plug-in PolarTileDataSource for spherical projection and plug-out otherwise\n     */\n    private updatePolarDataSource() {\n        const dataSource = this.m_polarDataSource;\n        if (this.m_enablePolarDataSource === true && dataSource !== undefined) {\n            const twinDataSource = this.getDataSourceByName(dataSource.name);\n\n            if (this.projection.type === ProjectionType.Spherical) {\n                if (twinDataSource === undefined) {\n                    this.addDataSource(dataSource);\n                }\n            } else {\n                if (twinDataSource !== undefined) {\n                    this.removeDataSource(dataSource);\n                }\n            }\n        }\n    }\n\n    /**\n     * Updates the camera and the projections and resets the screen collisions,\n     * note, setupCamera must be called before this is called.\n     * @param viewRanges optional parameter that supplies new view ranges, most importantly\n     * near/far clipping planes distance. If parameter is not provided view ranges will be\n     * calculated from [[ClipPlaneEvaluator]] used in [[VisibleTileSet]].\n     */\n    private updateCameras(viewRanges?: ViewRanges) {\n        const { width, height } = this.m_renderer.getSize(cache.vector2[0]);\n        this.m_camera.aspect =\n            this.m_forceCameraAspect !== undefined ? this.m_forceCameraAspect : width / height;\n        this.setFovOnCamera(this.m_options.fovCalculation!, height);\n\n        // When calculating clip planes account for the highest building on the earth,\n        // multiplying its height by projection scaling factor. This approach assumes\n        // constantHeight property of extruded polygon technique is set as default false,\n        // otherwise the near plane margins will be bigger then required, but still correct.\n        const projectionScale = this.projection.getScaleFactor(this.camera.position);\n        const maxGeometryHeightScaled =\n            projectionScale *\n            this.m_tileDataSources.reduce((r, ds) => Math.max(r, ds.maxGeometryHeight), 0);\n\n        // Copy all properties from new view ranges to our readonly object.\n        // This allows to keep all view ranges references valid and keeps up-to-date\n        // information within them. Works the same as copping all properties one-by-one.\n        Object.assign(\n            this.m_viewRanges,\n            viewRanges === undefined\n                ? this.m_visibleTiles.updateClipPlanes(maxGeometryHeightScaled)\n                : viewRanges\n        );\n        this.m_camera.near = this.m_viewRanges.near;\n        this.m_camera.far = this.m_viewRanges.far;\n\n        this.m_camera.updateProjectionMatrix();\n        this.m_camera.updateMatrixWorld(false);\n\n        // Update the \"relative to eye\" camera. Copy the public camera parameters\n        // and place the \"relative to eye\" at the world's origin.\n        this.m_rteCamera.copy(this.m_camera);\n        this.m_rteCamera.position.setScalar(0);\n        this.m_rteCamera.updateMatrixWorld(true);\n\n        this.m_screenCamera.left = width / -2;\n        this.m_screenCamera.right = width / 2;\n        this.m_screenCamera.bottom = height / -2;\n        this.m_screenCamera.top = height / 2;\n        this.m_screenCamera.updateProjectionMatrix();\n        this.m_screenCamera.updateMatrixWorld(false);\n\n        this.m_screenProjector.update(this.camera, width, height);\n        this.m_screenCollisions.update(width, height);\n\n        this.m_pixelToWorld = undefined;\n\n        const cameraPitch = MapViewUtils.extractAttitude(this, this.m_camera).pitch;\n        const cameraPosZ = this.getCameraHeightAboveTerrain(TERRAIN_ZOOM_LEVEL);\n\n        const target = MapViewUtils.rayCastWorldCoordinates(this, 0, 0);\n        if (target !== null) {\n            this.m_lookAtDistance = target.sub(this.camera.position).length();\n            const zoomLevelDistance = cameraPosZ / Math.cos(Math.min(cameraPitch, Math.PI / 3));\n            this.m_zoomLevel = MapViewUtils.calculateZoomLevelFromDistance(zoomLevelDistance, this);\n            this.m_fog.update(this, this.m_viewRanges.maximum);\n        }\n    }\n\n    /**\n     * Returns the height of the camera above the earths surface.\n     *\n     * If there is an ElevationProvider, this is used. Otherwise the projection is used to determine\n     * how high the camera is above the surface.\n     *\n     * @param level Which level to request the surface height from.\n     * @return Height in world units.\n     */\n    private getCameraHeightAboveTerrain(level?: number): number {\n        if (this.elevationProvider !== undefined) {\n            const heightAboveTerrain = this.elevationProvider.getHeight(this.geoCenter, level);\n            if (heightAboveTerrain !== undefined) {\n                const height =\n                    this.projection.unprojectAltitude(this.m_camera.position) - heightAboveTerrain;\n                return Math.max(height, 1);\n            }\n        }\n        return Math.abs(this.projection.groundDistance(this.m_camera.position));\n    }\n\n    private detectCurrentFps(now: number) {\n        // Skip the first frames, they are from not originated from requestAnimationFrame()\n        if (this.m_previousRequestAnimationTime !== undefined && this.m_frameNumber > 5) {\n            const currentFps = 1000 / (now - this.m_previousRequestAnimationTime);\n            this.m_frameTimeRing[this.m_frameTimeIndex % FRAME_RATE_RING_SIZE] = currentFps;\n            this.m_frameTimeIndex++;\n\n            const capturedFrames = Math.min(this.m_frameTimeIndex, FRAME_RATE_RING_SIZE);\n\n            let sum = 0;\n            for (let i = 0; i < capturedFrames; i++) {\n                sum += this.m_frameTimeRing[i];\n            }\n\n            this.m_detectedFps = sum / capturedFrames;\n        }\n        this.m_previousRequestAnimationTime = now;\n    }\n\n    /**\n     * Draw a new frame.\n     */\n    private drawFrame() {\n        if (this.m_drawing || this.m_options.synchronousRendering) {\n            return;\n        }\n        // Cancel an active requestAnimationFrame() cycle. Failure to do this may end up in\n        // rendering multiple times during a single frame.\n        if (this.m_animationFrameHandle !== undefined) {\n            cancelAnimationFrame(this.m_animationFrameHandle);\n            this.m_animationFrameHandle = undefined;\n        }\n\n        if (this.m_maxFps <= 0) {\n            // Render at maximum FPS.\n            this.m_animationFrameHandle = requestAnimationFrame(this.handleRequestAnimationFrame);\n            return;\n        }\n\n        // Magic ingredient to compensate time flux.\n        const fudgeTimeInMs = 3;\n        const vSyncFrameTime = 1000 / this.m_detectedFps;\n        const frameInterval = 1000 / this.m_maxFps;\n\n        const previousFrameTime =\n            this.m_previousFrameTimeStamp === undefined ? 0 : this.m_previousFrameTimeStamp;\n\n        // Compute a practical value to compare against.\n        const targetTime = previousFrameTime + frameInterval - vSyncFrameTime - fudgeTimeInMs;\n\n        this.m_targetRequestAnimationTime = targetTime;\n        this.postponedAnimationFrame(previousFrameTime);\n    }\n\n    private postponedAnimationFrame(now: number) {\n        if (this.m_targetRequestAnimationTime === undefined) {\n            return;\n        }\n\n        if (this.m_animationFrameHandle !== undefined) {\n            cancelAnimationFrame(this.m_animationFrameHandle);\n            this.m_animationFrameHandle = undefined;\n        }\n\n        this.detectCurrentFps(now);\n\n        this.m_animationFrameHandle = requestAnimationFrame(\n            now > this.m_targetRequestAnimationTime\n                ? this.handleRequestAnimationFrame\n                : this.handlePostponedAnimationFrame\n        );\n    }\n\n    /**\n     * Draw a new frame.\n     */\n    private renderFunc(time: number) {\n        this.render(time);\n    }\n\n    /**\n     * Returns the list of the enabled data sources.\n     */\n    private getEnabledTileDataSources(): DataSource[] {\n        // ### build this list once decoders && datasources are ready\n\n        const enabledDataSources: DataSource[] = [];\n\n        for (const dataSource of this.m_tileDataSources) {\n            if (this.isDataSourceEnabled(dataSource)) {\n                enabledDataSources.push(dataSource);\n            }\n        }\n\n        return enabledDataSources;\n    }\n\n    /**\n     * Renders the current frame.\n     */\n    private render(time: number): void {\n        if (this.m_drawing) {\n            return;\n        }\n        ++this.m_frameNumber;\n\n        const stats = PerformanceStatistics.instance;\n        const gatherStatistics: boolean = stats.enabled;\n\n        const frameStartTime = time;\n\n        RENDER_EVENT.time = time;\n        this.dispatchEvent(RENDER_EVENT);\n\n        let currentFrameEvent: FrameStats | undefined;\n\n        if (gatherStatistics) {\n            currentFrameEvent = stats.currentFrame;\n            currentFrameEvent.setValue(\"renderCount.frameNumber\", this.m_frameNumber);\n\n            if (this.m_previousFrameTimeStamp !== undefined) {\n                const timeSincePreviousFrame = frameStartTime - this.m_previousFrameTimeStamp;\n                if (gatherStatistics) {\n                    currentFrameEvent.setValue(\"render.fullFrameTime\", timeSincePreviousFrame);\n                    // For convenience and easy readability\n                    currentFrameEvent.setValue(\"render.fps\", 1000 / timeSincePreviousFrame);\n                }\n            }\n        }\n\n        this.m_previousFrameTimeStamp = frameStartTime;\n\n        let setupTime: number | undefined;\n        let cullTime: number | undefined;\n        let textPlacementTime: number | undefined;\n        let drawTime: number | undefined;\n        let textDrawTime: number | undefined;\n        let endTime: number | undefined;\n\n        this.m_renderer.info.reset();\n\n        this.m_updatePending = false;\n        this.m_thisFrameTilesChanged = undefined;\n\n        this.m_drawing = true;\n\n        if (this.m_renderer.getPixelRatio() !== this.pixelRatio) {\n            this.m_renderer.setPixelRatio(this.pixelRatio);\n        }\n\n        this.updateCameras();\n        this.m_renderer.clear();\n\n        // clear the scene\n        while (this.m_mapTilesRoot.children.length > 0) {\n            this.m_mapTilesRoot.remove(this.m_mapTilesRoot.children[0]);\n        }\n\n        if (gatherStatistics) {\n            setupTime = PerformanceTimer.now();\n        }\n\n        // TBD: Update renderList only any of its params (camera, etc...) has changed.\n        if (!this.lockVisibleTileSet) {\n            const viewRangesStatus = this.m_visibleTiles.updateRenderList(\n                this.storageLevel,\n                Math.floor(this.zoomLevel),\n                this.getEnabledTileDataSources(),\n                this.m_elevationRangeSource\n            );\n            // View ranges has changed due to features (with elevation) that affects clip planes\n            // positioning, update cameras with new clip planes positions.\n            if (viewRangesStatus.viewRangesChanged) {\n                this.updateCameras(viewRangesStatus.viewRanges);\n            }\n        }\n\n        if (gatherStatistics) {\n            cullTime = PerformanceTimer.now();\n        }\n\n        const renderList = this.m_visibleTiles.dataSourceTileList;\n\n        // no need to check everything if we're not going to create text renderer.\n        renderList.forEach(({ zoomLevel, renderedTiles }) => {\n            renderedTiles.forEach(tile => {\n                this.renderTileObjects(tile, zoomLevel);\n\n                //We know that rendered tiles are visible (in the view frustum), so we update the\n                //frame number, note we don't do this for the visibleTiles because some may still be\n                //loading (and therefore aren't visible in the sense of being seen on the screen).\n                //Note also, this number isn't currently used anywhere so should be considered to be\n                //removed in the future (though could be good for debugging purposes).\n                tile.frameNumLastVisible = this.m_frameNumber;\n            });\n        });\n\n        // Check if this is the time to place the labels for the first time. Pretty much everything\n        // should have been loaded, and no animation should be running.\n        if (\n            !this.m_initialTextPlacementDone &&\n            !this.m_firstFrameComplete &&\n            !this.isDynamicFrame &&\n            !this.m_themeIsLoading &&\n            this.m_poiTableManager.finishedLoading &&\n            this.m_visibleTiles.allVisibleTilesLoaded &&\n            this.m_connectedDataSources.size + this.m_failedDataSources.size ===\n                this.m_tileDataSources.length &&\n            !this.m_textElementsRenderer.initializing &&\n            !this.m_textElementsRenderer.loading\n        ) {\n            this.m_initialTextPlacementDone = true;\n        }\n\n        this.m_mapAnchors.children.forEach((childObject: MapAnchor) => {\n            if (childObject.geoPosition === undefined) {\n                return;\n            }\n            this.projection.projectPoint(childObject.geoPosition, childObject.position);\n            childObject.position.sub(this.camera.position);\n        });\n\n        this.m_animatedExtrusionHandler.zoom = this.m_zoomLevel;\n\n        if (currentFrameEvent !== undefined) {\n            // Make sure the counters all have a value.\n            currentFrameEvent.addValue(\"renderCount.numTilesRendered\", 0);\n            currentFrameEvent.addValue(\"renderCount.numTilesVisible\", 0);\n            currentFrameEvent.addValue(\"renderCount.numTilesLoading\", 0);\n\n            // Increment the counters for all data sources.\n            renderList.forEach(({ zoomLevel, renderedTiles, visibleTiles, numTilesLoading }) => {\n                currentFrameEvent!.addValue(\"renderCount.numTilesRendered\", renderedTiles.size);\n                currentFrameEvent!.addValue(\"renderCount.numTilesVisible\", visibleTiles.length);\n                currentFrameEvent!.addValue(\"renderCount.numTilesLoading\", numTilesLoading);\n            });\n        }\n\n        if (this.m_movementDetector.checkCameraMoved(this, time)) {\n            const { yaw, pitch, roll } = MapViewUtils.extractAttitude(this, this.camera);\n            const { latitude, longitude, altitude } = this.geoCenter;\n            this.dispatchEvent({\n                type: MapViewEventNames.CameraPositionChanged,\n                latitude,\n                longitude,\n                altitude,\n                yaw,\n                pitch,\n                roll,\n                zoom: this.zoomLevel\n            });\n        }\n\n        // The camera used to render the scene.\n        const camera = this.m_pointOfView !== undefined ? this.m_pointOfView : this.m_rteCamera;\n\n        if (this.renderLabels) {\n            this.prepareRenderTextElements(time);\n        }\n\n        if (gatherStatistics) {\n            textPlacementTime = PerformanceTimer.now();\n        }\n        if (this.m_skyBackground !== undefined && this.projection.type === ProjectionType.Planar) {\n            this.m_skyBackground.updateCamera(this.m_camera);\n        }\n\n        this.mapRenderingManager.render(\n            this.m_renderer,\n            this.m_scene,\n            camera,\n            !this.isDynamicFrame\n        );\n\n        if (gatherStatistics) {\n            drawTime = PerformanceTimer.now();\n        }\n\n        if (this.renderLabels) {\n            this.finishRenderTextElements();\n        }\n\n        if (gatherStatistics) {\n            textDrawTime = PerformanceTimer.now();\n        }\n\n        if (!this.m_firstFrameRendered) {\n            this.m_firstFrameRendered = true;\n\n            if (gatherStatistics) {\n                stats.appResults.set(\"firstFrame\", time);\n            }\n\n            FIRST_FRAME_EVENT.time = time;\n            this.dispatchEvent(FIRST_FRAME_EVENT);\n        }\n\n        this.m_visibleTiles.disposePendingTiles();\n\n        this.m_drawing = false;\n\n        if (this.animating || this.m_updatePending) {\n            this.drawFrame();\n        }\n\n        this.checkCopyrightUpdates();\n\n        if (currentFrameEvent !== undefined) {\n            endTime = PerformanceTimer.now();\n\n            currentFrameEvent.setValue(\"render.setupTime\", setupTime! - frameStartTime);\n            currentFrameEvent.setValue(\"render.cullTime\", cullTime! - setupTime!);\n            currentFrameEvent.setValue(\"render.textPlacementTime\", textPlacementTime! - cullTime!);\n            currentFrameEvent.setValue(\"render.drawTime\", drawTime! - textPlacementTime!);\n            currentFrameEvent.setValue(\"render.textDrawTime\", textDrawTime! - drawTime!);\n            currentFrameEvent.setValue(\"render.cleanupTime\", endTime - textDrawTime!);\n            currentFrameEvent.setValue(\"render.frameRenderTime\", endTime - frameStartTime);\n\n            PerformanceStatistics.instance.storeFrameInfo(this.m_renderer.info);\n        }\n\n        DID_RENDER_EVENT.time = time;\n        this.dispatchEvent(DID_RENDER_EVENT);\n\n        // After completely rendering this frame, it is checked if this frame was the first complete\n        // frame, with no more tiles, geometry and labels waiting to be added, and no animation\n        // running. The initial placement of text in this render call may have changed the loading\n        // state of the TextElementsRenderer, so this has to be checked again.\n        if (\n            !this.m_firstFrameComplete &&\n            this.m_initialTextPlacementDone &&\n            !this.isDynamicFrame &&\n            !this.textElementsRenderer.loading\n        ) {\n            this.m_firstFrameComplete = true;\n\n            if (gatherStatistics) {\n                stats.appResults.set(\"firstFrameComplete\", time);\n            }\n\n            FRAME_COMPLETE_EVENT.time = time;\n            this.dispatchEvent(FRAME_COMPLETE_EVENT);\n        }\n    }\n\n    private renderTileObjects(tile: Tile, zoomLevel: number) {\n        const worldOffsetX = tile.computeWorldOffsetX();\n        if (tile.willRender(zoomLevel)) {\n            for (const object of tile.objects) {\n                object.position.copy(tile.center);\n                if (object.displacement !== undefined) {\n                    object.position.add(object.displacement);\n                }\n                object.position.x += worldOffsetX;\n                object.position.sub(this.m_camera.position);\n                if (tile.localTangentSpace) {\n                    object.setRotationFromMatrix(tile.boundingBox.getRotationMatrix());\n                }\n                object.frustumCulled = false;\n                if (object._backupRenderOrder === undefined) {\n                    object._backupRenderOrder = object.renderOrder;\n                }\n\n                const isBuilding =\n                    object.userData !== undefined &&\n                    object.userData.kind !== undefined &&\n                    (object.userData.kind as GeometryKind[]).includes(GeometryKind.Building);\n\n                // When falling back to a parent tile (i.e. tile.levelOffset < 0) there will\n                // be overlaps with the already loaded tiles. Therefore all (flat) objects\n                // in a fallback tile must be shifted, such that their renderOrder is less\n                // than the groundPlane that each neighbouring Tile has (it has a renderOrder\n                // of -10000, see addGroundPlane in TileGeometryCreator), only then can we be\n                // sure that nothing of the parent will be rendered on top of the children,\n                // as such, we shift using the FALLBACK_RENDER_ORDER_OFFSET.\n                // This does not apply to buildings b/c they are 3d and the overlaps\n                // are resolved with a depth prepass. Note we set this always to ensure that if\n                // the Tile is used as a fallback, and then used normally, that we have the correct\n                // renderOrder.\n                object.renderOrder =\n                    object._backupRenderOrder +\n                    (!isBuilding && tile.levelOffset < 0\n                        ? FALLBACK_RENDER_ORDER_OFFSET * tile.levelOffset\n                        : 0);\n\n                this.m_mapTilesRoot.add(object);\n            }\n        }\n        tile.didRender();\n    }\n\n    private prepareRenderTextElements(time: number) {\n        // Disable rendering of text elements for debug camera. TextElements are rendered using an\n        // orthographic camera that covers the entire available screen space. Unfortunately, this\n        // particular camera set up is not compatible with the debug camera.\n        const debugCameraActive = this.m_pointOfView !== undefined;\n\n        if (debugCameraActive) {\n            return;\n        }\n\n        this.m_textElementsRenderer.placeText(\n            this.m_visibleTiles.dataSourceTileList,\n            this.projection,\n            time\n        );\n    }\n\n    private finishRenderTextElements() {\n        const canRenderTextElements = this.m_pointOfView === undefined;\n\n        if (canRenderTextElements) {\n            // copy far value from scene camera, as the distance to the POIs matter now.\n            this.m_screenCamera.far = this.m_viewRanges.maximum;\n            this.m_textElementsRenderer.renderText(this.m_screenCamera);\n        }\n    }\n\n    private initTheme() {\n        if (this.m_options.theme === undefined) {\n            return;\n        }\n\n        this.m_themeIsLoading = true;\n        Promise.resolve<string | Theme>(this.m_options.theme)\n            .then(theme => ThemeLoader.load(theme, { uriResolver: this.m_uriResolver }))\n            .then(theme => {\n                this.m_themeIsLoading = false;\n                this.theme = theme;\n                THEME_LOADED_EVENT.time = Date.now();\n                this.dispatchEvent(THEME_LOADED_EVENT);\n            })\n            .catch(error => {\n                this.m_themeIsLoading = false;\n                const themeName =\n                    typeof this.m_options.theme === \"string\" ? ` from ${this.m_options.theme}` : \"\";\n                logger.error(`Failed to load theme${themeName}: ${error}`, error);\n            });\n    }\n\n    private setupCamera(options: MapViewOptions) {\n        const { width, height } = this.getCanvasClientSize();\n\n        const defaultGeoCenter = MapViewDefaults.geoCenter;\n\n        this.projection.projectPoint(defaultGeoCenter, this.m_camera.position);\n\n        if (this.projection.type === ProjectionType.Spherical) {\n            this.m_camera.lookAt(this.scene.position);\n        }\n\n        this.m_lookAtDistance = defaultGeoCenter.altitude!;\n\n        this.calculateFocalLength(height);\n\n        this.m_visibleTiles = new VisibleTileSet(\n            new FrustumIntersection(\n                this.m_camera,\n                this,\n                this.m_visibleTileSetOptions.extendedFrustumCulling,\n                this.m_tileWrappingEnabled\n            ),\n            this.m_tileGeometryManager,\n            this.m_visibleTileSetOptions\n        );\n\n        this.setInitialCameraPosition(options);\n\n        // ### move & customize\n        this.resize(width, height);\n\n        this.m_screenCamera.position.z = 1;\n        this.m_screenCamera.near = 0;\n    }\n\n    private setInitialCameraPosition(options: MapViewOptions) {\n        const target = GeoCoordinates.fromObject(\n            getOptionValue(options.target, MapViewDefaults.target)\n        );\n        target.altitude = 0; // ensure that look at target has height of 0\n        const zoomLevel = getOptionValue(options.zoomLevel, MapViewDefaults.zoomLevel);\n        const tilt = getOptionValue(options.tilt, MapViewDefaults.tilt);\n        const heading = getOptionValue(options.heading, MapViewDefaults.heading);\n\n        this.lookAt(target, 300000, tilt, heading);\n        this.zoomLevel = zoomLevel;\n    }\n\n    private updateSkyBackground() {\n        if (this.m_theme === undefined) {\n            return;\n        }\n        const theme = this.m_theme;\n        if (this.m_skyBackground instanceof SkyBackground && theme.sky !== undefined) {\n            // there is a sky in the view and there is a sky option in the theme. Update the colors\n            this.updateSkyBackgroundColors(theme.sky, theme.clearColor);\n        } else if (this.m_skyBackground === undefined && theme.sky !== undefined) {\n            // there is no sky in the view but there is a sky option in the theme\n            this.addNewSkyBackground(theme.sky, theme.clearColor);\n            return;\n        } else if (this.m_skyBackground instanceof SkyBackground && theme.sky === undefined) {\n            // there is a sky in the view, but not in the theme\n            this.removeSkyBackGround();\n        }\n    }\n\n    private addNewSkyBackground(sky: Sky, clearColor: string | undefined) {\n        if (sky.type === \"gradient\" && (sky as GradientSky).groundColor === undefined) {\n            sky.groundColor = getOptionValue(clearColor, \"#000000\");\n        }\n        this.m_skyBackground = new SkyBackground(sky, this.projection.type, this.m_camera);\n        this.m_scene.background = this.m_skyBackground.texture;\n    }\n\n    private removeSkyBackGround() {\n        this.m_scene.background = null;\n        if (this.m_skyBackground !== undefined) {\n            this.m_skyBackground.dispose();\n            this.m_skyBackground = undefined;\n        }\n    }\n\n    private updateSkyBackgroundColors(sky: Sky, clearColor: string | undefined) {\n        if (sky.type === \"gradient\" && (sky as GradientSky).groundColor === undefined) {\n            sky.groundColor = getOptionValue(clearColor, \"#000000\");\n        }\n        if (this.m_skyBackground !== undefined) {\n            this.m_skyBackground.updateTexture(sky, this.projection.type);\n        }\n    }\n\n    private updateLighting() {\n        if (!this.m_theme) {\n            return;\n        }\n\n        const theme = this.m_theme as Theme;\n        if (theme.clearColor !== undefined) {\n            this.m_renderer.setClearColor(new THREE.Color(theme.clearColor));\n        }\n\n        if (this.m_createdLights) {\n            this.m_createdLights.forEach((light: THREE.Light) => {\n                this.m_scene.remove(light);\n            });\n        }\n        if (theme.lights !== undefined) {\n            this.m_createdLights = [];\n            theme.lights.forEach((lightDescription: Light) => {\n                const light = createLight(lightDescription);\n                if (!light) {\n                    logger.warn(\n                        // tslint:disable-next-line: max-line-length\n                        `MapView: failed to create light ${lightDescription.name} of type ${lightDescription.type}`\n                    );\n                    return;\n                }\n                this.m_scene.add(light);\n                this.m_createdLights!.push(light);\n            });\n        }\n    }\n\n    private movementStarted() {\n        this.m_textElementsRenderer.movementStarted();\n\n        MOVEMENT_STARTED_EVENT.time = Date.now();\n        this.dispatchEvent(MOVEMENT_STARTED_EVENT);\n    }\n\n    private movementFinished() {\n        this.m_textElementsRenderer.movementFinished();\n\n        MOVEMENT_FINISHED_EVENT.time = Date.now();\n        this.dispatchEvent(MOVEMENT_FINISHED_EVENT);\n\n        // render at the next possible time.\n        if (!this.animating) {\n            if (this.m_movementFinishedUpdateTimerId !== undefined) {\n                clearTimeout(this.m_movementFinishedUpdateTimerId);\n            }\n            this.m_movementFinishedUpdateTimerId = setTimeout(() => {\n                this.m_movementFinishedUpdateTimerId = undefined;\n                this.update();\n            }, 0);\n        }\n    }\n\n    /**\n     * Check if the set of visible tiles changed since the last frame.\n     *\n     * May be called multiple times per frame.\n     *\n     * Equality is computed by creating a string containing the IDs of the tiles.\n     */\n    private checkIfTilesChanged() {\n        if (this.m_thisFrameTilesChanged !== undefined) {\n            return this.m_thisFrameTilesChanged;\n        }\n        const renderList = this.m_visibleTiles.dataSourceTileList;\n\n        const tileIdList: string[] = [];\n\n        tileIdList.length = 0;\n\n        renderList.forEach(({ dataSource, renderedTiles }) => {\n            renderedTiles.forEach(tile => {\n                tileIdList.push(dataSource.name + \"-\" + tile.tileKey.mortonCode());\n            });\n        });\n\n        tileIdList.sort();\n\n        const newTileIds = tileIdList.join(\"#\");\n\n        if (newTileIds !== this.m_lastTileIds) {\n            this.m_lastTileIds = newTileIds;\n            this.m_thisFrameTilesChanged = true;\n        } else {\n            this.m_thisFrameTilesChanged = false;\n        }\n\n        return this.m_thisFrameTilesChanged;\n    }\n\n    private checkCopyrightUpdates() {\n        if (!this.checkIfTilesChanged()) {\n            return;\n        }\n\n        const newCopyrightInfo = this.getRenderedTilesCopyrightInfo();\n        if (newCopyrightInfo === this.m_copyrightInfo) {\n            return;\n        }\n        if (newCopyrightInfo.length === this.m_copyrightInfo.length) {\n            let allEqual = true;\n            for (let i = 0; i < newCopyrightInfo.length; i++) {\n                const a = newCopyrightInfo[i];\n                const b = this.m_copyrightInfo[i];\n                if (a.label !== b.label) {\n                    allEqual = false;\n                    break;\n                }\n            }\n            if (allEqual) {\n                return;\n            }\n        }\n        this.m_copyrightInfo = newCopyrightInfo;\n        this.dispatchEvent(COPYRIGHT_CHANGED_EVENT);\n    }\n\n    private getRenderedTilesCopyrightInfo(): CopyrightInfo[] {\n        let result: CopyrightInfo[] = [];\n        for (const tileList of this.m_visibleTiles.dataSourceTileList) {\n            for (const tile of tileList.renderedTiles.values()) {\n                const tileCopyrightInfo = tile.copyrightInfo;\n                if (tileCopyrightInfo === undefined || tileCopyrightInfo.length === 0) {\n                    continue;\n                }\n                result = CopyrightInfo.mergeArrays(result, tileCopyrightInfo);\n            }\n        }\n        return result;\n    }\n\n    private updateImages() {\n        if (!this.m_theme) {\n            return;\n        }\n\n        const theme = this.m_theme as Theme;\n\n        this.m_imageCache.clear();\n        this.poiManager.clear();\n\n        if (theme.images !== undefined) {\n            for (const name of Object.keys(theme.images)) {\n                const image = theme.images[name];\n                this.m_imageCache.addImage(name, image.url, image.preload === true);\n                if (typeof image.atlas === \"string\") {\n                    this.poiManager.addTextureAtlas(name, image.atlas);\n                }\n            }\n        }\n\n        if (theme.imageTextures !== undefined) {\n            theme.imageTextures.forEach((imageTexture: ImageTexture) => {\n                this.poiManager.addImageTexture(imageTexture);\n            });\n        }\n    }\n\n    private loadPoiTables() {\n        if (this.m_theme === undefined) {\n            return;\n        }\n\n        this.poiTableManager.clear();\n\n        // Add the POI tables defined in the theme.\n        this.poiTableManager\n            .loadPoiTables(this.m_theme as Theme)\n            .then(() => this.update())\n            .catch(() => this.update());\n    }\n\n    private setupStats(enable: boolean) {\n        // tslint:disable-next-line:no-unused-expression\n        new PerformanceStatistics(enable, 1000);\n    }\n\n    private setupRenderer() {\n        this.m_renderer.setClearColor(DEFAULT_CLEAR_COLOR);\n\n        this.m_scene.add(this.m_mapTilesRoot);\n        this.m_scene.add(this.m_mapAnchors);\n    }\n\n    private createTextRenderer(): TextElementsRenderer {\n        const updateCallback: ViewUpdateCallback = () => {\n            this.update();\n        };\n\n        return new TextElementsRenderer(\n            new MapViewState(this, this.checkIfTilesChanged.bind(this)),\n            this.m_camera,\n            updateCallback,\n            this.m_screenCollisions,\n            this.m_screenProjector,\n            new TextCanvasFactory(this.m_renderer),\n            this.m_poiManager,\n            new PoiRendererFactory(this),\n            new FontCatalogLoader(this.m_theme),\n            this.m_theme,\n            this.m_options\n        );\n    }\n\n    private resetTextRenderer(): void {\n        const overlayText = this.m_textElementsRenderer.overlayText;\n        this.m_textElementsRenderer = this.createTextRenderer();\n        if (overlayText !== undefined) {\n            this.m_textElementsRenderer.addOverlayText(overlayText);\n        }\n    }\n\n    /**\n     * Default handler for webglcontextlost event.\n     *\n     * Note: The renderer `this.m_renderer` may not be initialized when this function is called.\n     */\n    private onWebGLContextLost = (event: Event) => {\n        this.dispatchEvent(CONTEXT_LOST_EVENT);\n        logger.warn(\"WebGL context lost\", event);\n    };\n\n    /**\n     * Default handler for webglcontextrestored event.\n     *\n     * Note: The renderer `this.m_renderer` may not be initialized when this function is called.\n     */\n    private onWebGLContextRestored = (event: Event) => {\n        this.dispatchEvent(CONTEXT_RESTORED_EVENT);\n        if (this.m_renderer !== undefined) {\n            if (this.m_theme !== undefined && this.m_theme.clearColor !== undefined) {\n                this.m_renderer.setClearColor(new THREE.Color(this.m_theme.clearColor));\n            } else {\n                this.m_renderer.setClearColor(DEFAULT_CLEAR_COLOR);\n            }\n            this.update();\n        }\n        logger.warn(\"WebGL context restored\", event);\n    };\n\n    private limitFov(fov: number, aspect: number): number {\n        fov = THREE.Math.clamp(fov, MIN_FIELD_OF_VIEW, MAX_FIELD_OF_VIEW);\n\n        let hFov = THREE.Math.radToDeg(\n            MapViewUtils.calculateHorizontalFovByVerticalFov(THREE.Math.degToRad(fov), aspect)\n        );\n\n        if (hFov > MAX_FIELD_OF_VIEW || hFov < MIN_FIELD_OF_VIEW) {\n            hFov = THREE.Math.clamp(hFov, MIN_FIELD_OF_VIEW, MAX_FIELD_OF_VIEW);\n            fov = THREE.Math.radToDeg(\n                MapViewUtils.calculateVerticalFovByHorizontalFov(THREE.Math.degToRad(hFov), aspect)\n            );\n        }\n        return fov as number;\n    }\n\n    /**\n     * Sets the field of view calculation, and applies it immediately to the camera.\n     *\n     * @param type How to calculate the FOV\n     */\n    private setFovOnCamera(fovCalculation: FovCalculation, height: number) {\n        let fov = 0;\n        if (fovCalculation.type === \"fixed\") {\n            this.calculateFocalLength(height);\n            fov = fovCalculation.fov;\n        } else {\n            assert(this.m_focalLength !== 0);\n            fov = MapViewUtils.calculateFovByFocalLength(this.m_focalLength, height);\n        }\n        this.m_camera.fov = this.limitFov(fov, this.m_camera.aspect);\n    }\n\n    /**\n     * Sets the focal length based on the supplied fov and the height of the canvas. This must be\n     * called at least once. This is necessary to be recalled when the [[FovCalculation]]'s type is\n     * fixed. In such cases, when the height changes, the focal length must be readjusted whereas\n     * the FOV stays the same. The opposite is true for the dynamic case, where the focal length is\n     * fixed but the FOV changes.\n     * @param height Height of the canvas in css / client pixels.\n     */\n    private calculateFocalLength(height: number) {\n        assert(this.m_options.fovCalculation !== undefined);\n        this.m_focalLength = MapViewUtils.calculateFocalLengthByVerticalFov(\n            THREE.Math.degToRad(this.m_options.fovCalculation!.fov),\n            height\n        );\n    }\n\n    /**\n     * Get canvas client size in css/client pixels.\n     *\n     * Supports canvases not attached to DOM, which have 0 as `clientWidth` and `clientHeight` by\n     * calculating it from actual canvas size and current pixel ratio.\n     */\n    private getCanvasClientSize(): { width: number; height: number } {\n        const { clientWidth, clientHeight } = this.canvas;\n        if (\n            clientWidth === 0 ||\n            clientHeight === 0 ||\n            typeof clientWidth !== \"number\" ||\n            typeof clientHeight !== \"number\"\n        ) {\n            const pixelRatio = this.m_renderer.getPixelRatio();\n            return {\n                width: Math.round(this.canvas.width / pixelRatio),\n                height: Math.round(this.canvas.height / pixelRatio)\n            };\n        } else {\n            return { width: clientWidth, height: clientHeight };\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { JsonExpr } from \"./Expr\";\nimport { StringEncodedNumeralType } from \"./StringEncodedNumeral\";\n\n/**\n * Interpolation mode used when computing a [[InterpolatedProperty]] value for a given zoom level.\n */\nexport enum InterpolationMode {\n    Discrete,\n    Linear,\n    Cubic,\n    Exponential\n}\n\n/**\n * Interpolated property could have its value (some initial value should be provided) changed\n * according to an interpolation type.\n *\n * Here is an example of an interpolated property from a map style:\n * \"lineWidth\": {\n *  \"interpolation\": \"Linear\",\n *  \"zoomLevels\": [13, 14, 15],\n *  \"values\": [ 1.5, 1.2, 0.9]\n * }\n */\nexport interface InterpolatedPropertyDefinition<T> {\n    interpolation?: \"Discrete\" | \"Linear\" | \"Cubic\" | \"Exponential\";\n    zoomLevels: number[];\n    values: T[];\n    exponent?: number;\n}\n\n/**\n * Property which value is interpolated across different zoom levels.\n */\nexport interface InterpolatedProperty {\n    /**\n     * Interpolation mode that should be used for this property.\n     */\n    interpolationMode: InterpolationMode;\n\n    /**\n     * Zoom level keys array.\n     */\n    zoomLevels: Float32Array;\n\n    /**\n     * Property values array.\n     */\n    values: ArrayLike<any>;\n\n    /**\n     * Exponent used in interpolation. Only valid with `Exponential` [[InterpolationMode]].\n     */\n    exponent?: number;\n\n    /**\n     * @hidden\n     * [[StringEncodedNumeral]] type needed to interpret interpolated values back to numbers.\n     */\n    _stringEncodedNumeralType?: StringEncodedNumeralType;\n\n    /**\n     * @hidden\n     * Array of `0` and `1`mask values used to modify the interpolation behaviour of some\n     * [[StringEncodedNumeral]]s.\n     */\n    _stringEncodedNumeralDynamicMask?: Float32Array;\n}\n\n/**\n * Converts an [[InterpolatedPropertyDefinition]] to a [[JsonExpr]].\n *\n * @param property A valid [[InterpolatedPropertyDefinition]]\n */\nexport function interpolatedPropertyDefinitionToJsonExpr(\n    property: InterpolatedPropertyDefinition<any>\n): JsonExpr {\n    if (property.interpolation === undefined || property.interpolation === \"Discrete\") {\n        const step: JsonExpr = [\"step\", [\"zoom\"], property.values[0]];\n        for (let i = 1; i < property.zoomLevels.length; ++i) {\n            step.push(property.zoomLevels[i], property.values[i]);\n        }\n        return step;\n    }\n    const interpolation: JsonExpr = [\"interpolate\"];\n    switch (property.interpolation) {\n        case \"Linear\":\n            interpolation.push([\"linear\"]);\n            break;\n        case \"Cubic\":\n            interpolation.push([\"cubic\"]);\n            break;\n        case \"Exponential\":\n            interpolation.push([\n                \"exponential\",\n                property.exponent !== undefined ? property.exponent : 2\n            ]);\n            break;\n        default:\n            throw new Error(`interpolation mode '${property.interpolation}' is not supported`);\n    } //switch\n    interpolation.push([\"zoom\"]);\n    for (let i = 0; i < property.zoomLevels.length; ++i) {\n        interpolation.push(property.zoomLevels[i], property.values[i]);\n    }\n    return interpolation;\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Vector3Like } from \"@here/harp-geoutils/lib/math/Vector3Like\";\nimport { JsonExpr } from \"./Expr\";\nimport {\n    BaseTechniqueParams,\n    BasicExtrudedLineTechniqueParams,\n    DynamicProperty,\n    ExtrudedPolygonTechniqueParams,\n    FillTechniqueParams,\n    MarkerTechniqueParams,\n    PointTechniqueParams,\n    SegmentsTechniqueParams,\n    ShaderTechniqueParams,\n    SolidLineTechniqueParams,\n    StandardExtrudedLineTechniqueParams,\n    StandardTechniqueParams,\n    TerrainTechniqueParams,\n    TextTechniqueParams\n} from \"./TechniqueParams\";\n\n/**\n * Map theme is used to define what features are shown and how the map is styled, for example\n * which lightning is used or whether fog should be displayed.\n */\nexport interface Theme {\n    /**\n     * The URI of the JSON schema describing themes.\n     */\n    $schema?: string;\n\n    /**\n     * The base `Theme`s or `theme` URLs to extend.\n     *\n     * If used, base themes are loaded first, and then all the properties from inherited theme\n     * overwrite these defined in base theme.\n     */\n    extends?: string | Theme | Array<string | Theme>;\n\n    /**\n     * Actual URL the theme has been loaded from.\n     */\n    url?: string;\n\n    /**\n     * Color to be used as a clear background - no map objects.\n     * @format color-hex\n     */\n    clearColor?: string;\n\n    /**\n     * Define the default text style for styling labels and texts.\n     */\n    defaultTextStyle?: TextStyleDefinition;\n\n    /**\n     * Define the lightning available on the three.js scene.\n     */\n    lights?: Light[];\n\n    /**\n     * Define the style of the sky presented in the map scene.\n     */\n    sky?: Sky;\n\n    /**\n     * Define the fog used in the map scene.\n     */\n    fog?: Fog;\n\n    /**\n     * The definitions exported by these theme.\n     */\n    definitions?: Definitions;\n\n    /**\n     * Map styles available for datasources used to render the map.\n     */\n    styles?: Styles;\n\n    /**\n     * Define the style to render different types of text used on the map.\n     */\n    textStyles?: TextStyleDefinition[];\n\n    /**\n     * List available fonts to be used while rendering text.\n     */\n    fontCatalogs?: FontCatalogConfig[];\n\n    /**\n     * Optional images to be rendered on the map view.\n     */\n    images?: ImageDefinitions;\n\n    /**\n     * Image textures to be used while rendering geometries on the map view.\n     */\n    imageTextures?: ImageTexture[];\n\n    /**\n     * Optional list of [[ThemePoiTableDef]]s.\n     */\n    poiTables?: PoiTableRef[];\n}\n\n/**\n * An array of [[Definition]]s.\n */\nexport interface Definitions {\n    [name: string]: Definition;\n}\n\n/**\n * A value definition.\n */\nexport type ValueDefinition =\n    | BooleanValueDefinition\n    | NumericValueDefinition\n    | StringValueDefinition\n    | ColorValueDefinition\n    | SelectorValueDefinition;\n\n/**\n * Checks if the given definition implements the [[ValueDefinition]] interface.\n */\nexport function isValueDefinition(def: Definition): def is ValueDefinition {\n    const valueDef = def as ValueDefinition;\n    return (\n        typeof valueDef === \"object\" &&\n        valueDef !== null &&\n        typeof valueDef.type === \"string\" &&\n        valueDef.value !== undefined\n    );\n}\n\nexport function isSelectorDefinition(def: Definition): def is SelectorValueDefinition {\n    const valueDef = def as ValueDefinition;\n    return (\n        typeof valueDef === \"object\" &&\n        valueDef !== null &&\n        valueDef.type === \"selector\" &&\n        (typeof valueDef.value === \"string\" || Array.isArray(valueDef.value))\n    );\n}\n\n/**\n * Value definition commons.\n */\nexport interface BaseValueDefinition {\n    /**\n     * The description of the definition.\n     */\n    description?: string;\n}\n\n/**\n * A boolean value definition.\n */\nexport interface BooleanValueDefinition extends BaseValueDefinition {\n    /**\n     * The type of the definition.\n     */\n    type: \"boolean\";\n\n    /**\n     * The value of the definition.\n     */\n    value: DynamicProperty<boolean>;\n}\n\n/**\n * A numerical value definition.\n */\nexport interface NumericValueDefinition extends BaseValueDefinition {\n    /**\n     * The type of the definition.\n     */\n    type: \"number\";\n\n    /**\n     * The value of the definition.\n     */\n    value: DynamicProperty<number>;\n}\n\n/**\n * A string value definition.\n */\nexport interface StringValueDefinition extends BaseValueDefinition {\n    /**\n     * The type of the definition.\n     */\n    type: \"string\";\n\n    /**\n     * The value of the definition.\n     */\n    value: DynamicProperty<string>;\n}\n\n/**\n * A color value definition.\n */\nexport interface ColorValueDefinition extends BaseValueDefinition {\n    /**\n     * The type of the definition.\n     */\n    type: \"color\";\n\n    /**\n     * The value of the definition.\n     */\n    value: DynamicProperty<string>;\n}\n\nexport interface SelectorValueDefinition extends BaseValueDefinition {\n    /**\n     * The type of the definition.\n     */\n    type: \"selector\";\n\n    /**\n     * The value of the definition.\n     *\n     * See [[BaseStyle.when]].\n     */\n    value: string | JsonExpr;\n}\n\n/**\n * Base [StyleSelector] attributes required to match [Style] object against given feature.\n *\n * Contains [Style]'s members related to feature matching in [[StyleSetEvaluator]].\n */\nexport interface StyleSelector {\n    /**\n     * Condition that is applied to feature properties to check if given [[Style]] this feature\n     * should emit geometry of this style.\n     *\n     * Conditions are defined using [[Array]]s describing literals, built-in symbols and function\n     * calls:\n     *  - `[\"has\", string]` returns `true` if the given property exists.\n     *  - `[\"get\", string]` returns the value of the given feature property with the given name.\n     *  - `[\"all\", expressions...]` returns `true` if all the sub expressions evaluate to true.\n     *  - `[\"any\", expressions...]` returns `true` if any sub expression evaluates to true.\n     *  - `[\"in\", expression, [literals...]]` returns `true` if the result of evaluating the first\n     *    expression is included in the given `Array` of literals.\n     *  - `[\"!\", expression]` returns `false` if the sub expression evaluates to `true`.\n     *  - `[\"<\", expression, expression]` returns `true` if the result of evaluating the first\n     *    expression is less than the result of evaluating the second expression.\n     *  - `[\">\", expression, expression]` returns `true` if the result of evaluating the first\n     *    expression is greater than the result of evaluating the second expression.\n     *  - `[\"<=\", expression, expression]` returns `true` if the result of evaluating the first\n     *    expression is less than or equal the result of evaluating the second expression.\n     *  - `[\">=\", expression, expression]` returns `true` if the result of evaluating the first\n     *    expression is greater than or equal the result of evaluating the second expression.\n     *  - `[\"==\", expression, expression]` returns `true` if the result of evaluating the first\n     *    expression is equal the result of evaluating the second expression.\n     *  - `[\"!=\", expression, expression]` returns `true` if the result of evaluating the first\n     *    expression is not equal to the result of evaluating the second expression.\n     *  - `[\"length\", expression]` returns the length of the given expression if it evaluates to\n     *    a `string` or an `Array`; otherwise, returns `undefined`.\n     *  - `[\"~=\", expression, expression]` if the expressions evaluate to `string`, returns `true`\n     *    if the `string` obtained from the first expression contains the `string` obtained from the\n     *    second expression; otherwise, returns `undefined`.\n     *  - `[\"^=\", expression, expression]` if the expressions evaluate to `string`, returns `true`\n     *    if the `string` obtained from the first expression starts with the `string` obtained from\n     *    the second expression; otherwise, returns `undefined`.\n     *  - `[\"$=\", expression, expression]` if the expressions evaluate to `string`, returns `true`\n     *    if the `string` obtained from the first expression ends with the `string` obtained from\n     *    the second expression; otherwise, returns `undefined`.\n     */\n    when: string | JsonExpr;\n\n    /**\n     * The layer containing the carto features processed by this style rule.\n     */\n    layer?: string;\n\n    /**\n     * Optional. If `true`, no more matching styles will be evaluated.\n     */\n    final?: boolean;\n}\n\nexport type JsonExprReference = [\"ref\", string];\n\n/**\n * Checks if the given value is a reference to a definition.\n *\n * @param value The value of a technique property.\n */\nexport function isJsonExprReference(value: any): value is JsonExprReference {\n    return (\n        Array.isArray(value) &&\n        value.length === 2 &&\n        value[0] === \"ref\" &&\n        typeof value[1] === \"string\"\n    );\n}\n\n/**\n * Like [[StyleDeclaration]], but without [[Reference]] type.\n */\nexport type ResolvedStyleDeclaration = Style & StyleSelector;\n\n/**\n * Like [[StyleSet]], but without [[Reference]] type.\n */\nexport type ResolvedStyleSet = ResolvedStyleDeclaration[];\n\n/**\n * Compound type that merges all raw [Style] with selector arguments from [BaseSelector], optionally\n * a [[Reference]].\n */\nexport type StyleDeclaration = (Style & StyleSelector) | JsonExpr;\n\nexport function isActualSelectorDefinition(def: Definition): def is Style & StyleSelector {\n    const styleDef = def as StyleDeclaration;\n    return (\n        typeof styleDef === \"object\" &&\n        styleDef !== null &&\n        !Array.isArray(styleDef) &&\n        typeof styleDef.technique === \"string\"\n    );\n}\n\n/**\n * An array of [[StyleSelector]]s that are used together to define how a [[DataSource]] should be\n * rendered. `StyleSet`s are applied to sources providing vector tiles via their method\n * `setStyleSet`. This is also handle internally when a whole theme is passed to a [[MapView]] via\n * `mapview.theme`.\n */\nexport type StyleSet = StyleDeclaration[];\n\n/**\n * The object that defines what way an item of a [[DataSource]] should be decoded to assemble a\n * tile. [[Style]] is describing which features are shown on a map and in what way they are being\n * shown.\n */\nexport interface BaseStyle {\n    /**\n     * Human readable description.\n     */\n    description?: string;\n\n    /**\n     * Technique name. See the classes extending from this class to determine what possible\n     * techniques are possible, includes `\"line\"`, `\"fill\"`, `\"solid-line\"`, `\"extruded-line\"`,\n     * `\"extruded-polygon\"`, `\"text\"`, `\"none\"`.\n     */\n    technique?: string;\n\n    /**\n     * Specify `renderOrder` of value.\n     *\n     * @default If not specified in style file, `renderOrder` will be assigned with monotonically\n     * increasing values according to style position in file.\n     */\n    renderOrder?: number | JsonExpr;\n\n    /**\n     * Minimal zoom level. If the current zoom level is smaller, the technique will not be used.\n     */\n    minZoomLevel?: number | JsonExpr;\n\n    /**\n     * Maximum zoom level. If the current zoom level is larger, the technique will not be used.\n     */\n    maxZoomLevel?: number | JsonExpr;\n\n    /**\n     * Optional. If `true`, no IDs will be saved for the geometry this style creates. Default is\n     * `false`.\n     */\n    transient?: boolean;\n\n    /**\n     * Optional: If `true`, the objects with matching `when` statement will be printed to the\n     * console.\n     */\n    debug?: boolean;\n\n    // TODO: Make pixel units default.\n    /**\n     * Units in which different size properties are specified. Either `Meter` (default) or `Pixel`.\n     *\n     * @deprecated use \"string encoded numerals\" as documented in TODO, wher eis the doc ?\n     */\n    metricUnit?: \"Meter\" | \"Pixel\";\n\n    /**\n     * XYZ defines the property to display as text label of a feature in the styles.\n     */\n    labelProperty?: string;\n}\n\n/**\n *\n * @defaultSnippets [\n *     {\n *         \"label\": \"New solid-line\",\n *         \"description\": \"Add a new 'solid-line' Styling Rule\",\n *         \"body\": {\n *             \"technique\": \"solid-line\",\n *             \"when\": \"$1\",\n *             \"attr\": {\n *                 \"color\": \"#${2:fff}\",\n *                 \"lineWidth\": \"^${3:1}\",\n *                 \"secondaryColor\": \"#$4ddd\",\n *                 \"secondaryWidth\": \"^${5:2}\"\n *             }\n *         }\n *     },\n *     {\n *         \"label\": \"New dashed-line\",\n *         \"description\": \"Add a new 'dashed-line' Styling Rule\",\n *         \"body\": {\n *             \"technique\": \"solid-line\",\n *             \"when\": \"$1\",\n *             \"attr\": {\n *                 \"color\": \"#${2:fff}\",\n *                 \"lineWidth\": \"^${3:1}\",\n *                 \"gapSize\": \"^${4:10}\",\n *                 \"dashSize\": \"^${5:10}\"\n *             }\n *         }\n *     },\n *     {\n *         \"label\": \"New fill\",\n *         \"description\": \"Add a new 'fill' Styling Rule\",\n *         \"body\": {\n *             \"technique\": \"fill\",\n *             \"when\": \"$1\",\n *             \"attr\": {\n *                 \"color\": \"#${2:fff}\",\n *                 \"lineWidth\": \"^${3:0}\"\n *             }\n *         }\n *     },\n *     {\n *         \"label\": \"New text\",\n *         \"description\": \"Add a new 'text' Styling Rule\",\n *         \"body\": {\n *             \"technique\": \"text\",\n *             \"when\": \"$1\",\n *             \"attr\": {\n *                 \"size\": \"^${2:24}\",\n *                 \"color\": \"#${3:fff}\"\n *             }\n *         }\n *     },\n *     {\n *         \"label\": \"New labeled-icon\",\n *         \"description\": \"Add a new 'labeled-icon' marker styling\",\n *         \"body\": {\n *             \"technique\": \"labeled-icon\",\n *             \"when\": \"$1\",\n *             \"attr\": {\n *                 \"size\": \"^${2:24}\",\n *                 \"color\": \"#${3:fff}\",\n *                 \"backgroundSize\": \"^${4:32}\",\n *                 \"backgroundColor\": \"#${5:aaa}\"\n *             }\n *         }\n *     },\n *     {\n *         \"label\": \"New line-marker\",\n *         \"description\": \"Add a new 'line-marker' marker styling\",\n *         \"body\": {\n *             \"technique\": \"line-marker\",\n *             \"when\": \"$1\",\n *             \"attr\": {\n *                 \"size\": \"^${2:24}\",\n *                 \"color\": \"#${3:fff}\",\n *                 \"backgroundSize\": \"^${4:32}\",\n *                 \"backgroundColor\": \"#${5:aaa}\"\n *             }\n *         }\n *     },\n *     {\n *         \"label\": \"New line\",\n *         \"description\": \"Add a new 'line' Styling Rule\",\n *         \"body\": {\n *             \"technique\": \"line\",\n *             \"when\": \"$1\",\n *             \"attr\": {\n *                 \"color\": \"#${2:fff}\",\n *                 \"lineWidth\": \"^${3:1}\"\n *             }\n *         }\n *     },\n *     {\n *         \"label\": \"New segments\",\n *         \"description\": \"Add a new 'segments' Styling Rule\",\n *         \"body\": {\n *             \"technique\": \"segments\",\n *             \"when\": \"$1\",\n *             \"attr\": {\n *                 \"color\": \"#${2:fff}\",\n *                 \"lineWidth\": \"^${3:1}\"\n *             }\n *         }\n *     },\n *     {\n *         \"label\": \"New standard\",\n *         \"description\": \"Add a new 'standard' Styling Rule\",\n *         \"body\": {\n *             \"technique\": \"standard\",\n *             \"when\": \"$1\",\n *             \"attr\": {\n *                 \"color\": \"#${2:fff}\",\n *                 \"roughness\": \"^${3:0.5}\",\n *                 \"metalness\": \"^${4:0.5}\",\n *                 \"emissive\": \"#${5:c44}\",\n *                 \"emissiveIntensity\": \"^${6:0.8}\"\n *             }\n *         }\n *     },\n *     {\n *         \"label\": \"New extruded-line\",\n *         \"description\": \"Add a new 'extruded-line' Styling Rule\",\n *         \"body\": {\n *             \"technique\": \"extruded-line\",\n *             \"when\": \"$1\",\n *             \"attr\": {\n *                 \"shading\": \"${2:standard}\",\n *                 \"color\": \"#${3:fff}\",\n *                 \"lineWidth\": \"^${4:1}\",\n *                 \"caps\": \"${5:Circle}\"\n *             }\n *         }\n *     },\n *     {\n *         \"label\": \"New extruded-polygon\",\n *         \"description\": \"Add a new 'extruded-polygon' Styling Rule\",\n *         \"body\": {\n *             \"technique\": \"extruded-polygon\",\n *             \"when\": \"$1\",\n *             \"attr\": {\n *                 \"color\": \"#${2:fff}\",\n *                 \"roughness\": \"^${3:0.5}\",\n *                 \"metalness\": \"^${4:0.5}\",\n *                 \"emissive\": \"#${5:c44}\",\n *                 \"emissiveIntensity\": \"^${6:0.8}\",\n *                 \"lineWidth\": \"^${7:1}\",\n *                 \"lineColor\": \"#${8:c0f}\",\n *                 \"defaultHeight\": \"^${9:20}\",\n *                 \"animateExtrusion\": \"^${10:true}\",\n *                 \"animateExtrusionDuration\": \"^${11:300}\"\n *             }\n *         }\n *     },\n *     {\n *         \"label\": \"New none\",\n *         \"description\": \"Add a new 'none' Styling Rule\",\n *         \"body\": {\n *             \"technique\": \"none\",\n *             \"when\": \"$1\",\n *             \"attr\": {}\n *         }\n *     },\n *     {\n *         \"label\": \"New shader\",\n *         \"description\": \"Add a new 'shader' Styling Rule\",\n *         \"body\": {\n *             \"technique\": \"shader\",\n *             \"when\": \"$1\",\n *             \"attr\": {\n *                 \"primitive\": \"${2:mesh}\",\n *                 \"params\": {}\n *             }\n *         }\n *     },\n *     {\n *         \"label\": \"New squares\",\n *         \"description\": \"Add a new 'squares' point styling\",\n *         \"body\": {\n *             \"technique\": \"squares\",\n *             \"when\": \"$1\",\n *             \"attr\": {\n *                 \"color\": \"#${2:fff}\",\n *                 \"size\": \"^${3:32}\",\n *                 \"texture\": \"${4:url}\",\n *                 \"enablePicking\": \"^${5:true}\"\n *             }\n *         }\n *     },\n *     {\n *         \"label\": \"New circles\",\n *         \"description\": \"Add a new 'circles' point styling\",\n *         \"body\": {\n *             \"technique\": \"circles\",\n *             \"when\": \"$1\",\n *             \"attr\": {\n *                 \"color\": \"#${2:fff}\",\n *                 \"size\": \"^${3:32}\",\n *                 \"texture\": \"${4:url}\",\n *                 \"enablePicking\": \"^${5:true}\"\n *             }\n *         }\n *     }\n * ]\n *\n */\nexport type AllStyles =\n    | SquaresStyle\n    | CirclesStyle\n    | PoiStyle\n    | LineMarkerStyle\n    | LineStyle\n    | SegmentsStyle\n    | SolidLineStyle\n    | LabelRejectionLineStyle\n    | FillStyle\n    | StandardStyle\n    | BasicExtrudedLineStyle\n    | StandardExtrudedLineStyle\n    | ExtrudedPolygonStyle\n    | ShaderStyle\n    | TerrainStyle\n    | TextTechniqueStyle\n    | NoneStyle;\n\nexport type Style = AllStyles;\n/**\n * A dictionary of [[StyleSet]]s.\n */\nexport interface Styles {\n    [styleSetName: string]: StyleSet;\n}\n\n/**\n * Possible values for `definitions` element of [Theme].\n */\nexport type Definition = ValueDefinition | StyleDeclaration;\n\n/**\n * A reference to a style definition.\n *\n * Use as value `attrs` to reference value from `definitions`.\n *\n * Example of usage:\n * ```json\n * {\n *   \"definitions\": {\n *     \"roadColor\": { \"type\": \"color\", \"value\": \"#f00\" }\n *   },\n *   \"styles\": { \"tilezen\": [\n *      {\n *       \"when\": \"kind == 'road\",\n *       \"technique\": \"solid-line\",\n *       \"attr\": {\n *         \"lineColor\": { \"$ref\": \"roadColor\" }\n *       }\n *     }\n *   ] }\n * }\n *```\n */\n\n/**\n * The attributes of a technique.\n */\nexport type Attr<T> = { [P in keyof T]?: T[P] | JsonExpr };\n\n/**\n * Render feature as set of squares rendered in screen space.\n *\n * @see [[PointTechniqueParams]].\n */\nexport interface SquaresStyle extends BaseStyle {\n    technique: \"squares\";\n    attr?: Attr<PointTechniqueParams>;\n}\n\n/**\n * Render feature as set of circles rendered in screen space.\n *\n * @see [[PointTechniqueParams]].\n */\nexport interface CirclesStyle extends BaseStyle {\n    technique: \"circles\";\n    attr?: Attr<PointTechniqueParams>;\n}\n\n/**\n * Render feature as POIs (icons and text) rendered in screen space.\n *\n * @see [[MarkerTechniqueParams]].\n */\nexport interface PoiStyle extends BaseStyle {\n    technique: \"labeled-icon\";\n    attr?: Attr<MarkerTechniqueParams>;\n}\n\n/**\n * Render feature as line markers, which is a recurring marker along a line (usually road).\n *\n * @see [[MarkerTechniqueParams]].\n */\nexport interface LineMarkerStyle extends BaseStyle {\n    technique: \"line-marker\";\n    attr?: Attr<MarkerTechniqueParams>;\n}\n\n/**\n * Render feature as line.\n */\nexport interface LineStyle extends BaseStyle {\n    technique: \"line\";\n    secondaryRenderOrder?: number;\n    attr?: Attr<MarkerTechniqueParams>;\n}\n\n/**\n * Render feature as segments.\n */\nexport interface SegmentsStyle extends BaseStyle {\n    technique: \"segments\";\n    attr?: Attr<SegmentsTechniqueParams>;\n}\n\nexport interface SolidLineStyle extends BaseStyle {\n    technique: \"solid-line\" | \"dashed-line\";\n    secondaryRenderOrder?: number;\n    attr?: Attr<SolidLineTechniqueParams>;\n}\n\nexport interface LabelRejectionLineStyle extends BaseStyle {\n    technique: \"label-rejection-line\";\n    attr?: Attr<BaseTechniqueParams>;\n}\n\nexport interface FillStyle extends BaseStyle {\n    technique: \"fill\";\n    attr?: Attr<FillTechniqueParams>;\n}\n\nexport interface StandardStyle extends BaseStyle {\n    technique: \"standard\";\n    attr?: Attr<StandardTechniqueParams>;\n}\n\nexport interface TerrainStyle extends BaseStyle {\n    technique: \"terrain\";\n    attr?: Attr<TerrainTechniqueParams>;\n}\n\nexport interface BasicExtrudedLineStyle extends BaseStyle {\n    technique: \"extruded-line\";\n    shading?: \"basic\";\n    attr?: Attr<BasicExtrudedLineTechniqueParams>;\n}\n\nexport interface StandardExtrudedLineStyle extends BaseStyle {\n    technique: \"extruded-line\";\n    shading: \"standard\";\n    attr?: Attr<StandardExtrudedLineTechniqueParams>;\n}\n\n/**\n * Style used to draw a geometry as an extruded polygon, for example extruded buildings.\n */\nexport interface ExtrudedPolygonStyle extends BaseStyle {\n    technique: \"extruded-polygon\";\n    attr?: Attr<ExtrudedPolygonTechniqueParams>;\n}\n\nexport interface ShaderStyle extends BaseStyle {\n    technique: \"shader\";\n    attr?: Attr<ShaderTechniqueParams>;\n}\n\nexport interface TextTechniqueStyle extends BaseStyle {\n    technique: \"text\";\n    attr?: Attr<TextTechniqueParams>;\n}\n\nexport interface NoneStyle extends BaseStyle {\n    technique: \"none\";\n    attr?: {\n        [name: string]: any;\n    };\n}\n\n/**\n * Possible lights used for light the map.\n */\nexport type Light = AmbientLight | DirectionalLight;\n\nexport interface BaseLight {\n    type: string;\n    name: string;\n}\n\n/**\n * Light type: ambient.\n * @defaultSnippets [\n *     {\n *         \"label\": \"New Ambient Light\",\n *         \"description\": \"Adds a new Ambient Light\",\n *         \"body\": {\n *             \"type\": \"ambient\",\n *             \"name\": \"${1:ambient light}\",\n *             \"color\": \"#${2:fff}\",\n *             \"intensity\": \"^${3:1}\"\n *         }\n *     }\n * ]\n */\nexport interface AmbientLight extends BaseLight {\n    type: \"ambient\";\n    /**\n     * @format color-hex\n     */\n    color: string;\n    intensity?: number;\n}\n\n/**\n * Light type: directional.\n * @defaultSnippets [\n *     {\n *         \"label\": \"New Directional Light\",\n *         \"description\": \"Adds a new Directional Light\",\n *         \"body\": {\n *             \"type\": \"directional\",\n *             \"name\": \"${1:directional-light$:1}\",\n *             \"color\": \"#${2:fff}\",\n *             \"intensity\": \"^${3:1}\",\n *             \"direction\": {\n *                 \"x\": \"^${4:1}\",\n *                 \"y\": \"^${5:0}\",\n *                 \"z\": \"^${6:0}\"\n *             }\n *         }\n *     }\n * ]\n */\nexport interface DirectionalLight extends BaseLight {\n    type: \"directional\";\n    /**\n     * @format color-hex\n     */\n    color: string;\n    intensity: number;\n    direction: Vector3Like;\n    castShadow?: boolean;\n}\n\n/**\n * Various text styles used with labels and texts.\n */\nexport interface TextStyleDefinition {\n    name?: string;\n    fontCatalogName?: string;\n\n    fontName?: string;\n    size?: number;\n    backgroundSize?: number;\n    fontStyle?: \"Regular\" | \"Bold\" | \"Italic\" | \"BoldItalic\";\n    fontVariant?: \"Regular\" | \"AllCaps\" | \"SmallCaps\";\n    rotation?: number;\n    /**\n     * @format color-hex\n     */\n    color?: string;\n    /**\n     * @format color-hex\n     */\n    backgroundColor?: string;\n    opacity?: number;\n    backgroundOpacity?: number;\n\n    tracking?: number;\n    leading?: number;\n    maxLines?: number;\n    lineWidth?: number;\n    canvasRotation?: number;\n    lineRotation?: number;\n    wrappingMode?: \"None\" | \"Character\" | \"Word\";\n    hAlignment?: \"Left\" | \"Center\" | \"Right\";\n    vAlignment?: \"Above\" | \"Center\" | \"Below\";\n}\n\n/**\n * Interface that defines a procedural gradient sky.\n */\nexport interface GradientSky {\n    /** Sky type. */\n    type: \"gradient\";\n    /**\n     * Color of the upper part of the gradient.\n     * @format color-hex\n     */\n    topColor: string;\n    /**\n     * Color of bottom part of the gradient.\n     * @format color-hex\n     */\n    bottomColor: string;\n    /**\n     * Color of the ground plane.\n     * @format color-hex\n     */\n    groundColor: string;\n    /** Texture's gradient power. */\n    monomialPower?: number;\n}\n\n/**\n * Interface that defines a cubemap sky.\n */\nexport interface CubemapSky {\n    /** Sky type. */\n    type: \"cubemap\";\n    /** Positive X cube map face. */\n    positiveX: string;\n    /** Negative X cube map face. */\n    negativeX: string;\n    /** Positive Y cube map face. */\n    positiveY: string;\n    /** Negative Y cube map face. */\n    negativeY: string;\n    /** Positive Z cube map face. */\n    positiveZ: string;\n    /** Negative Z cube map face. */\n    negativeZ: string;\n}\n\n/**\n * Interface that defines the options to configure the sky.\n */\nexport type Sky = GradientSky | CubemapSky;\n\n/**\n * Interface that defines the options to configure fog.\n */\nexport interface Fog {\n    /** Fog's color. */\n    color: string;\n    /** Distance ratio to far plane at which the linear fog begins. */\n    startRatio: number;\n}\n\n/**\n * Define an image (e.g. icon).\n */\nexport interface ImageDefinition {\n    /** Url to load content from. */\n    url: string;\n    /** `true` to start loading at init tile, `false` to lazily wait until required. */\n    preload: boolean;\n    /** Url of JSON file containing the texture atlas */\n    atlas?: string;\n}\n\nexport interface ImageDefinitions {\n    /** Name of Image. */\n    [name: string]: ImageDefinition;\n}\n\n/**\n * Can be used to create a texture atlas.\n */\nexport interface ImageTexture {\n    /** Name of ImageTexture. Used to reference texture in the styles. */\n    name: string;\n    /** Name of ImageDefinition to use. */\n    image: string;\n    /** Origin of image, defaults to \"topleft\" */\n    origin?: string;\n    /** Specify sub-region: Defaults to 0. */\n    xOffset?: number;\n    /** Specify sub-region: Defaults to 0. */\n    yOffset?: number;\n    /** Specify sub-region:  Defaults to 0, meaning width is taken from loaded image. */\n    width?: number;\n    /** Specify sub-region:  Defaults to 0, meaning height is taken from loaded image. */\n    height?: number;\n    /** Defaults to false. */\n    flipH?: boolean;\n    /** Defaults to false. */\n    flipV?: boolean;\n    /** Defaults to 1. */\n    opacity?: number;\n}\n\n/**\n * Definition for a [[PoiTable]] reference as part of the [[Theme]] object.\n */\nexport interface PoiTableRef {\n    /** Required name of the [[PoiTable]] for later reference. */\n    name: string;\n    /**\n     * Required URL from where to load [[PoiTable]].\n     *\n     * Should refer to JSON that is matched [[PoiTableDef]] interface.\n     */\n    url: string;\n    /**\n     * If set to `true`, the list of values in the field \"altNames\" will be used as names for this\n     * POI.\n     */\n    useAltNamesForKey: boolean;\n}\n\n/**\n * Interface for the JSON description of the [[PoiTable]]. It is being implemented in [[PoiTable]].\n */\nexport interface PoiTableDef {\n    /** Name of the `PoiTable`. Must be unique. */\n    name?: string;\n    /**\n     * Stores the list of [[PoiTableEntry]]s.\n     */\n    poiList?: PoiTableEntryDef[];\n}\n\n/**\n * Interface for the JSON description of the [[PoiTableEntry]]. The interface is being implemented\n * as [[PoiTableEntry]].\n */\nexport interface PoiTableEntryDef {\n    /** Default name of the POI as the key for looking it up. */\n    name?: string;\n    /** Alternative names of the POI. */\n    altNames?: string[];\n    /** Visibility of the POI. If `false`, the POI will not be rendered. */\n    visible?: boolean;\n    /** Name of the icon, defined in the the texture atlases. */\n    iconName?: string;\n    /** Stacking mode of the POI. For future use. */\n    stackMode?: string;\n    /**\n     * Priority of the POI to select the visible set in case there are more POIs than can be\n     * handled.\n     */\n    priority?: number;\n    /** Minimum zoom level to render the icon on. */\n    iconMinLevel?: number;\n    /** Maximum zoom level to render the icon on. */\n    iconMaxLevel?: number;\n    /** Minimum zoom level to render the text label on. */\n    textMinLevel?: number;\n    /** Maximum zoom level to render the text label on. */\n    textMaxLevel?: number;\n}\n\n/**\n * Fonts used for all text related rendering.\n */\nexport interface FontCatalogConfig {\n    url: string;\n    name: string;\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeoBox } from \"../coordinates/GeoBox\";\nimport { GeoCoordinates } from \"../coordinates/GeoCoordinates\";\nimport { GeoCoordinatesLike } from \"../coordinates/GeoCoordinatesLike\";\nimport { Box3Like, isBox3Like } from \"../math/Box3Like\";\nimport { MathUtils } from \"../math/MathUtils\";\nimport { isOrientedBox3Like, OrientedBox3Like } from \"../math/OrientedBox3Like\";\nimport { TransformLike } from \"../math/TransformLike\";\nimport { Vector3Like } from \"../math/Vector3Like\";\nimport { EarthConstants } from \"./EarthConstants\";\nimport { Projection, ProjectionType } from \"./Projection\";\n\nclass MercatorProjection extends Projection {\n    protected static clamp(val: number, min: number, max: number): number {\n        return Math.min(Math.max(min, val), max);\n    }\n\n    protected static latitudeClamp(latitude: number): number {\n        return MercatorProjection.clamp(\n            latitude,\n            -MercatorConstants.MAXIMUM_LATITUDE,\n            MercatorConstants.MAXIMUM_LATITUDE\n        );\n    }\n\n    private static latitudeProject(latitude: number): number {\n        return Math.log(Math.tan(Math.PI * 0.25 + latitude * 0.5)) / Math.PI;\n    }\n\n    private static latitudeClampProject(latitude: number): number {\n        return MercatorProjection.latitudeProject(MercatorProjection.latitudeClamp(latitude));\n    }\n\n    private static unprojectLatitude(y: number): number {\n        return 2.0 * Math.atan(Math.exp(Math.PI * y)) - Math.PI * 0.5;\n    }\n\n    readonly type: ProjectionType = ProjectionType.Planar;\n\n    getScaleFactor(worldPoint: Vector3Like): number {\n        return Math.cosh(2 * Math.PI * (worldPoint.y / this.unitScale - 0.5));\n    }\n\n    worldExtent<WorldBoundingBox extends Box3Like>(\n        minAltitude: number,\n        maxAltitude: number,\n        result?: WorldBoundingBox\n    ): WorldBoundingBox {\n        if (!result) {\n            result = MathUtils.newEmptyBox3() as WorldBoundingBox;\n        }\n        result.min.x = 0;\n        result.min.y = 0;\n        result.min.z = minAltitude;\n        result.max.x = this.unitScale;\n        result.max.y = this.unitScale;\n        result.max.z = maxAltitude;\n        return result;\n    }\n\n    projectPoint<WorldCoordinates extends Vector3Like>(\n        geoPointLike: GeoCoordinatesLike,\n        result?: WorldCoordinates\n    ): WorldCoordinates {\n        let geoPoint: GeoCoordinates;\n\n        if (geoPointLike instanceof GeoCoordinates) {\n            geoPoint = geoPointLike;\n        } else {\n            geoPoint = new GeoCoordinates(\n                geoPointLike.latitude,\n                geoPointLike.longitude,\n                geoPointLike.altitude\n            );\n        }\n\n        if (!result) {\n            // tslint:disable-next-line:no-object-literal-type-assertion\n            result = { x: 0, y: 0, z: 0 } as WorldCoordinates;\n        }\n        result.x = ((geoPoint.longitude + 180) / 360) * this.unitScale;\n        result.y =\n            (MercatorProjection.latitudeClampProject(geoPoint.latitudeInRadians) * 0.5 + 0.5) *\n            this.unitScale;\n        result.z = geoPoint.altitude || 0;\n        return result;\n    }\n\n    unprojectPoint(worldPoint: Vector3Like): GeoCoordinates {\n        const geoPoint = GeoCoordinates.fromRadians(\n            MercatorProjection.unprojectLatitude((worldPoint.y / this.unitScale - 0.5) * 2.0),\n            (worldPoint.x / this.unitScale) * 2 * Math.PI - Math.PI,\n            worldPoint.z\n        );\n        return geoPoint;\n    }\n\n    unprojectAltitude(worldPoint: Vector3Like): number {\n        return worldPoint.z;\n    }\n\n    projectBox<WorldBoundingBox extends Box3Like | OrientedBox3Like>(\n        geoBox: GeoBox,\n        result?: WorldBoundingBox\n    ): WorldBoundingBox {\n        const worldCenter = this.projectPoint(geoBox.center);\n        const worldNorth =\n            (MercatorProjection.latitudeClampProject(geoBox.northEast.latitudeInRadians) * 0.5 +\n                0.5) *\n            this.unitScale;\n        const worldSouth =\n            (MercatorProjection.latitudeClampProject(geoBox.southWest.latitudeInRadians) * 0.5 +\n                0.5) *\n            this.unitScale;\n        const worldYCenter = (worldNorth + worldSouth) * 0.5;\n\n        worldCenter.y = worldYCenter;\n\n        const latitudeSpan = worldNorth - worldSouth;\n        const longitudeSpan = (geoBox.longitudeSpan / 360) * this.unitScale;\n        if (!result) {\n            result = MathUtils.newEmptyBox3() as WorldBoundingBox;\n        }\n        if (isBox3Like(result)) {\n            result.min.x = worldCenter.x - longitudeSpan * 0.5;\n            result.min.y = worldCenter.y - latitudeSpan * 0.5;\n            result.max.x = worldCenter.x + longitudeSpan * 0.5;\n            result.max.y = worldCenter.y + latitudeSpan * 0.5;\n            const altitudeSpan = geoBox.altitudeSpan;\n            if (altitudeSpan !== undefined) {\n                result.min.z = worldCenter.z - altitudeSpan * 0.5;\n                result.max.z = worldCenter.z + altitudeSpan * 0.5;\n            } else {\n                result.min.z = 0;\n                result.max.z = 0;\n            }\n        } else if (isOrientedBox3Like(result)) {\n            MathUtils.newVector3(1, 0, 0, result.xAxis);\n            MathUtils.newVector3(0, 1, 0, result.yAxis);\n            MathUtils.newVector3(0, 0, 1, result.zAxis);\n            result.position.x = worldCenter.x;\n            result.position.y = worldCenter.y;\n            result.position.z = worldCenter.z;\n            result.extents.x = longitudeSpan * 0.5;\n            result.extents.y = latitudeSpan * 0.5;\n            result.extents.z = Math.max(Number.EPSILON, (geoBox.altitudeSpan || 0) * 0.5);\n        } else {\n            throw new Error(\"invalid bounding box\");\n        }\n        return result;\n    }\n\n    unprojectBox(worldBox: Box3Like): GeoBox {\n        const minGeo = this.unprojectPoint(worldBox.min);\n        const maxGeo = this.unprojectPoint(worldBox.max);\n        const geoBox = GeoBox.fromCoordinates(minGeo, maxGeo);\n        return geoBox;\n    }\n\n    groundDistance(worldPoint: Vector3Like): number {\n        return worldPoint.z;\n    }\n\n    scalePointToSurface(worldPoint: Vector3Like): Vector3Like {\n        worldPoint.z = 0;\n        return worldPoint;\n    }\n\n    surfaceNormal(_worldPoint: Vector3Like, normal?: Vector3Like) {\n        if (normal === undefined) {\n            normal = { x: 0, y: 0, z: 1 };\n        } else {\n            normal.x = 0;\n            normal.y = 0;\n            normal.z = 1;\n        }\n        return normal;\n    }\n\n    reprojectPoint(\n        sourceProjection: Projection,\n        worldPos: Vector3Like,\n        result?: Vector3Like\n    ): Vector3Like {\n        // this implementation of [[reprojectPoint]] supports both\n        // [[WebMercatorProjection]] and [[MercatorProjection]]. The only\n        // difference betweeen these two variants of WEB Mercator\n        // is in the orientation of the Y axis, so we just flip Y coordinates\n        // when reprojecting between them.\n        if (\n            sourceProjection !== this &&\n            (sourceProjection === webMercatorProjection || sourceProjection === mercatorProjection)\n        ) {\n            if (result === undefined) {\n                // tslint:disable-next-line: no-object-literal-type-assertion\n                result = {} as Vector3Like;\n            }\n\n            result.x = worldPos.x;\n            result.y = this.unitScale - worldPos.y;\n            result.z = worldPos.z;\n\n            return result;\n        }\n\n        return super.reprojectPoint(sourceProjection, worldPos, result!);\n    }\n}\n\nclass WebMercatorProjection extends MercatorProjection {\n    projectPoint<WorldCoordinates extends Vector3Like>(\n        geoPointLike: GeoCoordinatesLike,\n        result?: WorldCoordinates\n    ): WorldCoordinates {\n        let geoPoint: GeoCoordinates;\n\n        if (geoPointLike instanceof GeoCoordinates) {\n            geoPoint = geoPointLike;\n        } else {\n            geoPoint = new GeoCoordinates(\n                geoPointLike.latitude,\n                geoPointLike.longitude,\n                geoPointLike.altitude\n            );\n        }\n\n        /*\n         * The following tslint:disable is due to the fact that the [[WorldCoordinates]]\n         * might be a concrete class which is not available at runtime.\n         * Consider the following example:\n         *\n         *  const x: THREE.Vector3 = new THREE.Vector3(0,0,0);\n         *  const result = EquirectangularProjection.projectPoint<THREE.Vector3>(x);\n         *\n         * Note: type of `result` is Vector3Like and not as expected: THREE.Vector3!\n         */\n        if (!result) {\n            // tslint:disable-next-line:no-object-literal-type-assertion\n            result = { x: 0, y: 0, z: 0 } as WorldCoordinates;\n        }\n\n        result.x = ((geoPoint.longitude + 180) / 360) * this.unitScale;\n        const sy = Math.sin(MercatorProjection.latitudeClamp(geoPoint.latitudeInRadians));\n        result.y = (0.5 - Math.log((1 + sy) / (1 - sy)) / (4 * Math.PI)) * this.unitScale;\n        result.z = geoPoint.altitude || 0;\n        return result;\n    }\n\n    unprojectPoint(worldPoint: Vector3Like): GeoCoordinates {\n        const x = worldPoint.x / this.unitScale - 0.5;\n        const y = 0.5 - worldPoint.y / this.unitScale;\n\n        const longitude = 360 * x;\n        const latitude = 90 - (360 * Math.atan(Math.exp(-y * 2 * Math.PI))) / Math.PI;\n\n        return new GeoCoordinates(latitude, longitude, worldPoint.z);\n    }\n\n    projectBox<WorldBoundingBox extends Box3Like | OrientedBox3Like>(\n        geoBox: GeoBox,\n        result?: WorldBoundingBox\n    ): WorldBoundingBox {\n        const r = super.projectBox(geoBox, result);\n        if (isBox3Like(r)) {\n            // Invert the y axis for web mercator, this means that max => min & min => max\n            const maxY = r.max.y;\n            r.max.y = this.unitScale - r.min.y;\n            r.min.y = this.unitScale - maxY;\n        } else if (isOrientedBox3Like(r)) {\n            MathUtils.newVector3(1, 0, 0, r.xAxis);\n            MathUtils.newVector3(0, -1, 0, r.yAxis);\n            MathUtils.newVector3(0, 0, -1, r.zAxis);\n            r.position.y = this.unitScale - r.position.y;\n        }\n        return r;\n    }\n\n    unprojectBox(worldBox: Box3Like): GeoBox {\n        const minGeo = this.unprojectPoint(worldBox.min);\n        const maxGeo = this.unprojectPoint(worldBox.max);\n        const geoBox = new GeoBox(\n            new GeoCoordinates(maxGeo.latitude, minGeo.longitude, minGeo.altitude),\n            new GeoCoordinates(minGeo.latitude, maxGeo.longitude, maxGeo.altitude)\n        );\n        return geoBox;\n    }\n\n    surfaceNormal(_worldPoint: Vector3Like, normal?: Vector3Like) {\n        if (normal === undefined) {\n            normal = { x: 0, y: 0, z: -1 };\n        } else {\n            normal.x = 0;\n            normal.y = 0;\n            normal.z = -1;\n        }\n        return normal;\n    }\n\n    localTangentSpace(geoPoint: GeoCoordinatesLike, result: TransformLike): TransformLike {\n        this.projectPoint(geoPoint, result.position);\n        MathUtils.newVector3(1, 0, 0, result.xAxis);\n        MathUtils.newVector3(0, -1, 0, result.yAxis);\n        MathUtils.newVector3(0, 0, -1, result.zAxis);\n        return result;\n    }\n}\n\nexport class MercatorConstants {\n    // Math.atan(Math.sinh(Math.PI))\n    static readonly MAXIMUM_LATITUDE: number = 1.4844222297453323;\n}\n\n/**\n * Mercator [[Projection]] used to convert geo coordinates to world coordinates and vice versa.\n */\nexport const mercatorProjection: Projection = new MercatorProjection(\n    EarthConstants.EQUATORIAL_CIRCUMFERENCE\n);\n\n/**\n * Web Mercator [[Projection]] used to convert geo coordinates to world coordinates and vice versa.\n */\nexport const webMercatorProjection: Projection = new WebMercatorProjection(\n    EarthConstants.EQUATORIAL_CIRCUMFERENCE\n);\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { SubdivisionScheme } from \"./SubdivisionScheme\";\n\nclass QuadTreeSubdivisionScheme implements SubdivisionScheme {\n    getSubdivisionX(): number {\n        return 2;\n    }\n    getSubdivisionY(): number {\n        return 2;\n    }\n    getLevelDimensionX(level: number): number {\n        // tslint:disable-next-line:no-bitwise\n        return 1 << level;\n    }\n    getLevelDimensionY(level: number): number {\n        // tslint:disable-next-line:no-bitwise\n        return 1 << level;\n    }\n}\n\n/**\n * [[SubdivisionScheme]] representing a quadtree.\n */\nexport const quadTreeSubdivisionScheme: SubdivisionScheme = new QuadTreeSubdivisionScheme();\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/** @hidden */\nconst powerOfTwo = [\n    0x1,\n    0x2,\n    0x4,\n    0x8,\n    0x10,\n    0x20,\n    0x40,\n    0x80,\n    0x100,\n    0x200,\n    0x400,\n    0x800,\n    0x1000,\n    0x2000,\n    0x4000,\n    0x8000,\n    0x10000,\n    0x20000,\n    0x40000,\n    0x80000,\n    0x100000,\n    0x200000,\n    0x400000,\n    0x800000,\n    0x1000000,\n    0x2000000,\n    0x4000000,\n    0x8000000,\n    0x10000000,\n    0x20000000,\n    0x40000000,\n    0x80000000,\n    0x100000000,\n    0x200000000,\n    0x400000000,\n    0x800000000,\n    0x1000000000,\n    0x2000000000,\n    0x4000000000,\n    0x8000000000,\n    0x10000000000,\n    0x20000000000,\n    0x40000000000,\n    0x80000000000,\n    0x100000000000,\n    0x200000000000,\n    0x400000000000,\n    0x800000000000,\n    0x1000000000000,\n    0x2000000000000,\n    0x4000000000000,\n    0x8000000000000,\n    0x10000000000000 // Math.pow(2, 52), highest bit that can be set correctly.\n];\n\n/**\n * The `TileKey` instances are used to address a tile in a quadtree.\n *\n * A tile key is defined by a row, a column, and a level. The tree has a root at level 0, with one\n * single tile. On every level, each tile is divided into four children (therefore the name\n * quadtree).\n *\n * Within each [[level]], any particular tile is addressed with [[row]] and [[column]]. The number\n * of rows and columns in each level is 2 to the power of the level. This means: On level 0, only\n * one tile exists, [[columnsAtLevel]]() and [[rowsAtLevel]]() are both 1. On level 1, 4 tiles\n * exist, in 2 rows and 2 columns. On level 2 we have 16 tiles, in 4 rows and 4 columns. And so on.\n *\n * A tile key is usually created using [[fromRowColumnLevel]]() method.\n *\n * `TileKey` instances are immutable, all members return new instances of `TileKey` and do not\n * modify the original object.\n *\n * Utility functions like [[parent]](), [[changedLevelBy]](), and [[changedLevelTo]]() allow for\n * easy vertical navigation of the tree. The number of available rows and columns in the tile's\n * level is given with [[rowCount]]() and [[columnCount]]().\n *\n * Tile keys can be created from and converted into various alternative formats:\n *\n *  - [[toQuadKey]]() / [[fromQuadKey]]() - string representation 4-based\n *  - [[toHereTile]]() / [[fromHereTile]]() - string representation 10-based\n *  - [[mortonCode]]() / [[fromMortonCode]]() - number representation\n *\n * Note - as JavaScript's number type can hold 53 bits in its mantissa, only levels up to 26 can be\n * represented in the number representation returned by [[mortonCode]]().\n */\nexport class TileKey {\n    /**\n     * Creates a tile key.\n     *\n     * @param row The requested row. Must be less than 2 to the power of level.\n     * @param column The requested column. Must be less than 2 to the power of level.\n     * @param level The requested level.\n     */\n    static fromRowColumnLevel(row: number, column: number, level: number): TileKey {\n        return new TileKey(row, column, level);\n    }\n\n    /**\n     * Creates a tile key from a quad string.\n     *\n     * The quad string can be created with [[toQuadKey]].\n     *\n     * @param quadkey The quadkey to convert.\n     * @returns A new instance of `TileKey`.\n     */\n    static fromQuadKey(quadkey: string): TileKey {\n        const level = quadkey.length;\n        let row = 0;\n        let column = 0;\n        // tslint:disable:no-bitwise\n        for (let i = 0; i < quadkey.length; ++i) {\n            const mask = 1 << i;\n            const d = parseInt(quadkey.charAt(level - i - 1), 10);\n            if (d & 0x1) {\n                column |= mask;\n            }\n            if (d & 0x2) {\n                row |= mask;\n            }\n        }\n        // tslint:enable:no-bitwise\n        return TileKey.fromRowColumnLevel(row, column, level);\n    }\n    /**\n     * Creates a tile key from a numeric Morton code representation.\n     *\n     * You can convert a tile key into a numeric Morton code with [[mortonCode]].\n     *\n     * @param quadKey64 The Morton code to be converted.\n     * @returns A new instance of [[TileKey]].\n     */\n    static fromMortonCode(quadKey64: number): TileKey {\n        let level = 0;\n        let row = 0;\n        let column = 0;\n        let quadKey = quadKey64;\n        // tslint:disable:no-bitwise\n        while (quadKey > 1) {\n            const mask: number = 1 << level;\n\n            if (quadKey & 0x1) {\n                column |= mask;\n            }\n            if (quadKey & 0x2) {\n                row |= mask;\n            }\n\n            level++;\n            quadKey = (quadKey - (quadKey & 0x3)) / 4;\n        }\n        // tslint:enable:no-bitwise\n        const result = TileKey.fromRowColumnLevel(row, column, level);\n        result.m_mortonCode = quadKey64;\n        return result;\n    }\n\n    /**\n     * Creates a tile key from a heretile code string.\n     *\n     * The string can be created with [[toHereTile]].\n     *\n     * @param quadkey64 The string representation of the HERE tile key.\n     * @returns A new instance of `TileKey`.\n     */\n    static fromHereTile(quadkey64: string): TileKey {\n        const result = TileKey.fromMortonCode(parseInt(quadkey64, 10));\n        result.m_hereTile = quadkey64;\n        return result;\n    }\n\n    /**\n     * Returns the number of available columns at a given level.\n     *\n     * This is 2 to the power of the level.\n     *\n     * @param level The level for which to return the number of columns.\n     * @returns The available columns at the given level.\n     */\n    static columnsAtLevel(level: number): number {\n        return Math.pow(2, level);\n    }\n\n    /**\n     * Returns the number of available rows at a given level.\n     *\n     * This is 2 to the power of the level.\n     *\n     * @param level The level for which to return the number of rows.\n     * @returns The available rows at the given level.\n     */\n    static rowsAtLevel(level: number): number {\n        return Math.pow(2, level);\n    }\n\n    /**\n     * Returns the closest matching `TileKey` in a cartesian coordinate system.\n     *\n     * @param level The level for the tile key.\n     * @param coordX The X coordinate.\n     * @param coordY The Y coordinate.\n     * @param totalWidth The maximum X coordinate.\n     * @param totalHeight The maximum Y coordinate.\n     * @returns A new tile key at the given level that includes the given coordinates.\n     */\n    static atCoords(\n        level: number,\n        coordX: number,\n        coordY: number,\n        totalWidth: number,\n        totalHeight: number\n    ): TileKey {\n        return TileKey.fromRowColumnLevel(\n            Math.floor(coordY / (totalHeight / TileKey.rowsAtLevel(level))),\n            Math.floor(coordX / (totalWidth / TileKey.columnsAtLevel(level))),\n            level\n        );\n    }\n\n    /**\n     * Computes the Morton code of the parent tile key of the given Morton code.\n     *\n     * Note: The parent key of the root key is the root key itself.\n     *\n     * @param mortonCode A Morton code, for example, obtained from [[mortonCode]].\n     * @returns The Morton code of the parent tile.\n     */\n    static parentMortonCode(mortonCode: number): number {\n        return Math.floor(mortonCode / 4);\n    }\n\n    private m_mortonCode?: number;\n    private m_hereTile?: string;\n\n    /**\n     * Constructs a new immutable instance of a `TileKey`.\n     *\n     * For the better readability, [[TileKey.fromRowColumnLevel]] should be preferred.\n     *\n     * Note - row and column must not be greater than the maximum rows/columns for the given level.\n     *\n     * @param row Represents the row in the quadtree.\n     * @param column Represents the column in the quadtree.\n     * @param level Represents the level in the quadtree.\n     */\n    constructor(readonly row: number, readonly column: number, readonly level: number) {}\n\n    /**\n     * Returns a tile key representing the parent of the tile addressed by this tile key.\n     *\n     * Throws an exception is this tile is already the root.\n     */\n    parent(): TileKey {\n        if (this.level === 0) {\n            throw new Error(\"Cannot get the parent of the root tile key\");\n        }\n        // tslint:disable-next-line:no-bitwise\n        return TileKey.fromRowColumnLevel(this.row >>> 1, this.column >>> 1, this.level - 1);\n    }\n\n    /**\n     * Returns a new tile key at a level that differs from this tile's level by delta.\n     *\n     * Equivalent to `changedLevelTo(level() + delta)`.\n     *\n     * Note - root key is returned if `delta` is smaller than the level of this tile key.\n     *\n     * @param delta The numeric difference between the current level and the requested level.\n     */\n    changedLevelBy(delta: number): TileKey {\n        const level = Math.max(0, this.level + delta);\n        let row = this.row;\n        let column = this.column;\n\n        // tslint:disable:no-bitwise\n        if (delta >= 0) {\n            row <<= delta;\n            column <<= delta;\n        } else {\n            row >>>= -delta;\n            column >>>= -delta;\n        }\n        // tslint:enable:no-bitwise\n        return TileKey.fromRowColumnLevel(row, column, level);\n    }\n\n    /**\n     * Returns a new tile key at the requested level.\n     *\n     * If the requested level is smaller than the tile's level, then the key of an ancestor of this\n     * tile is returned. If the requested level is larger than the tile's level, then the key of\n     * first child or grandchild of this tile is returned, for example, the child with the lowest\n     * row and column number. If the requested level equals this tile's level, then the tile key\n     * itself is returned. If the requested level is negative, the root tile key is returned.\n     *\n     * @param level The requested level.\n     */\n    changedLevelTo(level: number): TileKey {\n        return this.changedLevelBy(level - this.level);\n    }\n\n    /**\n     * Converts the tile key to a numeric code representation.\n     *\n     * You can create a tile key from a numeric Morton code with [[fromMortonCode]].\n     *\n     * Note - only levels <= 26 are supported.\n     */\n    mortonCode(): number {\n        if (this.m_mortonCode === undefined) {\n            let column = this.column;\n            let row = this.row;\n\n            // tslint:disable:no-bitwise\n            let result = powerOfTwo[this.level << 1];\n            for (let i = 0; i < this.level; ++i) {\n                if (column & 0x1) {\n                    result += powerOfTwo[2 * i];\n                }\n                if (row & 0x1) {\n                    result += powerOfTwo[2 * i + 1];\n                }\n                column >>>= 1;\n                row >>>= 1;\n            }\n            // tslint:enable:no-bitwise\n\n            this.m_mortonCode = result;\n        }\n        return this.m_mortonCode;\n    }\n\n    /**\n     * Converts the tile key into a string for using in REST API calls.\n     *\n     * The string is a quadkey Morton code representation as a string.\n     *\n     * You can convert back from a quadkey string with [[fromHereTile]].\n     */\n    toHereTile(): string {\n        if (this.m_hereTile === undefined) {\n            this.m_hereTile = this.mortonCode().toString();\n        }\n        return this.m_hereTile;\n    }\n\n    /**\n     * Converts the tile key into a string for using in REST API calls.\n     *\n     * If the tile is the root tile, the quadkey is '-'. Otherwise the string is a number to the\n     * base of 4, but without the leading 1, with the following properties:\n     *  1. the number of digits equals the level.\n     *  2. removing the last digit gives the parent tile's quadkey string, i.e. appending 0,1,2,3\n     *     to a quadkey string gives the tiles's children.\n     *\n     * You can convert back from a quadkey string with [[fromQuadKey]].\n     */\n    toQuadKey(): string {\n        let result: string = \"\";\n\n        // tslint:disable:no-bitwise\n        for (let i = this.level; i > 0; --i) {\n            const mask = 1 << (i - 1);\n\n            const col = (this.column & mask) !== 0;\n            const row = (this.row & mask) !== 0;\n\n            if (col && row) {\n                result += \"3\";\n            } else if (row) {\n                result += \"2\";\n            } else if (col) {\n                result += \"1\";\n            } else {\n                result += \"0\";\n            }\n        }\n        // tslint:enable:no-bitwise\n\n        return result;\n    }\n\n    /**\n     * Equality operator.\n     *\n     * @param qnr The tile key to compare to.\n     * @returns `true` if this tile key has identical row, column and level, `false` otherwise.\n     */\n    equals(qnr: TileKey): boolean {\n        return this.row === qnr.row && this.column === qnr.column && this.level === qnr.level;\n    }\n\n    /**\n     * Returns the absolute quadkey that is constructed from its sub quadkey.\n     *\n     * @param sub The sub key.\n     * @returns The absolute tile key in the quadtree.\n     */\n    addedSubKey(sub: string): TileKey {\n        const subQuad = TileKey.fromQuadKey(sub.length === 0 ? \"-\" : sub);\n        const child = this.changedLevelBy(subQuad.level);\n        return TileKey.fromRowColumnLevel(\n            child.row + subQuad.row,\n            child.column + subQuad.column,\n            child.level\n        );\n    }\n\n    /**\n     * Returns the absolute quadkey that is constructed from its sub HERE tile key.\n     *\n     * @param sub The sub HERE key.\n     * @returns The absolute tile key in the quadtree.\n     */\n    addedSubHereTile(sub: string): TileKey {\n        const subQuad = TileKey.fromHereTile(sub);\n        const child = this.changedLevelBy(subQuad.level);\n        return TileKey.fromRowColumnLevel(\n            child.row + subQuad.row,\n            child.column + subQuad.column,\n            child.level\n        );\n    }\n\n    /**\n     * Returns a sub quadkey that is relative to its parent.\n     *\n     * This function can be used to generate sub keys that are relative to a parent that is delta\n     * levels up in the quadtree.\n     *\n     * This function can be used to create shortened keys for quads on lower levels if the parent is\n     * known.\n     *\n     * Note - the sub quadkeys fit in a 16-bit unsigned integer if the `delta` is smaller than 8. If\n     * `delta` is smaller than 16, the sub quadkey fits into an unsigned 32-bit integer.\n     *\n     * Deltas larger than 16 are not supported.\n     *\n     * @param delta The number of levels relative to its parent quadkey. Must be greater or equal to\n     * 0 and smaller than 16.\n     * @returns The quadkey relative to its parent that is `delta` levels up the tree.\n     */\n    getSubHereTile(delta: number): string {\n        const key = this.mortonCode();\n        // tslint:disable-next-line:no-bitwise\n        const msb = 1 << (delta * 2);\n        const mask = msb - 1;\n        // tslint:disable-next-line:no-bitwise\n        const result = (key & mask) | msb;\n        return result.toString();\n    }\n\n    /**\n     * Returns the number of available rows in the tile's [[level]].\n     *\n     * This is 2 to the power of the level.\n     */\n    rowCount(): number {\n        return TileKey.rowsAtLevel(this.level);\n    }\n\n    /**\n     * Returns the number of available columns in the tile's [[level]].\n     *\n     * This is 2 to the power of the level.\n     */\n    columnCount(): number {\n        return TileKey.columnsAtLevel(this.level);\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {\n    BaseTechniqueParams,\n    BufferAttribute,\n    DecodedTile,\n    Expr,\n    ExtrudedPolygonTechnique,\n    FillTechnique,\n    Geometry,\n    GeometryKind,\n    GeometryKindSet,\n    getArrayConstructor,\n    getFeatureId,\n    getPropertyValue,\n    isCirclesTechnique,\n    isExtrudedLineTechnique,\n    isExtrudedPolygonTechnique,\n    isFillTechnique,\n    isJsonExpr,\n    isLineMarkerTechnique,\n    isLineTechnique,\n    isPoiTechnique,\n    isSegmentsTechnique,\n    isSolidLineTechnique,\n    isSquaresTechnique,\n    isTerrainTechnique,\n    isTextTechnique,\n    MakeTechniqueAttrs,\n    needsVertexNormals,\n    SolidLineTechnique,\n    StandardExtrudedLineTechnique,\n    Technique,\n    TerrainTechnique,\n    TextPathGeometry\n} from \"@here/harp-datasource-protocol\";\n// tslint:disable:max-line-length\nimport { SphericalGeometrySubdivisionModifier } from \"@here/harp-geometry/lib/SphericalGeometrySubdivisionModifier\";\nimport { EarthConstants, GeoCoordinates, ProjectionType } from \"@here/harp-geoutils\";\nimport {\n    EdgeMaterial,\n    EdgeMaterialParameters,\n    FadingFeature,\n    LineCapsDefinitions,\n    MapMeshBasicMaterial,\n    MapMeshStandardMaterial,\n    SolidLineMaterial\n} from \"@here/harp-materials\";\nimport { ContextualArabicConverter } from \"@here/harp-text-canvas\";\nimport { assert, chainCallbacks, LoggerManager } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { AnimatedExtrusionTileHandler } from \"../AnimatedExtrusionHandler\";\nimport { ColorCache } from \"../ColorCache\";\nimport {\n    applyBaseColorToMaterial,\n    applySecondaryColorToMaterial,\n    createMaterial,\n    getBufferAttribute,\n    getObjectConstructor\n} from \"../DecodedTileHelpers\";\nimport {\n    createDepthPrePassMesh,\n    isRenderDepthPrePassEnabled,\n    setDepthPrePassStencil\n} from \"../DepthPrePass\";\nimport { DisplacementMap, TileDisplacementMap } from \"../DisplacementMap\";\nimport { FALLBACK_RENDER_ORDER_OFFSET } from \"../MapView\";\nimport { MapViewPoints } from \"../MapViewPoints\";\nimport { PathBlockingElement } from \"../PathBlockingElement\";\nimport { TextElement } from \"../text/TextElement\";\nimport { DEFAULT_TEXT_DISTANCE_SCALE } from \"../text/TextElementsRenderer\";\nimport { Tile, TileFeatureData } from \"../Tile\";\nimport { TileGeometryLoader } from \"./TileGeometryLoader\";\n\nconst logger = LoggerManager.instance.create(\"TileGeometryCreator\");\n\n/**\n * The SORT_WEIGHT_PATH_LENGTH constants control how the priority of the labels are computed based\n * on the length of the label strings.\n *\n * Consequently, the [[Technique]]s priority is slightly modified while generating\n * [[TextElement]]s from the [[DecodedTile]], to get a more meaningful priority and stable results.\n */\n\n/**\n * Gives [[TextElement]]s with longer paths a higher priority.\n */\nconst SORT_WEIGHT_PATH_LENGTH = 0.1;\n\n/**\n * Parameters that control fading.\n */\nexport interface FadingParameters {\n    fadeNear?: number;\n    fadeFar?: number;\n}\n\n/**\n * Parameters that control fading for extruded buildings with fading edges.\n */\nexport interface PolygonFadingParameters extends FadingParameters {\n    color?: string | number;\n    colorMix?: number;\n    lineFadeNear?: number;\n    lineFadeFar?: number;\n}\n\n/**\n * Support class to create geometry for a [[Tile]] from a [[DecodedTile]].\n */\nexport class TileGeometryCreator {\n    private static m_instance: TileGeometryCreator;\n    // These are used for clipping the geometry so that the overlapping geometry is removed.\n    private clippingPlanes = [\n        new THREE.Plane(new THREE.Vector3(-1, 0, 0), 0),\n        new THREE.Plane(new THREE.Vector3(1, 0, 0), 0),\n        new THREE.Plane(new THREE.Vector3(0, -1, 0), 0),\n        new THREE.Plane(new THREE.Vector3(0, 1, 0), 0)\n    ];\n\n    /**\n     * The `instance` of the `TileGeometryCreator`.\n     *\n     * @returns TileGeometryCreator\n     */\n    static get instance(): TileGeometryCreator {\n        return this.m_instance || (this.m_instance = new TileGeometryCreator());\n    }\n\n    /**\n     *  Creates an instance of TileGeometryCreator. Access is allowed only through `instance`.\n     */\n    private constructor() {\n        //\n    }\n\n    /**\n     * Apply `enabledKinds` and `disabledKinds` to all techniques in the `decodedTile`. If a\n     * technique is identified as disabled, its property `enabled` is set to `false`.\n     *\n     * @param decodedTile The decodedTile containing the actual tile map data.\n     * @param enabledKinds Optional [[GeometryKindSet]] used to specify which object kinds should be\n     *      created.\n     * @param disabledKinds Optional [[GeometryKindSet]] used to filter objects that should not be\n     *      created.\n     */\n    initDecodedTile(\n        decodedTile: DecodedTile,\n        enabledKinds?: GeometryKindSet | undefined,\n        disabledKinds?: GeometryKindSet | undefined\n    ) {\n        for (const technique of decodedTile.techniques) {\n            // Already processed\n            if (technique.enabled !== undefined) {\n                continue;\n            }\n\n            // Turn technique.kind from the style, which may be a string or an array of strings,\n            // into a GeometryKindSet.\n            if (technique.kind !== undefined) {\n                if (Array.isArray(technique.kind)) {\n                    technique.kind = new GeometryKindSet(technique.kind);\n                } else if (typeof technique.kind !== \"string\") {\n                    logger.warn(\"Technique has unknown type of kind:\", technique);\n                    technique.kind = undefined;\n                }\n            }\n\n            // No info about kind, no way to filter it.\n            if (\n                technique.kind === undefined ||\n                (technique.kind instanceof Set && (technique.kind as GeometryKindSet).size === 0)\n            ) {\n                technique.enabled = true;\n                continue;\n            }\n\n            technique.enabled =\n                !(disabledKinds !== undefined && disabledKinds.hasOrIntersects(technique.kind)) ||\n                (enabledKinds !== undefined && enabledKinds.hasOrIntersects(technique.kind));\n        }\n        for (const srcGeometry of decodedTile.geometries) {\n            for (const group of srcGeometry.groups) {\n                group.createdOffsets = [];\n            }\n        }\n\n        // compile the dynamic expressions.\n        decodedTile.techniques.forEach((technique: any) => {\n            for (const propertyName in technique) {\n                if (!technique.hasOwnProperty(propertyName)) {\n                    continue;\n                }\n                const value = technique[propertyName];\n                if (isJsonExpr(value) && propertyName !== \"kind\") {\n                    // \"kind\" is reserved.\n                    try {\n                        technique[propertyName] = Expr.fromJSON(value);\n                    } catch (error) {\n                        logger.error(\"#initDecodedTile: Failed to compile expression:\", error);\n                    }\n                }\n            }\n        });\n    }\n\n    /**\n     * Called after the `Tile` has been decoded. It is required to call `initDecodedTile` before\n     * calling this method.\n     *\n     * @see [[TileGeometryCreator#initDecodedTile]]\n     *\n     * @param tile The [[Tile]] to process.\n     * @param decodedTile The decodedTile containing the actual tile map data.\n     */\n    createAllGeometries(tile: Tile, decodedTile: DecodedTile) {\n        const filter = (technique: Technique): boolean => {\n            return technique.enabled !== false;\n        };\n\n        if (decodedTile.maxGeometryHeight !== undefined) {\n            tile.maxGeometryHeight = decodedTile.maxGeometryHeight;\n        }\n        this.createObjects(tile, decodedTile, filter);\n\n        this.preparePois(tile, decodedTile);\n\n        // TextElements do not get their geometry created by Tile, but are managed on a\n        // higher level.\n        const textFilter = (technique: Technique): boolean => {\n            if (\n                !isPoiTechnique(technique) &&\n                !isLineMarkerTechnique(technique) &&\n                !isTextTechnique(technique)\n            ) {\n                return false;\n            }\n            return filter(technique);\n        };\n        this.createTextElements(tile, decodedTile, textFilter);\n\n        this.createLabelRejectionElements(tile, decodedTile);\n\n        // HARP-7899, disable ground plane for globe\n        if (tile.dataSource.addGroundPlane && tile.projection.type === ProjectionType.Planar) {\n            // The ground plane is required for when we change the zoom back and we fall back to the\n            // parent, in that case we reduce the renderOrder of the parent tile and this ground\n            // place ensures that parent doesn't come through. This value must be above the\n            // renderOrder of all objects in the fallback tile, otherwise there won't be a proper\n            // covering of the parent tile by the children, hence dividing by 2. To put a bit more\n            // concretely, we assume all objects are rendered with a renderOrder between 0 and\n            // FALLBACK_RENDER_ORDER_OFFSET / 2, i.e. 10000. The ground plane is put at -10000, and\n            // the fallback tiles have their renderOrder set between -20000 and -10000\n            TileGeometryCreator.instance.addGroundPlane(tile, -FALLBACK_RENDER_ORDER_OFFSET / 2);\n        }\n    }\n\n    createLabelRejectionElements(tile: Tile, decodedTile: DecodedTile) {\n        if (decodedTile.pathGeometries === undefined) {\n            return;\n        }\n        for (const path of decodedTile.pathGeometries) {\n            tile.addBlockingElement(new PathBlockingElement(path.path));\n        }\n    }\n\n    /**\n     * Apply enabled and disabled kinds as a filter.\n     *\n     * @param {DecodedTile} decodedTile\n     * @param {(GeometryKindSet | undefined)} enabledKinds\n     * @param {(GeometryKindSet | undefined)} disabledKinds\n     */\n    processTechniques(\n        decodedTile: DecodedTile,\n        enabledKinds: GeometryKindSet | undefined,\n        disabledKinds: GeometryKindSet | undefined\n    ): void {\n        if (decodedTile === undefined) {\n            return;\n        }\n\n        for (const technique of decodedTile.techniques) {\n            // Make sure that all technique have their geometryKind set, either from the Theme or\n            // their default value.\n            if (technique.kind === undefined) {\n                TileGeometryLoader.setDefaultGeometryKind(technique);\n            }\n        }\n\n        // Speedup and simplify following code: Test all techniques if they intersect with\n        // enabledKinds and disabledKinds, in which case they are flagged. The disabledKinds can be\n        // ignored hereafter.\n        this.initDecodedTile(decodedTile, enabledKinds, disabledKinds);\n    }\n\n    /**\n     * Adds a THREE object to the root of the tile. Sets the owning tiles datasource.name and the\n     * tileKey in the `userData` property of the object, such that the tile it belongs to can be\n     * identified during picking.\n     *\n     * @param tile The [[Tile]] to add the object to.\n     * @param object The object to add to the root of the tile.\n     * @param geometryKind The kind of object. Can be used for filtering.\n     */\n    registerTileObject(\n        tile: Tile,\n        object: THREE.Object3D,\n        geometryKind: GeometryKind | GeometryKindSet | undefined\n    ) {\n        if (object.userData === undefined) {\n            object.userData = {};\n        }\n        const userData = object.userData;\n        userData.tileKey = tile.tileKey;\n        userData.dataSource = tile.dataSource.name;\n\n        userData.kind =\n            geometryKind instanceof Set\n                ? Array.from((geometryKind as GeometryKindSet).values())\n                : Array.isArray(geometryKind)\n                ? geometryKind\n                : [geometryKind];\n\n        // Force a visibility check of all objects.\n        tile.resetVisibilityCounter();\n    }\n\n    /**\n     * Splits the text paths that contain sharp corners.\n     *\n     * @param tile The [[Tile]] to process paths on.\n     * @param textPathGeometries The original path geometries that may have defects.\n     * @param textFilter: Optional filter. Should return true for any text technique that is\n     *      applicable.\n     */\n    prepareTextPaths(\n        textPathGeometries: TextPathGeometry[],\n        decodedTile: DecodedTile,\n        textFilter?: (technique: Technique) => boolean\n    ): TextPathGeometry[] {\n        const processedPaths = new Array<TextPathGeometry>();\n        const newPaths = textPathGeometries.slice();\n\n        while (newPaths.length > 0) {\n            const textPath = newPaths.pop();\n\n            if (textPath === undefined) {\n                break;\n            }\n\n            const technique = decodedTile.techniques[textPath.technique];\n            if (\n                !isTextTechnique(technique) ||\n                (textFilter !== undefined && !textFilter(technique))\n            ) {\n                continue;\n            }\n\n            processedPaths.push(textPath);\n        }\n        return processedPaths;\n    }\n\n    /**\n     * Creates [[TextElement]] objects from the decoded tile and list of materials specified. The\n     * priorities of the [[TextElement]]s are updated to simplify label placement.\n     *\n     * @param tile The [[Tile]] to create the testElements on.\n     * @param decodedTile The [[DecodedTile]].\n     * @param textFilter: Optional filter. Should return true for any text technique that is\n     *      applicable.\n     */\n    createTextElements(\n        tile: Tile,\n        decodedTile: DecodedTile,\n        textFilter?: (technique: Technique) => boolean\n    ) {\n        const mapView = tile.mapView;\n        const textElementsRenderer = mapView.textElementsRenderer;\n        const displayZoomLevel = Math.floor(mapView.zoomLevel);\n        const worldOffsetX = tile.computeWorldOffsetX();\n\n        if (decodedTile.textPathGeometries !== undefined) {\n            const textPathGeometries = this.prepareTextPaths(\n                decodedTile.textPathGeometries,\n                decodedTile,\n                textFilter\n            );\n\n            // Compute maximum street length (squared). Longer streets should be labelled first,\n            // they have a higher chance of being placed in case the number of text elements is\n            // limited.\n            let maxPathLengthSqr = 0;\n            for (const textPath of textPathGeometries) {\n                const technique = decodedTile.techniques[textPath.technique];\n                if (technique.enabled === false || !isTextTechnique(technique)) {\n                    continue;\n                }\n                if (textPath.pathLengthSqr > maxPathLengthSqr) {\n                    maxPathLengthSqr = textPath.pathLengthSqr;\n                }\n            }\n\n            for (const textPath of textPathGeometries) {\n                const technique = decodedTile.techniques[textPath.technique];\n\n                if (\n                    technique.enabled === false ||\n                    !isTextTechnique(technique) ||\n                    (textFilter !== undefined && !textFilter(technique))\n                ) {\n                    continue;\n                }\n\n                const path: THREE.Vector3[] = [];\n                for (let i = 0; i < textPath.path.length; i += 3) {\n                    path.push(\n                        new THREE.Vector3(\n                            textPath.path[i] + worldOffsetX,\n                            textPath.path[i + 1],\n                            textPath.path[i + 2]\n                        )\n                    );\n                }\n\n                // Make sorting stable and make pathLengthSqr a differentiator for placement.\n                const priority =\n                    (technique.priority !== undefined\n                        ? getPropertyValue(technique.priority, displayZoomLevel)\n                        : 0) +\n                    (maxPathLengthSqr > 0\n                        ? (SORT_WEIGHT_PATH_LENGTH * textPath.pathLengthSqr) / maxPathLengthSqr\n                        : 0);\n                const fadeNear =\n                    technique.fadeNear !== undefined\n                        ? getPropertyValue(technique.fadeNear, displayZoomLevel)\n                        : technique.fadeNear;\n                const fadeFar =\n                    technique.fadeFar !== undefined\n                        ? getPropertyValue(technique.fadeFar, displayZoomLevel)\n                        : technique.fadeFar;\n                const userData = textPath.objInfos;\n                const featureId = getFeatureId(userData);\n                const textElement = new TextElement(\n                    ContextualArabicConverter.instance.convert(textPath.text),\n                    path,\n                    textElementsRenderer.styleCache.getRenderStyle(tile, technique),\n                    textElementsRenderer.styleCache.getLayoutStyle(tile, technique),\n                    priority,\n                    technique.xOffset !== undefined ? technique.xOffset : 0.0,\n                    technique.yOffset !== undefined ? technique.yOffset : 0.0,\n                    featureId,\n                    technique.style,\n                    fadeNear,\n                    fadeFar,\n                    tile.offset\n                );\n                textElement.minZoomLevel =\n                    technique.minZoomLevel !== undefined\n                        ? technique.minZoomLevel\n                        : mapView.minZoomLevel;\n                textElement.maxZoomLevel =\n                    technique.maxZoomLevel !== undefined\n                        ? technique.maxZoomLevel\n                        : mapView.maxZoomLevel;\n                textElement.distanceScale =\n                    technique.distanceScale !== undefined\n                        ? technique.distanceScale\n                        : DEFAULT_TEXT_DISTANCE_SCALE;\n                textElement.mayOverlap = technique.mayOverlap === true;\n                textElement.reserveSpace = technique.reserveSpace !== false;\n                textElement.kind = technique.kind;\n                // Get the userData for text element picking.\n                textElement.userData = textPath.objInfos;\n\n                tile.addTextElement(textElement);\n            }\n        }\n\n        if (decodedTile.textGeometries !== undefined) {\n            for (const text of decodedTile.textGeometries) {\n                if (text.technique === undefined || text.stringCatalog === undefined) {\n                    continue;\n                }\n\n                const technique = decodedTile.techniques[text.technique];\n\n                if (\n                    technique.enabled === false ||\n                    !isTextTechnique(technique) ||\n                    (textFilter !== undefined && !textFilter(technique))\n                ) {\n                    continue;\n                }\n\n                const positions = new THREE.BufferAttribute(\n                    new Float32Array(text.positions.buffer),\n                    text.positions.itemCount\n                );\n\n                const numPositions = positions.count;\n                if (numPositions < 1) {\n                    continue;\n                }\n\n                const priority =\n                    technique.priority !== undefined\n                        ? getPropertyValue(technique.priority, displayZoomLevel)\n                        : 0;\n                const fadeNear =\n                    technique.fadeNear !== undefined\n                        ? getPropertyValue(technique.fadeNear, displayZoomLevel)\n                        : technique.fadeNear;\n                const fadeFar =\n                    technique.fadeFar !== undefined\n                        ? getPropertyValue(technique.fadeFar, displayZoomLevel)\n                        : technique.fadeFar;\n\n                for (let i = 0; i < numPositions; ++i) {\n                    const x = positions.getX(i) + worldOffsetX;\n                    const y = positions.getY(i);\n                    const z = positions.getZ(i);\n                    const label = text.stringCatalog[text.texts[i]];\n                    if (label === undefined) {\n                        // skip missing labels\n                        continue;\n                    }\n\n                    const userData = text.objInfos !== undefined ? text.objInfos[i] : undefined;\n                    const featureId = getFeatureId(userData);\n\n                    const textElement = new TextElement(\n                        ContextualArabicConverter.instance.convert(label!),\n                        new THREE.Vector3(x, y, z),\n                        textElementsRenderer.styleCache.getRenderStyle(tile, technique),\n                        textElementsRenderer.styleCache.getLayoutStyle(tile, technique),\n                        priority,\n                        technique.xOffset || 0.0,\n                        technique.yOffset || 0.0,\n                        featureId,\n                        technique.style,\n                        undefined,\n                        undefined,\n                        tile.offset\n                    );\n\n                    textElement.minZoomLevel =\n                        technique.minZoomLevel !== undefined\n                            ? technique.minZoomLevel\n                            : mapView.minZoomLevel;\n                    textElement.maxZoomLevel =\n                        technique.maxZoomLevel !== undefined\n                            ? technique.maxZoomLevel\n                            : mapView.maxZoomLevel;\n                    textElement.mayOverlap = technique.mayOverlap === true;\n                    textElement.reserveSpace = technique.reserveSpace !== false;\n                    textElement.kind = technique.kind;\n\n                    textElement.fadeNear = fadeNear;\n                    textElement.fadeFar = fadeFar;\n\n                    // Get the userData for text element picking.\n                    textElement.userData = userData;\n\n                    tile.addTextElement(textElement);\n                }\n            }\n        }\n    }\n\n    /**\n     * Creates `Tile` objects from the decoded tile and list of materials specified.\n     *\n     * @param tile The [[Tile]] to create the geometry on.\n     * @param decodedTile The [[DecodedTile]].\n     * @param techniqueFilter: Optional filter. Should return true for any technique that is\n     *      applicable.\n     */\n    createObjects(\n        tile: Tile,\n        decodedTile: DecodedTile,\n        techniqueFilter?: (technique: Technique) => boolean\n    ) {\n        const materials: THREE.Material[] = [];\n        const mapView = tile.mapView;\n        const dataSource = tile.dataSource;\n        const displayZoomLevel = Math.floor(mapView.zoomLevel);\n        const objects = tile.objects;\n        const viewRanges = mapView.viewRanges;\n\n        for (const srcGeometry of decodedTile.geometries) {\n            const groups = srcGeometry.groups;\n            const groupCount = groups.length;\n\n            for (let groupIndex = 0; groupIndex < groupCount; ) {\n                const group = groups[groupIndex++];\n                const start = group.start;\n                const techniqueIndex = group.technique;\n                const technique = decodedTile.techniques[techniqueIndex];\n\n                if (\n                    group.createdOffsets!.indexOf(tile.offset) !== -1 ||\n                    technique.enabled === false ||\n                    (techniqueFilter !== undefined && !techniqueFilter(technique))\n                ) {\n                    continue;\n                }\n\n                let count = group.count;\n                group.createdOffsets!.push(tile.offset);\n\n                // compress consecutive groups\n                for (\n                    ;\n                    groupIndex < groupCount && groups[groupIndex].technique === techniqueIndex;\n                    ++groupIndex\n                ) {\n                    if (start + count !== groups[groupIndex].start) {\n                        break;\n                    }\n\n                    count += groups[groupIndex].count;\n\n                    // Mark this group as created, so it does not get processed again.\n                    groups[groupIndex].createdOffsets!.push(tile.offset);\n                }\n\n                const ObjectCtor = getObjectConstructor(technique);\n\n                if (ObjectCtor === undefined) {\n                    continue;\n                }\n\n                let material: THREE.Material | undefined = materials[techniqueIndex];\n\n                if (material === undefined) {\n                    const onMaterialUpdated = (texture: THREE.Texture) => {\n                        dataSource.requestUpdate();\n                        if (texture !== undefined) {\n                            tile.addOwnedTexture(texture);\n                        }\n                    };\n                    material = createMaterial(\n                        {\n                            technique,\n                            level: displayZoomLevel,\n                            fog: mapView.scene.fog !== null\n                        },\n                        onMaterialUpdated\n                    );\n                    if (material === undefined) {\n                        continue;\n                    }\n                    materials[techniqueIndex] = material;\n                }\n\n                // Modify the standard textured shader to support height-based coloring.\n                if (isTerrainTechnique(technique)) {\n                    this.setupTerrainMaterial(technique, material, tile.mapView.clearColor);\n                }\n\n                const bufferGeometry = new THREE.BufferGeometry();\n\n                srcGeometry.vertexAttributes.forEach((vertexAttribute: BufferAttribute) => {\n                    const buffer = getBufferAttribute(vertexAttribute);\n                    bufferGeometry.setAttribute(vertexAttribute.name, buffer);\n                });\n\n                if (srcGeometry.interleavedVertexAttributes !== undefined) {\n                    srcGeometry.interleavedVertexAttributes.forEach(\n                        (attr: {\n                            type: any;\n                            buffer: any;\n                            stride: any;\n                            attributes: {\n                                forEach: (\n                                    arg0: (interleavedAttr: {\n                                        itemSize: any;\n                                        offset: any;\n                                        name: any;\n                                    }) => void\n                                ) => void;\n                            };\n                        }) => {\n                            const ArrayCtor = getArrayConstructor(attr.type);\n                            const buffer = new THREE.InterleavedBuffer(\n                                new ArrayCtor(attr.buffer),\n                                attr.stride\n                            );\n                            attr.attributes.forEach(\n                                (interleavedAttr: { itemSize: any; offset: any; name: any }) => {\n                                    const attribute = new THREE.InterleavedBufferAttribute(\n                                        buffer,\n                                        interleavedAttr.itemSize,\n                                        interleavedAttr.offset,\n                                        false\n                                    );\n                                    bufferGeometry.setAttribute(interleavedAttr.name, attribute);\n                                }\n                            );\n                        }\n                    );\n                }\n\n                if (srcGeometry.index) {\n                    bufferGeometry.setIndex(getBufferAttribute(srcGeometry.index));\n                }\n\n                if (!bufferGeometry.getAttribute(\"normal\") && needsVertexNormals(technique)) {\n                    bufferGeometry.computeVertexNormals();\n                }\n\n                bufferGeometry.addGroup(start, count);\n\n                if (isSolidLineTechnique(technique)) {\n                    const lineMaterial = material as THREE.RawShaderMaterial;\n                    lineMaterial.uniforms.opacity.value = material.opacity;\n\n                    if (\n                        technique.clipping !== false &&\n                        tile.projection.type === ProjectionType.Planar\n                    ) {\n                        const tileSize = lineMaterial.uniforms.tileSize;\n                        const size = new THREE.Vector3();\n                        tile.boundingBox.getSize(size);\n                        tileSize.value.x = size.x;\n                        tileSize.value.y = size.y;\n                        lineMaterial.defines.TILE_CLIP = 1;\n                    }\n\n                    if (bufferGeometry.getAttribute(\"color\")) {\n                        lineMaterial.defines.USE_COLOR = 1;\n                    }\n\n                    if (\n                        technique.caps !== undefined &&\n                        LineCapsDefinitions.hasOwnProperty(technique.caps)\n                    ) {\n                        lineMaterial.defines[LineCapsDefinitions[technique.caps]] = 1;\n                    }\n                }\n\n                // Add the solid line outlines as a separate object.\n                const hasSolidLinesOutlines: boolean =\n                    isSolidLineTechnique(technique) && technique.secondaryWidth !== undefined;\n\n                const object = new ObjectCtor(bufferGeometry, material);\n                object.renderOrder = technique.renderOrder!;\n\n                if (group.renderOrderOffset !== undefined) {\n                    object.renderOrder += group.renderOrderOffset;\n                }\n\n                if (srcGeometry.uuid !== undefined) {\n                    object.userData.geometryId = srcGeometry.uuid;\n                }\n\n                if (\n                    isFillTechnique(technique) &&\n                    mapView.projection.type === ProjectionType.Planar\n                ) {\n                    object.onBeforeRender = chainCallbacks(\n                        object.onBeforeRender,\n                        (_renderer, _scene, _camera, _geometry, _material) => {\n                            if (_material.clippingPlanes === null) {\n                                _material.clippingPlanes = this.clippingPlanes;\n                                // TODO: Add clipping for Spherical projection.\n                            }\n                            const worldOffsetX =\n                                mapView.projection.worldExtent(0, 0).max.x * tile.offset;\n                            // This prevents aliasing issues in the pixel shader, there are artifacts\n                            // at low zoom levels, so we increase the factor by 10 to 1%.\n                            const expandFactor = mapView.zoomLevel <= 2 ? 1.01 : 1.001;\n                            const planes = _material.clippingPlanes;\n                            const rightConstant =\n                                tile.center.x -\n                                mapView.worldCenter.x +\n                                tile.boundingBox.extents.x * expandFactor +\n                                worldOffsetX;\n\n                            planes[0].constant = rightConstant;\n\n                            const leftConstant =\n                                tile.center.x -\n                                mapView.worldCenter.x -\n                                tile.boundingBox.extents.x * expandFactor +\n                                worldOffsetX;\n                            planes[1].constant = -leftConstant;\n\n                            const topConstant =\n                                tile.center.y -\n                                mapView.worldCenter.y +\n                                tile.boundingBox.extents.y * expandFactor;\n                            planes[2].constant = topConstant;\n\n                            const bottomConstant =\n                                tile.center.y -\n                                mapView.worldCenter.y -\n                                tile.boundingBox.extents.y * expandFactor;\n                            planes[3].constant = -bottomConstant;\n                        }\n                    );\n                }\n\n                if (\n                    (isCirclesTechnique(technique) || isSquaresTechnique(technique)) &&\n                    technique.enablePicking !== undefined\n                ) {\n                    // tslint:disable-next-line:max-line-length\n                    (object as MapViewPoints).enableRayTesting = technique.enablePicking!;\n                }\n\n                if (\n                    isLineTechnique(technique) ||\n                    (isSegmentsTechnique(technique) &&\n                        technique.color !== undefined &&\n                        Expr.isExpr(technique.color))\n                ) {\n                    const fadingParams = this.getFadingParams(displayZoomLevel, technique);\n                    FadingFeature.addRenderHelper(\n                        object,\n                        viewRanges,\n                        fadingParams.fadeNear,\n                        fadingParams.fadeFar,\n                        false,\n                        (renderer, mat) => {\n                            const lineMaterial = mat as THREE.LineBasicMaterial;\n                            applyBaseColorToMaterial(\n                                lineMaterial,\n                                lineMaterial.color,\n                                technique,\n                                technique.color,\n                                mapView.zoomLevel\n                            );\n                        }\n                    );\n                }\n\n                if (isSolidLineTechnique(technique)) {\n                    const fadingParams = this.getFadingParams(displayZoomLevel, technique);\n                    FadingFeature.addRenderHelper(\n                        object,\n                        viewRanges,\n                        fadingParams.fadeNear,\n                        fadingParams.fadeFar,\n                        false,\n                        (renderer, mat) => {\n                            const lineMaterial = mat as SolidLineMaterial;\n                            const unitFactor =\n                                technique.metricUnit === \"Pixel\" ? mapView.pixelToWorld : 1.0;\n\n                            if (technique.color !== undefined) {\n                                applyBaseColorToMaterial(\n                                    lineMaterial,\n                                    lineMaterial.color,\n                                    technique,\n                                    technique.color,\n                                    mapView.zoomLevel\n                                );\n                            }\n\n                            lineMaterial.lineWidth =\n                                getPropertyValue(\n                                    technique.lineWidth,\n                                    mapView.zoomLevel,\n                                    mapView.pixelToWorld\n                                ) *\n                                unitFactor *\n                                0.5;\n\n                            if (technique.outlineWidth !== undefined) {\n                                lineMaterial.outlineWidth =\n                                    getPropertyValue(\n                                        technique.outlineWidth,\n                                        mapView.zoomLevel,\n                                        mapView.pixelToWorld\n                                    ) * unitFactor;\n                            }\n\n                            if (technique.dashSize !== undefined) {\n                                lineMaterial.dashSize =\n                                    getPropertyValue(\n                                        technique.dashSize,\n                                        mapView.zoomLevel,\n                                        mapView.pixelToWorld\n                                    ) *\n                                    unitFactor *\n                                    0.5;\n                            }\n\n                            if (technique.gapSize !== undefined) {\n                                lineMaterial.gapSize =\n                                    getPropertyValue(\n                                        technique.gapSize,\n                                        mapView.zoomLevel,\n                                        mapView.pixelToWorld\n                                    ) *\n                                    unitFactor *\n                                    0.5;\n                            }\n                        }\n                    );\n                }\n\n                if (isExtrudedLineTechnique(technique)) {\n                    // extruded lines are normal meshes, and need transparency only when fading or\n                    // dynamic properties is defined.\n                    if (technique.fadeFar !== undefined || Expr.isExpr(technique.color)) {\n                        const fadingParams = this.getFadingParams(\n                            displayZoomLevel,\n                            technique as StandardExtrudedLineTechnique\n                        );\n\n                        FadingFeature.addRenderHelper(\n                            object,\n                            viewRanges,\n                            fadingParams.fadeNear,\n                            fadingParams.fadeFar,\n                            true,\n                            technique.color !== undefined && Expr.isExpr(technique.color)\n                                ? (renderer, mat) => {\n                                      const extrudedMaterial = mat as\n                                          | MapMeshStandardMaterial\n                                          | MapMeshBasicMaterial;\n\n                                      applyBaseColorToMaterial(\n                                          extrudedMaterial,\n                                          extrudedMaterial.color,\n                                          technique,\n                                          technique.color!,\n                                          mapView.zoomLevel\n                                      );\n                                  }\n                                : undefined\n                        );\n                    }\n                }\n\n                this.addFeatureData(srcGeometry, technique, object);\n                this.addGeometryObjInfos(tile, srcGeometry, technique, object);\n\n                if (isExtrudedPolygonTechnique(technique) || isFillTechnique(technique)) {\n                    // filled polygons are normal meshes, and need transparency only when fading or\n                    // dynamic properties is defined.\n                    const hasDynamicColor =\n                        (technique.color !== undefined && Expr.isExpr(technique.color)) ||\n                        (isExtrudedPolygonTechnique(technique) && Expr.isExpr(technique.emissive));\n                    if (technique.fadeFar !== undefined || hasDynamicColor) {\n                        const fadingParams = this.getFadingParams(displayZoomLevel, technique);\n                        FadingFeature.addRenderHelper(\n                            object,\n                            viewRanges,\n                            fadingParams.fadeNear,\n                            fadingParams.fadeFar,\n                            true,\n                            hasDynamicColor\n                                ? (renderer, mat) => {\n                                      const polygonMaterial = mat as\n                                          | MapMeshBasicMaterial\n                                          | MapMeshStandardMaterial;\n\n                                      applyBaseColorToMaterial(\n                                          polygonMaterial,\n                                          polygonMaterial.color,\n                                          technique,\n                                          technique.color!,\n                                          mapView.zoomLevel\n                                      );\n\n                                      if (\n                                          isExtrudedPolygonTechnique(technique) &&\n                                          technique.emissive !== undefined\n                                      ) {\n                                          const standardMat = mat as MapMeshStandardMaterial;\n\n                                          applySecondaryColorToMaterial(\n                                              standardMat.emissive,\n                                              technique.emissive,\n                                              mapView.zoomLevel\n                                          );\n                                      }\n                                  }\n                                : undefined\n                        );\n                    }\n                }\n\n                const extrudedObjects: Array<{\n                    object: THREE.Object3D;\n                    /**\n                     * If set to `true`, an [[ExtrusionFeature]] that injects extrusion shader\n                     * chunk will be applied to the material. Otherwise, extrusion should\n                     * be added in the material's shader manually.\n                     */\n                    materialFeature: boolean;\n                }> = [];\n\n                const animatedExtrusionHandler = mapView.animatedExtrusionHandler;\n\n                let extrusionAnimationEnabled: boolean | undefined = false;\n\n                if (\n                    isExtrudedPolygonTechnique(technique) &&\n                    animatedExtrusionHandler !== undefined\n                ) {\n                    let animateExtrusionValue = getPropertyValue(\n                        technique.animateExtrusion,\n                        displayZoomLevel\n                    );\n                    if (animateExtrusionValue !== undefined) {\n                        animateExtrusionValue =\n                            typeof animateExtrusionValue === \"boolean\"\n                                ? animateExtrusionValue\n                                : typeof animateExtrusionValue === \"number\"\n                                ? animateExtrusionValue !== 0\n                                : false;\n                    }\n                    extrusionAnimationEnabled =\n                        animateExtrusionValue !== undefined &&\n                        animatedExtrusionHandler.forceEnabled === false\n                            ? animateExtrusionValue\n                            : animatedExtrusionHandler.enabled;\n                }\n\n                const renderDepthPrePass =\n                    isExtrudedPolygonTechnique(technique) && isRenderDepthPrePassEnabled(technique);\n\n                if (renderDepthPrePass) {\n                    const depthPassMesh = createDepthPrePassMesh(object as THREE.Mesh);\n                    // Set geometry kind for depth pass mesh so that it gets the displacement map\n                    // for elevation overlay.\n                    this.registerTileObject(tile, depthPassMesh, technique.kind);\n                    objects.push(depthPassMesh);\n\n                    if (extrusionAnimationEnabled) {\n                        extrudedObjects.push({\n                            object: depthPassMesh,\n                            materialFeature: true\n                        });\n                    }\n\n                    setDepthPrePassStencil(depthPassMesh, object as THREE.Mesh);\n                }\n\n                this.registerTileObject(tile, object, technique.kind);\n                objects.push(object);\n\n                // Add the extruded building edges as a separate geometry.\n                if (isExtrudedPolygonTechnique(technique) && srcGeometry.edgeIndex !== undefined) {\n                    const edgeGeometry = new THREE.BufferGeometry();\n                    edgeGeometry.setAttribute(\"position\", bufferGeometry.getAttribute(\"position\"));\n\n                    const colorAttribute = bufferGeometry.getAttribute(\"color\");\n                    if (colorAttribute !== undefined) {\n                        edgeGeometry.setAttribute(\"color\", colorAttribute);\n                    }\n\n                    const extrusionAttribute = bufferGeometry.getAttribute(\"extrusionAxis\");\n                    if (extrusionAttribute !== undefined) {\n                        edgeGeometry.setAttribute(\"extrusionAxis\", extrusionAttribute);\n                    }\n\n                    const normalAttribute = bufferGeometry.getAttribute(\"normal\");\n                    if (normalAttribute !== undefined) {\n                        edgeGeometry.setAttribute(\"normal\", normalAttribute);\n                    }\n\n                    const uvAttribute = bufferGeometry.getAttribute(\"uv\");\n                    if (uvAttribute !== undefined) {\n                        edgeGeometry.setAttribute(\"uv\", uvAttribute);\n                    }\n\n                    edgeGeometry.setIndex(\n                        getBufferAttribute(srcGeometry.edgeIndex! as BufferAttribute)\n                    );\n\n                    // Read the uniforms from the technique values (and apply the default values).\n                    const extrudedPolygonTechnique = technique as ExtrudedPolygonTechnique;\n\n                    const fadingParams = this.getPolygonFadingParams(\n                        displayZoomLevel,\n                        extrudedPolygonTechnique\n                    );\n\n                    // Configure the edge material based on the theme values.\n                    const materialParams: EdgeMaterialParameters = {\n                        color: fadingParams.color,\n                        colorMix: fadingParams.colorMix,\n                        fadeNear: fadingParams.lineFadeNear,\n                        fadeFar: fadingParams.lineFadeFar\n                    };\n                    const edgeMaterial = new EdgeMaterial(materialParams);\n                    const edgeObj = new THREE.LineSegments(edgeGeometry, edgeMaterial);\n\n                    // Set the correct render order.\n                    edgeObj.renderOrder = object.renderOrder + 0.1;\n\n                    FadingFeature.addRenderHelper(\n                        edgeObj,\n                        viewRanges,\n                        fadingParams.lineFadeNear,\n                        fadingParams.lineFadeFar,\n                        false,\n                        extrudedPolygonTechnique.lineColor !== undefined &&\n                            Expr.isExpr(extrudedPolygonTechnique.lineColor)\n                            ? (renderer, mat) => {\n                                  applyBaseColorToMaterial(\n                                      edgeMaterial,\n                                      edgeMaterial.color,\n                                      extrudedPolygonTechnique,\n                                      extrudedPolygonTechnique.lineColor!,\n                                      mapView.zoomLevel\n                                  );\n                              }\n                            : undefined\n                    );\n\n                    if (extrusionAnimationEnabled) {\n                        extrudedObjects.push({\n                            object: edgeObj,\n                            materialFeature: false\n                        });\n                    }\n\n                    this.registerTileObject(tile, edgeObj, technique.kind);\n                    objects.push(edgeObj);\n                }\n\n                // animate the extrusion of buildings\n                if (isExtrudedPolygonTechnique(technique) && extrusionAnimationEnabled) {\n                    extrudedObjects.push({\n                        object,\n                        materialFeature: true\n                    });\n\n                    const extrusionAnimationDuration =\n                        technique.animateExtrusionDuration !== undefined &&\n                        animatedExtrusionHandler.forceEnabled === false\n                            ? technique.animateExtrusionDuration\n                            : animatedExtrusionHandler.duration;\n\n                    tile.animatedExtrusionTileHandler = new AnimatedExtrusionTileHandler(\n                        tile,\n                        extrudedObjects,\n                        extrusionAnimationDuration\n                    );\n                    mapView.animatedExtrusionHandler.add(tile.animatedExtrusionTileHandler);\n                }\n\n                // Add the fill area edges as a separate geometry.\n\n                if (isFillTechnique(technique) && srcGeometry.edgeIndex !== undefined) {\n                    const outlineGeometry = new THREE.BufferGeometry();\n                    outlineGeometry.setAttribute(\n                        \"position\",\n                        bufferGeometry.getAttribute(\"position\")\n                    );\n                    outlineGeometry.setIndex(getBufferAttribute(srcGeometry.edgeIndex!));\n\n                    const fillTechnique = technique as FillTechnique;\n\n                    const fadingParams = this.getPolygonFadingParams(\n                        displayZoomLevel,\n                        fillTechnique\n                    );\n\n                    // Configure the edge material based on the theme values.\n                    const materialParams: EdgeMaterialParameters = {\n                        color: fadingParams.color,\n                        colorMix: fadingParams.colorMix,\n                        fadeNear: fadingParams.lineFadeNear,\n                        fadeFar: fadingParams.lineFadeFar\n                    };\n                    const outlineMaterial = new EdgeMaterial(materialParams);\n                    const outlineObj = new THREE.LineSegments(outlineGeometry, outlineMaterial);\n                    outlineObj.renderOrder = object.renderOrder + 0.1;\n\n                    FadingFeature.addRenderHelper(\n                        outlineObj,\n                        viewRanges,\n                        fadingParams.lineFadeNear,\n                        fadingParams.lineFadeFar,\n                        false,\n                        fillTechnique.lineColor !== undefined &&\n                            Expr.isExpr(fillTechnique.lineColor)\n                            ? (renderer, mat) => {\n                                  const edgeMaterial = mat as EdgeMaterial;\n                                  applyBaseColorToMaterial(\n                                      edgeMaterial,\n                                      edgeMaterial.color,\n                                      fillTechnique,\n                                      fillTechnique.lineColor!,\n                                      mapView.zoomLevel\n                                  );\n                              }\n                            : undefined\n                    );\n\n                    this.registerTileObject(tile, outlineObj, technique.kind);\n                    objects.push(outlineObj);\n                }\n\n                // Add the fill area edges as a separate geometry.\n                if (hasSolidLinesOutlines) {\n                    const outlineTechnique = technique as SolidLineTechnique;\n                    const outlineMaterial = material.clone() as SolidLineMaterial;\n                    const outlineColor = ColorCache.instance.getColor(\n                        outlineTechnique.secondaryColor !== undefined\n                            ? getPropertyValue(outlineTechnique.secondaryColor!, displayZoomLevel)\n                            : 0x000000\n                    );\n                    outlineMaterial.uniforms.diffuse.value = outlineColor;\n                    if (outlineTechnique.secondaryCaps !== undefined) {\n                        outlineMaterial.caps = outlineTechnique.secondaryCaps;\n                    }\n                    const outlineObj = new ObjectCtor(bufferGeometry, outlineMaterial);\n\n                    outlineObj.renderOrder =\n                        outlineTechnique.secondaryRenderOrder !== undefined\n                            ? outlineTechnique.secondaryRenderOrder\n                            : technique.renderOrder - 0.0000001;\n\n                    if (group.renderOrderOffset !== undefined) {\n                        outlineObj.renderOrder += group.renderOrderOffset;\n                    }\n\n                    const fadingParams = this.getFadingParams(displayZoomLevel, technique);\n                    FadingFeature.addRenderHelper(\n                        outlineObj,\n                        viewRanges,\n                        fadingParams.fadeNear,\n                        fadingParams.fadeFar,\n                        false,\n                        (renderer, mat) => {\n                            const lineMaterial = mat as SolidLineMaterial;\n\n                            const unitFactor =\n                                outlineTechnique.metricUnit === \"Pixel\"\n                                    ? mapView.pixelToWorld\n                                    : 1.0;\n\n                            if (outlineTechnique.secondaryColor !== undefined) {\n                                applyBaseColorToMaterial(\n                                    lineMaterial,\n                                    lineMaterial.color,\n                                    outlineTechnique,\n                                    outlineTechnique.secondaryColor,\n                                    mapView.zoomLevel\n                                );\n                            }\n\n                            if (outlineTechnique.secondaryWidth !== undefined) {\n                                const techniqueLineWidth = getPropertyValue(\n                                    outlineTechnique.lineWidth!,\n                                    mapView.zoomLevel,\n                                    mapView.pixelToWorld\n                                );\n                                const techniqueSecondaryWidth = getPropertyValue(\n                                    outlineTechnique.secondaryWidth!,\n                                    mapView.zoomLevel,\n                                    mapView.pixelToWorld\n                                );\n                                const techniqueOpacity = getPropertyValue(\n                                    outlineTechnique.opacity,\n                                    mapView.zoomLevel\n                                );\n                                // hide outline when it's equal or smaller then line to avoid subpixel contour\n                                const lineWidth =\n                                    techniqueSecondaryWidth <= techniqueLineWidth &&\n                                    (techniqueOpacity === undefined || techniqueOpacity === 1)\n                                        ? 0\n                                        : techniqueSecondaryWidth;\n                                lineMaterial.lineWidth = lineWidth * unitFactor * 0.5;\n                            }\n                        }\n                    );\n\n                    this.registerTileObject(tile, outlineObj, technique.kind);\n                    objects.push(outlineObj);\n                }\n            }\n        }\n    }\n\n    /**\n     * Prepare the [[Tile]]s pois. Uses the [[PoiManager]] in [[MapView]].\n     */\n    preparePois(tile: Tile, decodedTile: DecodedTile) {\n        if (decodedTile.poiGeometries !== undefined) {\n            tile.mapView.poiManager.addPois(tile, decodedTile);\n        }\n    }\n\n    /**\n     * Creates and add a background plane for the tile.\n     */\n    addGroundPlane(tile: Tile, renderOrder: number) {\n        const mapView = tile.mapView;\n        const dataSource = tile.dataSource;\n        const projection = tile.projection;\n\n        const color = mapView.clearColor;\n        const tmpV = new THREE.Vector3();\n\n        if (tile.projection.type === ProjectionType.Spherical) {\n            const { east, west, north, south } = tile.geoBox;\n            const sourceProjection = dataSource.getTilingScheme().projection;\n            const g = new THREE.BufferGeometry();\n            const posAttr = new THREE.BufferAttribute(\n                new Float32Array([\n                    ...sourceProjection\n                        .projectPoint(new GeoCoordinates(south, west), tmpV)\n                        .toArray(),\n                    ...sourceProjection\n                        .projectPoint(new GeoCoordinates(south, east), tmpV)\n                        .toArray(),\n                    ...sourceProjection\n                        .projectPoint(new GeoCoordinates(north, west), tmpV)\n                        .toArray(),\n                    ...sourceProjection\n                        .projectPoint(new GeoCoordinates(north, east), tmpV)\n                        .toArray()\n                ]),\n                3\n            );\n            g.setAttribute(\"position\", posAttr);\n            g.setIndex(new THREE.BufferAttribute(new Uint16Array([0, 1, 2, 2, 1, 3]), 1));\n            const modifier = new SphericalGeometrySubdivisionModifier(\n                THREE.Math.degToRad(10),\n                sourceProjection\n            );\n            modifier.modify(g);\n\n            for (let i = 0; i < posAttr.array.length; i += 3) {\n                tmpV.set(posAttr.array[i], posAttr.array[i + 1], posAttr.array[i + 2]);\n                projection.reprojectPoint(sourceProjection, tmpV, tmpV);\n                tmpV.sub(tile.center);\n                (posAttr.array as Float32Array)[i] = tmpV.x;\n                (posAttr.array as Float32Array)[i + 1] = tmpV.y;\n                (posAttr.array as Float32Array)[i + 2] = tmpV.z;\n            }\n            posAttr.needsUpdate = true;\n\n            const material = new MapMeshBasicMaterial({\n                color,\n                visible: true,\n                depthWrite: true\n            });\n            const mesh = new THREE.Mesh(g, material);\n            mesh.renderOrder = renderOrder;\n            this.registerTileObject(tile, mesh, GeometryKind.Background);\n            tile.objects.push(mesh);\n        } else {\n            // Add a ground plane to the tile.\n            tile.boundingBox.getSize(tmpV);\n            const groundPlane = this.createPlane(\n                tmpV.x,\n                tmpV.y,\n                tile.center,\n                color,\n                true,\n                renderOrder\n            );\n\n            this.registerTileObject(tile, groundPlane, GeometryKind.Background);\n            tile.objects.push(groundPlane);\n        }\n    }\n\n    private setupTerrainMaterial(\n        technique: TerrainTechnique,\n        material: THREE.Material,\n        terrainColor: number\n    ) {\n        if (technique.displacementMap === undefined) {\n            // Render terrain using the given color.\n            const stdMaterial = material as MapMeshStandardMaterial;\n            stdMaterial.color.set(terrainColor);\n            return;\n        }\n\n        // Render terrain using height-based colors.\n        (material as any).onBeforeCompile = (shader: THREE.Shader) => {\n            shader.fragmentShader = shader.fragmentShader.replace(\n                \"#include <map_pars_fragment>\",\n                `#include <map_pars_fragment>\n    uniform sampler2D displacementMap;\n    uniform float displacementScale;\n    uniform float displacementBias;`\n            );\n            shader.fragmentShader = shader.fragmentShader.replace(\n                \"#include <map_fragment>\",\n                `#ifdef USE_MAP\n    float minElevation = ${EarthConstants.MIN_ELEVATION.toFixed(1)};\n    float maxElevation = ${EarthConstants.MAX_ELEVATION.toFixed(1)};\n    float elevationRange = maxElevation - minElevation;\n\n    float disp = texture2D( displacementMap, vUv ).x * displacementScale + displacementBias;\n    vec4 texelColor = texture2D( map, vec2((disp - minElevation) / elevationRange, 0.0) );\n    texelColor = mapTexelToLinear( texelColor );\n    diffuseColor *= texelColor;\n#endif`\n            );\n            // We remove the displacement map from manipulating the vertices, it is\n            // however still required for the pixel shader, so it can't be directly\n            // removed.\n            shader.vertexShader = shader.vertexShader.replace(\n                \"#include <displacementmap_vertex>\",\n                \"\"\n            );\n        };\n        (material as MapMeshStandardMaterial).displacementMap!.needsUpdate = true;\n    }\n\n    /**\n     * Create a simple flat plane for a [[Tile]].\n     *\n     * @param {number} width Width of plane.\n     * @param {number} height Height of plane.\n     * @param {THREE.Vector3} planeCenter Center of plane.\n     * @param {number} colorHex Color of the plane mesh.\n     * @param {boolean} isVisible `True` to make the mesh visible.\n     * @returns {THREE.Mesh} The created plane.\n     */\n    private createPlane(\n        width: number,\n        height: number,\n        planeCenter: THREE.Vector3,\n        colorHex: number,\n        isVisible: boolean,\n        renderOrder: number\n    ): THREE.Mesh {\n        const geometry = new THREE.PlaneGeometry(width, height, 1);\n        // TODO cache the material HARP-4207\n        const material = new MapMeshBasicMaterial({\n            color: colorHex,\n            visible: isVisible,\n            depthWrite: false\n        });\n        const plane = new THREE.Mesh(geometry, material);\n        plane.position.copy(planeCenter);\n        // Render before everything else\n        plane.renderOrder = renderOrder;\n        return plane;\n    }\n\n    /**\n     * Pass the feature data on to the object, so it can be used in picking\n     * `MapView.intersectMapObjects()`. Do not pass the feature data if the technique is a\n     * solid-line, because the line picking functionality for the lines is not object based, but\n     * tile based.\n     *\n     * @param srcGeometry The original [[Geometry]].\n     * @param technique The corresponding [[Technique]].\n     * @param object The object to pass info to.\n     */\n    private addFeatureData(srcGeometry: Geometry, technique: Technique, object: THREE.Object3D) {\n        if (\n            ((srcGeometry.objInfos !== undefined && srcGeometry.objInfos.length > 0) ||\n                isCirclesTechnique(technique) ||\n                isSquaresTechnique(technique)) &&\n            !isSolidLineTechnique(technique)\n        ) {\n            const featureData: TileFeatureData = {\n                geometryType: srcGeometry.type,\n                starts: srcGeometry.featureStarts,\n                objInfos: srcGeometry.objInfos\n            };\n            object.userData.feature = featureData;\n        }\n    }\n\n    private addGeometryObjInfos(\n        tile: Tile,\n        srcGeometry: Geometry,\n        technique: Technique,\n        object: THREE.Object3D\n    ) {\n        if (srcGeometry.objInfos === undefined || Object.keys(object.userData).length > 0) {\n            return;\n        }\n\n        if (isTerrainTechnique(technique)) {\n            if (typeof srcGeometry.objInfos![0] === \"number\") {\n                assert(false, \"Wrong attribute map type for terrain geometry\");\n                return;\n            }\n\n            const displacementMap = (srcGeometry.objInfos as DisplacementMap[])[0];\n            const tileDisplacementMap: TileDisplacementMap = {\n                tileKey: tile.tileKey,\n                texture: new THREE.DataTexture(\n                    displacementMap.buffer,\n                    displacementMap.xCountVertices,\n                    displacementMap.yCountVertices,\n                    THREE.LuminanceFormat,\n                    THREE.FloatType\n                ),\n                displacementMap\n            };\n            object.userData = tileDisplacementMap;\n        } else {\n            object.userData = srcGeometry.objInfos;\n        }\n    }\n\n    /**\n     * Gets the fading parameters for several kinds of objects.\n     */\n    private getFadingParams(\n        displayZoomLevel: number,\n        technique: MakeTechniqueAttrs<BaseTechniqueParams>\n    ): FadingParameters {\n        const fadeNear =\n            technique.fadeNear !== undefined\n                ? getPropertyValue(technique.fadeNear, displayZoomLevel)\n                : FadingFeature.DEFAULT_FADE_NEAR;\n        const fadeFar =\n            technique.fadeFar !== undefined\n                ? getPropertyValue(technique.fadeFar, displayZoomLevel)\n                : FadingFeature.DEFAULT_FADE_FAR;\n        return {\n            fadeNear,\n            fadeFar\n        };\n    }\n\n    /**\n     * Gets the fading parameters for several kinds of objects.\n     */\n    private getPolygonFadingParams(\n        displayZoomLevel: number,\n        technique: FillTechnique | ExtrudedPolygonTechnique\n    ): PolygonFadingParameters {\n        let color: string | number | undefined;\n        let colorMix = EdgeMaterial.DEFAULT_COLOR_MIX;\n\n        if (technique.lineColor !== undefined) {\n            color = getPropertyValue(technique.lineColor, displayZoomLevel);\n            if (isExtrudedPolygonTechnique(technique)) {\n                const extrudedPolygonTechnique = technique as ExtrudedPolygonTechnique;\n                colorMix =\n                    extrudedPolygonTechnique.lineColorMix !== undefined\n                        ? extrudedPolygonTechnique.lineColorMix\n                        : EdgeMaterial.DEFAULT_COLOR_MIX;\n            }\n        }\n\n        const fadeNear =\n            technique.fadeNear !== undefined\n                ? getPropertyValue(technique.fadeNear, displayZoomLevel)\n                : FadingFeature.DEFAULT_FADE_NEAR;\n        const fadeFar =\n            technique.fadeFar !== undefined\n                ? getPropertyValue(technique.fadeFar, displayZoomLevel)\n                : FadingFeature.DEFAULT_FADE_FAR;\n\n        const lineFadeNear =\n            technique.lineFadeNear !== undefined\n                ? getPropertyValue(technique.lineFadeNear, displayZoomLevel)\n                : fadeNear;\n        const lineFadeFar =\n            technique.lineFadeFar !== undefined\n                ? getPropertyValue(technique.lineFadeFar, displayZoomLevel)\n                : fadeFar;\n\n        if (color === undefined) {\n            color = EdgeMaterial.DEFAULT_COLOR;\n        }\n\n        return {\n            color,\n            colorMix,\n            fadeNear,\n            fadeFar,\n            lineFadeNear,\n            lineFadeFar\n        };\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\n/**\n * Use `ColorCache` to reuse a color specified by name and save allocation as well as\n * setup time.\n *\n * Implemented as a singleton. Do not modify colors after getting them from the `ColorCache`.\n */\nexport class ColorCache {\n    /**\n     * Return instance of `ColorCache`.\n     */\n    static get instance() {\n        return this.m_instance;\n    }\n\n    private static m_instance: ColorCache = new ColorCache();\n    private m_map: Map<string, THREE.Color> = new Map();\n\n    /**\n     * Returns the color for the given `colorCode`. This function may reuse a previously generated\n     * color, so you cannot modify the contents of the color.\n     *\n     * @param colorCode ThreeJS color code or name. You must provide a valid color code or name,\n     * as this function does not do any validation.\n     */\n    getColor(colorCode: string | number): THREE.Color {\n        if (typeof colorCode === \"number\") {\n            colorCode = \"#\" + colorCode.toString(16).padStart(6, \"0\");\n        }\n\n        let color = this.m_map.get(colorCode);\n        if (color !== undefined) {\n            return color;\n        }\n        color = new THREE.Color(colorCode);\n        this.m_map.set(colorCode, color);\n        return color;\n    }\n\n    /**\n     * Returns the number of elements in the cache.\n     */\n    get size(): number {\n        return this.m_map.size;\n    }\n\n    /**\n     * Clears the cache. Only references to the THREE.Color are removed from the cache.\n     * Consequently, clearing the cache does not cause any negative visual impact.\n     */\n    clear(): void {\n        this.m_map.clear();\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Types of text elements.\n */\nexport enum TextElementType {\n    PoiLabel,\n    PathLabel,\n    LineMarker\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { LineMarkerTechnique, Theme } from \"@here/harp-datasource-protocol\";\nimport {\n    AdditionParameters,\n    DEFAULT_TEXT_CANVAS_LAYER,\n    FontCatalog,\n    MeasurementParameters,\n    TextBufferAdditionParameters,\n    TextBufferCreationParameters,\n    TextCanvas,\n    TextLayoutStyle,\n    TextRenderStyle\n} from \"@here/harp-text-canvas\";\nimport {\n    assert,\n    LoggerManager,\n    LogLevel,\n    Math2D,\n    MathUtils,\n    PerformanceTimer\n} from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { Projection } from \"@here/harp-geoutils\";\nimport { DataSource } from \"../DataSource\";\nimport { debugContext } from \"../DebugContext\";\nimport { PickObjectType, PickResult } from \"../PickHandler\";\nimport { PoiManager } from \"../poi/PoiManager\";\nimport { PoiRenderer } from \"../poi/PoiRenderer\";\nimport { PoiRendererFactory } from \"../poi/PoiRendererFactory\";\nimport { IBox, LineWithBound, ScreenCollisions } from \"../ScreenCollisions\";\nimport { ScreenProjector } from \"../ScreenProjector\";\nimport { Tile } from \"../Tile\";\nimport { MapViewUtils } from \"../Utils\";\nimport { DataSourceTileList } from \"../VisibleTileSet\";\nimport { FontCatalogLoader } from \"./FontCatalogLoader\";\nimport {\n    checkReadyForPlacement,\n    computePointTextOffset,\n    computeViewDistance,\n    getMaxViewDistance,\n    PrePlacementResult\n} from \"./Placement\";\nimport { PlacementStats } from \"./PlacementStats\";\nimport { RenderState } from \"./RenderState\";\nimport { SimpleLineCurve, SimplePath } from \"./SimplePath\";\nimport { TextCanvasFactory } from \"./TextCanvasFactory\";\nimport { TextCanvasRenderer } from \"./TextCanvasRenderer\";\nimport { LoadingState, TextElement, TextPickResult } from \"./TextElement\";\nimport { TextElementGroup } from \"./TextElementGroup\";\nimport { TextElementFilter, TextElementGroupState } from \"./TextElementGroupState\";\nimport {\n    initializeDefaultOptions,\n    TextElementsRendererOptions\n} from \"./TextElementsRendererOptions\";\nimport { TextElementState } from \"./TextElementState\";\nimport { TextElementStateCache } from \"./TextElementStateCache\";\nimport { TextElementType } from \"./TextElementType\";\nimport { TextElementStyle, TextStyleCache } from \"./TextStyleCache\";\nimport { UpdateStats } from \"./UpdateStats\";\nimport { ViewState } from \"./ViewState\";\n\nconst MAX_INITIALIZED_TEXT_ELEMENTS_PER_FRAME = Infinity;\n\ninterface RenderParams {\n    numRenderedTextElements: number;\n    // TODO: HARP-7373. Move to update() method at the end of the frame.\n    fadeAnimationRunning: boolean;\n    time: number;\n}\n\ninterface TempParams {\n    additionParams: AdditionParameters;\n    poiMeasurementParams: MeasurementParameters;\n    measurementParams: MeasurementParameters;\n    bufferAdditionParams: TextBufferAdditionParameters;\n}\n\nenum Pass {\n    PersistentLabels,\n    NewLabels\n}\n\n/**\n * Default distance scale. Will be applied if distanceScale is not defined in the technique.\n * Defines the scale that will be applied to labeled icons (icon and text) in the distance.\n */\nexport const DEFAULT_TEXT_DISTANCE_SCALE = 0.5;\n\n/**\n * Maximum number of recommended labels. If more labels are encountered, the \"overloaded\" mode is\n * set, which modifies the behavior of label placement and rendering, trying to keep delivering an\n * interactive performance. The overloaded mode should not be activated if the [[MapView]] is\n * rendering a static image (camera not moving and no animation running).\n */\nconst OVERLOAD_LABEL_LIMIT = 20000;\n\n/**\n * If \"overloaded\" is `true`:\n *\n * Default number of labels/POIs updated in a frame. They are rendered only if they fit. If the\n * camera is not moving, it is ignored. See [[TextElementsRenderer.isDynamicFrame]].\n */\nconst OVERLOAD_UPDATED_LABEL_LIMIT = 100;\n\n/**\n * If \"overloaded\" is `true`:\n *\n * Maximum time in milliseconds available for placement. If value is <= 0, or if the camera is not\n * moving, it is ignored. See [[TextElementsRenderer.isDynamicFrame]].\n */\nconst OVERLOAD_UPDATE_TIME_LIMIT = 5;\n\n/**\n * If \"overloaded\" is `true`:\n *\n * Maximum time in milliseconds available for rendering. If value is <= 0, or if the camera is not\n * moving, it is ignored. See [[TextElementsRenderer.isDynamicFrame]].\n */\nconst OVERLOAD_PLACE_TIME_LIMIT = 10;\n\n/**\n * Minimum number of pixels per character. Used during estimation if there is enough screen space\n * available to render a text.\n */\nconst MIN_AVERAGE_CHAR_WIDTH = 5;\n\nconst logger = LoggerManager.instance.create(\"TextElementsRenderer\", { level: LogLevel.Log });\n\n// Development flag: Enable debug print.\nconst PRINT_LABEL_DEBUG_INFO: boolean = false;\nconst updateStats = PRINT_LABEL_DEBUG_INFO ? new UpdateStats(logger) : undefined;\nconst placementStats = PRINT_LABEL_DEBUG_INFO ? new PlacementStats(logger) : undefined;\n\nconst tempBox = new THREE.Box2();\nconst tempBoxes: THREE.Box2[] = [];\nconst tempBox2D = new Math2D.Box();\n\nconst tempPosition = new THREE.Vector3();\nconst tempScreenPosition = new THREE.Vector2();\nconst tempScreenPoints: THREE.Vector2[] = [];\nconst tempPoiScreenPosition = new THREE.Vector2();\nconst tempTextOffset = new THREE.Vector2();\nconst tmpTextBufferCreationParams: TextBufferCreationParameters = {};\n\nclass TileTextElements {\n    constructor(readonly tile: Tile, readonly group: TextElementGroup) {}\n}\n\nclass TextElementLists {\n    constructor(readonly lists: TileTextElements[]) {}\n\n    get priority() {\n        assert(this.lists.length > 0);\n        // All text element lists here have the same priority.\n        return this.lists[0].group.priority;\n    }\n    /**\n     * Sum up the number of elements in all lists.\n     */\n    count(): number {\n        let n = 0;\n        for (const list of this.lists) {\n            n += list.group.elements.length;\n        }\n        return n;\n    }\n}\n\nfunction checkIfTextElementsChanged(dataSourceTileList: DataSourceTileList[]) {\n    let textElementsChanged = false;\n\n    dataSourceTileList.forEach(({ renderedTiles }) => {\n        renderedTiles.forEach(tile => {\n            if (tile.textElementsChanged) {\n                tile.textElementsChanged = false;\n                textElementsChanged = true;\n            }\n        });\n    });\n\n    return textElementsChanged;\n}\n\nexport type ViewUpdateCallback = () => void;\n\nfunction isPlacementTimeExceeded(startTime: number | undefined): boolean {\n    // startTime is set in overload mode.\n    if (startTime === undefined || OVERLOAD_PLACE_TIME_LIMIT <= 0) {\n        return false;\n    }\n    const endTime = PerformanceTimer.now();\n    const elapsedTime = endTime - startTime;\n    if (elapsedTime > OVERLOAD_PLACE_TIME_LIMIT) {\n        logger.debug(\"Placement time limit exceeded.\");\n        return true;\n    }\n    return false;\n}\n\n/**\n * @hidden\n *\n * Internal class to manage all text rendering.\n */\nexport class TextElementsRenderer {\n    private m_initialized: boolean = false;\n    private m_initPromise: Promise<void> | undefined;\n    private m_glyphLoadingCount: number = 0;\n    private m_loadPromise: Promise<any> | undefined;\n    private m_initializedTextElementCount = 0;\n    private readonly m_options: TextElementsRendererOptions;\n\n    private readonly m_textStyleCache: TextStyleCache;\n    private m_textRenderers: TextCanvasRenderer[] = [];\n\n    private m_overlayTextElements?: TextElement[];\n\n    // TODO: Replace this for an array of textures when more fonts are in use.\n    private m_debugGlyphTextureCacheMesh?: THREE.Mesh;\n    private m_debugGlyphTextureCacheWireMesh?: THREE.LineSegments;\n\n    private m_tmpVector = new THREE.Vector2();\n    private m_overloaded: boolean = false;\n    private m_cacheInvalidated: boolean = false;\n    private m_forceNewLabelsPass: boolean = false;\n\n    private readonly m_textElementStateCache: TextElementStateCache = new TextElementStateCache();\n\n    /**\n     * Create the `TextElementsRenderer` which selects which labels should be placed on screen as\n     * a preprocessing step, which is not done every frame, and also renders the placed\n     * [[TextElement]]s every frame.\n     *\n     * @param m_viewState State of the view for which this renderer will draw text.\n     * @param m_viewCamera Camera used by the view for which this renderer will draw text.\n     * @param m_viewUpdateCallback To be called whenever the view needs to be updated.\n     * @param m_screenCollisions General 2D screen occlusion management, may be shared between\n     *     instances.\n     * @param m_screenProjector Projects 3D coordinates into screen space.\n     * @param m_textCanvasFactory To create TextCanvas instances.\n     * @param m_poiRendererFactory To create PoiRenderer instances.\n     * @param m_poiManager To prepare pois for rendering.\n     * @param m_fontCatalogLoader To load font catalogs.\n     * @param m_theme Theme defining  text styles.\n     * @param options Configuration options for the text renderer. See\n     * [[TextElementsRendererOptions]].\n     */\n    constructor(\n        private m_viewState: ViewState,\n        private m_viewCamera: THREE.Camera,\n        private m_viewUpdateCallback: ViewUpdateCallback,\n        private m_screenCollisions: ScreenCollisions,\n        private m_screenProjector: ScreenProjector,\n        private m_textCanvasFactory: TextCanvasFactory,\n        private m_poiManager: PoiManager,\n        private m_poiRendererFactory: PoiRendererFactory,\n        private m_fontCatalogLoader: FontCatalogLoader,\n        private m_theme: Theme,\n        options: TextElementsRendererOptions\n    ) {\n        this.m_textStyleCache = new TextStyleCache(this.m_theme);\n\n        this.m_options = { ...options };\n        initializeDefaultOptions(this.m_options);\n\n        this.m_textCanvasFactory.setGlyphCountLimits(\n            this.m_options.minNumGlyphs!,\n            this.m_options.maxNumGlyphs!\n        );\n    }\n\n    /**\n     * Disable all fading animations (for debugging and performance measurement). Defaults to\n     * `false`.\n     */\n    set disableFading(disable: boolean) {\n        this.m_options.disableFading = disable;\n    }\n\n    get disableFading(): boolean {\n        return this.m_options.disableFading === true;\n    }\n\n    get styleCache() {\n        return this.m_textStyleCache;\n    }\n\n    /**\n     * Render the text using the specified camera into the current canvas.\n     *\n     * @param camera Orthographic camera to use.\n     */\n    renderText(camera: THREE.OrthographicCamera) {\n        if (!this.initialized) {\n            return;\n        }\n\n        this.updateGlyphDebugMesh();\n\n        for (const textRenderer of this.m_textRenderers) {\n            textRenderer.textCanvas.render(camera);\n        }\n    }\n\n    /**\n     * Forces update of text elements in the next call to [[placeText]].\n     */\n    invalidateCache() {\n        this.m_cacheInvalidated = true;\n    }\n\n    /**\n     * Notify `TextElementsRenderer` that the camera has started a movement.\n     */\n    movementStarted() {\n        // Nothing to do (yet)\n    }\n\n    /**\n     * Notify `TextElementsRenderer` that the camera has finished its movement.\n     */\n    movementFinished() {\n        this.invalidateCache();\n    }\n\n    /**\n     * Is `true` if number of [[TextElement]]s in visible tiles is larger than the recommended\n     * number `OVERLOAD_LABEL_LIMIT`.\n     */\n    get overloaded(): boolean {\n        return this.m_overloaded;\n    }\n\n    /**\n     * Places text elements for the current frame.\n     * @param dataSourceTileList List of tiles to be rendered for each data source.\n     * @param projection The view's projection.\n     * @param time Current frame time.\n     */\n    placeText(dataSourceTileList: DataSourceTileList[], projection: Projection, time: number) {\n        const tileTextElementsChanged = checkIfTextElementsChanged(dataSourceTileList);\n\n        const textElementsAvailable = this.hasOverlayText() || tileTextElementsChanged;\n        if (!this.initialize(textElementsAvailable)) {\n            return;\n        }\n\n        const updateTextElements =\n            this.m_cacheInvalidated ||\n            tileTextElementsChanged ||\n            this.m_viewState.renderedTilesChanged;\n\n        logger.debug(\n            `FRAME: ${this.m_viewState.frameNumber}, ZOOM LEVEL: ${this.m_viewState.zoomLevel}`\n        );\n\n        if (updateTextElements) {\n            this.m_textElementStateCache.clearVisited();\n            this.updateTextElements(dataSourceTileList, projection);\n        }\n        const findReplacements = updateTextElements;\n        const anyTextGroupEvicted = this.m_textElementStateCache.update(\n            time,\n            this.m_options.disableFading!,\n            findReplacements,\n            this.m_viewState.zoomLevel\n        );\n\n        this.reset();\n        this.prepopulateScreenWithBlockingElements(dataSourceTileList);\n\n        // New text elements must be placed either if text elements were updated in this frame\n        // or if any text element group was evicted. The second case happens when the group is not\n        // visited anymore and all it's elements just became invisible, which means there's newly\n        // available screen space where new text elements could be placed. A common scenario where\n        // this happens is zooming in/out: text groups from the old level may still be fading out\n        // after all groups in the new level were updated.\n        const placeNewTextElements = updateTextElements || anyTextGroupEvicted;\n        this.placeTextElements(time, placeNewTextElements);\n        this.placeOverlayTextElements();\n        this.updateTextRenderers();\n    }\n\n    /**\n     * Adds new overlay text elements to this `MapView`.\n     *\n     * @param textElements Array of [[TextElement]] to be added.\n     */\n    addOverlayText(textElements: TextElement[]): void {\n        if (textElements.length === 0) {\n            return;\n        }\n        this.m_overlayTextElements =\n            this.m_overlayTextElements === undefined\n                ? textElements.slice()\n                : this.m_overlayTextElements.concat(textElements);\n    }\n\n    /**\n     * Adds new overlay text elements to this `MapView`.\n     *\n     * @param textElements Array of [[TextElement]] to be added.\n     */\n    clearOverlayText(): void {\n        this.m_overlayTextElements = [];\n    }\n\n    /**\n     * @returns Whether there's overlay text to be rendered.\n     */\n    hasOverlayText(): boolean {\n        return this.m_overlayTextElements !== undefined && this.m_overlayTextElements.length > 0;\n    }\n\n    get overlayText(): TextElement[] | undefined {\n        return this.m_overlayTextElements;\n    }\n\n    /**\n     * Fill the picking results for the pixel with the given screen coordinate. If multiple\n     * [[TextElement]]s are found, the order of the results is unspecified.\n     *\n     * Note: [[TextElement]]s with identical `featureId` or identical `userData` will only appear\n     * once in the list `pickResults`.\n     *\n     * @param screenPosition Screen coordinate of picking position.\n     * @param pickResults Array filled with pick results.\n     */\n    pickTextElements(screenPosition: THREE.Vector2, pickResults: PickResult[]) {\n        const pickHandler = (pickData: any | undefined, pickObjectType: PickObjectType) => {\n            const textElement = pickData as TextElement;\n\n            if (textElement === undefined) {\n                return;\n            }\n\n            let isDuplicate = false;\n\n            if (textElement.featureId !== undefined) {\n                isDuplicate = pickResults.some(pickResult => {\n                    return (\n                        pickResult !== undefined &&\n                        pickObjectType === pickResult.type &&\n                        ((pickResult.featureId !== undefined &&\n                            pickResult.featureId === textElement.featureId) ||\n                            (pickResult.userData !== undefined &&\n                                pickResult.userData === textElement.userData))\n                    );\n                });\n\n                if (!isDuplicate) {\n                    const pickResult: TextPickResult = {\n                        type: pickObjectType,\n                        point: screenPosition,\n                        distance: 0,\n                        featureId: textElement.featureId,\n                        userData: textElement.userData,\n                        text: textElement.text\n                    };\n\n                    pickResults.push(pickResult);\n                }\n            }\n        };\n\n        for (const textRenderer of this.m_textRenderers) {\n            textRenderer.textCanvas.pickText(screenPosition, (pickData: any | undefined) => {\n                pickHandler(pickData, PickObjectType.Text);\n            });\n            textRenderer.poiRenderer.pickTextElements(\n                screenPosition,\n                (pickData: any | undefined) => {\n                    pickHandler(pickData, PickObjectType.Icon);\n                }\n            );\n        }\n    }\n\n    /**\n     * `true` if any resource used by any `FontCatalog` is still loading.\n     */\n    get loading(): boolean {\n        return this.m_fontCatalogLoader.loading || this.m_glyphLoadingCount > 0;\n    }\n\n    /**\n     * Waits till all pending resources from any `FontCatalog` are loaded.\n     */\n    async waitLoaded(): Promise<boolean> {\n        const initialized = await this.waitInitialized();\n        if (!initialized) {\n            return false;\n        }\n        if (this.m_loadPromise === undefined) {\n            return false;\n        }\n        await this.m_loadPromise;\n        return true;\n    }\n\n    /**\n     * Reset the current text render states of all visible tiles. All [[TextElement]]s will fade in\n     * after that as if they have just been added.\n     */\n    clearRenderStates() {\n        this.m_textElementStateCache.clear();\n    }\n\n    /**\n     * Return memory used by all objects managed by `TextElementsRenderer`.\n     *\n     * @returns `MemoryUsage` Heap and GPU memory used by this `TextElementsRenderer`.\n     */\n    getMemoryUsage(): MapViewUtils.MemoryUsage {\n        const memoryUsage = {\n            heapSize: 0,\n            gpuSize: 0\n        };\n\n        for (const renderer of this.m_textRenderers) {\n            renderer.textCanvas.getMemoryUsage(memoryUsage);\n            renderer.poiRenderer.getMemoryUsage(memoryUsage);\n        }\n\n        return memoryUsage;\n    }\n\n    get initialized(): boolean {\n        return this.m_initialized;\n    }\n\n    get initializing(): boolean {\n        return this.m_initPromise !== undefined;\n    }\n\n    /**\n     * Waits until initialization is done.\n     * @returns Promise resolved to true if initialization was done, false otherwise.\n     */\n    async waitInitialized(): Promise<boolean> {\n        if (this.initialized) {\n            return true;\n        }\n\n        if (!this.initializing) {\n            return false;\n        }\n        await this.m_initPromise;\n        return true;\n    }\n\n    /**\n     * Initializes the text renderer once there's any text element available for rendering.\n     * @param textElementsAvailable Indicates whether there's any text element to be rendered.\n     * @returns Whether the text renderer is initialized.\n     */\n    private initialize(textElementsAvailable: boolean): boolean {\n        if (!this.initialized && !this.initializing && textElementsAvailable) {\n            this.initializeDefaultAssets();\n            this.m_initPromise = this.initializeTextCanvases().then(() => {\n                this.m_initialized = true;\n                this.m_initPromise = undefined;\n                this.invalidateCache(); // Force cache update after initialization.\n                this.m_viewUpdateCallback();\n            });\n        }\n        return this.initialized;\n    }\n\n    /**\n     * Reset internal state at the beginning of a frame.\n     */\n    private reset() {\n        this.m_screenCollisions.reset();\n        for (const textRenderer of this.m_textRenderers) {\n            textRenderer.textCanvas.clear();\n            textRenderer.poiRenderer.reset();\n        }\n        this.m_initializedTextElementCount = 0;\n    }\n\n    /**\n     * Update state at the end of a frame.\n     */\n    private updateTextRenderers() {\n        for (const textRenderer of this.m_textRenderers) {\n            textRenderer.poiRenderer.update();\n        }\n    }\n\n    /**\n     * Fills the screen with lines projected from world space, see [[Tile.blockingElements]].\n     * @note These boxes have highest priority, so will block all other labels.\n     * @param dataSourceTileList List of tiles to be rendered for each data source.\n     */\n    private prepopulateScreenWithBlockingElements(dataSourceTileList: DataSourceTileList[]) {\n        const boxes: IBox[] = [];\n        dataSourceTileList.forEach(renderListEntry => {\n            const startLinePointProj = new THREE.Vector3();\n            const endLinePointProj = new THREE.Vector3();\n            for (const tile of renderListEntry.renderedTiles.values()) {\n                for (const pathBlockingElement of tile.blockingElements) {\n                    if (pathBlockingElement.points.length < 2) {\n                        continue;\n                    }\n                    this.m_screenProjector.project3(\n                        pathBlockingElement.points[0],\n                        startLinePointProj\n                    );\n                    for (let i = 1; i < pathBlockingElement.points.length; i++) {\n                        this.m_screenProjector.project3(\n                            pathBlockingElement.points[i],\n                            endLinePointProj\n                        );\n                        const line = pathBlockingElement.screenSpaceLines[i - 1];\n                        line.start.copy(startLinePointProj);\n                        line.end.copy(endLinePointProj);\n                        const lineWithBound: LineWithBound = {\n                            minX: Math.min(startLinePointProj.x, endLinePointProj.x),\n                            maxX: Math.max(startLinePointProj.x, endLinePointProj.x),\n                            minY: Math.min(startLinePointProj.y, endLinePointProj.y),\n                            maxY: Math.max(startLinePointProj.y, endLinePointProj.y),\n                            type: \"line\",\n                            line\n                        };\n                        boxes.push(lineWithBound);\n                        startLinePointProj.copy(endLinePointProj);\n                    }\n                }\n            }\n        });\n        this.m_screenCollisions.allocateIBoxes(boxes);\n    }\n\n    /**\n     * @returns True if whole group was processed for placement,\n     * false otherwise (e.g. placement limit reached).\n     */\n    private placeTextElementGroup(\n        groupState: TextElementGroupState,\n        renderParams: RenderParams,\n        maxNumPlacedLabels: number,\n        pass: Pass\n    ): boolean {\n        // Unvisited text elements are never placed.\n        assert(groupState.visited);\n\n        if (this.m_textRenderers.length === 0) {\n            logger.warn(\"No text renderers initialized.\");\n            return false;\n        }\n\n        const shieldGroups: number[][] = [];\n\n        const temp: TempParams = {\n            additionParams: {},\n            poiMeasurementParams: {},\n            measurementParams: {},\n            bufferAdditionParams: {}\n        };\n        const hiddenKinds = this.m_viewState.hiddenGeometryKinds;\n\n        for (const textElementState of groupState.textElementStates) {\n            if (pass === Pass.PersistentLabels) {\n                if (placementStats) {\n                    ++placementStats.total;\n                }\n            }\n            if (\n                maxNumPlacedLabels >= 0 &&\n                renderParams.numRenderedTextElements >= maxNumPlacedLabels\n            ) {\n                logger.debug(\"Placement label limit exceeded.\");\n                return false;\n            }\n\n            // Skip all labels that are not initialized (didn't pass early placement tests)\n            // or don't belong to this pass.\n            if (!textElementState.initialized) {\n                if (placementStats) {\n                    ++placementStats.uninitialized;\n                }\n                continue;\n            }\n            if (textElementState.viewDistance === undefined) {\n                if (placementStats) {\n                    ++placementStats.tooFar;\n                }\n                continue;\n            }\n\n            const elementVisible = textElementState.visible;\n            if (\n                (pass === Pass.PersistentLabels && !elementVisible) ||\n                (pass === Pass.NewLabels && elementVisible)\n            ) {\n                continue;\n            }\n\n            const textElement = textElementState.element;\n\n            // Get the TextElementStyle.\n            const textElementStyle = this.m_textStyleCache.getTextElementStyle(textElement.style);\n            const textCanvas = textElementStyle.textCanvas;\n            const poiRenderer = textElementStyle.poiRenderer;\n            if (textCanvas === undefined || poiRenderer === undefined) {\n                logger.warn(\"Text canvas or poi renderer not ready.\");\n                continue;\n            }\n\n            // TODO: HARP-7648. Discard hidden kinds sooner, before placement.\n            // Check if the label should be hidden.\n            if (\n                hiddenKinds !== undefined &&\n                textElement.kind !== undefined &&\n                hiddenKinds.hasOrIntersects(textElement.kind)\n            ) {\n                continue;\n            }\n\n            const elementType = textElement.type;\n            const isPathLabel = elementType === TextElementType.PathLabel;\n\n            // For paths, check if the label may fit.\n            if (isPathLabel) {\n                // TODO: HARP-7648. checkForSmallLabels takes a large part of text placement time.\n                // Try to make it faster or execute cheaper rejection tests before.\n                if (!this.checkForSmallLabels(textElement, tempScreenPoints)) {\n                    if (placementStats) {\n                        placementStats.numNotVisible++;\n                    }\n                    if (textElement.dbgPathTooSmall === true) {\n                        if (placementStats) {\n                            placementStats.numPathTooSmall++;\n                        }\n                    }\n                    textElementState.reset();\n                    continue;\n                }\n            }\n\n            if (!this.initializeGlyphs(textElement, textElementStyle, temp)) {\n                continue;\n            }\n\n            const layer = textCanvas.getLayer(textElement.renderOrder || DEFAULT_TEXT_CANVAS_LAYER);\n\n            // Move onto the next TextElement if we cannot continue adding glyphs to this layer.\n            if (layer !== undefined) {\n                if (layer.storage.drawCount + textElement.glyphs!.length > layer.storage.capacity) {\n                    if (placementStats) {\n                        ++placementStats.numCannotAdd;\n                    }\n                    logger.warn(\"layer glyph storage capacity exceeded.\");\n                    continue;\n                }\n            }\n\n            // Set the current style for the canvas.\n            textCanvas.textRenderStyle = textElement.renderStyle!;\n            textCanvas.textLayoutStyle = textElement.layoutStyle!;\n\n            switch (elementType) {\n                case TextElementType.PoiLabel:\n                    this.addPoiLabel(textElementState, poiRenderer, textCanvas, renderParams, temp);\n                    break;\n                case TextElementType.LineMarker:\n                    this.addLineMarkerLabel(\n                        textElementState,\n                        poiRenderer,\n                        shieldGroups,\n                        textCanvas,\n                        renderParams,\n                        temp\n                    );\n                    break;\n                case TextElementType.PathLabel:\n                    this.addPathLabel(\n                        textElementState,\n                        tempScreenPoints,\n                        textCanvas,\n                        renderParams,\n                        temp\n                    );\n            }\n        }\n        return true;\n    }\n\n    private initializeGlyphs(\n        textElement: TextElement,\n        textElementStyle: TextElementStyle,\n        tempParams: TempParams\n    ): boolean {\n        // Trigger the glyph load if needed.\n        if (textElement.loadingState === LoadingState.Initialized) {\n            return true;\n        }\n\n        assert(textElementStyle.textCanvas !== undefined);\n        const textCanvas = textElementStyle.textCanvas!;\n\n        if (textElement.loadingState === undefined) {\n            textElement.loadingState = LoadingState.Requested;\n\n            if (textElement.renderStyle === undefined) {\n                textElement.renderStyle = new TextRenderStyle({\n                    ...textElementStyle.renderParams,\n                    ...textElement.renderParams\n                });\n            }\n            if (textElement.layoutStyle === undefined) {\n                textElement.layoutStyle = new TextLayoutStyle({\n                    ...textElementStyle.layoutParams,\n                    ...textElement.layoutParams\n                });\n            }\n\n            if (textElement.text === \"\") {\n                textElement.loadingState = LoadingState.Loaded;\n            } else {\n                const newLoadPromise = textCanvas.fontCatalog\n                    .loadCharset(textElement.text, textElement.renderStyle)\n                    .then(() => {\n                        --this.m_glyphLoadingCount;\n                        textElement.loadingState = LoadingState.Loaded;\n                        // Ensure that text elements still loading glyphs get a chance to\n                        // be rendered if there's no text element updates in the next frames.\n                        this.m_forceNewLabelsPass = true;\n                        this.m_viewUpdateCallback();\n                    });\n                if (this.m_glyphLoadingCount === 0) {\n                    this.m_loadPromise = undefined;\n                }\n                ++this.m_glyphLoadingCount;\n\n                this.m_loadPromise =\n                    this.m_loadPromise === undefined\n                        ? newLoadPromise\n                        : Promise.all([this.m_loadPromise, newLoadPromise]);\n            }\n        }\n        if (textElement.loadingState === LoadingState.Loaded) {\n            if (this.m_initializedTextElementCount < MAX_INITIALIZED_TEXT_ELEMENTS_PER_FRAME) {\n                textCanvas.textRenderStyle = textElement.renderStyle!;\n                textCanvas.textLayoutStyle = textElement.layoutStyle!;\n                textElement.glyphCaseArray = [];\n                textElement.glyphs = textCanvas.fontCatalog.getGlyphs(\n                    textElement.text,\n                    textCanvas.textRenderStyle,\n                    textElement.glyphCaseArray\n                );\n                if (textElement.type !== TextElementType.PathLabel) {\n                    textElement.bounds = new THREE.Box2();\n                    tempParams.poiMeasurementParams.letterCaseArray = textElement.glyphCaseArray!;\n                    textCanvas.measureText(\n                        textElement.glyphs!,\n                        textElement.bounds,\n                        tempParams.poiMeasurementParams\n                    );\n                }\n                textElement.loadingState = LoadingState.Initialized;\n                ++this.m_initializedTextElementCount;\n            }\n        }\n        // Return true as soon as a text element has some glyphs assigned so that it's rendered.\n        // The glyphs may be either the final ones or some temporal glyphs inherited from a\n        // predecessor as part of the text element replacement process.\n        // See TextElementState.replace().\n        return textElement.glyphs !== undefined;\n    }\n\n    private initializeDefaultAssets(): void {\n        const defaultFontCatalogName = this.m_fontCatalogLoader.initialize(\n            this.m_options.fontCatalog!\n        );\n        this.m_textStyleCache.initializeDefaultTextElementStyle(defaultFontCatalogName);\n    }\n\n    private async initializeTextCanvases(): Promise<void> {\n        const catalogCallback = (name: string, catalog: FontCatalog) => {\n            const loadedTextCanvas = this.m_textCanvasFactory.createTextCanvas(catalog);\n\n            this.m_textRenderers.push({\n                fontCatalog: name,\n                textCanvas: loadedTextCanvas,\n                poiRenderer: this.m_poiRendererFactory.createPoiRenderer(loadedTextCanvas)\n            });\n        };\n\n        return this.m_fontCatalogLoader.loadCatalogs(catalogCallback).then(() => {\n            // Find the default TextCanvas and PoiRenderer.\n            let defaultTextCanvas: TextCanvas | undefined;\n            this.m_textRenderers.forEach(textRenderer => {\n                if (defaultTextCanvas === undefined) {\n                    defaultTextCanvas = textRenderer.textCanvas;\n                }\n            });\n            const defaultPoiRenderer = this.m_poiRendererFactory.createPoiRenderer(\n                defaultTextCanvas!\n            );\n\n            this.m_textStyleCache.initializeTextElementStyles(\n                defaultPoiRenderer,\n                defaultTextCanvas!,\n                this.m_textRenderers\n            );\n        });\n    }\n\n    private updateGlyphDebugMesh() {\n        const debugGlyphs = debugContext.getValue(\"DEBUG_GLYPHS\");\n        if (debugGlyphs === undefined) {\n            return;\n        }\n\n        if (debugGlyphs && this.m_debugGlyphTextureCacheMesh === undefined) {\n            this.initializeGlyphDebugMesh();\n        }\n        assert(this.m_debugGlyphTextureCacheMesh !== undefined);\n        assert(this.m_debugGlyphTextureCacheWireMesh !== undefined);\n\n        this.m_debugGlyphTextureCacheMesh!.visible = debugGlyphs;\n        this.m_debugGlyphTextureCacheWireMesh!.visible = debugGlyphs;\n    }\n\n    private initializeGlyphDebugMesh() {\n        const defaultFontCatalog = this.m_textRenderers[0].textCanvas.fontCatalog;\n\n        // Initialize glyph-debugging mesh.\n        const planeGeometry = new THREE.PlaneGeometry(\n            defaultFontCatalog.textureSize.width / 2.5,\n            defaultFontCatalog.textureSize.height / 2.5,\n            defaultFontCatalog.textureSize.width / defaultFontCatalog.maxWidth,\n            defaultFontCatalog.textureSize.height / defaultFontCatalog.maxHeight\n        );\n        const material = new THREE.MeshBasicMaterial({\n            transparent: true,\n            depthWrite: false,\n            depthTest: false,\n            map: defaultFontCatalog.texture\n        });\n        this.m_debugGlyphTextureCacheMesh = new THREE.Mesh(planeGeometry, material);\n        this.m_debugGlyphTextureCacheMesh.renderOrder = 10000;\n        this.m_debugGlyphTextureCacheMesh.visible = false;\n\n        this.m_debugGlyphTextureCacheMesh.name = \"glyphDebug\";\n\n        const wireframe = new THREE.WireframeGeometry(planeGeometry);\n        const wireframeMaterial = new THREE.LineBasicMaterial({\n            transparent: true,\n            color: 0x999999,\n            depthWrite: false,\n            depthTest: false\n        });\n        this.m_debugGlyphTextureCacheWireMesh = new THREE.LineSegments(\n            wireframe,\n            wireframeMaterial\n        );\n        this.m_debugGlyphTextureCacheWireMesh.renderOrder = 9999;\n        this.m_debugGlyphTextureCacheWireMesh.visible = false;\n\n        this.m_debugGlyphTextureCacheWireMesh.name = \"glyphDebug\";\n\n        this.m_textRenderers[0].textCanvas\n            .getLayer(DEFAULT_TEXT_CANVAS_LAYER)!\n            .storage.scene.add(\n                this.m_debugGlyphTextureCacheMesh,\n                this.m_debugGlyphTextureCacheWireMesh\n            );\n    }\n\n    /**\n     * Visit all visible tiles and add/ their text elements to cache. The update of\n     * [[TextElement]]s is a time consuming process, and cannot be done every frame, but should only\n     * be done when the camera moved (a lot) of whenever the set of visible tiles change.\n     *\n     * The actually rendered [[TextElement]]s are stored internally until the next update is done\n     * to speed up rendering when no camera movement was detected.\n     * @param dataSourceTileList List of tiles to be rendered for each data source.\n     * @param projection The view's projection.\n     */\n    private updateTextElements(dataSourceTileList: DataSourceTileList[], projection: Projection) {\n        logger.debug(\"updateTextElements\");\n\n        if (updateStats) {\n            updateStats.clear();\n        }\n\n        this.m_textElementStateCache.clearTextCache();\n        this.m_cacheInvalidated = false;\n\n        this.checkIfOverloaded(dataSourceTileList);\n\n        // Used with tile offset to compute the x coordinate offset for tiles.\n        const updateStartTime =\n            this.overloaded && this.m_viewState.isDynamic ? PerformanceTimer.now() : undefined;\n\n        // TODO: HARP-7648. Skip all data sources that won't contain text.\n        // TODO: HARP-7651. Higher priority labels should be updated before lower priority ones\n        // across all data sources.\n        // TODO: HARP-7373. Use rendered tiles (tiles currently rendered to cover the view,\n        // including fallbacks if necessary) instead of visible tiles (target tiles that might not\n        // be decoded yet).\n        // Otherwise labels persistent when crossing a zoom level boundary will flicker (fade out\n        // and back in) due to the delay in decoding the visible tiles.\n        dataSourceTileList.forEach(tileList => {\n            this.updateTextElementsFromSource(\n                tileList.dataSource,\n                tileList.storageLevel,\n                Array.from(tileList.renderedTiles.values()),\n                projection,\n                updateStartTime\n            );\n        });\n\n        if (updateStats) {\n            updateStats.log();\n        }\n    }\n\n    private updateTextElementsFromSource(\n        tileDataSource: DataSource,\n        storageLevel: number,\n        visibleTiles: Tile[],\n        projection: Projection,\n        updateStartTime: number | undefined\n    ) {\n        if (updateStats) {\n            updateStats.tiles += visibleTiles.length;\n        }\n        const sortedTiles = visibleTiles;\n\n        // TODO: HARP-7648. Really needed? Should it be done here or in VisibleTileSet?\n        sortedTiles.sort((a: Tile, b: Tile) => {\n            return a.tileKey.mortonCode() - b.tileKey.mortonCode();\n        });\n\n        // Prepare user text elements.\n        for (const tile of sortedTiles) {\n            this.prepareTextElementGroup(tile.userTextElements, projection);\n        }\n\n        const sortedGroups: TextElementLists[] = [];\n        this.createSortedGroupsForSorting(tileDataSource, storageLevel, sortedTiles, sortedGroups);\n\n        let numTextElementsUpdated = 0;\n\n        for (const textElementLists of sortedGroups) {\n            this.selectTextElementsToUpdateByDistance(textElementLists, projection);\n\n            // The value of updateStartTime is set if this.overloaded is true.\n            if (updateStartTime !== undefined) {\n                // If overloaded and all time is used up, exit early.\n                if (OVERLOAD_UPDATE_TIME_LIMIT > 0) {\n                    const endTime = PerformanceTimer.now();\n                    const elapsedTime = endTime - updateStartTime;\n                    if (elapsedTime > OVERLOAD_UPDATE_TIME_LIMIT) {\n                        logger.debug(\"Update time limit exceeded.\");\n                        break;\n                    }\n                }\n\n                // Try not to update too many elements. They will be checked for visibility each\n                // frame.\n                numTextElementsUpdated += textElementLists.count();\n                if (numTextElementsUpdated >= OVERLOAD_UPDATED_LABEL_LIMIT) {\n                    logger.debug(\"Update label limit exceeded.\");\n                    break;\n                }\n            }\n        }\n    }\n\n    private prepareTextElementGroup(\n        textElementGroup: TextElementGroup,\n        projection: Projection,\n        maxViewDistance?: number\n    ) {\n        if (textElementGroup.elements.length === 0) {\n            return;\n        }\n\n        const textElementSelection: TextElementFilter = (\n            textElementState: TextElementState\n        ): number | undefined => {\n            let { result, viewDistance } = checkReadyForPlacement(\n                textElementState.element,\n                this.m_viewState,\n                this.m_viewCamera,\n                this.m_poiManager,\n                projection.type,\n                maxViewDistance\n            );\n\n            if (\n                result === PrePlacementResult.Ok &&\n                !this.m_textElementStateCache.deduplicateElement(\n                    this.m_viewState.zoomLevel,\n                    textElementState\n                )\n            ) {\n                result = PrePlacementResult.Duplicate;\n                viewDistance = undefined;\n            }\n\n            if (updateStats) {\n                updateStats.totalLabels++;\n                updateStats.results[result]++;\n            }\n            return viewDistance;\n        };\n\n        const [, found] = this.m_textElementStateCache.getOrSet(\n            textElementGroup,\n            textElementSelection\n        );\n\n        if (updateStats) {\n            ++updateStats.totalGroups;\n            if (!found) {\n                ++updateStats.newGroups;\n            }\n        }\n    }\n\n    private createSortedGroupsForSorting(\n        tileDataSource: DataSource,\n        storageLevel: number,\n        sortedTiles: Tile[],\n        sortedGroups: TextElementLists[]\n    ) {\n        if (sortedTiles.length === 0) {\n            return;\n        }\n\n        const tilesToRender: Tile[] = [];\n\n        for (const tile of sortedTiles) {\n            if (tileDataSource.shouldRenderText(storageLevel, tile.tileKey)) {\n                tilesToRender.push(tile);\n            }\n        }\n\n        const groupedPriorityLists: Map<number, TextElementLists> = new Map();\n\n        for (const tile of tilesToRender) {\n            for (const group of tile.textElementGroups.groups.values()) {\n                if (group.elements.length === 0) {\n                    continue;\n                }\n\n                const foundGroup = groupedPriorityLists.get(group.priority);\n                if (foundGroup === undefined) {\n                    groupedPriorityLists.set(\n                        group.priority,\n                        new TextElementLists([new TileTextElements(tile, group)])\n                    );\n                } else {\n                    foundGroup.lists.push(new TileTextElements(tile, group));\n                }\n            }\n        }\n\n        if (groupedPriorityLists.size === 0) {\n            return;\n        }\n\n        for (const g of groupedPriorityLists) {\n            const lists = g[1];\n            sortedGroups.push(lists);\n        }\n\n        sortedGroups.sort((a: TextElementLists, b: TextElementLists) => {\n            return b.priority - a.priority;\n        });\n\n        const printTextInfo = false;\n\n        if (PRINT_LABEL_DEBUG_INFO && printTextInfo) {\n            let outString = \"\";\n            for (const textElementLists of sortedGroups) {\n                let size = 0;\n                for (const tileTextElements of textElementLists.lists) {\n                    size += tileTextElements.group.elements.length;\n                }\n                outString += `priority ${textElementLists.priority} size: ${size}\\n`;\n            }\n            logger.log(outString);\n        }\n    }\n\n    private selectTextElementsToUpdateByDistance(\n        textElementLists: TextElementLists,\n        projection: Projection\n    ) {\n        const farDistanceLimitRatio = Math.max(\n            this.m_options.maxDistanceRatioForTextLabels!,\n            this.m_options.maxDistanceRatioForPoiLabels!\n        );\n        const maxViewDistance = getMaxViewDistance(this.m_viewState, farDistanceLimitRatio);\n\n        for (const tileTextElements of textElementLists.lists) {\n            this.prepareTextElementGroup(tileTextElements.group, projection, maxViewDistance);\n        }\n    }\n\n    private placeTextElements(time: number, placeNewTextElements: boolean) {\n        const renderParams: RenderParams = {\n            numRenderedTextElements: 0,\n            fadeAnimationRunning: false,\n            time\n        };\n\n        const placeStartTime =\n            this.overloaded && this.m_viewState.isDynamic ? PerformanceTimer.now() : undefined;\n\n        if (placementStats) {\n            placementStats.clear();\n        }\n\n        if (this.m_textElementStateCache.size === 0) {\n            logger.debug(\"Text element cache empty.\");\n            return;\n        }\n\n        const placeNew = this.m_forceNewLabelsPass || placeNewTextElements;\n        if (this.m_forceNewLabelsPass) {\n            if (!placeNewTextElements) {\n                logger.debug(\"Force new label pass\");\n            }\n            this.m_forceNewLabelsPass = false;\n        }\n        const maxNumPlacedTextElements = this.m_options.maxNumVisibleLabels!;\n\n        // TODO: HARP-7648. Potential performance improvement. Place persistent labels + rejected\n        // candidates from previous frame if there's been no placement in this one.\n        const groupStates = this.m_textElementStateCache.sortedGroupStates;\n        let currentPriority: number = groupStates[0].priority;\n        let currentPriorityBegin: number = 0;\n\n        for (let i = 0; i < groupStates.length; ++i) {\n            const textElementGroupState = groupStates[i];\n            if (placementStats) {\n                ++placementStats.totalGroups;\n            }\n\n            const newPriority = textElementGroupState.priority;\n            if (placeNew && currentPriority !== newPriority) {\n                // Place all new labels of the previous priority before placing the persistent\n                // labels of this priority.\n                this.placeNewTextElements(currentPriorityBegin, i, renderParams);\n                if (isPlacementTimeExceeded(placeStartTime)) {\n                    break;\n                }\n                currentPriority = newPriority;\n                currentPriorityBegin = i;\n            }\n            if (\n                !this.placeTextElementGroup(\n                    textElementGroupState,\n                    renderParams,\n                    maxNumPlacedTextElements,\n                    Pass.PersistentLabels\n                )\n            ) {\n                break;\n            }\n\n            if (isPlacementTimeExceeded(placeStartTime)) {\n                break;\n            }\n        }\n\n        if (placeNew) {\n            // Place new text elements of the last priority.\n            this.placeNewTextElements(currentPriorityBegin, groupStates.length, renderParams);\n        }\n\n        if (placementStats) {\n            placementStats.numRenderedTextElements = renderParams.numRenderedTextElements;\n            placementStats.log();\n        }\n\n        if (!this.m_options.disableFading && renderParams.fadeAnimationRunning) {\n            this.m_viewUpdateCallback();\n        }\n    }\n\n    private placeNewTextElements(\n        beginGroupIndex: number,\n        endGroupIndex: number,\n        renderParams: RenderParams\n    ) {\n        const groupStates = this.m_textElementStateCache.sortedGroupStates;\n        for (let i = beginGroupIndex; i < endGroupIndex; ++i) {\n            if (\n                !this.placeTextElementGroup(\n                    groupStates[i],\n                    renderParams,\n                    this.m_options.maxNumVisibleLabels!,\n                    Pass.NewLabels\n                )\n            ) {\n                break;\n            }\n        }\n    }\n\n    private placeOverlayTextElements() {\n        if (this.m_overlayTextElements === undefined || this.m_overlayTextElements.length === 0) {\n            return;\n        }\n\n        const screenSize = this.m_tmpVector.set(\n            this.m_screenProjector.width,\n            this.m_screenProjector.height\n        );\n        const screenXOrigin = -screenSize.width / 2.0;\n        const screenYOrigin = screenSize.height / 2.0;\n\n        const tempAdditionParams: AdditionParameters = {};\n        const tempBufferAdditionParams: TextBufferAdditionParameters = {};\n\n        // Place text elements one by one.\n        for (const textElement of this.m_overlayTextElements!) {\n            // Get the TextElementStyle.\n            const textElementStyle = this.m_textStyleCache.getTextElementStyle(textElement.style);\n            const textCanvas = textElementStyle.textCanvas;\n            if (textCanvas === undefined) {\n                continue;\n            }\n            const layer = textCanvas.getLayer(textElement.renderOrder || DEFAULT_TEXT_CANVAS_LAYER);\n\n            // Trigger the glyph load if needed.\n            if (textElement.loadingState === undefined) {\n                textElement.loadingState = LoadingState.Requested;\n\n                if (textElement.renderStyle === undefined) {\n                    textElement.renderStyle = new TextRenderStyle({\n                        ...textElementStyle.renderParams,\n                        ...textElement.renderParams\n                    });\n                }\n                if (textElement.layoutStyle === undefined) {\n                    textElement.layoutStyle = new TextLayoutStyle({\n                        ...textElementStyle.layoutParams,\n                        ...textElement.layoutParams\n                    });\n                }\n\n                if (textElement.text === \"\") {\n                    textElement.loadingState = LoadingState.Loaded;\n                } else {\n                    textCanvas.fontCatalog\n                        .loadCharset(textElement.text, textElement.renderStyle)\n                        .then(() => {\n                            textElement.loadingState = LoadingState.Loaded;\n                            this.m_viewUpdateCallback();\n                        });\n                }\n            }\n            if (textElement.loadingState === LoadingState.Loaded) {\n                if (this.m_initializedTextElementCount < MAX_INITIALIZED_TEXT_ELEMENTS_PER_FRAME) {\n                    textCanvas.textRenderStyle = textElement.renderStyle!;\n                    textCanvas.textLayoutStyle = textElement.layoutStyle!;\n                    textElement.glyphCaseArray = [];\n                    textElement.glyphs = textCanvas.fontCatalog.getGlyphs(\n                        textElement.text,\n                        textCanvas.textRenderStyle,\n                        textElement.glyphCaseArray\n                    );\n                    textElement.loadingState = LoadingState.Initialized;\n                    ++this.m_initializedTextElementCount;\n                }\n            }\n            if (textElement.loadingState !== LoadingState.Initialized) {\n                continue;\n            }\n\n            // Move onto the next TextElement if we cannot continue adding glyphs to this layer.\n            if (layer !== undefined) {\n                if (layer.storage.drawCount + textElement.glyphs!.length > layer.storage.capacity) {\n                    continue;\n                }\n            }\n\n            // Set the current style for the canvas.\n            textCanvas.textRenderStyle = textElement.renderStyle!;\n            textCanvas.textLayoutStyle = textElement.layoutStyle!;\n\n            // Place text.\n            let textPath;\n            if (!(textElement.type === TextElementType.PathLabel)) {\n                // Adjust the label positioning.\n                tempScreenPosition.x = screenXOrigin + textElement.position.x * screenSize.width;\n                tempScreenPosition.y = screenYOrigin - textElement.position.y * screenSize.height;\n                if (textElement.xOffset !== undefined) {\n                    tempScreenPosition.x += textElement.xOffset;\n                }\n                if (textElement.yOffset !== undefined) {\n                    tempScreenPosition.y -= textElement.yOffset;\n                }\n\n                tempPosition.x = tempScreenPosition.x;\n                tempPosition.y = tempScreenPosition.y;\n                tempPosition.z = 0.0;\n\n                tempBufferAdditionParams.position = tempPosition;\n                tempAdditionParams.layer = textElement.renderOrder;\n                tempAdditionParams.letterCaseArray = textElement.glyphCaseArray;\n                tempAdditionParams.pickingData = textElement.userData ? textElement : undefined;\n                textCanvas.addText(textElement.glyphs!, tempPosition, tempAdditionParams);\n            } else {\n                // Adjust the label positioning.\n                tempScreenPosition.x = screenXOrigin;\n                tempScreenPosition.y = screenYOrigin;\n                if (textElement.xOffset !== undefined) {\n                    tempScreenPosition.x += textElement.xOffset;\n                }\n                if (textElement.yOffset !== undefined) {\n                    tempScreenPosition.y -= textElement.yOffset;\n                }\n\n                // Get the screen points that define the label's segments and create a path with\n                // them.\n                // TODO: HARP-7648. Optimize array allocations.\n                const screenPoints: THREE.Vector2[] = [];\n                for (const pt of textElement.path!) {\n                    const pX = tempScreenPosition.x + pt.x * screenSize.width;\n                    const pY = tempScreenPosition.y - pt.y * screenSize.height;\n                    screenPoints.push(new THREE.Vector2(pX, pY));\n                }\n                textPath = new SimplePath();\n                for (let i = 0; i < screenPoints.length - 1; ++i) {\n                    textPath.add(new THREE.LineCurve(screenPoints[i], screenPoints[i + 1]));\n                }\n\n                tempAdditionParams.path = textPath;\n                tempAdditionParams.pathOverflow = true;\n                tempAdditionParams.layer = textElement.renderOrder;\n                tempAdditionParams.letterCaseArray = textElement.glyphCaseArray;\n                tempAdditionParams.pickingData = textElement.userData ? textElement : undefined;\n                textCanvas.addText(textElement.glyphs!, tempPosition, tempAdditionParams);\n            }\n        }\n    }\n\n    private getDistanceScalingFactor(\n        label: TextElement,\n        distance: number,\n        lookAtDistance: number\n    ): number {\n        // Distance scale is based on relation between camera focus point distance and\n        // the actual label distance. For labels close to camera look at point the scale\n        // remains unchanged, the farther is label from that point the smaller size it is\n        // rendered in screen space. This method is unaffected by near and far clipping planes\n        // distances, but may be improved by taking FOV into equation or customizing the\n        // focus point screen position based on horizont, actual ground, tilt ets.\n        let factor = lookAtDistance / distance;\n        // The label.distanceScale property defines the influence ratio at which\n        // distance affects the final scaling of label.\n        factor = 1.0 + (factor - 1.0) * label.distanceScale;\n        // Preserve the constraints\n        factor = Math.max(factor, this.m_options.labelDistanceScaleMin!);\n        factor = Math.min(factor, this.m_options.labelDistanceScaleMax!);\n        return factor;\n    }\n\n    private getDistanceFadingFactor(\n        label: TextElement,\n        state: TextElementState,\n        maxVisibilityDist: number\n    ): number {\n        let distanceFadeValue = 1.0;\n        const textDistance = state.viewDistance;\n\n        if (textDistance !== undefined && label.fadeFar !== undefined && label.fadeFar > 0.0) {\n            const fadeNear = label.fadeNear === undefined ? 0.0 : label.fadeNear;\n            const fadeFar = label.fadeFar;\n            if (fadeFar > fadeNear) {\n                distanceFadeValue =\n                    1.0 -\n                    THREE.Math.clamp(\n                        (textDistance / maxVisibilityDist - fadeNear) / (fadeFar - fadeNear),\n                        0.0,\n                        1.0\n                    );\n            }\n        }\n        return distanceFadeValue;\n    }\n\n    private addPointLabel(\n        labelState: TextElementState,\n        position: THREE.Vector3,\n        screenPosition: THREE.Vector2,\n        poiRenderer: PoiRenderer,\n        textCanvas: TextCanvas,\n        renderParams: RenderParams,\n        temp: TempParams,\n        iconIndex?: number\n    ): boolean {\n        const pointLabel: TextElement = labelState.element;\n        const textRenderState: RenderState | undefined = labelState.textRenderState;\n\n        assert(iconIndex === undefined || labelState.iconRenderStates !== undefined);\n        const iconRenderState: RenderState =\n            iconIndex !== undefined\n                ? labelState.iconRenderStates![iconIndex]\n                : labelState.iconRenderState!;\n        assert(iconRenderState !== undefined);\n\n        const poiTextMaxDistance = getMaxViewDistance(\n            this.m_viewState,\n            this.m_options.maxDistanceRatioForPoiLabels!\n        );\n        const hasText = textRenderState !== undefined && pointLabel.text !== \"\";\n\n        // Find the label's original position.\n        tempScreenPosition.x = tempPoiScreenPosition.x = screenPosition.x;\n        tempScreenPosition.y = tempPoiScreenPosition.y = screenPosition.y;\n\n        // Scale the text depending on the label's distance to the camera.\n        let textScale = 1.0;\n        let distanceScaleFactor = 1.0;\n        const textDistance = this.m_viewState.worldCenter.distanceTo(position);\n        if (textDistance !== undefined) {\n            if (\n                pointLabel.fadeFar !== undefined &&\n                (pointLabel.fadeFar <= 0.0 ||\n                    pointLabel.fadeFar * this.m_viewState.maxVisibilityDist < textDistance)\n            ) {\n                // The label is farther away than fadeFar value, which means it is totally\n                // transparent.\n                if (placementStats) {\n                    ++placementStats.tooFar;\n                }\n                return false;\n            }\n            labelState.setViewDistance(textDistance);\n\n            distanceScaleFactor = this.getDistanceScalingFactor(\n                pointLabel,\n                textDistance,\n                this.m_viewState.lookAtDistance\n            );\n            textScale *= distanceScaleFactor;\n        }\n        const distanceFadeFactor = this.getDistanceFadingFactor(\n            pointLabel,\n            labelState,\n            this.m_viewState.maxVisibilityDist\n        );\n\n        // Check if there is need to check for screen space for the label's icon.\n        const poiInfo = pointLabel.poiInfo;\n        let iconRejected = false;\n\n        // Check if icon should be rendered at this zoomLevel\n        const renderIcon =\n            poiInfo !== undefined &&\n            MathUtils.isClamped(\n                this.m_viewState.zoomLevel,\n                poiInfo.iconMinZoomLevel,\n                poiInfo.iconMaxZoomLevel\n            ) &&\n            poiInfo!.isValid !== false;\n\n        const iconReady =\n            renderIcon && poiRenderer.prepareRender(pointLabel, this.m_viewState.zoomLevel);\n\n        if (iconReady) {\n            PoiRenderer.computeIconScreenBox(\n                poiInfo!,\n                tempPoiScreenPosition,\n                distanceScaleFactor,\n                this.m_viewState.zoomLevel,\n                tempBox2D\n            );\n            const iconIsVisible = this.m_screenCollisions.isVisible(tempBox2D);\n\n            // If the icon is prepared and valid, but just not visible, try again next time.\n            if (!iconIsVisible) {\n                iconRenderState.reset();\n\n                if (placementStats) {\n                    ++placementStats.numNotVisible;\n                }\n                return false;\n            }\n\n            const iconSpaceAvailable =\n                poiInfo!.mayOverlap === true || !this.m_screenCollisions.isAllocated(tempBox2D);\n\n            if (!iconSpaceAvailable && !iconRenderState.isVisible()) {\n                if (placementStats) {\n                    ++placementStats.numNotVisible;\n                }\n                return false;\n            }\n            iconRejected = !iconSpaceAvailable;\n        } else if (renderIcon && poiInfo!.isValid !== false) {\n            // Ensure that text elements still loading icons get a chance to be rendered if\n            // there's no text element updates in the next frames.\n            this.m_forceNewLabelsPass = true;\n        }\n\n        // Check if label should be rendered at this zoomLevel\n        const renderText =\n            hasText &&\n            (poiInfo === undefined ||\n                this.m_viewState.zoomLevel === undefined ||\n                MathUtils.isClamped(\n                    this.m_viewState.zoomLevel,\n                    poiInfo.iconMinZoomLevel,\n                    poiInfo.iconMaxZoomLevel\n                ));\n\n        // Check if we should render the label's text.\n        const doRenderText =\n            // Render if between min/max zoom level\n            renderText &&\n            // Do not render if the distance is too great and distance shouldn't be ignored.\n            (pointLabel.ignoreDistance === true ||\n                labelState.viewDistance === undefined ||\n                labelState.viewDistance < poiTextMaxDistance) &&\n            // Do not render text if POI cannot be rendered and is not optional.\n            (poiInfo === undefined || poiInfo.isValid === true || poiInfo.iconIsOptional !== false);\n\n        // Render the label's text...\n        // textRenderState is always defined at this point.\n        if (doRenderText) {\n            tempScreenPosition.add(computePointTextOffset(pointLabel, tempTextOffset));\n\n            // Adjust the label positioning to match its bounding box.\n            tempPosition.x = tempScreenPosition.x;\n            tempPosition.y = tempScreenPosition.y;\n            tempPosition.z = labelState.renderDistance;\n\n            tempBox2D.x = tempScreenPosition.x + pointLabel.bounds!.min.x * textScale;\n            tempBox2D.y = tempScreenPosition.y + pointLabel.bounds!.min.y * textScale;\n            tempBox2D.w = (pointLabel.bounds!.max.x - pointLabel.bounds!.min.x) * textScale;\n            tempBox2D.h = (pointLabel.bounds!.max.y - pointLabel.bounds!.min.y) * textScale;\n\n            // TODO: Make the margin configurable\n            tempBox2D.x -= 4 * textScale;\n            tempBox2D.y -= 2 * textScale;\n            tempBox2D.w += 8 * textScale;\n            tempBox2D.h += 4 * textScale;\n\n            // Check the text visibility.\n            if (!this.m_screenCollisions.isVisible(tempBox2D)) {\n                if (placementStats) {\n                    placementStats.numPoiTextsInvisible++;\n                }\n                labelState.reset();\n                return false;\n            }\n\n            const textIsOptional: boolean =\n                pointLabel.poiInfo !== undefined && pointLabel.poiInfo.textIsOptional === true;\n\n            let textRejected = true;\n            if (!iconRejected) {\n                textRejected =\n                    !pointLabel.textMayOverlap && this.m_screenCollisions.isAllocated(tempBox2D);\n                iconRejected = textRejected && !textIsOptional;\n            }\n\n            if (textRejected && !labelState.visible) {\n                if (placementStats) {\n                    placementStats.numPoiTextsInvisible++;\n                }\n                return false;\n            }\n\n            if (textRejected) {\n                textRenderState!.startFadeOut(renderParams.time);\n            }\n\n            const textNeedsDraw = !textRejected || textRenderState!.isFading();\n\n            if (textNeedsDraw) {\n                // Don't allocate space for rejected text. When zooming, this allows placement of a\n                // lower priority text element that was displaced by a higher priority one (not\n                // present in the new zoom level) before an even lower priority one takes the space.\n                // Otherwise the lowest priority text will fade in and back out.\n                // TODO: Add a unit test for this scenario.\n                if (pointLabel.textReservesSpace && !textRejected) {\n                    this.m_screenCollisions.allocate(tempBox2D);\n                }\n\n                // Do not actually render (just allocate space) if camera is moving and\n                // renderTextDuringMovements is not true.\n                if (\n                    (textRenderState!.isFading() ||\n                        !this.m_viewState.cameraIsMoving ||\n                        poiInfo === undefined ||\n                        poiInfo.renderTextDuringMovements === true) &&\n                    !iconRenderState.isFadedOut()\n                ) {\n                    if (!textRejected) {\n                        textRenderState!.startFadeIn(renderParams.time);\n                    }\n                    renderParams.fadeAnimationRunning =\n                        renderParams.fadeAnimationRunning || textRenderState!.isFading();\n                    const opacity =\n                        textRenderState!.opacity *\n                        distanceFadeFactor *\n                        pointLabel.renderStyle!.opacity;\n                    if (opacity > 0) {\n                        // Compute the TextBufferObject when we know we're gonna render this label.\n                        tmpTextBufferCreationParams.letterCaseArray = pointLabel.glyphCaseArray;\n                        if (pointLabel.textBufferObject === undefined) {\n                            pointLabel.textBufferObject = textCanvas.createTextBufferObject(\n                                pointLabel.glyphs!,\n                                tmpTextBufferCreationParams\n                            );\n                        }\n                        const backgroundIsVisible =\n                            pointLabel.renderStyle!.backgroundOpacity > 0 &&\n                            textCanvas.textRenderStyle.fontSize.backgroundSize > 0;\n\n                        temp.bufferAdditionParams.layer = pointLabel.renderOrder;\n                        temp.bufferAdditionParams.position = tempPosition;\n                        temp.bufferAdditionParams.scale = textScale;\n                        temp.bufferAdditionParams.opacity = opacity;\n                        temp.bufferAdditionParams.backgroundOpacity = backgroundIsVisible\n                            ? temp.bufferAdditionParams.opacity *\n                              pointLabel.renderStyle!.backgroundOpacity\n                            : 0.0;\n                        temp.bufferAdditionParams.pickingData = pointLabel.userData\n                            ? pointLabel\n                            : undefined;\n                        textCanvas.addTextBufferObject(\n                            pointLabel.textBufferObject!,\n                            temp.bufferAdditionParams\n                        );\n                        if (placementStats) {\n                            placementStats.numRenderedPoiTexts++;\n                        }\n                    }\n                }\n            }\n        }\n        // ... and render the icon (if any).\n        if (iconReady) {\n            if (iconRejected) {\n                iconRenderState!.startFadeOut(renderParams.time);\n            } else {\n                iconRenderState!.startFadeIn(renderParams.time);\n            }\n\n            renderParams.fadeAnimationRunning =\n                renderParams.fadeAnimationRunning || iconRenderState!.isFading();\n\n            const opacity = iconRenderState.opacity * distanceFadeFactor;\n            if (opacity > 0) {\n                // Same as for text, don't allocate screen space for an icon that's fading out so\n                // that any label blocked by it gets a chance to be placed as soon as any other\n                // surrounding new labels.\n                const allocateSpace = poiInfo!.reserveSpace !== false && !iconRejected;\n                poiRenderer.renderPoi(\n                    poiInfo!,\n                    tempPoiScreenPosition,\n                    this.m_screenCollisions,\n                    labelState.renderDistance,\n                    distanceScaleFactor,\n                    allocateSpace,\n                    iconRenderState.opacity * distanceFadeFactor,\n                    this.m_viewState.zoomLevel\n                );\n\n                if (placementStats) {\n                    placementStats.numRenderedPoiIcons++;\n                }\n            }\n        }\n        renderParams.numRenderedTextElements++;\n        return true;\n    }\n\n    private addPoiLabel(\n        labelState: TextElementState,\n        poiRenderer: PoiRenderer,\n        textCanvas: TextCanvas,\n        renderParams: RenderParams,\n        temp: TempParams\n    ): boolean {\n        const poiLabel = labelState.element;\n        const worldPosition = poiLabel.points as THREE.Vector3;\n\n        // Only process labels frustum-clipped labels\n        if (this.m_screenProjector.project(worldPosition, tempScreenPosition) === undefined) {\n            return false;\n        }\n        // Add this POI as a point label.\n        return this.addPointLabel(\n            labelState,\n            worldPosition,\n            tempScreenPosition,\n            poiRenderer,\n            textCanvas,\n            renderParams,\n            temp\n        );\n    }\n\n    private addLineMarkerLabel(\n        labelState: TextElementState,\n        poiRenderer: PoiRenderer,\n        shieldGroups: number[][],\n        textCanvas: TextCanvas,\n        renderParams: RenderParams,\n        temp: TempParams\n    ): void {\n        const lineMarkerLabel = labelState.element;\n        const path = lineMarkerLabel.points as THREE.Vector3[];\n\n        // Early exit if the line marker doesn't have the necessary data.\n        const poiInfo = lineMarkerLabel.poiInfo!;\n        if (\n            path.length === 0 ||\n            !poiRenderer.prepareRender(lineMarkerLabel, this.m_viewState.zoomLevel)\n        ) {\n            return;\n        }\n\n        // Initialize the shield group for this lineMarker.\n        let shieldGroup: number[] | undefined;\n        if (poiInfo.shieldGroupIndex !== undefined) {\n            shieldGroup = shieldGroups[poiInfo.shieldGroupIndex];\n            if (shieldGroup === undefined) {\n                shieldGroup = [];\n                shieldGroups[poiInfo.shieldGroupIndex] = shieldGroup;\n            }\n        }\n\n        const lineTechnique = poiInfo.technique as LineMarkerTechnique;\n        const minDistanceSqr =\n            lineTechnique.minDistance !== undefined\n                ? lineTechnique.minDistance * lineTechnique.minDistance\n                : 0;\n\n        // Process markers (with shield groups).\n        if (minDistanceSqr > 0 && shieldGroup !== undefined) {\n            for (let pointIndex = 0; pointIndex < path.length; ++pointIndex) {\n                const point = path[pointIndex];\n                // Only process labels frustum-clipped labels\n                if (this.m_screenProjector.project(point, tempScreenPosition) !== undefined) {\n                    // Find a suitable location for the lineMarker to be placed at.\n                    let tooClose = false;\n                    for (let j = 0; j < shieldGroup.length; j += 2) {\n                        const distanceSqr = Math2D.distSquared(\n                            shieldGroup[j],\n                            shieldGroup[j + 1],\n                            tempScreenPosition.x,\n                            tempScreenPosition.y\n                        );\n                        tooClose = distanceSqr < minDistanceSqr;\n                        if (tooClose) {\n                            break;\n                        }\n                    }\n\n                    // Place it as a point label if it's not to close to other marker in the\n                    // same shield group.\n                    if (!tooClose) {\n                        if (\n                            this.addPointLabel(\n                                labelState,\n                                point,\n                                tempScreenPosition,\n                                poiRenderer,\n                                textCanvas,\n                                renderParams,\n                                temp,\n                                pointIndex\n                            )\n                        ) {\n                            shieldGroup.push(tempScreenPosition.x, tempScreenPosition.y);\n                        }\n                    }\n                }\n            }\n        }\n        // Process markers (without shield groups).\n        else {\n            for (let pointIndex = 0; pointIndex < path.length; ++pointIndex) {\n                const point = path[pointIndex];\n                // Only process labels frustum-clipped labels\n                if (this.m_screenProjector.project(point, tempScreenPosition) !== undefined) {\n                    this.addPointLabel(\n                        labelState,\n                        point,\n                        tempScreenPosition,\n                        poiRenderer,\n                        textCanvas,\n                        renderParams,\n                        temp,\n                        pointIndex\n                    );\n                }\n            }\n        }\n    }\n\n    private addPathLabel(\n        labelState: TextElementState,\n        screenPoints: THREE.Vector2[],\n        textCanvas: TextCanvas,\n        renderParams: RenderParams,\n        temp: TempParams\n    ): boolean {\n        // TODO: HARP-7649. Add fade out transitions for path labels.\n        const textMaxDistance = getMaxViewDistance(\n            this.m_viewState,\n            this.m_options.maxDistanceRatioForTextLabels!\n        );\n        const pathLabel = labelState.element;\n\n        // Limit the text rendering of path labels in the far distance.\n        if (\n            !(\n                pathLabel.ignoreDistance === true ||\n                labelState.viewDistance === undefined ||\n                labelState.viewDistance < textMaxDistance\n            )\n        ) {\n            if (placementStats) {\n                ++placementStats.tooFar;\n            }\n            labelState.reset();\n            return false;\n        }\n\n        if (\n            pathLabel.fadeFar !== undefined &&\n            (pathLabel.fadeFar <= 0.0 ||\n                pathLabel.fadeFar * this.m_viewState.maxVisibilityDist < labelState.renderDistance)\n        ) {\n            // The label is farther away than fadeFar value, which means it is totally\n            // transparent\n            if (placementStats) {\n                ++placementStats.tooFar;\n            }\n            labelState.reset();\n            return false;\n        }\n\n        // Compute values common for all glyphs in the label.\n        let textScale = textCanvas.textRenderStyle.fontSize.size / 100.0;\n        let opacity = pathLabel.renderStyle!.opacity;\n\n        // Get the screen points that define the label's segments and create a path with\n        // them.\n        let textPath = new THREE.Path();\n        tempScreenPosition.copy(screenPoints[0]);\n        for (let i = 0; i < screenPoints.length - 1; ++i) {\n            textPath.add(new SimpleLineCurve(screenPoints[i], screenPoints[i + 1]));\n        }\n        // Flip the path if the label is gonna be rendered downwards.\n        if (textPath.getPoint(0.5).x - textPath.getPoint(0.51).x > 0) {\n            tempScreenPosition.copy(screenPoints[screenPoints.length - 1]);\n            textPath = new THREE.Path();\n            for (let i = screenPoints.length - 1; i > 0; --i) {\n                textPath.add(new SimpleLineCurve(screenPoints[i], screenPoints[i - 1]));\n            }\n        }\n\n        // Update the real rendering distance to have smooth fading and scaling\n        labelState.setViewDistance(computeViewDistance(this.m_viewState.worldCenter, pathLabel));\n        const textRenderDistance = -labelState.renderDistance;\n\n        // Scale the text depending on the label's distance to the camera.\n        const distanceScaleFactor = this.getDistanceScalingFactor(\n            pathLabel,\n            textRenderDistance,\n            this.m_viewState.lookAtDistance\n        );\n        textScale *= distanceScaleFactor;\n\n        // Scale the path label correctly.\n        const prevSize = textCanvas.textRenderStyle.fontSize.size;\n        textCanvas.textRenderStyle.fontSize.size = textScale * 100;\n\n        // Recalculate the text bounds for this path label. If measurement fails, the whole\n        // label doesn't fit the path and should be discarded.\n        temp.measurementParams.path = textPath;\n        temp.measurementParams.outputCharacterBounds = tempBoxes;\n        temp.measurementParams.letterCaseArray = pathLabel.glyphCaseArray!;\n\n        // TODO: HARP-7648. TextCanvas.measureText does the placement as in TextCanvas.addText but\n        // without storing the result. If the measurement succeeds, the placement work is done\n        // twice.\n        // This could be done in one step (e.g measureAndAddText). Collision test could be injected\n        // in the middle as a function.\n        if (!textCanvas.measureText(pathLabel.glyphs!, tempBox, temp.measurementParams)) {\n            textCanvas.textRenderStyle.fontSize.size = prevSize;\n            if (placementStats) {\n                ++placementStats.numNotVisible;\n            }\n            labelState.reset();\n            return false;\n        }\n\n        // Perform per-character collision checks.\n        for (const charBounds of tempBoxes) {\n            tempBox2D.x = tempScreenPosition.x + charBounds.min.x;\n            tempBox2D.y = tempScreenPosition.y + charBounds.min.y;\n            tempBox2D.w = charBounds.max.x - charBounds.min.x;\n            tempBox2D.h = charBounds.max.y - charBounds.min.y;\n            if (\n                !this.m_screenCollisions.isVisible(tempBox2D) ||\n                (!pathLabel.textMayOverlap && this.m_screenCollisions.isAllocated(tempBox2D))\n            ) {\n                textCanvas.textRenderStyle.fontSize.size = prevSize;\n                if (placementStats) {\n                    ++placementStats.numNotVisible;\n                }\n                return false;\n            }\n        }\n\n        labelState.textRenderState!.startFadeIn(renderParams.time);\n\n        if (labelState.textRenderState!.isFading()) {\n            opacity = labelState.textRenderState!.opacity * pathLabel.renderStyle!.opacity;\n            renderParams.fadeAnimationRunning = true;\n        }\n\n        const prevOpacity = textCanvas.textRenderStyle.opacity;\n        const prevBgOpacity = textCanvas.textRenderStyle.backgroundOpacity;\n        const distanceFadeFactor = this.getDistanceFadingFactor(\n            pathLabel,\n            labelState,\n            this.m_viewState.maxVisibilityDist\n        );\n        textCanvas.textRenderStyle.opacity = opacity * distanceFadeFactor;\n        textCanvas.textRenderStyle.backgroundOpacity =\n            textCanvas.textRenderStyle.opacity * pathLabel.renderStyle!.backgroundOpacity;\n\n        tempPosition.z = labelState.renderDistance;\n\n        temp.additionParams.path = textPath;\n        temp.additionParams.layer = pathLabel.renderOrder;\n        temp.additionParams.letterCaseArray = pathLabel.glyphCaseArray;\n        temp.additionParams.pickingData = pathLabel.userData ? pathLabel : undefined;\n        textCanvas.addText(pathLabel.glyphs!, tempPosition, temp.additionParams);\n\n        // Allocate collision info if needed.\n        if (pathLabel.textReservesSpace) {\n            tempBox2D.x = tempScreenPosition.x + tempBox.min.x;\n            tempBox2D.y = tempScreenPosition.y + tempBox.min.y;\n            tempBox2D.w = tempBox.max.x - tempBox.min.x;\n            tempBox2D.h = tempBox.max.y - tempBox.min.y;\n            this.m_screenCollisions.allocate(tempBox2D);\n        }\n\n        renderParams.numRenderedTextElements++;\n\n        // Restore previous style values for text elements using the same style.\n        textCanvas.textRenderStyle.fontSize.size = prevSize;\n        textCanvas.textRenderStyle.opacity = prevOpacity;\n        textCanvas.textRenderStyle.backgroundOpacity = prevBgOpacity;\n        return true;\n    }\n\n    private checkForSmallLabels(textElement: TextElement, screenPoints: THREE.Vector2[]): boolean {\n        // Get the screen points that define the label's segments and create a path with\n        // them.\n        screenPoints.length = 0;\n        let anyPointVisible = false;\n\n        for (const pt of textElement.points as THREE.Vector3[]) {\n            // Skip invisible points at the beginning of the path.\n            const screenPoint = anyPointVisible\n                ? this.m_screenProjector.project(pt, tempScreenPosition)\n                : this.m_screenProjector.projectOnScreen(pt, tempScreenPosition);\n            if (screenPoint === undefined) {\n                continue;\n            }\n            anyPointVisible = true;\n\n            screenPoints.push(tempScreenPosition.clone());\n        }\n\n        // TODO: (HARP-3515)\n        //      The rendering of a path label that contains just a single point that is not\n        //      visible is impossible, which is problematic with long paths.\n        //      Fix: Skip/clip the invisible points at beginning and end of the path to get\n        //      the visible part of the path.\n\n        // If not a single point is visible, skip the path\n        if (!anyPointVisible) {\n            return false;\n        }\n\n        // Check/guess if the screen box can hold a string of that length. It is important\n        // to guess that value without measuring the font first to save time.\n        const minScreenSpace = textElement.text.length * MIN_AVERAGE_CHAR_WIDTH;\n\n        tempBox.setFromPoints(screenPoints);\n        const boxDiagonalSq = tempBox.max.sub(tempBox.min).lengthSq();\n\n        if (boxDiagonalSq < minScreenSpace * minScreenSpace) {\n            textElement.dbgPathTooSmall = true;\n            return false;\n        }\n\n        return true;\n    }\n\n    private checkIfOverloaded(dataSourceTileList: DataSourceTileList[]): boolean {\n        // Count the number of TextElements in the scene to see if we have to switch to\n        // \"overloadMode\".\n        let numTextElementsInScene = 0;\n\n        dataSourceTileList.forEach(renderListEntry => {\n            for (const tile of renderListEntry.renderedTiles.values()) {\n                numTextElementsInScene += tile.textElementGroups.count();\n                numTextElementsInScene += tile.userTextElements.elements.length;\n            }\n        });\n        const newOverloaded = numTextElementsInScene > OVERLOAD_LABEL_LIMIT;\n\n        if (newOverloaded && !this.m_overloaded) {\n            logger.debug(\"Overloaded Mode enabled.\");\n        }\n        this.m_overloaded = newOverloaded;\n        return this.m_overloaded;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeometryType, getFeatureId, Technique } from \"@here/harp-datasource-protocol\";\nimport * as THREE from \"three\";\n\nimport { MapView } from \"./MapView\";\nimport { MapViewPoints } from \"./MapViewPoints\";\nimport { RoadPicker } from \"./RoadPicker\";\nimport { RoadIntersectionData, Tile, TileFeatureData } from \"./Tile\";\n\n/**\n * Describes the general type of a picked object.\n */\nexport enum PickObjectType {\n    /**\n     * Unspecified.\n     */\n    Unspecified = 0,\n\n    /**\n     * A point object.\n     */\n    Point,\n\n    /**\n     * A line object.\n     */\n    Line,\n\n    /**\n     * An area object.\n     */\n    Area,\n\n    /**\n     * The text part of a [[TextElement]]\n     */\n    Text,\n\n    /**\n     * The Icon of a [[TextElement]].\n     */\n    Icon,\n\n    /**\n     * Any general 3D object, for example, a landmark.\n     */\n    Object3D\n}\n\n/**\n * A general pick result. You can access the details of a picked geometry from the property\n * `intersection`, which is available if a geometry was hit. If a road was hit, a [[RoadPickResult]]\n * is returned, which has additional information, but no `intersection`.\n */\nexport interface PickResult {\n    /**\n     * General type of object.\n     */\n    type: PickObjectType;\n\n    /**\n     * A 2D point in screen coordinates, or a 3D point in world coordinates.\n     */\n    point: THREE.Vector2 | THREE.Vector3;\n\n    /**\n     * Distance from the camera to the picking point; used to determine the closest object.\n     */\n    distance: number;\n\n    /**\n     * An optional feature ID of the picked object; typically applies to the Optimized Map\n     * Vector (OMV) format.\n     */\n    featureId?: number;\n\n    /**\n     * Defined for geometry only.\n     */\n    intersection?: THREE.Intersection;\n\n    /**\n     * Defined for roads only.\n     */\n    technique?: Technique;\n\n    /**\n     * Optional user data that has been defined in the picked object. This object points directly to\n     * information contained in the original [[TileFeatureData]] stored in [[MapView]], and should\n     * not be modified.\n     */\n    userData?: any;\n}\n\n/**\n * Handles the picking of scene geometry and roads.\n */\nexport class PickHandler {\n    private readonly m_plane = new THREE.Plane(new THREE.Vector3(0, 0, 1));\n    private readonly m_roadPicker?: RoadPicker;\n\n    constructor(\n        readonly mapView: MapView,\n        readonly camera: THREE.Camera,\n        public enableRoadPicking = true\n    ) {\n        if (enableRoadPicking) {\n            this.m_roadPicker = new RoadPicker(mapView);\n        }\n    }\n\n    /**\n     * The `RoadPicker` class manages picking of roads, which may not be pickable in THREE.js,\n     * since their geometry is generated in the vertex shader. The `RoadPicker` requires that\n     * all [[Tile]]s are registered before they can be picked successfully.\n     */\n    registerTile(tile: Tile): RoadIntersectionData | undefined {\n        return this.m_roadPicker !== undefined ? this.m_roadPicker.registerTile(tile) : undefined;\n    }\n\n    /**\n     * Does a raycast on all objects in the scene; useful for picking. This function is Limited to\n     * objects that THREE.js can raycast. However, any solid lines that have their geometry in the\n     * shader cannot be tested for intersection.\n     *\n     * @param x The X position in CSS/client coordinates, without the applied display ratio.\n     * @param y The Y position in CSS/client coordinates, without the applied display ratio.\n     * @returns the list of intersection results.\n     */\n    intersectMapObjects(x: number, y: number): PickResult[] {\n        const worldPos = this.mapView.getNormalizedScreenCoordinates(x, y);\n\n        const rayCaster = this.mapView.raycasterFromScreenPoint(x, y);\n        const pickResults: PickResult[] = [];\n\n        if (this.mapView.textElementsRenderer !== undefined) {\n            const { clientWidth, clientHeight } = this.mapView.canvas;\n            const screenX = worldPos.x * clientWidth * 0.5 * this.mapView.pixelRatio;\n            const screenY = worldPos.y * clientHeight * 0.5 * this.mapView.pixelRatio;\n            const scenePosition = new THREE.Vector2(screenX, screenY);\n            this.mapView.textElementsRenderer.pickTextElements(scenePosition, pickResults);\n        }\n\n        // calculate objects intersecting the picking ray\n        const intersects = rayCaster.intersectObjects(this.mapView.worldRootObject.children, true);\n        for (const intersect of intersects) {\n            const pickResult: PickResult = {\n                type: PickObjectType.Unspecified,\n                point: intersect.point,\n                distance: intersect.distance,\n                intersection: intersect\n            };\n\n            if (\n                intersect.object.userData === undefined ||\n                intersect.object.userData.feature === undefined\n            ) {\n                pickResults.push(pickResult);\n                continue;\n            }\n\n            const featureData: TileFeatureData = intersect.object.userData.feature;\n\n            this.addObjInfo(featureData, intersect, pickResult);\n\n            if (featureData.objInfos !== undefined) {\n                const featureId =\n                    featureData.objInfos.length === 1\n                        ? getFeatureId(featureData.objInfos[0])\n                        : undefined;\n                pickResult.featureId = featureId;\n            }\n\n            let pickObjectType: PickObjectType;\n\n            switch (featureData.geometryType) {\n                case GeometryType.Point:\n                case GeometryType.Text:\n                    pickObjectType = PickObjectType.Point;\n                    break;\n                case GeometryType.Line:\n                case GeometryType.ExtrudedLine:\n                case GeometryType.SolidLine:\n                case GeometryType.TextPath:\n                    pickObjectType = PickObjectType.Line;\n                    break;\n                case GeometryType.Polygon:\n                case GeometryType.ExtrudedPolygon:\n                    pickObjectType = PickObjectType.Area;\n                    break;\n                case GeometryType.Object3D:\n                    pickObjectType = PickObjectType.Object3D;\n                    break;\n                default:\n                    pickObjectType = PickObjectType.Unspecified;\n            }\n\n            pickResult.type = pickObjectType;\n            pickResults.push(pickResult);\n        }\n\n        if (this.enableRoadPicking) {\n            const planeIntersectPosition = new THREE.Vector3();\n            const cameraPos = this.mapView.camera.position.clone();\n\n            rayCaster.setFromCamera(worldPos, this.mapView.camera);\n            rayCaster.ray.intersectPlane(this.m_plane, planeIntersectPosition);\n\n            this.mapView.forEachVisibleTile(tile => {\n                this.m_roadPicker!.intersectRoads(\n                    tile,\n                    cameraPos,\n                    planeIntersectPosition,\n                    pickResults\n                );\n            });\n        }\n\n        pickResults.sort((a: PickResult, b: PickResult) => {\n            return a.distance - b.distance;\n        });\n\n        return pickResults;\n    }\n\n    private addObjInfo(\n        featureData: TileFeatureData,\n        intersect: THREE.Intersection,\n        pickResult: PickResult\n    ) {\n        if (pickResult.intersection!.object instanceof MapViewPoints) {\n            pickResult.userData = featureData.objInfos![intersect.index!];\n            return;\n        } else if (\n            featureData.objInfos === undefined ||\n            featureData.starts === undefined ||\n            intersect.faceIndex === undefined\n        ) {\n            return;\n        }\n\n        if (featureData.starts.length > 1) {\n            let objInfosIndex = 0;\n            for (const polygonStartFace of featureData.starts) {\n                if (polygonStartFace > intersect.faceIndex * 3) {\n                    break;\n                }\n                objInfosIndex++;\n            }\n            pickResult.userData = featureData.objInfos[objInfosIndex - 1];\n        } else {\n            pickResult.userData = featureData.objInfos[0];\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {\n    DecodedTile,\n    GeometryType,\n    Technique,\n    TextPathGeometry\n} from \"@here/harp-datasource-protocol\";\nimport { GeoBox, OrientedBox3, Projection, TileKey } from \"@here/harp-geoutils\";\nimport { assert, CachedResource, LoggerManager } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { AnimatedExtrusionTileHandler } from \"./AnimatedExtrusionHandler\";\nimport { CopyrightInfo } from \"./copyrights/CopyrightInfo\";\nimport { DataSource } from \"./DataSource\";\nimport { TileGeometryLoader } from \"./geometry/TileGeometryLoader\";\nimport { MapView } from \"./MapView\";\nimport { PathBlockingElement } from \"./PathBlockingElement\";\nimport { PerformanceStatistics } from \"./Statistics\";\nimport { TextElement } from \"./text/TextElement\";\nimport { TextElementGroup } from \"./text/TextElementGroup\";\nimport { TextElementGroupPriorityList } from \"./text/TextElementGroupPriorityList\";\nimport { MapViewUtils } from \"./Utils\";\n\nconst logger = LoggerManager.instance.create(\"Tile\");\n\nexport type TileObject = THREE.Object3D & {\n    /**\n     * Distance of this object from the [[Tile]]'s center.\n     */\n    displacement?: THREE.Vector3;\n\n    /**\n     * This stores the THREE.Object3D renderOrder property, we need to back it up because we need to\n     * reduce it if the tile is used as fall back. When it is used normally, the renderOrder needs\n     * to be reset.\n     * @hidden\n     */\n    _backupRenderOrder?: number;\n};\n\ninterface DisposableObject {\n    geometry?: THREE.BufferGeometry | THREE.Geometry;\n    material?: THREE.Material[] | THREE.Material;\n}\n\n/**\n * An interface for optional feature data that is saved in a `THREE.Object3D`'s `userData`\n * property.\n */\nexport interface TileFeatureData {\n    /**\n     * The original type of geometry.\n     */\n    geometryType?: GeometryType;\n\n    /**\n     * An optional array of indices into geometry where the feature starts. The lists of IDs\n     * and starting indices (starts) must have the same size.\n     */\n    starts?: number[];\n\n    /**\n     * An optional object containing properties defined by the developer. It has the same size as\n     * the list of IDs and the starting indices (starts).\n     */\n    objInfos?: Array<{} | undefined>;\n}\n\n/**\n * Minimum estimated size of a JS object.\n */\nconst MINIMUM_SMALL_OBJECT_SIZE_ESTIMATION = 16;\nconst MINIMUM_OBJECT_SIZE_ESTIMATION = 100;\n\n/**\n * Compute the memory footprint of `TileFeatureData`.\n */\nexport function getFeatureDataSize(featureData: TileFeatureData): number {\n    let numBytes = MINIMUM_OBJECT_SIZE_ESTIMATION;\n\n    if (featureData.starts !== undefined) {\n        numBytes += featureData.starts.length * 8;\n    }\n    if (featureData.objInfos !== undefined) {\n        // 16 (estimated) bytes per objInfos\n        numBytes += featureData.objInfos.length * MINIMUM_SMALL_OBJECT_SIZE_ESTIMATION;\n    }\n\n    return numBytes;\n}\n\n/**\n * Contains data that describes the road on a `tile`. The `RoadIntersectionData` is generated by\n * the [[RoadPicker]] class.\n *\n * @see [[RoadPicker]]\n */\nexport interface RoadIntersectionData {\n    /**\n     * Optional array of feature IDs.\n     */\n    ids: Array<number | undefined>;\n\n    /**\n     * An array of indices into the technique catalog. The lists of `techniqueIndex` and `starts`\n     * have the same size.\n     */\n    techniqueIndex: number[];\n\n    /**\n     * An array of the indices into geometry where the feature starts. The lists of IDs and\n     * starting indices (starts) have the same size.\n     */\n    starts: number[];\n\n    /**\n     * An array of widths of the roads. The lists of IDs and widths have the same size.\n     */\n    widths: Array<number | (() => number)>;\n\n    /**\n     * An array of 2D numbers that make up the road geometry.\n     */\n    positions: number[];\n\n    /**\n     * A catalog of [[Technique]]s for road lines. Allows to reconstruct the visual appearance of\n     * the identified line.\n     */\n    techniques: Technique[];\n    /**\n     * An optional object that contains properties defined by the developer. This object has the\n     * same size as the list of IDs and the starts.\n     */\n    objInfos?: Array<{} | undefined>;\n}\n\n/**\n * Compute the memory footprint of `RoadIntersectionData`.\n */\nfunction getRoadIntersectionDataSize(intersectionData: RoadIntersectionData): number {\n    let numBytes = MINIMUM_OBJECT_SIZE_ESTIMATION;\n\n    // 8 bytes per techniqueIndex\n    // 8 bytes per start\n    // 8 bytes per width\n    // 8 bytes per position\n    // 100 (estimated) bytes per technique\n    const bytesPerEntry = 8 + 8 + 8 + 8 + MINIMUM_OBJECT_SIZE_ESTIMATION;\n    const numEntries = intersectionData.techniqueIndex.length;\n    numBytes += intersectionData.techniqueIndex.length * bytesPerEntry;\n\n    if (intersectionData.ids !== undefined) {\n        numBytes += numEntries * 8;\n    }\n\n    if (intersectionData.objInfos !== undefined) {\n        // 16 (estimated) bytes per objInfos\n        numBytes += numEntries * MINIMUM_SMALL_OBJECT_SIZE_ESTIMATION;\n    }\n\n    return numBytes;\n}\n\n/**\n * Missing Typedoc\n */\nexport enum TileLoaderState {\n    Initialized,\n    Loading,\n    Loaded,\n    Decoding,\n    Ready,\n    Canceled,\n    Failed\n}\n\nexport interface ITileLoader {\n    state: TileLoaderState;\n    payload?: ArrayBufferLike | {};\n    decodedTile?: DecodedTile;\n\n    isFinished: boolean;\n\n    loadAndDecode(): Promise<TileLoaderState>;\n    waitSettled(): Promise<TileLoaderState>;\n\n    updatePriority(area: number): void;\n\n    cancel(): void;\n}\n\n/**\n * An object that contains information about resources used by a tile.\n */\nexport interface TileResourceUsage {\n    /**\n     * The estimated memory usage, in bytes.\n     */\n    estimatedMemoryUsage: number;\n    /**\n     * The amount of vertices used by a tile.\n     */\n    numVertices: number;\n    /**\n     * The amount of colors used by a tile.\n     */\n    numColors: number;\n    /**\n     * The amount of objects used by a tile.\n     */\n    numObjects: number;\n    /**\n     * The amount of geometries used by a tile.\n     */\n    numGeometries: number;\n    /**\n     * The amount of materials used by a tile.\n     */\n    numMaterials: number;\n}\n\n/**\n * Simple information about resource usage by the [[Tile]]. Heap and GPU information are\n * estimations.\n */\nexport interface TileResourceInfo {\n    /**\n     * Estimated number of bytes used on the heap.\n     */\n    heapSize: number;\n    /**\n     * Estimated number of bytes used on the GPU.\n     */\n    gpuSize: number;\n    /**\n     * Number of [[THREE.Object3D]] in this tile.\n     */\n    num3dObjects: number;\n    /**\n     * Number of [[TextElement]]s in this tile.\n     */\n    numTextElements: number;\n    /**\n     * Number of user [[TextElement]]s in this tile.\n     */\n    numUserTextElements: number;\n}\n\nexport interface TextElementIndex {\n    groupIndex: number;\n    elementIndex: number;\n}\n\n/**\n * The class that holds the tiled data for a [[DataSource]].\n */\nexport class Tile implements CachedResource {\n    /**\n     * A list of the THREE.js objects stored in this `Tile`.\n     */\n    readonly objects: TileObject[] = [];\n\n    /**\n     * The optional list of HERE TileKeys of tiles with geometries that cross\n     * the boundaries of this `Tile`.\n     */\n    readonly dependencies: string[] = new Array<string>();\n\n    /**\n     * The bounding box of this `Tile` in geocoordinates.\n     */\n    readonly geoBox: GeoBox;\n\n    /**\n     * The bounding box of this `Tile` in world coordinates.\n     */\n    readonly boundingBox = new OrientedBox3();\n\n    /**\n     * Maximum height of geometry on this tile above ground level.\n     */\n    maxGeometryHeight: number = 0;\n\n    /**\n     * A record of road data that cannot be intersected with THREE.JS, because the geometry is\n     * created in the vertex shader.\n     */\n    roadIntersectionData?: RoadIntersectionData;\n\n    /**\n     * Copyright information of this `Tile`'s data.\n     */\n    copyrightInfo?: CopyrightInfo[];\n\n    /**\n     * Keeping some stats for the individual [[Tile]]s to analyze caching behavior.\n     *\n     * The frame the [[Tile]] was last requested. This is required to know when the given [[Tile]]\n     * can be removed from the cache.\n     */\n    frameNumLastRequested: number = -1;\n\n    /**\n     * The frame the `Tile` was first visible.\n     */\n    frameNumVisible: number = -1;\n\n    /**\n     * The last frame this `Tile` has been rendered (or was in the visible set). Used to determine\n     * visibility of `Tile` at the end of a frame, if the number is the current frame number, it is\n     * visible.\n     */\n    frameNumLastVisible: number = -1;\n\n    /**\n     * After removing from cache, this is the number of frames the `Tile` was visible.\n     */\n    numFramesVisible: number = 0;\n\n    /**\n     * Version stamp of the visibility set in the [[TileManager]]. If the counter is different, the\n     * visibility of the Tile's objects has to be calculated. Optimization to reduce overhead of\n     * computing visibility.\n     */\n    visibilityCounter: number = -1;\n\n    /**\n     * @hidden\n     *\n     * Prepared text geometries optimized for display.\n     */\n    preparedTextPaths: TextPathGeometry[] | undefined;\n\n    /**\n     * @hidden\n     *\n     * Used to tell if the Tile is used temporarily as a fallback tile.\n     *\n     * levelOffset is in in the range [-quadTreeSearchDistanceUp,\n     * quadTreeSearchDistanceDown], where these values come from the\n     * [[VisibleTileSetOptions]]\n     */\n    levelOffset: number = 0;\n\n    private m_disposed: boolean = false;\n    private m_localTangentSpace = false;\n\n    private m_forceHasGeometry: boolean | undefined = undefined;\n\n    private m_tileLoader?: ITileLoader;\n    private m_decodedTile?: DecodedTile;\n    private m_tileGeometryLoader?: TileGeometryLoader;\n\n    // TODO: Delay construction of text element groups until first text element is added.\n\n    // Used for [[TextElement]]s which the developer defines. Group created with maximum priority\n    // so that user text elements are placed before others.\n    private readonly m_userTextElements = new TextElementGroup(Number.MAX_SAFE_INTEGER);\n\n    // Used for [[TextElement]]s that are stored in the data, and that are placed explicitly,\n    // fading in and out.\n    private readonly m_textElementGroups = new TextElementGroupPriorityList();\n\n    // Blocks other labels from showing.\n    private readonly m_pathBlockingElements: PathBlockingElement[] = [];\n\n    // If `true`, the text content of the [[Tile]] changed.\n    private m_textElementsChanged: boolean = false;\n\n    private m_visibleArea: number = 0;\n    private m_minElevation: number = 0;\n    private m_maxElevation: number = 0;\n\n    private m_resourceInfo: TileResourceInfo | undefined;\n\n    // List of owned textures for disposal\n    private m_ownedTextures: WeakSet<THREE.Texture> = new WeakSet();\n\n    private m_animatedExtrusionTileHandler: AnimatedExtrusionTileHandler | undefined;\n\n    private m_nextTextElementToOverlay: TextElementIndex = {\n        groupIndex: 0,\n        elementIndex: 0\n    };\n\n    /**\n     * Creates a new [[Tile]].\n     *\n     * @param dataSource The [[DataSource]] that created this [[Tile]].\n     * @param tileKey The unique identifier for this [[Tile]]. Currently only up to level 24 is\n     * supported, because of the use of the upper bits for the offset.\n     * @param offset The optional offset, this is an integer which represents what multiple of 360\n     * degrees to shift, only useful for flat projections, hence optional.\n     * @param localTangentSpace Whether the tile geometry is in local tangent space or not.\n     */\n    constructor(\n        readonly dataSource: DataSource,\n        readonly tileKey: TileKey,\n        public offset: number = 0,\n        localTangentSpace?: boolean\n    ) {\n        this.geoBox = this.dataSource.getTilingScheme().getGeoBox(this.tileKey);\n        this.projection.projectBox(this.geoBox, this.boundingBox);\n        this.m_localTangentSpace = localTangentSpace !== undefined ? localTangentSpace : false;\n    }\n\n    /**\n     * The visibility status of the [[Tile]]. It is actually visible or planned to become visible.\n     */\n    get isVisible(): boolean {\n        // Tiles are not evaluated as invisible until the second frame they aren't requested.\n        // This happens in order to prevent that, during [[VisibleTileSet]] visibility evaluation,\n        // visible tiles that haven't yet been evaluated for the current frame are preemptively\n        // removed from [[DataSourceCache]].\n        return this.frameNumLastRequested >= this.dataSource.mapView.frameNumber - 1;\n    }\n\n    set isVisible(visible: boolean) {\n        this.frameNumLastRequested = visible ? this.dataSource.mapView.frameNumber : -1;\n    }\n\n    /**\n     * The [[Projection]] currently used by the [[MapView]].\n     */\n    get projection(): Projection {\n        return this.dataSource.projection;\n    }\n\n    /**\n     * The [[MapView]] this `Tile` belongs to.\n     */\n    get mapView(): MapView {\n        return this.dataSource.mapView;\n    }\n\n    /**\n     * Whether the data of this tile is in local tangent space or not.\n     * If the data is in local tangent space (i.e. up vector is (0,0,1) for high zoomlevels) then\n     * [[MapView]] will rotate the objects before rendering using the rotation matrix of the\n     * oriented [[boundingBox]].\n     */\n    get localTangentSpace(): boolean {\n        return this.m_localTangentSpace;\n    }\n\n    /*\n     * The size of this Tile in system memory.\n     */\n    get memoryUsage(): number {\n        if (this.m_resourceInfo === undefined) {\n            this.computeResourceInfo();\n        }\n        return this.m_resourceInfo!.heapSize;\n    }\n\n    /**\n     * The center of this `Tile` in world coordinates.\n     */\n    get center(): THREE.Vector3 {\n        return this.boundingBox.position;\n    }\n\n    /**\n     * Compute [[TileResourceInfo]] of this `Tile`. May be using a cached value. The method\n     * `invalidateResourceInfo` can be called beforehand to force a recalculation.\n     *\n     * @returns `TileResourceInfo` for this `Tile`.\n     */\n    getResourceInfo(): TileResourceInfo {\n        if (this.m_resourceInfo === undefined) {\n            this.computeResourceInfo();\n        }\n        return this.m_resourceInfo!;\n    }\n\n    /**\n     * Force invalidation of the cached [[TileResourceInfo]]. Useful after the `Tile` has been\n     * modified.\n     */\n    invalidateResourceInfo(): void {\n        this.m_resourceInfo = undefined;\n    }\n\n    /**\n     * Add ownership of a texture to this tile. The texture will be disposed if the `Tile` is\n     * disposed.\n     * @param texture Texture to be owned by the `Tile`\n     */\n    addOwnedTexture(texture: THREE.Texture): void {\n        this.m_ownedTextures.add(texture);\n    }\n\n    /**\n     * Gets the list of developer-defined [[TextElement]] in this `Tile`. This list is always\n     * rendered first.\n     */\n    get userTextElements(): TextElementGroup {\n        return this.m_userTextElements;\n    }\n\n    /**\n     * Adds a developer-defined [[TextElement]] to this `Tile`. The [[TextElement]] is always\n     * visible, if it's in the map's currently visible area.\n     *\n     * @param textElement The Text element to add.\n     */\n    addUserTextElement(textElement: TextElement) {\n        this.m_userTextElements.elements.push(textElement);\n        this.textElementsChanged = true;\n    }\n\n    /**\n     * Removes a developer-defined [[TextElement]] from this `Tile`.\n     *\n     * @param textElement A developer-defined TextElement to remove.\n     * @returns `true` if the element has been removed successfully; `false` otherwise.\n     */\n    removeUserTextElement(textElement: TextElement): boolean {\n        const foundIndex = this.m_userTextElements.elements.indexOf(textElement);\n        if (foundIndex >= 0) {\n            this.m_userTextElements.elements.splice(foundIndex, 1);\n            this.textElementsChanged = true;\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Adds a [[TextElement]] to this `Tile`, which is added to the visible set of\n     * [[TextElement]]s based on the capacity and visibility. The [[TextElement]]'s priority\n     * controls if or when it becomes visible.\n     *\n     * To ensure that a TextElement is visible, use a high value for its priority, such as\n     * `Number.MAX_SAFE_INTEGER`. Since the number of visible TextElements is limited by the\n     * screen space, not all TextElements are visible at all times.\n     *\n     * @param textElement The TextElement to add.\n     */\n    addTextElement(textElement: TextElement) {\n        this.textElementGroups.add(textElement);\n        this.textElementsChanged = true;\n    }\n\n    /**\n     * Adds a [[PathBlockingElement]] to this `Tile`. This path has the highest priority and blocks\n     * all other labels. There maybe in future a use case to give it a priority, but as that isn't\n     * yet required, it is left to be implemented later if required.\n     * @param blockingElement Element which should block all other labels.\n     */\n    addBlockingElement(blockingElement: PathBlockingElement) {\n        this.m_pathBlockingElements.push(blockingElement);\n    }\n\n    /**\n     * Removes a [[TextElement]] from this `Tile`. For the element to be removed successfully, the\n     * priority of the [[TextElement]] has to be equal to its priority when it was added.\n     *\n     * @param textElement The TextElement to remove.\n     * @returns `true` if the TextElement has been removed successfully; `false` otherwise.\n     */\n    removeTextElement(textElement: TextElement): boolean {\n        if (this.textElementGroups.remove(textElement)) {\n            this.textElementsChanged = true;\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Gets the current [[GroupedPriorityList]] which contains a list of all [[TextElement]]s to be\n     * selected and placed for rendering.\n     */\n    get textElementGroups(): TextElementGroupPriorityList {\n        return this.m_textElementGroups;\n    }\n\n    /**\n     * Gets the current modification state for the list of [[TextElement]]s in the `Tile`. If the\n     * value is `true` the TextElement is placed for rendering during the next frame.\n     */\n    get textElementsChanged(): boolean {\n        return this.m_textElementsChanged;\n    }\n\n    set textElementsChanged(changed: boolean) {\n        this.m_textElementsChanged = changed;\n    }\n\n    /**\n     * Returns true if the `Tile` has any text elements to render.\n     */\n    hasTextElements(): boolean {\n        return this.m_textElementGroups.count() > 0 || this.m_userTextElements.elements.length > 0;\n    }\n\n    /**\n     * Get the current blocking elements.\n     */\n    get blockingElements(): PathBlockingElement[] {\n        return this.m_pathBlockingElements;\n    }\n\n    /**\n     * Called by [[VisibleTileSet]] to mark that [[Tile]] is visible and it should prepare its road\n     * geometry for picking.\n     */\n    prepareTileInfo() {\n        // If the tile is not ready for display, or if it has become invisible while being loaded,\n        // for example by moving the camera, the tile is not finished and its geometry is not\n        // created. This is an optimization for fast camera movements and zooms.\n        if (this.m_decodedTile === undefined || this.m_disposed || !this.isVisible) {\n            return;\n        }\n\n        if (this.m_decodedTile.tileInfo !== undefined) {\n            this.roadIntersectionData = this.dataSource.mapView.pickHandler.registerTile(this);\n        }\n    }\n\n    /**\n     * Called before [[MapView]] starts rendering this `Tile`.\n     *\n     * @param zoomLevel The current zoom level.\n     * @returns Returns `true` if this `Tile` should be rendered.\n     */\n    willRender(_zoomLevel: number): boolean {\n        return true;\n    }\n\n    /**\n     * Called after [[MapView]] has rendered this `Tile`.\n     */\n    didRender(): void {\n        // to be overridden by subclasses\n    }\n\n    /**\n     * Estimated visible area of tile used for sorting the priorities during loading.\n     */\n    get visibleArea(): number {\n        return this.m_visibleArea;\n    }\n\n    set visibleArea(area: number) {\n        this.m_visibleArea = area;\n        if (this.tileLoader !== undefined) {\n            this.tileLoader.updatePriority(area);\n        }\n    }\n\n    /**\n     * Estimated tile's minimum elevation above the sea level.\n     * @note Negative values indicates depressions.\n     */\n    get minElevation(): number {\n        return this.m_minElevation;\n    }\n\n    set minElevation(elevation: number) {\n        this.m_minElevation = elevation;\n    }\n\n    /**\n     * Estimated maximum ground elevation above the sea level that may be found on tile.\n     * @note Negative values indicates depressions.\n     */\n    get maxElevation(): number {\n        return this.m_maxElevation;\n    }\n\n    set maxElevation(elevation: number) {\n        this.m_maxElevation = elevation;\n    }\n\n    /**\n     * Gets the decoded tile; it is removed after geometry handling.\n     */\n    get decodedTile(): DecodedTile | undefined {\n        return this.m_decodedTile;\n    }\n\n    /**\n     * Applies the decoded tile to the tile.\n     * If the geometry is empty, then the tile's forceHasGeometry flag is set.\n     * Map is updated.\n     * @param decodedTile The decoded tile to set.\n     */\n    set decodedTile(decodedTile: DecodedTile | undefined) {\n        this.m_decodedTile = decodedTile;\n        this.invalidateResourceInfo();\n\n        if (decodedTile === undefined) {\n            return;\n        }\n\n        if (decodedTile.geometries.length === 0) {\n            this.forceHasGeometry(true);\n        }\n\n        if (decodedTile.boundingBox !== undefined) {\n            // If the decoder provides a more accurate bounding box than the one we computed from\n            // the flat geo box we take it instead.\n            this.boundingBox.copy(decodedTile.boundingBox);\n        }\n\n        const stats = PerformanceStatistics.instance;\n        if (stats.enabled && decodedTile.decodeTime !== undefined) {\n            stats.currentFrame.addValue(\"decode.decodingTime\", decodedTile.decodeTime);\n            stats.currentFrame.addValue(\"decode.decodedTiles\", 1);\n        }\n\n        if (decodedTile.copyrightHolderIds !== undefined) {\n            this.copyrightInfo = decodedTile.copyrightHolderIds.map(id => ({ id }));\n        }\n\n        this.dataSource.requestUpdate();\n    }\n\n    /**\n     * Remove the decodedTile when no longer needed.\n     */\n    removeDecodedTile() {\n        this.m_decodedTile = undefined;\n        this.invalidateResourceInfo();\n    }\n\n    /**\n     * Called by the [[TileLoader]] after the `Tile` has finished loading its map data. Can be used\n     * to add content to the `Tile`. The [[DecodedTile]] should still be available.\n     */\n    loadingFinished() {\n        // To be used in subclasses.\n    }\n\n    /**\n     * Called when the default implementation of `dispose()` needs\n     * to free the geometry of a `Tile` object.\n     *\n     * @param object The object that references the geometry.\n     * @returns `true` if the geometry can be disposed.\n     */\n    // tslint:disable-next-line:no-unused-variable\n    shouldDisposeObjectGeometry(object: TileObject): boolean {\n        return true;\n    }\n\n    /**\n     * Called when the default implementation of `dispose()` needs\n     * to free a `Tile` object's material.\n     *\n     * @param object The object referencing the geometry.\n     * @returns `true` if the material can be disposed.\n     */\n    // tslint:disable-next-line:no-unused-variable\n    shouldDisposeObjectMaterial(object: TileObject): boolean {\n        return true;\n    }\n\n    /**\n     * Called when the default implementation of `dispose()` needs\n     * to free a Texture that is part of a `Tile` object's material.\n     *\n     * @param texture The texture about to be disposed.\n     * @returns `true` if the texture can be disposed.\n     */\n    shouldDisposeTexture(texture: THREE.Texture): boolean {\n        return this.m_ownedTextures.has(texture);\n    }\n\n    /**\n     * Returns `true` if this `Tile` has been disposed.\n     */\n    get disposed(): boolean {\n        return this.m_disposed;\n    }\n\n    /**\n     * Gets the [[TileGeometryLoader]] that manages this tile.\n     */\n    get tileGeometryLoader(): TileGeometryLoader | undefined {\n        return this.m_tileGeometryLoader;\n    }\n\n    /**\n     * Sets the [[TileGeometryLoader]] to manage this tile.\n     *\n     * @param tileGeometryLoader A [[TileGeometryLoader]] instance to manage the geometry creation\n     *      for this tile.\n     */\n    set tileGeometryLoader(tileGeometryLoader: TileGeometryLoader | undefined) {\n        this.m_tileGeometryLoader = tileGeometryLoader;\n    }\n\n    /**\n     * `True` if the basic geometry has been loaded, and the `Tile` is ready  for display.\n     */\n    get basicGeometryLoaded(): boolean {\n        return this.m_tileGeometryLoader === undefined\n            ? this.hasGeometry\n            : this.m_tileGeometryLoader.basicGeometryLoaded || this.m_tileGeometryLoader.isFinished;\n    }\n\n    /**\n     * `True` if all geometry of the `Tile` has been loaded.\n     */\n    get allGeometryLoaded(): boolean {\n        return this.m_tileGeometryLoader === undefined\n            ? this.hasGeometry\n            : this.m_tileGeometryLoader.allGeometryLoaded || this.m_tileGeometryLoader.isFinished;\n    }\n\n    /**\n     * MapView checks if this `Tile` is ready to be rendered while culling.\n     *\n     * By default, MapView checks if the [[objects]] list is not empty. However, you can override\n     * this check by manually setting this property.\n     */\n    get hasGeometry(): boolean {\n        if (this.m_forceHasGeometry === undefined) {\n            return this.objects.length !== 0;\n        } else {\n            return this.m_forceHasGeometry;\n        }\n    }\n\n    /**\n     * Overrides the default value for [[hasGeometry]] if value is not `undefined`.\n     *\n     * @param value A new value for the [[hasGeometry]] flag.\n     */\n    forceHasGeometry(value: boolean | undefined) {\n        this.m_forceHasGeometry = value;\n    }\n\n    /**\n     * Reset the visibility counter. This will force the visibility check to be rerun on all objects\n     * in this `Tile`.\n     */\n    resetVisibilityCounter(): void {\n        this.visibilityCounter = -1;\n    }\n\n    /**\n     * Gets the [[ITileLoader]] that manages this tile.\n     */\n    get tileLoader(): ITileLoader | undefined {\n        return this.m_tileLoader;\n    }\n\n    /**\n     * Sets the [[ITileLoader]] to manage this tile.\n     *\n     * @param tileLoader A [[ITileLoader]] instance to manage the loading process for this tile.\n     */\n    set tileLoader(tileLoader: ITileLoader | undefined) {\n        this.m_tileLoader = tileLoader;\n    }\n\n    /**\n     * Loads this `Tile` geometry.\n     */\n    load() {\n        const tileLoader = this.tileLoader;\n        if (tileLoader === undefined) {\n            return;\n        }\n\n        tileLoader\n            .loadAndDecode()\n            .then(tileLoaderState => {\n                assert(tileLoaderState === TileLoaderState.Ready);\n                const decodedTile = tileLoader.decodedTile;\n                this.decodedTile = decodedTile;\n            })\n            .catch(tileLoaderState => {\n                if (\n                    tileLoaderState !== TileLoaderState.Canceled &&\n                    tileLoaderState !== TileLoaderState.Failed\n                ) {\n                    logger.error(\"Unknown error\" + tileLoaderState);\n                }\n            });\n    }\n\n    /**\n     * Handler for animation of `Tile` geometries.\n     */\n    get animatedExtrusionTileHandler(): AnimatedExtrusionTileHandler | undefined {\n        return this.m_animatedExtrusionTileHandler;\n    }\n\n    set animatedExtrusionTileHandler(handler: AnimatedExtrusionTileHandler | undefined) {\n        this.m_animatedExtrusionTileHandler = handler;\n    }\n\n    get allTextElementsOverlaid(): boolean {\n        return (\n            this.allGeometryLoaded &&\n            this.nextTextElementToOverlay.groupIndex >= this.m_textElementGroups.groups.size\n        );\n    }\n\n    get nextTextElementToOverlay(): TextElementIndex {\n        return this.m_nextTextElementToOverlay;\n    }\n\n    set nextTextElementToOverlay(index: TextElementIndex) {\n        this.m_nextTextElementToOverlay = index;\n    }\n\n    /**\n     * Frees the rendering resources allocated by this `Tile`.\n     *\n     * The default implementation of this method frees the geometries and the materials for all the\n     * reachable objects.\n     * Textures are freed if they are owned by this `Tile` (i.e. if they where created by this\n     * `Tile`or if the ownership was explicitely set to this `Tile` by [[addOwnedTexture]]).\n     */\n    clear() {\n        const disposeMaterial = (material: THREE.Material) => {\n            Object.getOwnPropertyNames(material).forEach((property: string) => {\n                const materialProperty = (material as any)[property];\n                if (materialProperty !== undefined && materialProperty instanceof THREE.Texture) {\n                    const texture = materialProperty;\n                    if (this.shouldDisposeTexture(texture)) {\n                        texture.dispose();\n                    }\n                }\n            });\n            material.dispose();\n        };\n\n        const disposeObject = (object: TileObject & DisposableObject) => {\n            if (object.geometry !== undefined && this.shouldDisposeObjectGeometry(object)) {\n                object.geometry.dispose();\n            }\n\n            if (object.material !== undefined && this.shouldDisposeObjectMaterial(object)) {\n                if (object.material instanceof Array) {\n                    object.material.forEach((material: THREE.Material | undefined) => {\n                        if (material !== undefined) {\n                            disposeMaterial(material);\n                        }\n                    });\n                } else {\n                    disposeMaterial(object.material);\n                }\n            }\n        };\n\n        this.objects.forEach((rootObject: TileObject & DisposableObject) => {\n            rootObject.traverse((object: TileObject & DisposableObject) => {\n                disposeObject(object);\n            });\n\n            disposeObject(rootObject);\n        });\n        this.objects.length = 0;\n\n        if (this.preparedTextPaths) {\n            this.preparedTextPaths = [];\n        }\n\n        if (this.m_animatedExtrusionTileHandler !== undefined) {\n            this.m_animatedExtrusionTileHandler.dispose();\n        }\n\n        this.clearTextElements();\n        this.invalidateResourceInfo();\n    }\n\n    /**\n     * Removes all [[TextElement]] from the tile.\n     */\n    clearTextElements() {\n        this.textElementsChanged = this.hasTextElements();\n        this.m_pathBlockingElements.splice(0);\n        this.textElementGroups.clear();\n        this.userTextElements.elements.length = 0;\n    }\n\n    /**\n     * Disposes this `Tile`, freeing all geometries and materials for the reachable objects.\n     */\n    dispose() {\n        if (this.m_disposed) {\n            return;\n        }\n        if (this.m_tileLoader) {\n            this.m_tileLoader.cancel();\n            this.m_tileLoader = undefined;\n        }\n        if (this.m_tileGeometryLoader !== undefined) {\n            this.m_tileGeometryLoader.dispose();\n            this.m_tileGeometryLoader = undefined;\n        }\n        this.clear();\n        this.userTextElements.elements.length = 0;\n        this.m_disposed = true;\n        // Ensure that tile is removable from tile cache.\n        this.frameNumLastRequested = 0;\n    }\n\n    /**\n     * Computes the offset in the x world coordinates corresponding to this tile, based on\n     * its [[offset]].\n     * @returns The x offset.\n     */\n    computeWorldOffsetX(): number {\n        return this.projection.worldExtent(0, 0).max.x * this.offset;\n    }\n\n    private computeResourceInfo(): void {\n        let heapSize = 0;\n        let num3dObjects = 0;\n        let numTextElements = 0;\n        let numUserTextElements = 0;\n\n        const aggregatedObjSize = {\n            heapSize: 0,\n            gpuSize: 0\n        };\n\n        // Keep a map of the uuids of the larger objects, like Geometries, Materials and Attributes.\n        // They should be counted only once even if they are shared.\n        const visitedObjects: Map<string, boolean> = new Map();\n\n        for (const object of this.objects) {\n            if (object.visible) {\n                num3dObjects++;\n            }\n            MapViewUtils.estimateObject3dSize(object, aggregatedObjSize, visitedObjects);\n        }\n\n        for (const group of this.textElementGroups.groups) {\n            numTextElements += group[1].elements.length;\n        }\n        numUserTextElements = this.userTextElements.elements.length;\n\n        // 216 was the shallow size of a single TextElement last time it has been checked, 312 bytes\n        // was the minimum retained size of a TextElement that was not being rendered. If a\n        // TextElement is actually rendered, the size may be _much_ bigger.\n        heapSize += (numTextElements + numUserTextElements) * 312;\n\n        if (this.m_decodedTile !== undefined && this.m_decodedTile.tileInfo !== undefined) {\n            aggregatedObjSize.heapSize += this.m_decodedTile.tileInfo.numBytes;\n        }\n\n        if (this.roadIntersectionData !== undefined) {\n            heapSize += getRoadIntersectionDataSize(this.roadIntersectionData);\n        }\n\n        this.m_resourceInfo = {\n            heapSize: aggregatedObjSize.heapSize + heapSize,\n            gpuSize: aggregatedObjSize.gpuSize,\n            num3dObjects,\n            numTextElements,\n            numUserTextElements\n        };\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { IChannel } from \"./IChannel\";\n\n/**\n * Enum log levels\n */\nexport enum LogLevel {\n    Trace,\n    Debug,\n    Log,\n    Info,\n    Warn,\n    Error\n}\n\n/**\n * Logger options to configure logger\n */\nexport class LoggerOptions {\n    enabled?: boolean;\n    level?: LogLevel;\n}\n\n/**\n * Public interface for Logger class.\n */\nexport interface ILogger extends IChannel {\n    readonly name: string;\n\n    enabled: boolean;\n\n    level: LogLevel;\n\n    /**\n     * Update logger options\n     *\n     * @param  {LoggerOptions} options Set logger options and configure internal logger.\n     */\n    update(options: LoggerOptions): void;\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Resolve URI of referenced object w.r.t parent URI.\n *\n * Resolves `childUri` as it would be loaded from location specified by `parentUri`.\n *\n * If `childUri` is absolute, then it is returned unchanged.\n * If `childUri` is origin-absolute path, then only origin path is taken from `parentUri`.\n *\n * See [[baseUri]] for reference how base URL of `parentUri` is determined.\n *\n * Examples:\n *\n *     // normal case, child is sibling\n *     https://foo.com/themes/day.json + images/foo.png -> https://foo.com/themes/images/foo.png\n *\n *     // parent is \"folder\", so child is just located in this folder\n *     https://foo.com/themes/ + images/foo.png -> https://foo.com/themes/images/foo.png\n *\n *     // parent looks like leaf, so last component is stripped\n *     https://foo.com/themes + images/foo.png -> https://foo.com/images/foo.png\n *\n *     // origin-absolute URL, takes only origin from parent\n *     https://foo.com/themes/day.json + /fonts/foo.json -> https://foo.com/fonts/foo.json\n *\n * @param parentUri URI of parent resource\n * @param childUri URI of child as referenced from parent resource\n * @return `childUrl` as if anchored in location of `parentUrl`\n */\nexport function resolveReferenceUri(parentUri: string | undefined, childUri: string): string {\n    if (absoluteUrlWithOriginRe.test(childUri)) {\n        return childUri;\n    } else if (childUri.startsWith(\"/\")) {\n        const origin = getUrlOrigin(parentUri);\n        return origin + childUri;\n    } else {\n        if (childUri.startsWith(\"./\")) {\n            childUri = childUri.substr(2);\n        }\n        const parentBaseUrl = baseUrl(parentUri);\n        return parentBaseUrl + childUri;\n    }\n}\n\nconst absoluteUrlWithOriginRe = new RegExp(\"^(?:[a-z]+:)?//\", \"i\");\n\n/**\n * Returns base URL of given resource URL.\n *\n * `Url` with trailing slash are considered genuine 'locations', they are returned as is, however if\n * `url` ends with name component it is treated as \"leaf\", so last path component is removed.\n *\n * Standalone files (without any folder structure) are considered relative to `./`.\n *\n * Examples:\n * ```\n *     https://foo.com/themes/a.json -> https://foo.com/themes/\n *     https://foo.com/themes/ -> https://foo.com/themes/\n *     https://foo.com/themes -> https://foo.com/ // note, themes is treated as leaf\n *     themes/day.json -> themes/\n *     themes -> ./\n * ```\n */\nexport function baseUrl(url: string | undefined) {\n    if (url === undefined) {\n        return \"./\";\n    }\n    let idx = url.indexOf(\"#\");\n    if (idx !== -1) {\n        url = url.slice(0, idx);\n    }\n    idx = url.indexOf(\"?\");\n    if (idx !== -1) {\n        url = url.slice(0, idx);\n    }\n    idx = url.lastIndexOf(\"/\");\n    if (idx === -1) {\n        return \"./\";\n    } else {\n        return url.substring(0, idx + 1);\n    }\n}\n\n/**\n * Get `origin` part of URL.\n *\n * @example\n *    https://example.com/foo -> https://example.com\n *    //example.com:8080/ -> //example.com:8080\n *    file:///etc/hosts ->\n *\n * @param url input URL\n * @return origin of given URL\n */\nexport function getUrlOrigin(url: string | undefined): string {\n    if (url === undefined) {\n        return \"\";\n    }\n    const parsed = getUrlHostAndProtocol(url);\n    if (parsed.protocol === \"file:\") {\n        return \"file://\";\n    } else if (parsed.host && parsed.protocol) {\n        return parsed.protocol + \"//\" + parsed.host;\n    } else if (parsed.host) {\n        return \"//\" + parsed.host;\n    } else if (parsed.protocol) {\n        return parsed.protocol + \"//\";\n    } else {\n        return \"\";\n    }\n}\n\n/**\n * Parse `host` and `protocol` part from URL.\n */\nexport function getUrlHostAndProtocol(\n    url: string\n): {\n    protocol: string;\n    host: string;\n} {\n    const urlOriginRe = new RegExp(/^(?:([a-z]+:))?\\/\\/([^\\/]*)/, \"i\");\n\n    const match = url.match(urlOriginRe);\n    if (!match) {\n        throw new Error(`getUrlHostAndProtocol: unable to parse URL '${url}'`);\n    }\n    return {\n        protocol: match[1],\n        host: match[2]\n    };\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { TileKey } from \"@here/harp-geoutils\";\nimport { ExtrusionFeature } from \"@here/harp-materials\";\nimport { MathUtils } from \"@here/harp-utils\";\nimport { MapView, MapViewEventNames, RenderEvent } from \"./MapView\";\nimport { Tile } from \"./Tile\";\n\nimport * as THREE from \"three\";\n\n/**\n * Animation states for extrusion effect\n */\nexport enum AnimatedExtrusionState {\n    None,\n    Started,\n    Playing,\n    Finished\n}\n\n/**\n * Handles animated extrusion effect of the buildings in [[MapView]].\n */\nexport class AnimatedExtrusionHandler {\n    /**\n     * Animate the extrusion of the buildings if set to `true`.\n     */\n    enabled: boolean = true;\n    /**\n     * Duration of the building's extrusion in milliseconds\n     */\n    duration: number = 750;\n    /**\n     * If `forceEnabled` is set to `true` then `animateExtrusion` and `animateExtrusionDuration`\n     * values from [[extrudedPolygonTechnique]] will be ignored in [[Tile]] and\n     * `AnimatedExtrusionHandler.enabled` with `AnimatedExtrusionHandler.duration` will be used\n     */\n    forceEnabled: boolean = false;\n\n    private m_zoomLevelPrevious: number;\n    private m_tileHandlerMap: Map<Tile, AnimatedExtrusionTileHandler> = new Map();\n    private m_zoomDirection: number = 0;\n    private m_forceAnimatedExtrusion: boolean | undefined;\n    private m_forceAnimatedExtrusionDuration: number | undefined;\n\n    /**\n     * Creates an [[AnimatedExtrusionHandler]] in [[MapView]].\n     *\n     * @param m_mapView Instance of [[MapView]] that passes `zoomLevel`\n     * through the `zoom` property update\n     */\n    constructor(private m_mapView: MapView) {\n        this.m_zoomLevelPrevious = this.m_mapView.zoomLevel;\n    }\n\n    /**\n     * Returns direction of the last zoom event.\n     * Zoom in - positive value, zoom out - negative value\n     */\n    get zoomDirection(): number {\n        return this.m_zoomDirection;\n    }\n\n    /**\n     * [[MapView]] updates zoom level. Then [[AnimatedExtrusionTileHandler]] calculates actual\n     * extrusion ratio and trigger animation\n     */\n    set zoom(zoomLevel: number) {\n        // if zoomLevel has been changed since last render\n        if (this.m_zoomLevelPrevious !== zoomLevel) {\n            this.m_tileHandlerMap.forEach(tileHandler => {\n                if (\n                    this.m_mapView.getDataSourceByName(tileHandler.tile.dataSource.name) !==\n                    undefined\n                ) {\n                    this.m_zoomDirection = zoomLevel > this.m_zoomLevelPrevious ? 1 : -1;\n                    tileHandler.zoomLevelChanged(this.m_zoomDirection);\n                }\n            });\n            this.m_zoomLevelPrevious = zoomLevel;\n        }\n    }\n\n    /**\n     * Checks whether animated extrusion effect was forcibly turned off/on in [[MapView]]\n     */\n    get forceAnimatedExtrusion(): boolean | undefined {\n        return this.m_forceAnimatedExtrusion;\n    }\n\n    /**\n     * If set to `true` it will force the animation extrusion effect to run.\n     * In case it was set to `false` animation extrusion effect will be switched off.\n     */\n    set forceAnimatedExtrusion(animatedExtrusion: boolean | undefined) {\n        this.m_forceAnimatedExtrusion = animatedExtrusion;\n    }\n\n    /**\n     * Returns `animatedExtrusionDuration` value that was set in [[MapView]].\n     */\n    get forceAnimatedExtrusionDuration(): number | undefined {\n        return this.m_forceAnimatedExtrusionDuration;\n    }\n\n    /**\n     * If value is set, it will overlap in [[Tile]] with\n     * `animatedExtrusionDuration` property from [[ExtrudedPolygonTechnique]]\n     * and `DEFAULT_DURATION` from [[AnimatedExtrusionTileHandler]].\n     */\n    set forceAnimatedExtrusionDuration(extrusionDuration: number | undefined) {\n        this.m_forceAnimatedExtrusionDuration = extrusionDuration;\n    }\n\n    /**\n     * Adds an [[AnimatedExtrusionTileHandler]] to [[AnimatedExtrusionHandler]]\n     */\n    add(tileHandler: AnimatedExtrusionTileHandler): void {\n        this.m_tileHandlerMap.set(tileHandler.tile, tileHandler);\n    }\n\n    /**\n     * Removes tile from the list subscribed for extrusion ratio updates\n     */\n    removeTile(tile: Tile): void {\n        this.m_tileHandlerMap.delete(tile);\n    }\n\n    /**\n     * Returns first [[AnimatedExtrusionTileHandler]] existed from the list of [[Tile]]s\n     */\n    find(tileKeys: Array<TileKey | undefined>): AnimatedExtrusionTileHandler | undefined {\n        for (const tileHandler of this.m_tileHandlerMap) {\n            for (const tileKey of tileKeys) {\n                if (\n                    tileKey !== undefined &&\n                    tileHandler[0].tileKey.mortonCode() === tileKey.mortonCode()\n                ) {\n                    return tileHandler[1];\n                }\n            }\n        }\n        return undefined;\n    }\n\n    /**\n     * Is `true` if any extrusion handlers are currently animating.\n     */\n    get isAnimating(): boolean {\n        for (const tileHandler of this.m_tileHandlerMap) {\n            if (tileHandler[1].isAnimating) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n/**\n * Implements animated extrusion effect for the extruded objects in the [[Tile]]\n */\nexport class AnimatedExtrusionTileHandler {\n    private m_extrudedObjects: THREE.Object3D[] = [];\n    private m_animatedExtrusionRatio: number = ExtrusionFeature.DEFAULT_RATIO_MAX;\n    private m_animatedExtrusionState: AnimatedExtrusionState = AnimatedExtrusionState.None;\n    private m_animatedExtrusionStartTime: number | undefined = undefined;\n    private m_mapView: MapView;\n    private m_animatedExtrusionHandler: AnimatedExtrusionHandler;\n\n    constructor(\n        private m_tile: Tile,\n        extrudedObjects: Array<{ object: THREE.Object3D; materialFeature: boolean }>,\n        private m_animatedExtrusionDuration: number\n    ) {\n        this.m_mapView = m_tile.mapView;\n        this.m_animatedExtrusionHandler = this.m_mapView.animatedExtrusionHandler;\n\n        extrudedObjects.forEach(extrudedObject => {\n            if (extrudedObject.materialFeature) {\n                ExtrusionFeature.addRenderHelper(extrudedObject.object);\n            }\n            this.m_extrudedObjects.push(extrudedObject.object);\n        });\n\n        this.startExtrusionAnimationIfNeeded(this.m_animatedExtrusionHandler.zoomDirection);\n    }\n\n    /**\n     * Set an extrusion ratio value for the materials [[MapMeshBasicMaterial]]\n     * and [[EdgeMaterial]]. Controlled by [[AnimatedExtrusionHandler]]\n     * for extrusion animation effect.\n     */\n    set extrusionRatio(value: number) {\n        this.m_animatedExtrusionRatio = value;\n\n        this.m_extrudedObjects.forEach(object => {\n            const material = (object as THREE.Mesh | THREE.LineSegments)\n                .material as ExtrusionFeature;\n            material.extrusionRatio = this.m_animatedExtrusionRatio;\n        });\n    }\n\n    /**\n     * Returns the [[Tile]] related to [[AnimatedExtrusionTileHandler]]\n     */\n    get tile(): Tile {\n        return this.m_tile;\n    }\n\n    /**\n     * Return the current state of animated extrusion effect\n     */\n    get animationState(): AnimatedExtrusionState {\n        return this.m_animatedExtrusionState;\n    }\n\n    /**\n     * Is `true` if this handler is currently animating.\n     */\n    get isAnimating(): boolean {\n        return this.m_animatedExtrusionState !== AnimatedExtrusionState.Finished;\n    }\n\n    /**\n     * Cancel animation and remove from [[AnimatedExtrusionHandler]]\n     */\n    dispose() {\n        this.stopExtrusionAnimation();\n        this.m_animatedExtrusionHandler.removeTile(this.m_tile);\n    }\n\n    /**\n     * Start / Stop extrusion animation if zoom level was changed\n     */\n    zoomLevelChanged(zoomDirection: number) {\n        if (\n            this.m_tile.isVisible === false &&\n            this.m_animatedExtrusionState !== AnimatedExtrusionState.None\n        ) {\n            this.m_animatedExtrusionState = AnimatedExtrusionState.None;\n            this.stopExtrusionAnimation();\n        }\n\n        if (\n            this.m_tile.isVisible === true &&\n            this.m_animatedExtrusionState === AnimatedExtrusionState.None\n        ) {\n            this.startExtrusionAnimationIfNeeded(zoomDirection);\n        }\n    }\n\n    private getChildTiles(tileKeys: TileKey[]) {\n        const result: TileKey[] = [];\n\n        tileKeys.forEach(tileKey => {\n            const childTileKeys = this.tile.dataSource.getTilingScheme().getSubTileKeys(tileKey);\n\n            for (const childTileKey of childTileKeys) {\n                result.push(childTileKey);\n            }\n        });\n        return result;\n    }\n\n    // search for the [[Tile]] with extrusion animation started\n    private startExtrusionAnimationIfNeeded(zoomDirection?: number) {\n        const {\n            quadTreeSearchDistanceUp,\n            quadTreeSearchDistanceDown\n        } = this.tile.mapView.visibleTileSet.options;\n        const tile = this.m_tile;\n        let extrusionStartTime: number | undefined;\n\n        if (zoomDirection !== undefined) {\n            let tileHandler;\n\n            // if zoom out, go down and look for a child tile\n            if (zoomDirection < 0) {\n                let nextLevelDiff = 0;\n                let tileKeys = [tile.tileKey];\n                while (\n                    quadTreeSearchDistanceDown > nextLevelDiff &&\n                    extrusionStartTime === undefined\n                ) {\n                    const childTileKeys = this.getChildTiles(tileKeys);\n                    if (childTileKeys !== undefined) {\n                        tileHandler = this.m_animatedExtrusionHandler.find(childTileKeys);\n                        if (tileHandler !== undefined) {\n                            extrusionStartTime = tileHandler.m_animatedExtrusionStartTime;\n                            break;\n                        }\n                        tileKeys = childTileKeys;\n                    }\n                    nextLevelDiff++;\n                }\n            }\n            // if zoom in, go up and get the parent tile\n            if (zoomDirection > 0) {\n                let nextLevelDiff = 0;\n                let tileKey = tile.tileKey;\n                while (\n                    quadTreeSearchDistanceUp > nextLevelDiff &&\n                    extrusionStartTime === undefined &&\n                    tileKey.level !== 0\n                ) {\n                    const parentTileKey = tileKey.parent();\n                    tileHandler = this.m_animatedExtrusionHandler.find([parentTileKey]);\n                    if (tileHandler !== undefined) {\n                        extrusionStartTime = tileHandler.m_animatedExtrusionStartTime;\n                        break;\n                    }\n                    tileKey = parentTileKey;\n                    nextLevelDiff++;\n                }\n            }\n        }\n        this.startExtrusionAnimation(extrusionStartTime);\n    }\n\n    private startExtrusionAnimation(startTime?: number): void {\n        this.m_animatedExtrusionState = AnimatedExtrusionState.Started;\n        this.m_animatedExtrusionStartTime = startTime;\n        this.animateExtrusion();\n        this.m_mapView.addEventListener(MapViewEventNames.AfterRender, this.animateExtrusion);\n    }\n\n    private stopExtrusionAnimation(): void {\n        this.m_mapView.removeEventListener(MapViewEventNames.AfterRender, this.animateExtrusion);\n    }\n\n    private animateExtrusion = (event?: RenderEvent) => {\n        if (this.m_animatedExtrusionState !== AnimatedExtrusionState.Playing) {\n            if (this.m_animatedExtrusionState === AnimatedExtrusionState.Started) {\n                this.m_animatedExtrusionState = AnimatedExtrusionState.Playing;\n            } else {\n                return;\n            }\n        }\n\n        const currentTime = Date.now();\n        if (\n            this.m_animatedExtrusionStartTime === undefined ||\n            this.m_animatedExtrusionStartTime <= 0\n        ) {\n            this.m_animatedExtrusionStartTime = currentTime;\n        }\n\n        const timeProgress = Math.min(\n            currentTime - this.m_animatedExtrusionStartTime,\n            this.m_animatedExtrusionDuration\n        );\n\n        this.extrusionRatio = MathUtils.easeInOutCubic(\n            ExtrusionFeature.DEFAULT_RATIO_MIN,\n            ExtrusionFeature.DEFAULT_RATIO_MAX,\n            timeProgress / this.m_animatedExtrusionDuration\n        );\n\n        if (timeProgress >= this.m_animatedExtrusionDuration) {\n            this.m_animatedExtrusionState = AnimatedExtrusionState.Finished;\n            this.stopExtrusionAnimation();\n        }\n\n        this.m_tile.dataSource.requestUpdate();\n    };\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ViewRanges } from \"@here/harp-datasource-protocol/lib/ViewRanges\";\nimport { applyMixinsWithoutProperties, chainCallbacks } from \"@here/harp-utils\";\nimport { insertShaderInclude } from \"./Utils\";\n\nimport * as THREE from \"three\";\n\nimport extrusionShaderChunk from \"./ShaderChunks/ExtrusionChunks\";\nimport fadingShaderChunk from \"./ShaderChunks/FadingChunks\";\n\n/**\n * The MapMeshMaterials [[MapMeshBasicMaterial]] and [[MapMeshStandardMaterial]] are the standard\n * [[THREE.MeshBasicMaterial]] and [[THREE.MeshStandardMaterial]], with the addition functionality\n * of fading out the geometry between a fadeNear and fadeFar value.\n *\n * The implementation is designed around a mixin class [[FadingFeatureMixin]], which requires\n * a bit of care when adding the FadingFeature to the existing mesh classes, but it is safe to use\n * and also reduces code duplication.\n */\n\n/**\n * Parameters used when constructing a new implementor of [[FadingFeature]].\n */\nexport interface FadingFeatureParameters {\n    /**\n     * Distance to the camera (range: `[0.0, 1.0]`) from which the objects start fading out.\n     */\n    fadeNear?: number;\n\n    /**\n     * Distance to the camera (range: `[0.0, 1.0]`) from which the objects are transparent.\n     */\n    fadeFar?: number;\n}\n\n/**\n * Parameters used when constructing a new implementor of [[ExtrusionFeature]].\n */\nexport interface ExtrusionFeatureParameters {\n    /**\n     * Ratio of the extruded objects, where `1.0` is the default value\n     */\n    extrusionRatio?: number;\n}\n\n/**\n * Parameters used when constructing a new implementor of [[DisplacementFeature]].\n */\nexport interface DisplacementFeatureParameters {\n    /**\n     * Texture used for vertex displacement along their normals.\n     */\n    displacementMap?: THREE.Texture;\n}\n\n/**\n * Used internally.\n *\n * @hidden\n */\ninterface UnifomType {\n    value: any;\n}\n\n/**\n * Used internally.\n *\n * @hidden\n */\ninterface UniformsType {\n    [index: string]: UnifomType;\n}\n\n/**\n * Translates a linear distance value [0..1], where 1 is the distance to the far plane, into\n * [0..maxVisibilityRange].\n *\n * Copy from MapViewUtils, since it cannot be accessed here because of circular dependencies.\n *\n * @param distance Distance from the camera (range: [0, 1]).\n * @param visibilityRange object describiing maximum and minimum visibility range - distances\n * from camera at which objects won't be rendered anymore.\n */\nfunction cameraToWorldDistance(distance: number, visibilityRange: ViewRanges): number {\n    return distance * visibilityRange.maximum;\n}\n\n/**\n * Material properties used from THREE, which may not be defined in the type.\n */\nexport interface HiddenThreeJSMaterialProperties {\n    needsUpdate?: boolean;\n\n    /**\n     * Used internally for material shader defines.\n     */\n    defines?: any;\n\n    /**\n     * Hidden ThreeJS value that is made public here. Required to add new uniforms to subclasses of\n     * [[THREE.MeshBasicMaterial]]/[[THREE.MeshStandardMaterial]], basically all materials that are\n     * not THREE.ShaderMaterial.\n     */\n    uniformsNeedUpdate?: boolean;\n\n    /**\n     * Available in all materials in ThreeJS.\n     */\n    transparent?: boolean;\n}\n\n/**\n * Base interface for all objects that should fade in the distance. The implemntation of the actual\n * FadingFeature is done with the help of the mixon class [[FadingFeatureMixin]] and a set of\n * supporting functions in the namespace of the same name.\n */\nexport interface FadingFeature extends HiddenThreeJSMaterialProperties {\n    /**\n     * Distance to the camera (range: `[0.0, 1.0]`) from which the objects start fading out.\n     */\n    fadeNear?: number;\n\n    /**\n     * Distance to the camera (range: `[0.0, 1.0]`) from which the objects are transparent. A value\n     * of <= 0.0 disables fading.\n     */\n    fadeFar?: number;\n}\n\n/**\n * Base interface for all objects that should have animated extrusion effect. The implemntation of\n * the actual ExtrusionFeature is done with the help of the mixin class [[ExtrusionFeatureMixin]]\n * and a set of supporting functions in the namespace of the same name.\n */\nexport interface ExtrusionFeature extends HiddenThreeJSMaterialProperties {\n    /**\n     * Ratio of the extruded objects, where `1.0` is the default value. Minimum suggested value\n     * is `0.01`\n     */\n    extrusionRatio?: number;\n}\n\nexport type DisplacementFeature = HiddenThreeJSMaterialProperties & DisplacementFeatureParameters;\n\nexport namespace DisplacementFeature {\n    /**\n     * Update the internals of the `DisplacementFeature` depending on the value of\n     * [[displacementMap]].\n     *\n     * @param displacementMaterial DisplacementFeature\n     */\n    export function updateDisplacementFeature(displacementMaterial: DisplacementFeature): void {\n        displacementMaterial.needsUpdate = true;\n\n        if (displacementMaterial.defines === undefined) {\n            displacementMaterial.defines = {};\n        }\n\n        if (displacementMaterial.displacementMap !== undefined) {\n            displacementMaterial.displacementMap.needsUpdate = true;\n            // Add this define to differentiate it internally from other MeshBasicMaterial\n            displacementMaterial.defines.USE_DISPLACEMENTMAP = \"\";\n        }\n    }\n\n    /**\n     * This function should be called on implementors of DisplacementFeature in the\n     * `onBeforeCompile` callback of that material. It adds the required code to the shaders to\n     * apply displacement maps.\n     *\n     * @param displacementMaterial Material to add uniforms to.\n     * @param shader [[THREE.WebGLShader]] containing the vertex and fragment shaders to add the\n     *                  special includes to.\n     */\n    export function onBeforeCompile(displacementMaterial: DisplacementFeature, shader: any) {\n        if (displacementMaterial.displacementMap === undefined) {\n            return;\n        }\n        // The vertex and fragment shaders have been constructed dynamically. The uniforms and\n        // the shader includes are now appended to them.\n        //\n        // The object \"defines\" are not available for this material, so the fading shader chunks\n        // have the #ifdefs commented out.\n\n        // Create the uniforms for the shader (if not already existing), and add the new uniforms\n        // to it:\n        const uniforms = shader.uniforms as UniformsType;\n        uniforms.displacementMap = { value: displacementMaterial.displacementMap };\n        uniforms.displacementScale = { value: 1 };\n        uniforms.displacementBias = { value: 0 };\n\n        // Append the displacement map chunk to the vertex shader.\n        shader.vertexShader = shader.vertexShader.replace(\n            \"#include <skinbase_vertex>\",\n            `#include <skinbase_vertex>\n#ifndef USE_ENVMAP\n    vec3 objectNormal = vec3( normal );\n#endif`\n        );\n        shader.vertexShader = insertShaderInclude(\n            shader.vertexShader,\n            \"uv2_pars_vertex\",\n            \"displacementmap_pars_vertex\"\n        );\n\n        shader.vertexShader = insertShaderInclude(\n            shader.vertexShader,\n            \"skinning_vertex\",\n            \"displacementmap_vertex\",\n            true\n        );\n    }\n}\n\nexport class DisplacementFeatureMixin implements DisplacementFeature {\n    needsUpdate?: boolean;\n    uniformsNeedUpdate?: boolean;\n    private m_displacementMap?: THREE.Texture;\n\n    protected getDisplacementMap(): THREE.Texture | undefined {\n        return this.m_displacementMap;\n    }\n\n    protected setDisplacementMap(map: THREE.Texture | undefined) {\n        this.needsUpdate = this.needsUpdate || map !== this.m_displacementMap;\n        this.m_displacementMap = map;\n        if (this.needsUpdate) {\n            DisplacementFeature.updateDisplacementFeature(this);\n        }\n    }\n\n    /**\n     * The mixin class should call this method to register the property [[displacementMap]]\n     */\n    protected addDisplacementProperties(): void {\n        Object.defineProperty(this, \"displacementMap\", {\n            get: () => {\n                return this.getDisplacementMap();\n            },\n            set: val => {\n                this.setDisplacementMap(val);\n            }\n        });\n    }\n\n    /**\n     * Apply the displacementMap value from the parameters to the respective properties.\n     */\n    protected applyDisplacementParameters(params?: DisplacementFeatureParameters) {\n        // Apply initial parameter values.\n        if (params !== undefined) {\n            if (params.displacementMap !== undefined) {\n                this.setDisplacementMap(params.displacementMap);\n            }\n        }\n\n        (this as any).onBeforeCompile = (shader: any) => {\n            DisplacementFeature.onBeforeCompile(this, shader);\n        };\n    }\n\n    /**\n     * Copy displacementMap from other DisplacementFeature.\n     *\n     * @param source The material to copy property values from.\n     */\n    protected copyDisplacementParameters(source: DisplacementFeature) {\n        this.setDisplacementMap(source.displacementMap);\n        return this;\n    }\n}\n\n/**\n * Namespace with support functions for implementors of `FadingFeature`.\n */\nexport namespace FadingFeature {\n    export const DEFAULT_FADE_NEAR: number = -1.0;\n    export const DEFAULT_FADE_FAR: number = -1.0;\n\n    /**\n     * Patch the THREE.ShaderChunk on first call with some extra shader chunks.\n     */\n    export function patchGlobalShaderChunks() {\n        if (THREE.ShaderChunk.fading_pars_vertex === undefined) {\n            Object.assign(THREE.ShaderChunk, fadingShaderChunk);\n        }\n    }\n\n    /**\n     * Update the internals of the `FadingFeature` depending on the value of [[fadeNear]]. The\n     * fading feature will be disabled if fadeFar <= 0.0.\n     *\n     * @param fadingMaterial FadingFeature\n     */\n    export function updateDistanceFadeFeature(fadingMaterial: FadingFeature): void {\n        fadingMaterial.needsUpdate = true;\n\n        if (fadingMaterial.defines === undefined) {\n            fadingMaterial.defines = {};\n        }\n\n        if (fadingMaterial.fadeFar !== undefined && fadingMaterial.fadeFar > 0.0) {\n            // Add this define to differentiate it internally from other MeshBasicMaterial\n            fadingMaterial.defines.FADING_MATERIAL = \"\";\n        }\n    }\n\n    /**\n     * This function should be called on implementors of FadingFeature in the `onBeforeCompile`\n     * callback of that material. It adds the required code to the shaders and declares the new\n     * uniforms that control fading based on view distance.\n     *\n     * @param fadingMaterial Material to add uniforms to.\n     * @param shader [[THREE.WebGLShader]] containing the vertex and fragment shaders to add the\n     *                  special includes to.\n     */\n    export function onBeforeCompile(fadingMaterial: FadingFeature, shader: any) {\n        if (fadingMaterial.fadeFar === undefined || fadingMaterial.fadeFar <= 0.0) {\n            return;\n        }\n        // The vertex and fragment shaders have been constructed dynamically. The uniforms and\n        // the shader includes are now appended to them.\n        //\n        // The object \"defines\" are not available for this material, so the fading shader chunks\n        // have the #ifdefs commented out.\n\n        // Create the uniforms for the shader (if not already existing), and add the new uniforms\n        // to it:\n        const uniforms = shader.uniforms as UniformsType;\n        uniforms.fadeNear = { value: fadingMaterial.fadeNear };\n        uniforms.fadeFar = { value: fadingMaterial.fadeFar };\n\n        // Append the new fading shader cod directly after the fog code. This is done by adding an\n        // include directive for the fading code.\n        shader.vertexShader = insertShaderInclude(\n            shader.vertexShader,\n            \"fog_pars_vertex\",\n            \"fading_pars_vertex\"\n        );\n\n        shader.vertexShader = insertShaderInclude(\n            shader.vertexShader,\n            \"fog_vertex\",\n            \"fading_vertex\",\n            true\n        );\n\n        shader.fragmentShader = insertShaderInclude(\n            shader.fragmentShader,\n            \"fog_pars_fragment\",\n            \"fading_pars_fragment\"\n        );\n\n        shader.fragmentShader = insertShaderInclude(\n            shader.fragmentShader,\n            \"fog_fragment\",\n            \"fading_fragment\",\n            true\n        );\n    }\n\n    /**\n     * As threejs is rendering the transparent objects last (internally), regardless of their\n     * renderOrder value, we set the transparent value to false in the [[onAfterRenderCall]]. In\n     * [[onBeforeRender]], the function [[calculateDepthFromCameraDistance]] sets it to true if the\n     * fade distance value is less than 1.\n     *\n     * @param object [[THREE.Object3D]] to prepare for rendering.\n     * @param viewRanges The visibility ranges (clip planes and maxiumum visible distance) for\n     * actual camera setup.\n     * @param fadeNear The fadeNear value to set in the material.\n     * @param fadeFar The fadeFar value to set in the material.\n     * @param updateUniforms If `true`, the fading uniforms are set. Not rquired if material is\n     *          handling the uniforms already, like in a [[THREE.ShaderMaterial]].\n     * @param additionalCallback If defined, this function will be called before the function will\n     *          return.\n     */\n    export function addRenderHelper(\n        object: THREE.Object3D,\n        viewRanges: ViewRanges,\n        fadeNear: number | undefined,\n        fadeFar: number | undefined,\n        updateUniforms: boolean,\n        additionalCallback?: (\n            renderer: THREE.WebGLRenderer,\n            material: THREE.Material & FadingFeature\n        ) => void\n    ) {\n        // tslint:disable-next-line:no-unused-variable\n        object.onBeforeRender = chainCallbacks(\n            object.onBeforeRender,\n            (\n                renderer: THREE.WebGLRenderer,\n                scene: THREE.Scene,\n                camera: THREE.Camera,\n                geometry: THREE.Geometry | THREE.BufferGeometry,\n                material: THREE.Material & FadingFeature,\n                group: THREE.Group\n            ) => {\n                const fadingMaterial = material as FadingFeature;\n\n                fadingMaterial.fadeNear =\n                    fadeNear === undefined\n                        ? FadingFeature.DEFAULT_FADE_NEAR\n                        : cameraToWorldDistance(fadeNear, viewRanges);\n\n                fadingMaterial.fadeFar =\n                    fadeFar === undefined\n                        ? FadingFeature.DEFAULT_FADE_FAR\n                        : cameraToWorldDistance(fadeFar, viewRanges);\n\n                if (updateUniforms) {\n                    const properties = renderer.properties.get(material);\n\n                    if (\n                        properties.shader !== undefined &&\n                        properties.shader.uniforms.fadeNear !== undefined\n                    ) {\n                        properties.shader.uniforms.fadeNear.value = fadingMaterial.fadeNear;\n                        properties.shader.uniforms.fadeFar.value = fadingMaterial.fadeFar;\n                        fadingMaterial.uniformsNeedUpdate = true;\n                    }\n                }\n\n                if (additionalCallback !== undefined) {\n                    additionalCallback(renderer, material);\n                }\n            }\n        );\n    }\n}\n\n/**\n * Mixin class for extended THREE materials. Adds new properties required for `fadeNear` and\n * `fadeFar`. Thre is some special handling for the fadeNear/fadeFar properties, which get some\n * setters and getters in a way that works well with the mixin.\n *\n * @see [[Tile#addRenderHelper]]\n */\nexport class FadingFeatureMixin implements FadingFeature {\n    needsUpdate?: boolean;\n    uniformsNeedUpdate?: boolean;\n    private m_fadeNear: number = FadingFeature.DEFAULT_FADE_NEAR;\n    private m_fadeFar: number = FadingFeature.DEFAULT_FADE_FAR;\n\n    /**\n     * @see [[FadingFeature#fadeNear]]\n     */\n    protected getFadeNear(): number {\n        return this.m_fadeNear;\n    }\n    /**\n     * @see [[FadingFeature#fadeNear]]\n     */\n    protected setFadeNear(value: number) {\n        this.needsUpdate = this.needsUpdate || value !== this.m_fadeNear;\n        this.m_fadeNear = value;\n        if (this.needsUpdate) {\n            FadingFeature.updateDistanceFadeFeature(this);\n        }\n    }\n\n    /**\n     * @see [[FadingFeature#fadeFar]]\n     */\n    protected getFadeFar(): number {\n        return this.m_fadeFar;\n    }\n    /**\n     * @see [[FadingFeature#fadeFar]]\n     */\n    protected setFadeFar(value: number) {\n        this.needsUpdate = this.needsUpdate || value !== this.m_fadeFar;\n        this.m_fadeFar = value;\n        if (this.needsUpdate) {\n            FadingFeature.updateDistanceFadeFeature(this);\n        }\n    }\n\n    /**\n     * The mixin classes should call this method to register the properties [[fadeNear]] and\n     * [[fadeFar]].\n     */\n    protected addFadingProperties(): void {\n        Object.defineProperty(this, \"fadeNear\", {\n            get: () => {\n                return this.getFadeNear();\n            },\n            set: val => {\n                this.setFadeNear(val);\n            }\n        });\n        Object.defineProperty(this, \"fadeFar\", {\n            get: () => {\n                return this.getFadeFar();\n            },\n            set: val => {\n                this.setFadeFar(val);\n            }\n        });\n    }\n\n    /**\n     * Apply the fadeNear/fadeFar values from the parameters to the respective properties.\n     *\n     * @param params `FadingMeshBasicMaterial` parameters.\n     */\n    protected applyFadingParameters(params?: FadingFeatureParameters) {\n        // Apply initial parameter values.\n        if (params !== undefined) {\n            if (params.fadeNear !== undefined) {\n                this.setFadeNear(params.fadeNear);\n            }\n            if (params.fadeFar !== undefined) {\n                this.setFadeFar(params.fadeFar);\n            }\n        }\n\n        (this as any).onBeforeCompile = (shader: any) => {\n            FadingFeature.onBeforeCompile(this, shader);\n        };\n    }\n\n    /**\n     * Copy fadeNear/fadeFar values from other FadingFeature.\n     *\n     * @param source The material to copy property values from.\n     */\n    protected copyFadingParameters(source: FadingFeature) {\n        this.setFadeNear(\n            source.fadeNear === undefined ? FadingFeature.DEFAULT_FADE_NEAR : source.fadeNear\n        );\n        this.setFadeFar(\n            source.fadeFar === undefined ? FadingFeature.DEFAULT_FADE_FAR : source.fadeFar\n        );\n        return this;\n    }\n}\n\nexport namespace ExtrusionFeature {\n    /**\n     * Minimum ratio value for extrusion effect\n     */\n    export const DEFAULT_RATIO_MIN: number = 0.001;\n    /**\n     * Maximum ratio value for extrusion effect\n     */\n    export const DEFAULT_RATIO_MAX: number = 1;\n\n    /**\n     * Patch the THREE.ShaderChunk on first call with some extra shader chunks.\n     */\n    export function patchGlobalShaderChunks() {\n        if (THREE.ShaderChunk.extrusion_pars_vertex === undefined) {\n            Object.assign(THREE.ShaderChunk, extrusionShaderChunk);\n        }\n    }\n\n    /**\n     * Update the internals of the `ExtrusionFeature` depending on the value of [[extrusionRatio]].\n     *\n     * @param ExtrusionMaterial ExtrusionFeature\n     */\n    export function updateExtrusionFeature(extrusionMaterial: ExtrusionFeature): void {\n        extrusionMaterial.needsUpdate = true;\n\n        if (extrusionMaterial.defines === undefined) {\n            extrusionMaterial.defines = {};\n        }\n\n        if (\n            extrusionMaterial.extrusionRatio !== undefined &&\n            extrusionMaterial.extrusionRatio >= ExtrusionFeature.DEFAULT_RATIO_MIN\n        ) {\n            // Add this define to differentiate it internally from other MeshBasicMaterial\n            extrusionMaterial.defines.EXTRUSION_MATERIAL = \"\";\n        }\n    }\n\n    /**\n     * This function should be called on implementors of ExtrusionFeature in the `onBeforeCompile`\n     * callback of that material. It adds the required code to the shaders and declares the new\n     * uniforms that control extrusion.\n     *\n     * @param extrusionMaterial Material to add uniforms to.\n     * @param shader [[THREE.WebGLShader]] containing the vertex and fragment shaders to add the\n     *                  special includes to.\n     */\n    export function onBeforeCompile(extrusionMaterial: ExtrusionFeature, shader: any) {\n        if (extrusionMaterial.extrusionRatio === undefined) {\n            return;\n        }\n        // The vertex and fragment shaders have been constructed dynamically. The uniforms and\n        // the shader includes are now appended to them.\n\n        // Create the uniforms for the shader (if not already existing), and add the new uniforms\n        // to it:\n        const uniforms = shader.uniforms as UniformsType;\n        uniforms.extrusionRatio = { value: extrusionMaterial.extrusionRatio };\n\n        shader.vertexShader = insertShaderInclude(\n            shader.vertexShader,\n            \"common\",\n            \"extrusion_pars_vertex\"\n        );\n\n        shader.vertexShader = insertShaderInclude(\n            shader.vertexShader,\n            \"begin_vertex\",\n            \"extrusion_vertex\",\n            true\n        );\n\n        shader.fragmentShader = insertShaderInclude(\n            shader.fragmentShader,\n            \"fog_pars_fragment\",\n            \"extrusion_pars_fragment\"\n        );\n\n        shader.fragmentShader = shader.fragmentShader.replace(\n            \"#include <normal_fragment_begin>\",\n            \"#include <extrusion_normal_fragment_begin>\"\n        );\n\n        shader.fragmentShader = insertShaderInclude(\n            shader.fragmentShader,\n            \"fog_fragment\",\n            \"extrusion_fragment\",\n            true\n        );\n    }\n\n    /**\n     * Handles animated extrusion on each frame. Should be installed as respective\n     * Object3D.onBeforeRender of meshes which use animated extusion feature.\n     */\n    export function addRenderHelper(object: THREE.Object3D) {\n        object.onBeforeRender = chainCallbacks(\n            object.onBeforeRender,\n            ExtrusionFeature.onBeforeRender\n        );\n    }\n\n    export function onBeforeRender(\n        renderer: THREE.WebGLRenderer,\n        scene: THREE.Scene,\n        camera: THREE.Camera,\n        geometry: THREE.Geometry | THREE.BufferGeometry,\n        material: THREE.Material,\n        group: THREE.Group\n    ) {\n        const extrusionMaterial = material as ExtrusionFeature;\n        const properties = renderer.properties.get(material);\n\n        if (\n            properties.shader !== undefined &&\n            properties.shader.uniforms.extrusionRatio !== undefined\n        ) {\n            properties.shader.uniforms.extrusionRatio.value =\n                extrusionMaterial.extrusionRatio || ExtrusionFeature.DEFAULT_RATIO_MAX;\n            extrusionMaterial.uniformsNeedUpdate = true;\n        }\n    }\n}\n\n/**\n * Mixin class for extended THREE materials. Adds new properties required for `extrusionRatio`.\n * Thre is some special handling for the extrusionRatio property, which get some setters and\n * getters in a way that works well with the mixin.\n *\n * @see [[Tile#addRenderHelper]]\n */\nexport class ExtrusionFeatureMixin implements ExtrusionFeature {\n    needsUpdate?: boolean;\n    uniformsNeedUpdate?: boolean;\n    private m_extrusion: number = ExtrusionFeature.DEFAULT_RATIO_MAX;\n\n    /**\n     * @see [[ExtrusionFeature#extrusion]]\n     */\n    protected getExtrusionRatio(): number {\n        return this.m_extrusion;\n    }\n    /**\n     * @see [[ExtrusionFeature#extrusion]]\n     */\n    protected setExtrusionRatio(value: number) {\n        this.needsUpdate = this.needsUpdate || value !== this.m_extrusion;\n        this.m_extrusion = value;\n        if (this.needsUpdate) {\n            ExtrusionFeature.updateExtrusionFeature(this);\n        }\n    }\n\n    /**\n     * The mixin class should call this method to register the property [[extrusionRatio]]\n     */\n    protected addExtrusionProperties(): void {\n        Object.defineProperty(this, \"extrusionRatio\", {\n            get: () => {\n                return this.getExtrusionRatio();\n            },\n            set: val => {\n                this.setExtrusionRatio(val);\n            }\n        });\n    }\n\n    /**\n     * Apply the extrusionRatio value from the parameters to the respective properties.\n     */\n    protected applyExtrusionParameters(params?: ExtrusionFeatureParameters) {\n        // Apply initial parameter values.\n        if (params !== undefined) {\n            if (params.extrusionRatio !== undefined) {\n                this.setExtrusionRatio(params.extrusionRatio);\n            }\n        }\n\n        (this as any).onBeforeCompile = (shader: any) => {\n            ExtrusionFeature.onBeforeCompile(this, shader);\n        };\n    }\n\n    /**\n     * Copy extrusionRatio values from other ExtrusionFeature.\n     *\n     * @param source The material to copy property values from.\n     */\n    protected copyExtrusionParameters(source: ExtrusionFeature) {\n        if (source.extrusionRatio !== undefined) {\n            this.setExtrusionRatio(source.extrusionRatio);\n        }\n        return this;\n    }\n}\n\n/**\n * Subclass of [[THREE.MeshBasicMaterial]]. Adds new properties required for [[fadeNear]] and\n * [[fadeFar]]. In addition to the new properties (which update their respective uniforms), it is\n * also required to update the material in their objects [[onBeforeRender]] and [[OnAfterRender]]\n * calls, where their flag [[transparent]] is set and the internal fadeNear/fadeFar values are\n * updated to world space distances.\n *\n * @see [[Tile#addRenderHelper]]\n */\nexport class MapMeshBasicMaterial extends THREE.MeshBasicMaterial\n    implements FadingFeature, ExtrusionFeature, DisplacementFeature {\n    /**\n     * Constructs a new `FadingMeshBasicMaterial`.\n     *\n     * @param params `FadingMeshBasicMaterial` parameters.\n     */\n    constructor(\n        params?: THREE.MeshBasicMaterialParameters &\n            FadingFeatureParameters &\n            ExtrusionFeatureParameters &\n            DisplacementFeatureParameters\n    ) {\n        super(params);\n\n        FadingFeature.patchGlobalShaderChunks();\n\n        this.addFadingProperties();\n        this.applyFadingParameters(params);\n\n        ExtrusionFeature.patchGlobalShaderChunks();\n\n        this.addExtrusionProperties();\n        this.applyExtrusionParameters(params);\n\n        this.addDisplacementProperties();\n        this.applyDisplacementParameters(params);\n    }\n\n    clone(): this {\n        return new MapMeshBasicMaterial().copy(this);\n    }\n\n    copy(source: this): any {\n        super.copy(source);\n        this.copyFadingParameters(source);\n        this.copyExtrusionParameters(source);\n        this.copyDisplacementParameters(source);\n        return this;\n    }\n\n    // Only here to make the compiler happy, these methods will be overriden: The actual\n    // implementations are those in [[FadingFeatureMixin]] and [[ExtrusionFeatureMixin]], see below:\n    //\n    // applyMixinsWithoutProperties(FadingMeshBasicMaterial, [FadingFeatureMixin]);\n    // applyMixinsWithoutProperties(ExtrudionMeshBasicMaterial, [ExtrusionFeatureMixin]);\n    //\n    // Mixin declarations start ---------------------------------------------------------\n\n    get fadeNear(): number {\n        return FadingFeature.DEFAULT_FADE_NEAR;\n    }\n    // tslint:disable-next-line:no-unused-variable\n    set fadeNear(value: number) {\n        // to be overridden\n    }\n\n    get fadeFar(): number {\n        return FadingFeature.DEFAULT_FADE_FAR;\n    }\n    // tslint:disable-next-line:no-unused-variable\n    set fadeFar(value: number) {\n        // to be overridden\n    }\n\n    get extrusionRatio(): number {\n        return ExtrusionFeature.DEFAULT_RATIO_MAX;\n    }\n    // tslint:disable-next-line:no-unused-variable\n    set extrusionRatio(value: number) {\n        // to be overridden\n    }\n\n    get displacementMap(): THREE.Texture | undefined {\n        return undefined;\n    }\n\n    // tslint:disable-next-line:no-unused-variable\n    set displacementMap(value: THREE.Texture | undefined) {\n        // to be overridden\n    }\n\n    protected addFadingProperties(): void {\n        // to be overridden\n    }\n\n    // tslint:disable-next-line:no-unused-variable\n    protected applyFadingParameters(params?: FadingFeatureParameters) {\n        // to be overridden\n    }\n\n    // tslint:disable-next-line:no-unused-variable\n    protected copyFadingParameters(source: FadingFeature) {\n        // to be overridden\n    }\n\n    protected addExtrusionProperties(): void {\n        // to be overridden\n    }\n\n    // tslint:disable-next-line:no-unused-variable\n    protected applyExtrusionParameters(params?: ExtrusionFeatureParameters) {\n        // to be overridden\n    }\n\n    // tslint:disable-next-line:no-unused-variable\n    protected copyExtrusionParameters(source: FadingFeature) {\n        // to be overridden\n    }\n\n    protected addDisplacementProperties(): void {\n        // to be overridden\n    }\n\n    // tslint:disable-next-line:no-unused-variable\n    protected applyDisplacementParameters(params?: DisplacementFeatureParameters) {\n        // to be overridden\n    }\n\n    // tslint:disable-next-line:no-unused-variable\n    protected copyDisplacementParameters(source: DisplacementFeature) {\n        // to be overridden\n    }\n    // Mixin declarations end -----------------------------------------------------------\n}\n\n/**\n * Subclass of THREE.MeshStandardMaterial. Adds new properties required for `fadeNear` and\n * `fadeFar`. In addition to the new properties (which fill respective uniforms), it is also\n * required to update the material in their objects `onBeforeRender` and `OnAfterRender` calls,\n * where their flag `transparent` is set and the internal fadeNear/fadeFar values are updated to\n * world space distances.\n *\n * @see [[Tile#addRenderHelper]]\n */\nexport class MapMeshStandardMaterial extends THREE.MeshStandardMaterial\n    implements FadingFeature, ExtrusionFeature {\n    uniformsNeedUpdate?: boolean;\n\n    /**\n     * Constructs a new `FadingMeshStandardMaterial`.\n     *\n     * @param params `FadingMeshStandardMaterial` parameters.\n     */\n    constructor(\n        params?: THREE.MeshStandardMaterialParameters &\n            FadingFeatureParameters &\n            ExtrusionFeatureParameters\n    ) {\n        super(params);\n\n        FadingFeature.patchGlobalShaderChunks();\n\n        this.addFadingProperties();\n        this.applyFadingParameters(params);\n\n        ExtrusionFeature.patchGlobalShaderChunks();\n\n        this.addExtrusionProperties();\n        this.applyExtrusionParameters(params);\n    }\n\n    clone(): this {\n        return new MapMeshStandardMaterial().copy(this);\n    }\n\n    copy(source: this): any {\n        super.copy(source);\n        this.copyFadingParameters(source);\n        this.copyExtrusionParameters(source);\n        return this;\n    }\n\n    // Only here to make the compiler happy, these methods will be overriden: The actual\n    // implementations are those in [[FadingFeatureMixin]] and [[ExtrusionFeatureMixin]], see below:\n    //\n    // applyMixinsWithoutProperties(FadingMeshBasicMaterial, [FadingFeatureMixin]);\n    // applyMixinsWithoutProperties(ExtrudionMeshBasicMaterial, [ExtrusionFeatureMixin]);\n    //\n    // Mixin declarations start ---------------------------------------------------------\n\n    get fadeNear(): number {\n        return FadingFeature.DEFAULT_FADE_NEAR;\n    }\n    // tslint:disable-next-line:no-unused-variable\n    set fadeNear(value: number) {\n        // to be overridden\n    }\n\n    get fadeFar(): number {\n        return FadingFeature.DEFAULT_FADE_FAR;\n    }\n    // tslint:disable-next-line:no-unused-variable\n    set fadeFar(value: number) {\n        // to be overridden\n    }\n\n    get extrusionRatio(): number {\n        return ExtrusionFeature.DEFAULT_RATIO_MAX;\n    }\n    // tslint:disable-next-line:no-unused-variable\n    set extrusionRatio(value: number) {\n        // to be overridden\n    }\n\n    protected addFadingProperties(): void {\n        // to be overridden\n    }\n\n    // tslint:disable-next-line:no-unused-variable\n    protected applyFadingParameters(params?: FadingFeatureParameters) {\n        // to be overridden\n    }\n\n    // tslint:disable-next-line:no-unused-variable\n    protected copyFadingParameters(source: FadingFeature) {\n        // to be overridden\n    }\n\n    protected addExtrusionProperties(): void {\n        // to be overridden\n    }\n\n    // tslint:disable-next-line:no-unused-variable\n    protected applyExtrusionParameters(params?: ExtrusionFeatureParameters) {\n        // to be overridden\n    }\n\n    // tslint:disable-next-line:no-unused-variable\n    protected copyExtrusionParameters(source: FadingFeature) {\n        // to be overridden\n    }\n    // Mixin declarations end -----------------------------------------------------------\n}\n\n/**\n * Finish the classes MapMeshBasicMaterial and MapMeshStandardMaterial by assigning them the actual\n * implementations of the mixed in functions.\n */\napplyMixinsWithoutProperties(MapMeshBasicMaterial, [FadingFeatureMixin]);\napplyMixinsWithoutProperties(MapMeshStandardMaterial, [FadingFeatureMixin]);\napplyMixinsWithoutProperties(MapMeshBasicMaterial, [ExtrusionFeatureMixin]);\napplyMixinsWithoutProperties(MapMeshStandardMaterial, [ExtrusionFeatureMixin]);\napplyMixinsWithoutProperties(MapMeshBasicMaterial, [DisplacementFeatureMixin]);\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport default {\n    extrude_line_vert_func: `\nvec3 extrudeLine(\n        in vec3 vertexPosition,\n        in float linePosition,\n        in float lineWidth,\n        in vec4 bitangent,\n        in vec3 tangent,\n        inout vec2 uv\n    ) {\n    vec3 result = vertexPosition;\n    // Retrieve the angle between this segment and the previous one (stored in the bitangent w\n    // component).\n    float angle = bitangent.w;\n    // Extrude according to the angle between segments to properly render narrow joints...\n    if (angle != 0.0) {\n        result += uv.y * lineWidth * bitangent.xyz / cos(angle / 2.0);\n        uv.x = linePosition + uv.x * lineWidth * uv.y * tan(angle / 2.0);\n    }\n    // ... or extrude in a simple manner for segments that keep the same direction.\n    else {\n        result += uv.y * lineWidth * bitangent.xyz + uv.x * lineWidth * tangent;\n        uv.x = linePosition + uv.x * lineWidth;\n    }\n    uv.y *= lineWidth;\n    return result;\n}\n`,\n    round_edges_and_add_caps: `\nfloat roundEdgesAndAddCaps(in vec4 coords, in vec3 range) {\n    // Compute the line's width to length ratio.\n    float widthRatio = range.y / range.x;\n\n    // Compute the inner segment distance (same for all cap mode).\n    float dist = abs(coords.y);\n    float segmentBeginMask = clamp(ceil(coords.z - coords.x), 0.0, 1.0);\n    float segmentEndMask = clamp(ceil(coords.x - coords.w), 0.0, 1.0);\n    dist = max(dist, segmentBeginMask * length(vec2((coords.x - coords.z) / widthRatio, coords.y)));\n    dist = max(dist, segmentEndMask * length(vec2((coords.x - coords.w) / widthRatio, coords.y)));\n\n    #if !CAPS_ROUND\n    // Compute the caps mask.\n    float capRangeMask = clamp(1.0 - ceil(range.z - drawRange.y), 0.0, 1.0);\n    float beginCapMask = clamp(ceil(drawRange.x - coords.x), 0.0, 1.0);\n    float endCapMask = clamp(ceil(coords.x - drawRange.y), 0.0, 1.0);\n    float capMask = capRangeMask * max(beginCapMask, endCapMask);\n\n    // Compute the outer segment distance (specific for each cap mode).\n    float capDist = max(coords.x - drawRange.y, drawRange.x - coords.x) / widthRatio;\n    #if CAPS_NONE\n    dist = mix(dist, max(abs(coords.y), (capDist + 0.1) / 0.1), capMask);\n    #elif CAPS_SQUARE\n    dist = mix(dist, max(abs(coords.y), capDist), capMask);\n    #elif CAPS_TRIANGLE_OUT\n    dist = mix(dist, abs(coords.y) + capDist, capMask);\n    #elif CAPS_TRIANGLE_IN\n    dist = mix(dist, max(abs(coords.y), (capDist - abs(coords.y)) + capDist), capMask);\n    #endif\n    #endif\n\n    return dist;\n}\n`,\n    tile_clip_func: `\nvoid tileClip(vec2 tilePos, vec2 tileSize) {\n    if (tileSize.x > 0.0 && (tilePos.x < -tileSize.x / 2.0 || tilePos.x > tileSize.x / 2.0))\n        discard;\n    if (tileSize.y > 0.0 && (tilePos.y < -tileSize.y / 2.0 || tilePos.y > tileSize.y / 2.0))\n        discard;\n}\n`,\n    high_precision_vert_func: `\nvec3 subtractDblEyePos( const in vec3 pos ) {\n    vec3 t1 = positionLow - u_eyepos_lowpart;\n    vec3 e = t1 - positionLow;\n    vec3 t2 = ((-u_eyepos_lowpart - e) + (positionLow - (t1 - e))) + pos - u_eyepos;\n    vec3 high_delta = t1 + t2;\n    vec3 low_delta = t2 - (high_delta - t1);\n    return (high_delta + low_delta);\n}\n`\n};\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    BaseTechniqueParams,\n    BasicExtrudedLineTechniqueParams,\n    ExtrudedPolygonTechniqueParams,\n    FillTechniqueParams,\n    isTextureBuffer,\n    LineTechniqueParams,\n    MarkerTechniqueParams,\n    PointTechniqueParams,\n    PolygonalTechniqueParams,\n    SegmentsTechniqueParams,\n    ShaderTechniqueParams,\n    SolidLineTechniqueParams,\n    StandardExtrudedLineTechniqueParams,\n    StandardTechniqueParams,\n    TerrainTechniqueParams,\n    TextTechniqueParams,\n    TextureCoordinateType\n} from \"./TechniqueParams\";\n\nimport { Expr, JsonExpr } from \"./Expr\";\nimport { InterpolatedProperty, InterpolatedPropertyDefinition } from \"./InterpolatedPropertyDefs\";\nimport {\n    AttrScope,\n    mergeTechniqueDescriptor,\n    TechniqueDescriptor,\n    TechniqueDescriptorRegistry\n} from \"./TechniqueDescriptor\";\n/**\n * Names of the supported texture properties.\n */\nexport const TEXTURE_PROPERTY_KEYS = [\n    \"map\",\n    \"normalMap\",\n    \"displacementMap\",\n    \"roughnessMap\",\n    \"emissiveMap\",\n    \"alphaMap\",\n    \"metalnessMap\",\n    \"bumpMap\"\n];\n\n/**\n * Names of the properties controlling transparency.\n */\nexport const TRANSPARENCY_PROPERTY_KEYS = [\"opacity\", \"transparent\"];\n\n// TODO: Can be removed, when all when interpolators are implemented as [[Expr]]s\nexport type RemoveInterpolatedPropDef<T> = T | InterpolatedPropertyDefinition<any> extends T\n    ? Exclude<T, InterpolatedPropertyDefinition<any>>\n    : T;\nexport type RemoveJsonExpr<T> = T | JsonExpr extends T ? Exclude<T, JsonExpr> : T;\n\n/**\n * Make runtime representation of technique attributes from JSON-compatible typings.\n *\n * Translates\n *  - InterpolatedPropertyDefinition -> InterpolatedProperty\n *  - JsonExpr -> Expr\n */\nexport type MakeTechniqueAttrs<T> = {\n    [P in keyof T]: T[P] | JsonExpr extends T[P]\n        ? RemoveInterpolatedPropDef<RemoveJsonExpr<T[P]>> | Expr | InterpolatedProperty\n        : T[P];\n};\n\nexport const techniqueDescriptors: TechniqueDescriptorRegistry = {};\n\nexport const baseTechniqueParamsDescriptor: TechniqueDescriptor<BaseTechniqueParams> = {\n    // TODO: Choose which techniques should support color with transparency.\n    // For now we chosen all, but it maybe not suitable for text or line marker techniques.\n    attrTransparencyColor: \"color\",\n    attrScopes: {\n        renderOrder: AttrScope.TechniqueGeometry,\n        renderOrderOffset: AttrScope.TechniqueGeometry,\n        enabled: AttrScope.TechniqueGeometry,\n        kind: AttrScope.TechniqueGeometry,\n        transient: AttrScope.TechniqueGeometry,\n        fadeFar: AttrScope.TechniqueRendering,\n        fadeNear: AttrScope.TechniqueRendering\n    }\n};\n\nexport const pointTechniquePropTypes = mergeTechniqueDescriptor<PointTechniqueParams>(\n    baseTechniqueParamsDescriptor,\n    {\n        attrScopes: {\n            texture: AttrScope.TechniqueGeometry,\n            enablePicking: AttrScope.TechniqueGeometry,\n            color: AttrScope.TechniqueRendering,\n            transparent: AttrScope.TechniqueRendering,\n            opacity: AttrScope.TechniqueGeometry\n        }\n    }\n);\n\n/**\n * Runtime representation of [[SquaresStyle]] as parsed by [[StyleSetEvaluator]].\n * For technique parameters see [[PointTechniqueParams]].\n */\nexport interface SquaresTechnique extends MakeTechniqueAttrs<PointTechniqueParams> {\n    name: \"squares\";\n}\n\nexport const squaresTechniquePropTypes = mergeTechniqueDescriptor<SquaresTechnique>(\n    baseTechniqueParamsDescriptor,\n    pointTechniquePropTypes\n);\ntechniqueDescriptors.squares = squaresTechniquePropTypes;\n\n/**\n * Runtime representation of [[CirclesStyle]] as parsed by [[StyleSetEvaluator]].\n * For technique parameters see [[PointTechniqueParams]].\n */\nexport interface CirclesTechnique extends MakeTechniqueAttrs<PointTechniqueParams> {\n    name: \"circles\";\n}\n\nexport const circlesTechniquePropTypes = mergeTechniqueDescriptor<CirclesTechnique>(\n    baseTechniqueParamsDescriptor,\n    pointTechniquePropTypes\n);\ntechniqueDescriptors.circles = circlesTechniquePropTypes;\n\n/**\n * Runtime representation of [[PoiStyle]] as parsed by [[StyleSetEvaluator]].\n * For technique parameters see [[MarkerTechniqueParams]].\n */\nexport interface PoiTechnique extends MakeTechniqueAttrs<MarkerTechniqueParams> {\n    name: \"labeled-icon\";\n}\n\n/**\n * Runtime representation of [[LineMarkerStyle]] as parsed by [[StyleSetEvaluator]].\n * For technique parameters see [[MarkerTechniqueParams]].\n */\nexport interface LineMarkerTechnique extends MakeTechniqueAttrs<MarkerTechniqueParams> {\n    name: \"line-marker\";\n}\n\nconst lineMarkerTechniquePropTypes = mergeTechniqueDescriptor<LineMarkerTechnique>(\n    baseTechniqueParamsDescriptor,\n    {\n        attrScopes: {\n            text: AttrScope.FeatureGeometry,\n            label: AttrScope.FeatureGeometry,\n            useAbbreviation: AttrScope.FeatureGeometry,\n            useIsoCode: AttrScope.FeatureGeometry,\n            priority: AttrScope.TechniqueGeometry,\n            textMinZoomLevel: AttrScope.TechniqueGeometry,\n            textMaxZoomLevel: AttrScope.TechniqueGeometry,\n            iconMinZoomLevel: AttrScope.TechniqueGeometry,\n            iconMaxZoomLevel: AttrScope.TechniqueGeometry,\n            distanceScale: AttrScope.TechniqueGeometry,\n            textMayOverlap: AttrScope.TechniqueGeometry,\n            iconMayOverlap: AttrScope.TechniqueGeometry,\n            textReserveSpace: AttrScope.TechniqueGeometry,\n            iconReserveSpace: AttrScope.TechniqueGeometry,\n            renderTextDuringMovements: AttrScope.TechniqueGeometry,\n            alwaysOnTop: AttrScope.TechniqueGeometry,\n            textIsOptional: AttrScope.TechniqueGeometry,\n            showOnMap: AttrScope.TechniqueGeometry,\n            stackMode: AttrScope.TechniqueGeometry,\n            minDistance: AttrScope.TechniqueGeometry,\n            iconIsOptional: AttrScope.TechniqueGeometry,\n            iconFadeTime: AttrScope.TechniqueGeometry,\n            textFadeTime: AttrScope.TechniqueGeometry,\n            xOffset: AttrScope.TechniqueGeometry,\n            yOffset: AttrScope.TechniqueGeometry,\n            iconXOffset: AttrScope.TechniqueGeometry,\n            iconYOffset: AttrScope.TechniqueGeometry,\n            iconScale: AttrScope.TechniqueGeometry,\n            screenHeight: AttrScope.TechniqueGeometry,\n            screenWidth: AttrScope.TechniqueGeometry,\n            poiTable: AttrScope.TechniqueGeometry,\n            poiName: AttrScope.FeatureGeometry,\n            poiNameField: AttrScope.TechniqueGeometry,\n            imageTexture: AttrScope.FeatureGeometry,\n            imageTextureField: AttrScope.TechniqueGeometry,\n            imageTexturePrefix: AttrScope.TechniqueGeometry,\n            imageTexturePostfix: AttrScope.TechniqueGeometry,\n            style: AttrScope.TechniqueGeometry,\n            fontName: AttrScope.TechniqueGeometry,\n            fontStyle: AttrScope.TechniqueGeometry,\n            fontVariant: AttrScope.TechniqueGeometry,\n            rotation: AttrScope.TechniqueGeometry,\n            tracking: AttrScope.TechniqueGeometry,\n            leading: AttrScope.TechniqueGeometry,\n            maxLines: AttrScope.TechniqueGeometry,\n            lineWidth: AttrScope.TechniqueGeometry,\n            canvasRotation: AttrScope.TechniqueGeometry,\n            lineRotation: AttrScope.TechniqueGeometry,\n            wrappingMode: AttrScope.TechniqueGeometry,\n            hAlignment: AttrScope.TechniqueGeometry,\n            vAlignment: AttrScope.TechniqueGeometry,\n            backgroundColor: AttrScope.TechniqueRendering,\n            backgroundSize: AttrScope.TechniqueRendering,\n            backgroundOpacity: AttrScope.TechniqueRendering,\n            color: AttrScope.TechniqueRendering,\n            opacity: AttrScope.TechniqueRendering,\n            size: AttrScope.TechniqueRendering\n        }\n    }\n);\ntechniqueDescriptors[\"line-marker\"] = lineMarkerTechniquePropTypes;\ntechniqueDescriptors[\"labeled-icon\"] = lineMarkerTechniquePropTypes;\n\n/**\n * Runtime representation of [[SegmentsStyle]] as parsed by [[StyleSetEvaluator]].\n * For technique parameters see [[SegmentsTechniqueParams]].\n */\nexport interface SegmentsTechnique extends MakeTechniqueAttrs<SegmentsTechniqueParams> {\n    name: \"segments\";\n}\n\nconst polygonalTechniqueDescriptor: TechniqueDescriptor<PolygonalTechniqueParams> = {\n    attrScopes: {\n        polygonOffset: AttrScope.TechniqueRendering,\n        polygonOffsetFactor: AttrScope.TechniqueRendering,\n        polygonOffsetUnits: AttrScope.TechniqueRendering,\n        lineColor: AttrScope.TechniqueRendering,\n        lineFadeFar: AttrScope.TechniqueRendering,\n        lineFadeNear: AttrScope.TechniqueRendering\n    }\n};\n/**\n * Runtime representation of [[BasicExtrudedLineStyle]] as parsed by [[StyleSetEvaluator]].\n * For technique parameters see [[BasicExtrudedLineTechniqueParams]].\n */\nexport interface BasicExtrudedLineTechnique\n    extends MakeTechniqueAttrs<BasicExtrudedLineTechniqueParams> {\n    name: \"extruded-line\";\n}\n\n/**\n * Runtime representation of [[StandardExtrudedLineStyle]] as parsed by [[StyleSetEvaluator]].\n * For technique parameters see [[StandardExtrudedLineTechniqueParams]].\n */\nexport interface StandardExtrudedLineTechnique\n    extends MakeTechniqueAttrs<StandardExtrudedLineTechniqueParams> {\n    name: \"extruded-line\";\n}\n\n/**\n * Runtime representation of [[SolidLineStyle]] as parsed by [[StyleSetEvaluator]].\n * For technique parameters see [[SolidLineTechniqueParams]].\n */\nexport interface SolidLineTechnique extends MakeTechniqueAttrs<SolidLineTechniqueParams> {\n    name: \"solid-line\" | \"dashed-line\";\n}\n\nexport const solidLineTechniqueDescriptor = mergeTechniqueDescriptor<SolidLineTechnique>(\n    baseTechniqueParamsDescriptor,\n    polygonalTechniqueDescriptor,\n    {\n        attrScopes: {\n            clipping: AttrScope.TechniqueGeometry,\n            secondaryRenderOrder: AttrScope.TechniqueGeometry,\n            color: AttrScope.TechniqueRendering,\n            opacity: AttrScope.TechniqueRendering,\n            transparent: AttrScope.TechniqueRendering,\n            lineWidth: AttrScope.TechniqueRendering,\n            secondaryWidth: AttrScope.TechniqueRendering,\n            secondaryColor: AttrScope.TechniqueRendering,\n            dashSize: AttrScope.TechniqueRendering,\n            gapSize: AttrScope.TechniqueRendering\n        }\n    }\n);\ntechniqueDescriptors[\"solid-line\"] = solidLineTechniqueDescriptor;\n// TODO: Remove deprecated \"dashed-line\" support in future releases.\ntechniqueDescriptors[\"dashed-line\"] = solidLineTechniqueDescriptor;\n\n/**\n * Runtime representation of [[LineStyle]] as parsed by [[StyleSetEvaluator]].\n * For technique parameters see [[LineTechniqueParams]].\n */\nexport interface LineTechnique extends MakeTechniqueAttrs<LineTechniqueParams> {\n    name: \"line\";\n}\n\nexport const lineTechniqueDescriptor = mergeTechniqueDescriptor<LineTechnique>(\n    baseTechniqueParamsDescriptor,\n    {\n        attrScopes: {\n            // TODO, check, which are really dynamic !\n            color: AttrScope.TechniqueRendering,\n            opacity: AttrScope.TechniqueRendering,\n            transparent: AttrScope.TechniqueRendering,\n            lineWidth: AttrScope.FeatureGeometry\n        }\n    }\n);\n\ntechniqueDescriptors.line = lineTechniqueDescriptor;\n\n/**\n * Runtime representation of [[FillStyle]] as parsed by [[StyleSetEvaluator]].\n * For technique parameters see [[FillTechniqueParams]].\n */\nexport interface FillTechnique extends MakeTechniqueAttrs<FillTechniqueParams> {\n    name: \"fill\";\n}\n\nconst fillTechniqueDescriptor = mergeTechniqueDescriptor<FillTechnique>(\n    baseTechniqueParamsDescriptor,\n    polygonalTechniqueDescriptor,\n    {\n        attrScopes: {\n            color: AttrScope.TechniqueRendering,\n            opacity: AttrScope.TechniqueRendering,\n            transparent: AttrScope.TechniqueRendering,\n            lineWidth: AttrScope.TechniqueRendering\n        }\n    }\n);\ntechniqueDescriptors.fill = fillTechniqueDescriptor;\n\n/**\n * Technique used to render a mesh geometry.\n * For technique parameters see [[StandardTechniqueParams]].\n */\nexport interface StandardTechnique extends MakeTechniqueAttrs<StandardTechniqueParams> {\n    name: \"standard\";\n}\nconst standardTechniqueDescriptor = mergeTechniqueDescriptor<StandardTechnique>(\n    baseTechniqueParamsDescriptor,\n    {\n        attrScopes: {\n            color: AttrScope.FeatureGeometry,\n            vertexColors: AttrScope.FeatureGeometry,\n            wireframe: AttrScope.TechniqueRendering,\n            roughness: AttrScope.TechniqueRendering,\n            metalness: AttrScope.TechniqueRendering,\n            alphaTest: AttrScope.TechniqueRendering,\n            depthTest: AttrScope.TechniqueRendering,\n            transparent: AttrScope.TechniqueRendering,\n            opacity: AttrScope.TechniqueRendering,\n            emissive: AttrScope.TechniqueRendering,\n            emissiveIntensity: AttrScope.TechniqueRendering,\n            refractionRatio: AttrScope.TechniqueRendering,\n            map: AttrScope.TechniqueGeometry,\n            mapProperties: AttrScope.TechniqueGeometry,\n            normalMap: AttrScope.TechniqueGeometry,\n            normalMapProperties: AttrScope.TechniqueGeometry,\n            displacementMap: AttrScope.TechniqueGeometry,\n            displacementMapProperties: AttrScope.TechniqueGeometry,\n            roughnessMap: AttrScope.TechniqueGeometry,\n            roughnessMapProperties: AttrScope.TechniqueGeometry,\n            emissiveMap: AttrScope.TechniqueGeometry,\n            emissiveMapProperties: AttrScope.TechniqueGeometry,\n            bumpMap: AttrScope.TechniqueGeometry,\n            bumpMapProperties: AttrScope.TechniqueGeometry,\n            metalnessMap: AttrScope.TechniqueGeometry,\n            metalnessMapProperties: AttrScope.TechniqueGeometry,\n            alphaMap: AttrScope.TechniqueGeometry,\n            alphaMapProperties: AttrScope.TechniqueGeometry\n        }\n    }\n);\ntechniqueDescriptors.standard = standardTechniqueDescriptor;\n\n/**\n * Runtime representation of [[ExtrudedPolygonStyle]] as parsed by [[StyleSetEvaluator]].\n * For technique parameters see [[ExtrudedPolygonTechniqueParams]].\n */\nexport interface ExtrudedPolygonTechnique\n    extends MakeTechniqueAttrs<ExtrudedPolygonTechniqueParams> {\n    name: \"extruded-polygon\";\n}\n\nconst extrudedPolygonTechniqueDescriptor = mergeTechniqueDescriptor<ExtrudedPolygonTechnique>(\n    baseTechniqueParamsDescriptor,\n    standardTechniqueDescriptor,\n    {\n        attrScopes: {\n            height: AttrScope.FeatureGeometry,\n            floorHeight: AttrScope.FeatureGeometry,\n            color: AttrScope.FeatureGeometry,\n            defaultColor: AttrScope.FeatureGeometry,\n            defaultHeight: AttrScope.FeatureGeometry,\n            constantHeight: AttrScope.FeatureGeometry,\n            boundaryWalls: AttrScope.FeatureGeometry,\n            footprint: AttrScope.FeatureGeometry,\n            maxSlope: AttrScope.FeatureGeometry,\n            enableDepthPrePass: AttrScope.TechniqueGeometry,\n            animateExtrusionDuration: AttrScope.TechniqueGeometry,\n            animateExtrusion: AttrScope.TechniqueRendering,\n            opacity: AttrScope.TechniqueRendering,\n            transparent: AttrScope.TechniqueRendering,\n            lineWidth: AttrScope.TechniqueRendering,\n            lineFadeNear: AttrScope.TechniqueRendering,\n            lineFadeFar: AttrScope.TechniqueRendering,\n            lineColorMix: AttrScope.TechniqueGeometry,\n            lineColor: AttrScope.TechniqueRendering\n        }\n    }\n);\ntechniqueDescriptors[\"extruded-polygon\"] = extrudedPolygonTechniqueDescriptor;\n/**\n * Runtime representation of [[TextStyle]] as parsed by [[StyleSetEvaluator]].\n * For technique parameters see [[TextTechniqueParams]].\n */\nexport interface TextTechnique extends MakeTechniqueAttrs<TextTechniqueParams> {\n    name: \"text\";\n}\n\nconst textTechniqueDescriptor = mergeTechniqueDescriptor<TextTechnique>(\n    baseTechniqueParamsDescriptor,\n    {\n        attrScopes: {\n            text: AttrScope.FeatureGeometry,\n            label: AttrScope.FeatureGeometry,\n            useAbbreviation: AttrScope.FeatureGeometry,\n            useIsoCode: AttrScope.FeatureGeometry,\n\n            minZoomLevel: AttrScope.TechniqueGeometry,\n            maxZoomLevel: AttrScope.TechniqueGeometry,\n            distanceScale: AttrScope.TechniqueGeometry,\n            mayOverlap: AttrScope.TechniqueGeometry,\n            reserveSpace: AttrScope.TechniqueGeometry,\n            textFadeTime: AttrScope.TechniqueGeometry,\n            xOffset: AttrScope.TechniqueGeometry,\n            yOffset: AttrScope.TechniqueGeometry,\n            style: AttrScope.TechniqueGeometry,\n            fontName: AttrScope.TechniqueGeometry,\n            fontStyle: AttrScope.TechniqueGeometry,\n            fontVariant: AttrScope.TechniqueGeometry,\n            rotation: AttrScope.TechniqueGeometry,\n            tracking: AttrScope.TechniqueGeometry,\n            leading: AttrScope.TechniqueGeometry,\n            maxLines: AttrScope.TechniqueGeometry,\n            lineWidth: AttrScope.TechniqueGeometry,\n            canvasRotation: AttrScope.TechniqueGeometry,\n            lineRotation: AttrScope.TechniqueGeometry,\n            wrappingMode: AttrScope.TechniqueGeometry,\n            hAlignment: AttrScope.TechniqueGeometry,\n            vAlignment: AttrScope.TechniqueGeometry,\n            backgroundColor: AttrScope.TechniqueRendering,\n            backgroundSize: AttrScope.TechniqueRendering,\n            backgroundOpacity: AttrScope.TechniqueRendering,\n            color: AttrScope.TechniqueRendering,\n            opacity: AttrScope.TechniqueRendering,\n            priority: AttrScope.TechniqueRendering,\n            size: AttrScope.TechniqueRendering\n        }\n    }\n);\ntechniqueDescriptors.text = textTechniqueDescriptor;\n\n/**\n * Special technique for user-defined shaders.\n * For technique parameters see [[ShaderTechniqueParams]].\n */\nexport interface ShaderTechnique extends MakeTechniqueAttrs<ShaderTechniqueParams> {\n    name: \"shader\";\n}\n\nconst shaderTechniqueDescriptor = mergeTechniqueDescriptor<ShaderTechnique>(\n    baseTechniqueParamsDescriptor,\n    {\n        attrScopes: {\n            primitive: AttrScope.TechniqueGeometry,\n            params: AttrScope.TechniqueRendering\n        }\n    }\n);\n\ntechniqueDescriptors.shader = shaderTechniqueDescriptor;\n\n/**\n * Technique used to render a terrain geometry with textures.\n * For technique parameters see [[TerrainTechniqueParams]].\n */\nexport interface TerrainTechnique extends MakeTechniqueAttrs<TerrainTechniqueParams> {\n    name: \"terrain\";\n}\n\n/**\n * Technique to avoid label rendering on top of certain line geometries.\n * For technique parameters see [[BaseTechniqueParams]].\n */\nexport interface LabelRejectionLineTechnique extends MakeTechniqueAttrs<BaseTechniqueParams> {\n    name: \"label-rejection-line\";\n}\n\n/**\n * Possible techniques that can be used to draw a geometry on the map.\n */\nexport type Technique =\n    | SquaresTechnique\n    | CirclesTechnique\n    | PoiTechnique\n    | LineMarkerTechnique\n    | LineTechnique\n    | SegmentsTechnique\n    | SolidLineTechnique\n    | FillTechnique\n    | StandardTechnique\n    | TerrainTechnique\n    | BasicExtrudedLineTechnique\n    | StandardExtrudedLineTechnique\n    | ExtrudedPolygonTechnique\n    | ShaderTechnique\n    | TextTechnique\n    | LabelRejectionLineTechnique;\n\n/**\n * Additional params used for optimized usage of `Techniques`.\n */\nexport interface IndexedTechniqueParams {\n    /**\n     * Optimization: Index into table in [[StyleSetEvaluator]] or in [[DecodedTile]].\n     * @hidden\n     */\n    _index: number;\n\n    /**\n     * Unique technique key derived from all dynamic expressions that were input to this particular\n     * technique instance.\n     * @hidden\n     */\n    _key: string;\n\n    /**\n     * Optimization: Unique [[Technique]] index of [[Style]] from which technique was derived.\n     * @hidden\n     */\n    _styleSetIndex: number;\n}\n\n/**\n * For efficiency, [[StyleSetEvaluator]] returns [[Techniques]] additional params as defined in\n * [[IndexedTechniqueParams]].\n */\nexport type IndexedTechnique = Technique & IndexedTechniqueParams;\n\n/**\n * Type guard to check if an object is an instance of [[CirclesTechnique]].\n */\nexport function isCirclesTechnique(technique: Technique): technique is CirclesTechnique {\n    return technique.name === \"circles\";\n}\n\n/**\n * Type guard to check if an object is an instance of [[SquaresTechnique]].\n */\nexport function isSquaresTechnique(technique: Technique): technique is SquaresTechnique {\n    return technique.name === \"squares\";\n}\n\n/**\n * Type guard to check if an object is an instance of [[PoiTechnique]].\n */\nexport function isPoiTechnique(technique: Technique): technique is PoiTechnique {\n    return technique.name === \"labeled-icon\";\n}\n\n/**\n * Type guard to check if an object is an instance of [[LineMarkerTechnique]].\n */\nexport function isLineMarkerTechnique(technique: Technique): technique is LineMarkerTechnique {\n    return technique.name === \"line-marker\";\n}\n\n/**\n * Type guard to check if an object is an instance of [[LineTechnique]].\n */\nexport function isLineTechnique(technique: Technique): technique is LineTechnique {\n    return technique.name === \"line\";\n}\n\n/**\n * Type guard to check if an object is an instance of [[SolidLineTechnique]].\n */\nexport function isSolidLineTechnique(technique: Technique): technique is SolidLineTechnique {\n    return technique.name === \"solid-line\" || technique.name === \"dashed-line\";\n}\n\n/**\n * Type guard to check if an object is an instance of [[SegmentsTechnique]].\n */\nexport function isSegmentsTechnique(technique: Technique): technique is SegmentsTechnique {\n    return technique.name === \"segments\";\n}\n\n/**\n * Type guard to check if an object is an instance of [[BasicExtrudedLineTechnique]]\n * or [[StandardExtrudedLineTechnique]].\n */\nexport function isExtrudedLineTechnique(\n    technique: Technique\n): technique is BasicExtrudedLineTechnique | StandardExtrudedLineTechnique {\n    return technique.name === \"extruded-line\";\n}\n\n/**\n * Type guard to check if an object is an instance of [[BasicExtrudedLineTechnique]].\n */\nexport function isBasicExtrudedLineTechnique(\n    technique: Technique\n): technique is BasicExtrudedLineTechnique {\n    return isExtrudedLineTechnique(technique) && technique.shading === \"basic\";\n}\n\n/**\n * Type guard to check if an object is an instance of [[StandardExtrudedLineTechnique]].\n */\nexport function isStandardExtrudedLineTechnique(\n    technique: Technique\n): technique is StandardExtrudedLineTechnique {\n    return isExtrudedLineTechnique(technique) && technique.shading === \"standard\";\n}\n\n/**\n * Type guard to check if an object is an instance of [[FillTechnique]].\n */\nexport function isFillTechnique(technique: Technique): technique is FillTechnique {\n    return technique.name === \"fill\";\n}\n\n/**\n * Type guard to check if an object is an instance of [[ExtrudedPolygonTechnique]].\n */\nexport function isExtrudedPolygonTechnique(\n    technique: Technique\n): technique is ExtrudedPolygonTechnique {\n    return technique.name === \"extruded-polygon\";\n}\n\n/**\n * Type guard to check if an object is an instance of [[StandardTechnique]].\n */\nexport function isStandardTechnique(technique: Technique): technique is StandardTechnique {\n    return technique.name === \"standard\";\n}\n\n/**\n * Type guard to check if an object is an instance of [[TerrainTechnique]].\n */\nexport function isTerrainTechnique(technique: Technique): technique is TerrainTechnique {\n    return technique.name === \"terrain\";\n}\n\n/**\n * Type guard to check if an object is an instance of [[TextTechnique]].\n */\nexport function isTextTechnique(technique: Technique): technique is TextTechnique {\n    return technique.name === \"text\";\n}\n\n/**\n * Type guard to check if an object is an instance of [[ShaderTechnique]].\n */\nexport function isShaderTechnique(technique: Technique): technique is ShaderTechnique {\n    return technique.name === \"shader\";\n}\n\nexport function isLabelRejectionLineTechnique(\n    technique: Technique\n): technique is LabelRejectionLineTechnique {\n    return technique.name === \"label-rejection-line\";\n}\n\n/**\n * Check if vertex normals should be generated for this technique (if no normals are in the data).\n * @param technique Technique to check.\n */\nexport function needsVertexNormals(technique: Technique): boolean {\n    return (\n        isFillTechnique(technique) ||\n        isStandardTechnique(technique) ||\n        isTerrainTechnique(technique) ||\n        isStandardExtrudedLineTechnique(technique)\n    );\n}\n\n/**\n * Get the texture coordinate type if the technique supports it.\n */\nexport function textureCoordinateType(technique: Technique): TextureCoordinateType | undefined {\n    if (isStandardTechnique(technique)) {\n        return technique.textureCoordinateType;\n    } else if (isExtrudedPolygonTechnique(technique)) {\n        return technique.textureCoordinateType;\n    } else if (isTerrainTechnique(technique)) {\n        return technique.textureCoordinateType;\n    } else {\n        return undefined;\n    }\n}\n\n/**\n * Add all the buffers of the technique to the transfer list.\n */\nexport function addBuffersToTransferList(technique: Technique, transferList: ArrayBuffer[]) {\n    if (\n        isStandardTechnique(technique) ||\n        isExtrudedPolygonTechnique(technique) ||\n        isTerrainTechnique(technique)\n    ) {\n        for (const texturePropertyKey of TEXTURE_PROPERTY_KEYS) {\n            const textureProperty = (technique as any)[texturePropertyKey];\n            if (isTextureBuffer(textureProperty)) {\n                if (textureProperty.buffer instanceof ArrayBuffer) {\n                    transferList.push(textureProperty.buffer);\n                }\n            }\n        }\n    }\n}\n\n/**\n * Compose full texture name for given image name with technique specified.\n * Some techniques allows to add prefix/postfix to icons names specified, this\n * function uses technique information to create fully qualified texture name.\n * @param imageName base name of the marker icon.\n * @param technique the technique describing POI or line marker.\n * @returns fully qualified texture name for loading from atlas (without extension).\n */\nexport function composeTechniqueTextureName(\n    imageName: string,\n    technique: PoiTechnique | LineMarkerTechnique\n): string {\n    let textureName = imageName;\n    if (typeof technique.imageTexturePrefix === \"string\") {\n        textureName = technique.imageTexturePrefix + textureName;\n    }\n    if (typeof technique.imageTexturePostfix === \"string\") {\n        textureName = textureName + technique.imageTexturePostfix;\n    }\n    return textureName;\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { Definitions, StyleSet, Theme } from \"@here/harp-datasource-protocol\";\nimport { Projection, TileKey, TilingScheme } from \"@here/harp-geoutils\";\nimport { assert } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\nimport { MapView } from \"./MapView\";\nimport { Tile } from \"./Tile\";\n\nconst UPDATE_EVENT = { type: \"update\" };\n\n/**\n * Derive a class from `DataSource` to contribute data and geometries to the [[MapView]].\n */\nexport abstract class DataSource extends THREE.EventDispatcher {\n    /**\n     * A counter to generate unique names for each `DataSource`, if no name is provided in the\n     * constructor.\n     */\n    private static uniqueNameCounter: number = 0;\n\n    /**\n     * Set to `true` if this `DataSource` is enabled; `false` otherwise.\n     */\n    enabled: boolean = true;\n\n    /**\n     * Set to `true` if the [[MapView]] can cache tiles produced by this `DataSource`.\n     */\n    cacheable: boolean = false;\n\n    /**\n     * Set to `true` if the loader should be used to get the tile contents.\n     */\n    useGeometryLoader: boolean = false;\n\n    /**\n     * The unique name of a `DataSource` instance.\n     */\n    name: string;\n\n    /**\n     * Whether the datasource should have a ground plane (this plane covers the tile entirely and\n     * has the minimum possible renderOrder), this can be required in some cases when fallback\n     * parent tiles need to be covered by the children, otherwise the content will overlap.\n     * Default is false\n     */\n    addGroundPlane: boolean = false;\n\n    /**\n     * The [[MapView]] instance holding a reference to this `DataSource`.\n     */\n    private m_mapView?: MapView;\n\n    /**\n     * The name of the [[StyleSet]] to evaluate for the decoding.\n     */\n    private m_styleSetName?: string;\n\n    /**\n     * Minimum zoom level this `DataSource` can be displayed in.\n     */\n    private m_minZoomLevel: number = 1;\n\n    /**\n     * Maximum zoom level this `DataSource` can be displayed in.\n     */\n    private m_maxZoomLevel: number = 20;\n\n    /**\n     * Current value of [[maxGeometryHeight]] property.\n     */\n    private m_maxGeometryHeight = 0;\n\n    /**\n     * Storage level offset applied to this `DataSource`.\n     */\n    private m_storageLevelOffset: number = 0;\n\n    /**\n     * Constructs a new `DataSource`.\n     *\n     * @param uniqueName A unique name that represents this `DataSource`.\n     * @param styleSetName The name of the [[StyleSet]] to refer to in a [[Theme]], to decode vector\n     * tiles.\n     * @param minZoomLevel Minimum zoom level this `DataSource` can be displayed in.\n     * @param maxZoomLevel Maximum zoom level this `DataSource` can be displayed in.\n     * @param storageLevelOffset Storage level offset applied to this `DataSource`.\n     */\n    constructor(\n        uniqueName?: string,\n        styleSetName?: string,\n        minZoomLevel?: number,\n        maxZoomLevel?: number,\n        storageLevelOffset?: number\n    ) {\n        super();\n        if (uniqueName === undefined || uniqueName.length === 0) {\n            uniqueName = `anonymous-datasource#${++DataSource.uniqueNameCounter}`;\n        }\n        this.name = uniqueName;\n\n        this.styleSetName = styleSetName;\n\n        if (minZoomLevel !== undefined) {\n            this.m_minZoomLevel = minZoomLevel;\n        }\n        if (maxZoomLevel !== undefined) {\n            this.m_maxZoomLevel = maxZoomLevel;\n        }\n        if (storageLevelOffset !== undefined) {\n            this.m_storageLevelOffset = storageLevelOffset;\n        }\n    }\n\n    /**\n     * Returns the name of the [[StyleSet]] to use for the decoding.\n     */\n    get styleSetName(): string | undefined {\n        return this.m_styleSetName;\n    }\n\n    /**\n     * Sets the name of the [[StyleSet]] to use for the decoding. If this [[DataSource]] is already\n     * attached to a [[MapView]], this setter then reapplies [[StyleSet]] with this name found in\n     * [[MapView]]s theme.\n     */\n    set styleSetName(styleSetName: string | undefined) {\n        this.m_styleSetName = styleSetName;\n        if (this.m_mapView !== undefined && styleSetName !== undefined) {\n            this.setTheme(this.m_mapView.theme);\n        }\n    }\n\n    /**\n     * Destroys this `DataSource`.\n     */\n    dispose() {\n        // to be overloaded by subclasses\n    }\n\n    /**\n     * Purges all the caching done by this `DataSource`\n     */\n    clearCache() {\n        // to be overloaded by subclasses\n    }\n\n    /**\n     * Returns `true` if this `DataSource` is ready and the [[MapView]] can invoke `getTile()` to\n     * start requesting data.\n     */\n    ready(): boolean {\n        return true;\n    }\n\n    /**\n     * The [[MapView]] that is holding this `DataSource`.\n     */\n    get mapView(): MapView {\n        if (this.m_mapView === undefined) {\n            throw new Error(\"This DataSource was not added to MapView\");\n        }\n\n        return this.m_mapView;\n    }\n\n    /**\n     * The [[Projection]] used by the [[MapView]] that is holding this `DataSource`.\n     *\n     * An `Error` is thrown if you call this method before this `DataSource` has been added\n     * to a [[MapView]].\n     */\n    get projection(): Projection {\n        return this.mapView.projection;\n    }\n\n    /**\n     * This method is called when the `DataSource` is added to a [[MapView]]. Reimplement this\n     * method to provide any custom initialization, such as, to establish a network connection,\n     * or to initialize complex data structures.\n     */\n    async connect(): Promise<void> {\n        // to be overloaded by subclasses\n    }\n\n    /**\n     * Returns the [[TilingScheme]] used by this `DataSource`.\n     */\n    abstract getTilingScheme(): TilingScheme;\n\n    /**\n     * This method is called when this `DataSource` is added to a [[MapView]].\n     *\n     * Reimplementations of this method must invoke the definition of the super class.\n     *\n     * @param mapView The instance of the [[MapView]].\n     */\n    attach(mapView: MapView): void {\n        this.m_mapView = mapView;\n    }\n\n    /**\n     * This method is called when this `DataSource` is removed from a [[MapView]].\n     *\n     * Reimplementations of this method must invoke the definition of the super class.\n     *\n     * @param mapView The instance of the [[MapView]].\n     */\n    detach(mapView: MapView) {\n        assert(this.m_mapView === mapView);\n        this.m_mapView = undefined;\n    }\n\n    /**\n     * Invoked by [[MapView]] to notify when the [[Theme]] has been changed.\n     *\n     * If `DataSource` depends on a `styleSet` or `languages`, it must update its tiles' geometry.\n     *\n     * @deprecated, Use [[setTheme]].\n     *\n     * @param styleSet The new theme that [[MapView]] uses.\n     * @param languages An optional list of languages for the `DataSource`.\n     */\n    // tslint:disable-next-line:no-unused-variable\n    setStyleSet(styleSet?: StyleSet, definitions?: Definitions, languages?: string[]): void {\n        // to be overwritten by subclasses\n    }\n\n    /**\n     * Apply the [[Theme]] to this data source.\n     *\n     * If `DataSource` depends on a `styleSet` defined by this theme or `languages`, it must update\n     * its tiles' geometry.\n     *\n     * @param languages\n     */\n    setTheme(theme: Theme, languages?: string[]): void {\n        // to be overwritten by subclasses\n    }\n\n    /**\n     * Used to configure the languages used by the `DataSource` according to priority;\n     * the first language in the array has the highest priority.\n     *\n     * @param languages An array of ISO 639-1 language codes.\n     */\n    setLanguages(languages?: string[]): void {\n        // to be overloaded by subclasses\n    }\n\n    /**\n     * This method is called when [[MapView]] needs to visualize or preload the content of a\n     * [[TileKey]].\n     *\n     * @param tileKey The unique identifier for a map tile.\n     */\n    abstract getTile(tileKey: TileKey): Tile | undefined;\n\n    /**\n     * This method is called by [[MapView]] before the tile needs to be updated, for example after\n     * a theme change.\n     *\n     * @param tile The [[Tile]] to update.\n     */\n    // tslint:disable-next-line:no-unused-variable\n    updateTile(tile: Tile) {\n        // to be overloaded by subclasses\n    }\n\n    /**\n     * This method is called by the [[MapView]] to determine if the content of the surrounding\n     * tiles must be preloaded.\n     *\n     * @returns `true` if the [[MapView]] should try to preload tiles surrounding the visible\n     * tiles; `false` otherwise. The default is `false`.\n     */\n    shouldPreloadTiles(): boolean {\n        return false;\n    }\n\n    /**\n     * The minimum zoom level to use for display.\n     *\n     * @returns The minimum zoom level to use for display.\n     */\n    get minZoomLevel(): number {\n        return this.m_minZoomLevel;\n    }\n\n    set minZoomLevel(level: number) {\n        this.m_minZoomLevel = level;\n    }\n\n    /**\n     * The maximum zoom level to use for display.\n     */\n    get maxZoomLevel(): number {\n        return this.m_maxZoomLevel;\n    }\n\n    set maxZoomLevel(level: number) {\n        this.m_maxZoomLevel = level;\n    }\n\n    /**\n     * Maximum geometry height above ground level this `DataSource` can produce.\n     *\n     * Used in first stage of frustum culling before [[Tile.maxGeometryHeight]] data is available.\n     *\n     * @default 0.\n     */\n    get maxGeometryHeight() {\n        return this.m_maxGeometryHeight;\n    }\n    set maxGeometryHeight(value: number) {\n        this.m_maxGeometryHeight = value;\n    }\n\n    /**\n     * The difference between storage level and display level of tile.\n     *\n     * Storage level offset is a value applied (added) to current zoom level giving\n     * a final tile level being displayed. This way we may differentate current\n     * zoom level from the storage level that is displayed, giving fine grained\n     * control over the tiles being decoded an displayed.\n     */\n    get storageLevelOffset() {\n        return this.m_storageLevelOffset;\n    }\n\n    /**\n     * Setup the relative offset between storage level and display level of tile.\n     *\n     * @param levelOffset Difference between zoom level and display level.\n     */\n    set storageLevelOffset(levelOffset: number) {\n        this.m_storageLevelOffset = levelOffset;\n    }\n\n    /**\n     * Enables or disables overlay of geometry on elevation. It must be overloaded by data sources\n     * supporting this feature.\n     *\n     * @param value True to enable, false to disable.\n     */\n    setEnableElevationOverlay(enable: boolean) {\n        // to be overloaded by subclasses\n    }\n\n    /**\n     * Computes the zoom level to use for display.\n     *\n     * @param zoomLevel The zoom level of the [[MapView]].\n     * @returns The zoom level to use for display.\n     */\n    getDisplayZoomLevel(zoomLevel: number): number {\n        return THREE.Math.clamp(\n            zoomLevel + this.m_storageLevelOffset,\n            this.m_minZoomLevel,\n            this.m_maxZoomLevel\n        );\n    }\n\n    /**\n     * Returns `true` if [[MapView]] should render the tile with given [[TileKey]] and zoom level.\n     *\n     * @param zoomLevel The zoom level of the [[MapView]].\n     * @param tileKey The unique identifier for a map tile.\n     * @returns `true` if the geometries created for the given [[TileKey]] should be rendered.\n     */\n    shouldRender(zoomLevel: number, tileKey: TileKey): boolean {\n        return tileKey.level === zoomLevel;\n    }\n\n    /**\n     * Returns `true` if [[MapView]] should traverse tiles further with given [[TileKey]] and\n     * zoom level.\n     *\n     * @param zoomLevel The zoom level of the [[MapView]].\n     * @param tileKey The unique identifier for a map tile.\n     * @returns `true` if the subtiles of the given [[TileKey]] should be\n     * checked for collisions.\n     */\n    shouldSubdivide(zoomLevel: number, tileKey: TileKey): boolean {\n        return tileKey.level <= zoomLevel;\n    }\n\n    /**\n     * Returns `true` if [[MapView]] should render the text elements with the given [[TileKey]] and\n     * zoom level.\n     *\n     * This is an additional check for the tiles that are already selected for rendering so the\n     * default implementation returns `true`.\n     *\n     * @param zoomLevel The zoom level.\n     * @param tileKey The unique identifier for a map tile.\n     * @returns `true` if the text elements created for the given [[TileKey]] should be rendered.\n     */\n    // tslint:disable-next-line:no-unused-variable\n    shouldRenderText(zoomLevel: number, tileKey: TileKey): boolean {\n        return true;\n    }\n\n    /**\n     * Sends a request to the [[MapView]] to redraw the scene.\n     */\n    requestUpdate() {\n        this.dispatchEvent(UPDATE_EVENT);\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { UnicodeUtils } from \"../utils/UnicodeUtils\";\nimport { Font } from \"./FontCatalog\";\n\n/**\n * Structure containing all the required information necessary to render a BMFont glyph using\n * [[TextCanvas]].\n */\nexport class GlyphData {\n    /**\n     * Unicode character represented by this glyph.\n     */\n    readonly character: string;\n\n    /**\n     * Glyph' direction.\n     */\n    readonly direction: UnicodeUtils.Direction;\n\n    /**\n     * Array containing the positions for all corners of this glyph.\n     */\n    positions: THREE.Vector3[] = [];\n\n    /**\n     * Array containing the source texture coordinates for all corners of this glyph.\n     * Used to sample the original texture atlas pages.\n     */\n    sourceTextureCoordinates: THREE.Vector2[] = [];\n\n    /**\n     * Array containing the dynamic texture coordinates for all corners of this glyph.\n     * Used to sample the dynamic texture atlas page.\n     */\n    dynamicTextureCoordinates: THREE.Vector2[] = [];\n\n    /**\n     * Source texture atlas' page copy index.\n     */\n    copyIndex: number = 0;\n\n    /**\n     * Flag indicating if glyph can be currently rendered.\n     */\n    isInCache: boolean = false;\n\n    /**\n     * Creates a new `GlyphData` object.\n     *\n     * @param codePoint Unicode code point.\n     * @param block Unicode block.\n     * @param width Glyph' width.\n     * @param height Glyph' height.\n     * @param advanceX Amount of pixel to move after placing this glyph.\n     * @param offsetX Horizontal offset from the glyph' origin.\n     * @param offsetY Vertical offset from the glyph' origin.\n     * @param u0 Glyph' left texture coordinate.\n     * @param v0 Glyph' bottom texture coordinate.\n     * @param u1 Glyph' right texture coordinate.\n     * @param v1 Glyph' top texture coordinate.\n     * @param texture Glyph' source texture atlas page.\n     * @param font Glyph' font.\n     *\n     * @returns New `GlyphData`.\n     */\n    constructor(\n        readonly codePoint: number,\n        readonly block: string,\n        readonly width: number,\n        readonly height: number,\n        readonly advanceX: number,\n        readonly offsetX: number,\n        readonly offsetY: number,\n        u0: number,\n        v0: number,\n        u1: number,\n        v1: number,\n        readonly texture: THREE.Texture,\n        readonly font: Font\n    ) {\n        this.character = String.fromCodePoint(codePoint);\n        this.direction = UnicodeUtils.getDirection(codePoint, block);\n\n        const left = this.offsetX;\n        const right = left + this.width;\n        const top = font.metrics.lineHeight - this.offsetY;\n        const bottom = top - this.height;\n\n        this.positions.push(\n            new THREE.Vector3(left, bottom, 1.0),\n            new THREE.Vector3(right, bottom, 1.0),\n            new THREE.Vector3(left, top, 1.0),\n            new THREE.Vector3(right, top, 1.0)\n        );\n\n        this.sourceTextureCoordinates.push(\n            new THREE.Vector2(u0, v0),\n            new THREE.Vector2(u1, v0),\n            new THREE.Vector2(u0, v1),\n            new THREE.Vector2(u1, v1)\n        );\n\n        this.dynamicTextureCoordinates.push(\n            new THREE.Vector2(0.0, 0.0),\n            new THREE.Vector2(1.0, 0.0),\n            new THREE.Vector2(0.0, 1.0),\n            new THREE.Vector2(1.0, 1.0)\n        );\n    }\n\n    /**\n     * Clone this `GlyphData`.\n     *\n     * @returns Cloned `GlyphData`.\n     */\n    clone(): GlyphData {\n        return new GlyphData(\n            this.codePoint,\n            this.block,\n            this.width,\n            this.height,\n            this.advanceX,\n            this.offsetX,\n            this.offsetY,\n            this.sourceTextureCoordinates[0].x,\n            this.sourceTextureCoordinates[0].y,\n            this.sourceTextureCoordinates[3].x,\n            this.sourceTextureCoordinates[3].y,\n            this.texture,\n            this.font\n        );\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport * from \"./lib/LRUCache\";\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport * as THREE from \"three\";\n\nimport { MemoryUsage } from \"../TextCanvas\";\nimport { GlyphData } from \"./GlyphData\";\nimport { TextBufferObject } from \"./TextBufferObject\";\nimport { TextRenderStyle } from \"./TextStyle\";\n\nexport const MAX_CAPACITY = 65536;\nexport const VERTEX_BUFFER_STRIDE = 16;\nexport const INDEX_BUFFER_STRIDE = 1;\nexport const VERTICES_PER_QUAD = 4;\nexport const INDICES_PER_QUAD = 6;\nexport const QUAD_VERTEX_MEMORY_FOOTPRINT = VERTICES_PER_QUAD * VERTEX_BUFFER_STRIDE;\nexport const QUAD_INDEX_MEMORY_FOOTPRINT = INDICES_PER_QUAD * INDEX_BUFFER_STRIDE;\n\n/**\n * Number of bytes for float in an Float32Array.\n */\nconst NUM_BYTES_PER_FLOAT = 4;\n\n/**\n * Number of bytes for integer number in an UInt32Array.\n */\nconst NUM_BYTES_PER_INT32 = 4;\n\n/**\n * Interface containing user-supplied picking data, as well as the [[TextGeometry]] range it's\n * assigned to.\n */\ninterface PickingData {\n    start: number;\n    end: number;\n    data: any;\n}\n\n/**\n * Procedural geometry that holds vertex attribute data for all glyphs in a [[TextCanvas]].\n */\nexport class TextGeometry {\n    /**\n     * Count of currently drawn glyphs.\n     */\n    get drawCount(): number {\n        return this.m_drawCount;\n    }\n\n    /**\n     * Mesh used to render foreground glyphs.\n     */\n    get mesh(): THREE.Mesh {\n        return this.m_mesh;\n    }\n\n    /**\n     * Mesh used to render background glyphs.\n     */\n    get backgroundMesh(): THREE.Mesh {\n        return this.m_bgMesh;\n    }\n    /**\n     * Maximum glyph capacity.\n     */\n    readonly capacity: number;\n\n    private m_currentCapacity: number;\n    private m_drawCount: number;\n    private m_updateOffset: number;\n\n    private m_vertexBuffer: THREE.InterleavedBuffer;\n    private m_positionAttribute: THREE.InterleavedBufferAttribute;\n    private m_uvAttribute: THREE.InterleavedBufferAttribute;\n    private m_colorAttribute: THREE.InterleavedBufferAttribute;\n    private m_bgColorAttribute: THREE.InterleavedBufferAttribute;\n    private m_indexBuffer: THREE.BufferAttribute;\n\n    private m_geometry: THREE.BufferGeometry;\n    private m_mesh: THREE.Mesh;\n    private m_bgMesh: THREE.Mesh;\n\n    private m_pickingCount: number;\n    private m_pickingDataArray: PickingData[];\n\n    /**\n     * Creates a new `TextGeometry`.\n     *\n     * @param material Material used to render foreground glyphs.\n     * @param backgroundMaterial Material used to render background glyphs.\n     * @param initialSize Initial amount of glyphs that can be stored.\n     * @param capacity Maximum glyph capacity.\n     *\n     * @returns New `TextGeometry`.\n     */\n    constructor(\n        readonly scene: THREE.Scene,\n        material: THREE.Material,\n        backgroundMaterial: THREE.Material,\n        initialSize: number,\n        capacity: number\n    ) {\n        this.capacity = Math.min(capacity, MAX_CAPACITY);\n        this.m_currentCapacity = Math.min(initialSize, capacity);\n        this.m_drawCount = 0;\n        this.m_updateOffset = 0;\n        this.m_pickingCount = 0;\n\n        this.m_vertexBuffer = new THREE.InterleavedBuffer(\n            new Float32Array(this.m_currentCapacity * QUAD_VERTEX_MEMORY_FOOTPRINT),\n            VERTEX_BUFFER_STRIDE\n        );\n        this.m_vertexBuffer.setUsage(THREE.DynamicDrawUsage);\n        this.m_positionAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 0);\n        this.m_uvAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 4);\n        this.m_colorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 8);\n        this.m_bgColorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 12);\n\n        this.m_indexBuffer = new THREE.BufferAttribute(\n            new Uint32Array(this.m_currentCapacity * QUAD_INDEX_MEMORY_FOOTPRINT),\n            INDEX_BUFFER_STRIDE\n        );\n        this.m_indexBuffer.setUsage(THREE.DynamicDrawUsage);\n\n        this.m_geometry = new THREE.BufferGeometry();\n        this.m_geometry.setAttribute(\"position\", this.m_positionAttribute);\n        this.m_geometry.setAttribute(\"uv\", this.m_uvAttribute);\n        this.m_geometry.setAttribute(\"color\", this.m_colorAttribute);\n        this.m_geometry.setAttribute(\"bgColor\", this.m_bgColorAttribute);\n        this.m_geometry.setIndex(this.m_indexBuffer);\n\n        this.m_pickingDataArray = new Array(this.m_currentCapacity);\n\n        this.m_mesh = new THREE.Mesh(this.m_geometry, material);\n        this.m_bgMesh = new THREE.Mesh(this.m_geometry, backgroundMaterial);\n        this.m_mesh.renderOrder = Number.MAX_SAFE_INTEGER;\n        this.m_bgMesh.renderOrder = Number.MAX_SAFE_INTEGER - 1;\n        this.m_mesh.frustumCulled = false;\n        this.m_bgMesh.frustumCulled = false;\n        this.scene.add(this.m_bgMesh, this.m_mesh);\n    }\n\n    /**\n     * Release all allocated resources.\n     */\n    dispose() {\n        this.scene.remove(this.m_bgMesh, this.m_mesh);\n        this.m_geometry.dispose();\n    }\n\n    /**\n     * Clear the geometry.\n     */\n    clear() {\n        this.m_drawCount = 0;\n        this.m_updateOffset = 0;\n        this.m_pickingCount = 0;\n    }\n\n    /**\n     * Update the GPU resources to reflect the latest additions to the geometry.\n     */\n    update() {\n        if (this.drawCount > this.m_updateOffset) {\n            this.m_vertexBuffer.needsUpdate = true;\n            this.m_vertexBuffer.updateRange.offset =\n                this.m_updateOffset * QUAD_VERTEX_MEMORY_FOOTPRINT;\n            this.m_vertexBuffer.updateRange.count =\n                (this.m_drawCount - this.m_updateOffset) * QUAD_VERTEX_MEMORY_FOOTPRINT;\n            this.m_indexBuffer.needsUpdate = true;\n            this.m_indexBuffer.updateRange.offset =\n                this.m_updateOffset * QUAD_INDEX_MEMORY_FOOTPRINT;\n            this.m_indexBuffer.updateRange.count =\n                (this.m_drawCount - this.m_updateOffset) * QUAD_INDEX_MEMORY_FOOTPRINT;\n        }\n        this.m_updateOffset = this.m_drawCount;\n        this.m_geometry.setDrawRange(0, this.m_drawCount * INDICES_PER_QUAD);\n    }\n\n    /**\n     * Add a new glyph to the `TextGeometry`.\n     *\n     * @param glyphData [[GlyphData]] holding the glyph description.\n     * @param corners Transformed glyph corners.\n     * @param weight Foreground glyph sampling weight.\n     * @param bgWeight Foreground glyph sampling weight.\n     * @param mirrored If `true`, UVs will be horizontally mirrored (needed for RTL punctuation).\n     * @param style Currently set [[TextRenderStyle]].\n     *\n     * @returns Result of the addition.\n     */\n    add(\n        glyphData: GlyphData,\n        corners: THREE.Vector3[],\n        weight: number,\n        bgWeight: number,\n        mirrored: boolean,\n        style: TextRenderStyle\n    ): boolean {\n        if (this.m_drawCount >= this.capacity) {\n            return false;\n        } else if (this.m_drawCount >= this.m_currentCapacity) {\n            const newSize = Math.min(this.m_currentCapacity * 2, this.capacity);\n            this.resizeBuffers(newSize);\n        }\n\n        const baseVertex = this.m_drawCount * VERTICES_PER_QUAD;\n        const baseIndex = this.m_drawCount * INDICES_PER_QUAD;\n\n        for (let i = 0; i < VERTICES_PER_QUAD; ++i) {\n            this.m_positionAttribute.setXYZW(\n                baseVertex + i,\n                corners[i].x,\n                corners[i].y,\n                corners[i].z,\n                (mirrored ? -1.0 : 1.0) * style.rotation\n            );\n            const mirroredUVIdx = mirrored ? ((i + 1) % 2) + Math.floor(i / 2) * 2 : i;\n            this.m_uvAttribute.setXYZW(\n                baseVertex + i,\n                glyphData.dynamicTextureCoordinates[mirroredUVIdx].x,\n                glyphData.dynamicTextureCoordinates[mirroredUVIdx].y,\n                weight,\n                bgWeight\n            );\n            this.m_colorAttribute.setXYZW(\n                baseVertex + i,\n                style.color.r,\n                style.color.g,\n                style.color.b,\n                style.opacity\n            );\n            this.m_bgColorAttribute.setXYZW(\n                baseVertex + i,\n                style.backgroundColor.r,\n                style.backgroundColor.g,\n                style.backgroundColor.b,\n                style.backgroundOpacity\n            );\n        }\n\n        this.m_indexBuffer.setX(baseIndex, baseVertex);\n        this.m_indexBuffer.setX(baseIndex + 1, baseVertex + 1);\n        this.m_indexBuffer.setX(baseIndex + 2, baseVertex + 2);\n        this.m_indexBuffer.setX(baseIndex + 3, baseVertex + 2);\n        this.m_indexBuffer.setX(baseIndex + 4, baseVertex + 1);\n        this.m_indexBuffer.setX(baseIndex + 5, baseVertex + 3);\n\n        ++this.m_drawCount;\n        return true;\n    }\n\n    /**\n     * Add a new glyph to a text buffer.\n     *\n     * @param buffer Target buffer where glyph attributes will be stored.\n     * @param offset Offset of the target buffer.\n     * @param glyphData [[GlyphData]] holding the glyph description.\n     * @param corners Transformed glyph corners.\n     * @param weight Foreground glyph sampling weight.\n     * @param bgWeight Foreground glyph sampling weight.\n     * @param mirrored If `true`, UVs will be mirrored (needed for RTL punctuation).\n     * @param style Currently set [[TextRenderStyle]].\n     */\n    addToBuffer(\n        buffer: Float32Array,\n        offset: number,\n        glyphData: GlyphData,\n        corners: THREE.Vector3[],\n        weight: number,\n        bgWeight: number,\n        mirrored: boolean,\n        style: TextRenderStyle\n    ): void {\n        for (let i = 0; i < VERTICES_PER_QUAD; ++i) {\n            const vertexOffset = offset + VERTEX_BUFFER_STRIDE * i;\n            buffer[vertexOffset] = corners[i].x;\n            buffer[vertexOffset + 1] = corners[i].y;\n            buffer[vertexOffset + 2] = corners[i].z;\n            buffer[vertexOffset + 3] = (mirrored ? -1.0 : 1.0) * style.rotation;\n\n            const mirroredUVIdx = mirrored ? ((i + 1) % 2) + Math.floor(i / 2) * 2 : i;\n            buffer[vertexOffset + 4] = glyphData.dynamicTextureCoordinates[mirroredUVIdx].x;\n            buffer[vertexOffset + 5] = glyphData.dynamicTextureCoordinates[mirroredUVIdx].y;\n            buffer[vertexOffset + 6] = weight;\n            buffer[vertexOffset + 7] = bgWeight;\n\n            buffer[vertexOffset + 8] = style.color.r;\n            buffer[vertexOffset + 9] = style.color.g;\n            buffer[vertexOffset + 10] = style.color.b;\n            buffer[vertexOffset + 11] = style.opacity;\n\n            buffer[vertexOffset + 12] = style.backgroundColor.r;\n            buffer[vertexOffset + 13] = style.backgroundColor.g;\n            buffer[vertexOffset + 14] = style.backgroundColor.b;\n            buffer[vertexOffset + 15] = style.backgroundOpacity;\n        }\n    }\n\n    /**\n     * Add a previously computed [[TextBufferObject]] to the `TextGeometry`. Extra parameters can\n     * be passed to override the passed attribute data.\n     *\n     * @param textBufferObject [[TextBufferObject]] containing computed glyphs.\n     * @param position Override position value.\n     * @param scale Override scale value.\n     * @param rotation Override rotation value.\n     * @param color Override color value.\n     * @param opacity Override opacity value.\n     * @param bgColor Override background color value.\n     * @param bgOpacity Override background opacity value.\n     *\n     * @returns Result of the addition.\n     */\n    addTextBufferObject(\n        textBufferObject: TextBufferObject,\n        position?: THREE.Vector3,\n        scale?: number,\n        rotation?: number,\n        color?: THREE.Color,\n        opacity?: number,\n        bgColor?: THREE.Color,\n        bgOpacity?: number\n    ): boolean {\n        if (this.m_drawCount + textBufferObject.glyphs.length >= this.capacity) {\n            return false;\n        } else if (this.m_drawCount + textBufferObject.glyphs.length >= this.m_currentCapacity) {\n            const newSize = Math.min(this.m_currentCapacity * 2, this.capacity);\n            this.resizeBuffers(newSize);\n        }\n\n        const s = scale || 1.0;\n        const r = rotation || 0.0;\n        const cosR = Math.cos(r);\n        const sinR = Math.sin(r);\n        const offsetX = position !== undefined ? position.x : 0.0;\n        const offsetY = position !== undefined ? position.y : 0.0;\n        const offsetZ = position !== undefined ? position.z : 0.0;\n\n        const buffer = textBufferObject.buffer;\n\n        const rot = buffer[3];\n        const rotSign = rot < 0 ? -1.0 : 1.0;\n\n        const red = color !== undefined ? color.r : buffer[8];\n        const green = color !== undefined ? color.g : buffer[9];\n        const blue = color !== undefined ? color.b : buffer[10];\n        const alpha = opacity !== undefined ? opacity : buffer[11];\n        const bgRed = bgColor !== undefined ? bgColor.r : buffer[12];\n        const bgGreen = bgColor !== undefined ? bgColor.g : buffer[13];\n        const bgBlue = bgColor !== undefined ? bgColor.b : buffer[14];\n        const bgAlpha = bgOpacity !== undefined ? bgOpacity : buffer[15];\n\n        const targetOffset = this.m_drawCount * VERTICES_PER_QUAD;\n        for (let i = 0; i < textBufferObject.glyphs.length; ++i) {\n            const srcOffset = i * QUAD_VERTEX_MEMORY_FOOTPRINT;\n\n            const glyph = textBufferObject.glyphs[i];\n            if (!glyph.isInCache) {\n                return false;\n            }\n\n            const mirrored = buffer[srcOffset + 4] > buffer[srcOffset + VERTEX_BUFFER_STRIDE + 4];\n            const w = buffer[srcOffset + 6];\n            const bw = buffer[srcOffset + 7];\n\n            for (let j = 0; j < VERTICES_PER_QUAD; ++j) {\n                const x = buffer[srcOffset + j * VERTEX_BUFFER_STRIDE];\n                const y = buffer[srcOffset + j * VERTEX_BUFFER_STRIDE + 1];\n                this.m_positionAttribute.setXYZW(\n                    targetOffset + i * VERTICES_PER_QUAD + j,\n                    x * s * cosR + y * s * -sinR + offsetX,\n                    x * s * sinR + y * s * cosR + offsetY,\n                    buffer[srcOffset + j * VERTEX_BUFFER_STRIDE + 2] + offsetZ,\n                    buffer[srcOffset + j * VERTEX_BUFFER_STRIDE + 3] + rotSign * r\n                );\n                const mirroredUVIdx = mirrored ? ((j + 1) % 2) + Math.floor(j / 2) * 2 : j;\n                this.m_uvAttribute.setXYZW(\n                    targetOffset + i * VERTICES_PER_QUAD + j,\n                    glyph.dynamicTextureCoordinates[mirroredUVIdx].x,\n                    glyph.dynamicTextureCoordinates[mirroredUVIdx].y,\n                    w,\n                    (bw - w) / s + w\n                );\n                this.m_colorAttribute.setXYZW(\n                    targetOffset + i * VERTICES_PER_QUAD + j,\n                    red,\n                    green,\n                    blue,\n                    alpha\n                );\n                this.m_bgColorAttribute.setXYZW(\n                    targetOffset + i * VERTICES_PER_QUAD + j,\n                    bgRed,\n                    bgGreen,\n                    bgBlue,\n                    bgAlpha\n                );\n            }\n\n            this.m_indexBuffer.setX(\n                (this.m_drawCount + i) * INDICES_PER_QUAD,\n                (this.m_drawCount + i) * VERTICES_PER_QUAD\n            );\n            this.m_indexBuffer.setX(\n                (this.m_drawCount + i) * INDICES_PER_QUAD + 1,\n                (this.m_drawCount + i) * VERTICES_PER_QUAD + 1\n            );\n            this.m_indexBuffer.setX(\n                (this.m_drawCount + i) * INDICES_PER_QUAD + 2,\n                (this.m_drawCount + i) * VERTICES_PER_QUAD + 2\n            );\n            this.m_indexBuffer.setX(\n                (this.m_drawCount + i) * INDICES_PER_QUAD + 3,\n                (this.m_drawCount + i) * VERTICES_PER_QUAD + 2\n            );\n            this.m_indexBuffer.setX(\n                (this.m_drawCount + i) * INDICES_PER_QUAD + 4,\n                (this.m_drawCount + i) * VERTICES_PER_QUAD + 1\n            );\n            this.m_indexBuffer.setX(\n                (this.m_drawCount + i) * INDICES_PER_QUAD + 5,\n                (this.m_drawCount + i) * VERTICES_PER_QUAD + 3\n            );\n        }\n\n        this.m_drawCount += textBufferObject.glyphs.length;\n        return true;\n    }\n\n    /**\n     * Adds picking data for glyphs from the specified start until the last glyph added.\n     *\n     * @param startIdx First glyph index that this picking data is associated to.\n     * @param endIdx Last glyph index that this picking data is associated to.\n     * @param pickingData Picking data to be added.\n     */\n    addPickingData(startIdx: number, endIdx: number, pickingData: any): boolean {\n        if (this.m_pickingCount >= this.m_currentCapacity) {\n            return false;\n        }\n\n        this.m_pickingDataArray[this.m_pickingCount] = {\n            start: Math.min(startIdx, this.capacity),\n            end: Math.min(endIdx, this.capacity),\n            data: pickingData\n        };\n\n        ++this.m_pickingCount;\n        return true;\n    }\n\n    /**\n     * Fill the picking results for the pixel with the given screen coordinate. If multiple glyphs\n     * are found, the order of the results is unspecified.\n     *\n     * @param screenPosition Screen coordinate of picking position.\n     * @param pickCallback Callback to be called for every picked element.\n     */\n    pick(screenPosition: THREE.Vector2, pickCallback: (pickData: any | undefined) => void) {\n        for (const pickingData of this.m_pickingDataArray) {\n            if (pickingData === undefined) {\n                return;\n            }\n\n            for (let i = pickingData.start; i < pickingData.end; ++i) {\n                const positionIndex = i * VERTICES_PER_QUAD;\n\n                const minX = Math.min(\n                    this.m_positionAttribute.getX(positionIndex + 2),\n                    this.m_positionAttribute.getX(positionIndex + 1)\n                );\n                if (screenPosition.x < minX) {\n                    continue;\n                }\n\n                const maxX = Math.max(\n                    this.m_positionAttribute.getX(positionIndex + 2),\n                    this.m_positionAttribute.getX(positionIndex + 1)\n                );\n                if (screenPosition.x > maxX) {\n                    continue;\n                }\n\n                const minY = Math.min(\n                    this.m_positionAttribute.getY(positionIndex + 2),\n                    this.m_positionAttribute.getY(positionIndex + 1)\n                );\n                if (screenPosition.y < minY) {\n                    continue;\n                }\n\n                const maxY = Math.max(\n                    this.m_positionAttribute.getY(positionIndex + 2),\n                    this.m_positionAttribute.getY(positionIndex + 1)\n                );\n                if (screenPosition.y > maxY) {\n                    continue;\n                }\n\n                pickCallback(pickingData.data);\n                break;\n            }\n        }\n    }\n\n    /**\n     * Update the info with the memory footprint caused by objects owned by the `TextGeometry`.\n     *\n     * @param info The info object to increment with the values from this `TextGeometry`.\n     */\n    updateMemoryUsage(info: MemoryUsage) {\n        const numBytes =\n            this.m_vertexBuffer.count * NUM_BYTES_PER_FLOAT +\n            this.m_indexBuffer.count * NUM_BYTES_PER_INT32;\n        info.heapSize += numBytes;\n        info.gpuSize += numBytes;\n    }\n\n    private resizeBuffers(size: number) {\n        this.m_currentCapacity = size;\n\n        const newVertexBuffer = new Float32Array(size * QUAD_VERTEX_MEMORY_FOOTPRINT);\n        newVertexBuffer.set(this.m_vertexBuffer.array);\n        this.m_vertexBuffer = new THREE.InterleavedBuffer(newVertexBuffer, VERTEX_BUFFER_STRIDE);\n        this.m_vertexBuffer.setUsage(THREE.DynamicDrawUsage);\n        this.m_positionAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 0);\n        this.m_uvAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 4);\n        this.m_colorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 8);\n        this.m_bgColorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 12);\n\n        const newIndexBuffer = new Uint32Array(size * QUAD_INDEX_MEMORY_FOOTPRINT);\n        newIndexBuffer.set(this.m_indexBuffer.array);\n        this.m_indexBuffer = new THREE.BufferAttribute(newIndexBuffer, INDEX_BUFFER_STRIDE);\n        this.m_indexBuffer.setUsage(THREE.DynamicDrawUsage);\n\n        this.m_geometry.dispose();\n        this.m_geometry = new THREE.BufferGeometry();\n        this.m_geometry.setAttribute(\"position\", this.m_positionAttribute);\n        this.m_geometry.setAttribute(\"uv\", this.m_uvAttribute);\n        this.m_geometry.setAttribute(\"color\", this.m_colorAttribute);\n        this.m_geometry.setAttribute(\"bgColor\", this.m_bgColorAttribute);\n        this.m_geometry.setIndex(this.m_indexBuffer);\n\n        this.m_pickingDataArray.length = this.m_currentCapacity;\n\n        this.scene.remove(this.m_bgMesh, this.m_mesh);\n        this.m_mesh = new THREE.Mesh(this.m_geometry, this.m_mesh.material);\n        this.m_bgMesh = new THREE.Mesh(this.m_geometry, this.m_bgMesh.material);\n        this.m_mesh.renderOrder = Number.MAX_SAFE_INTEGER;\n        this.m_bgMesh.renderOrder = Number.MAX_SAFE_INTEGER - 1;\n        this.m_mesh.frustumCulled = false;\n        this.m_bgMesh.frustumCulled = false;\n        this.scene.add(this.m_bgMesh, this.m_mesh);\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { GlyphData } from \"../rendering/GlyphData\";\nimport { FontUnit, FontVariant } from \"../rendering/TextStyle\";\nimport { UnicodeUtils } from \"../utils/UnicodeUtils\";\n\n/**\n * Collection of different constants and utility functions used by [[Typesetter]]s.\n */\nexport namespace TypesettingUtils {\n    /**\n     * Ratio between EMs and Pixels.\n     */\n    export const EM_TO_PX = 16.0;\n\n    /**\n     * Ratio between Points and Pixels.\n     */\n    export const PT_TO_PX = 1.25;\n\n    /**\n     * Angle used when emulating italic fonts (oblique).\n     */\n    export const OBLIQUE_ANGLE = 0.174533;\n\n    /**\n     * Horizontal offset used when emulating italic fonts (oblique).\n     */\n    export const OBLIQUE_OFFSET = Math.tan(OBLIQUE_ANGLE);\n\n    /**\n     * Convert between any size specified in any [[FontUnit]] to pixels.\n     *\n     * @param size Font size (specified in `unit`).\n     * @param unit Size unit.\n     * @param originalSize Original size (pixels)\n     *\n     * @returns Pixel size.\n     */\n    export function getPixelSize(size: number, unit: FontUnit, originalSize: number) {\n        let result = size;\n        switch (unit) {\n            case FontUnit.Em:\n                result *= EM_TO_PX;\n                break;\n            case FontUnit.Point:\n                result *= PT_TO_PX;\n                break;\n            case FontUnit.Percent:\n                result *= (1.0 / 100) * originalSize;\n                break;\n        }\n        return result;\n    }\n\n    /**\n     * Gets the scale applied to a certain character when using the [[FontVariant]].`SmallCaps`.\n     *\n     * @param glyphs Array containing [[TransformedGlyphData]].\n     * @param index Index to `glyphDataArray`.\n     * @param fontVariant Currently active [[FontVariant]].\n     *\n     * @returns Glyph `SmallCaps` scale.\n     */\n    export function getSmallCapsScale(\n        glyphs: GlyphData[],\n        smallCapsTransformations: boolean[],\n        index: number,\n        fontVariant: FontVariant\n    ): number {\n        const isSmallCaps =\n            smallCapsTransformations[index] && fontVariant === FontVariant.SmallCaps;\n        return isSmallCaps\n            ? glyphs[index].font.metrics.xHeight / glyphs[index].font.metrics.capHeight\n            : 1.0;\n    }\n\n    /**\n     * Returns the first strong direction (LTR or RTL) found for a given array of [[GlyphData]].\n     *\n     * @param glyphs Array containing [[GlyphData]].\n     * @param offset `glyphDataArray` offset.\n     *\n     * @returns Strong direction.\n     */\n    export function getDirection(glyphs: GlyphData[], offset: number): UnicodeUtils.Direction {\n        let result = UnicodeUtils.Direction.LTR;\n        let index = offset;\n        while (\n            glyphs[index].direction !== UnicodeUtils.Direction.LTR &&\n            glyphs[index].direction !== UnicodeUtils.Direction.RTL &&\n            index < glyphs.length - 1\n        ) {\n            ++index;\n        }\n\n        if (Math.abs(glyphs[index].direction) === 1.0) {\n            result = glyphs[index].direction;\n        }\n        return result;\n    }\n\n    /**\n     * Computes the transformation matrix for a glyph.\n     *\n     * @param transform Matrix used to store the results.\n     * @param position Glyph' position.\n     * @param scale Glyph' scale.\n     * @param rotation [[TextCanvas]] rotation.\n     * @param localRotation Glyph' local rotation.\n     */\n    export function computeGlyphTransform(\n        transform: THREE.Matrix3,\n        position: THREE.Vector3,\n        scale: number,\n        rotation: number,\n        localRotation: number\n    ): void {\n        const cosAngle = Math.cos(rotation);\n        const sinAngle = Math.sin(rotation);\n        const localCosAngle = Math.cos(localRotation);\n        const localSinAngle = Math.sin(localRotation);\n        transform.set(\n            scale * localCosAngle,\n            scale * -localSinAngle,\n            cosAngle * position.x - sinAngle * position.y,\n            scale * localSinAngle,\n            scale * localCosAngle,\n            sinAngle * position.x + cosAngle * position.y,\n            0,\n            0,\n            1.0\n        );\n    }\n\n    /**\n     * Updates the supplied bounds with the computed screen-space corners for a given glyph.\n     *\n     * @param corners Glyph' corners.\n     * @param globalBounds Global text bounds.\n     * @param individualBounds Individual per-character bounds.\n     */\n    export function updateBounds(\n        corners: THREE.Vector3[],\n        globalBounds: THREE.Box2,\n        individualBounds?: { array: THREE.Box2[]; offset: number }\n    ): void {\n        const minX = Math.min(corners[0].x, corners[1].x, corners[2].x, corners[3].x);\n        const maxX = Math.max(corners[0].x, corners[1].x, corners[2].x, corners[3].x);\n        const minY = Math.min(corners[0].y, corners[1].y, corners[2].y, corners[3].y);\n        const maxY = Math.max(corners[0].y, corners[1].y, corners[2].y, corners[3].y);\n\n        if (individualBounds !== undefined) {\n            if (individualBounds.array[individualBounds.offset] !== undefined) {\n                individualBounds.array[individualBounds.offset].min.set(minX, minY);\n                individualBounds.array[individualBounds.offset].max.set(maxX, maxY);\n            } else {\n                individualBounds.array.push(\n                    new THREE.Box2(new THREE.Vector2(minX, minY), new THREE.Vector2(maxX, maxY))\n                );\n            }\n            ++individualBounds.offset;\n        }\n\n        globalBounds.min.set(\n            Math.min(globalBounds.min.x, minX),\n            Math.min(globalBounds.min.y, minY)\n        );\n        globalBounds.max.set(\n            Math.max(globalBounds.max.x, maxX),\n            Math.max(globalBounds.max.y, maxY)\n        );\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\nimport { PickingRaycaster } from \"./PickingRaycaster\";\n\n/**\n * `MapViewPoints` is a class to extend for the `\"circles\"` and `\"squares\"` [[Technique]]s to\n * implement raycasting of [[THREE.Points]] as expected in [[MapView]], that is in screen space. It\n * copies the behaviour of the `raycast` method in [[THREE.Points]] and dispatches it to its\n * children classes, [[Circles]] and [[Squares]], who hold the intersection testing in the\n * `testPoint` method. This class also has the ability to dismiss the testing via the\n * `enableRayTesting` flag.\n *\n * Its main motivation is to handle the point styles of XYZ projects.\n *\n * @see https://github.com/mrdoob/three.js/blob/master/src/objects/Points.js\n */\nexport abstract class MapViewPoints extends THREE.Points {\n    /**\n     * This allows to discard the ray testing.\n     */\n    enableRayTesting: boolean = true;\n\n    /**\n     * Implements the intersection testing in screen space between the drawn points and the ray. The\n     * drawing of the points being different between [[Circles]] and [[Squares]], this method is\n     * implemented in these child classes.\n     *\n     * @param point The point to test.\n     * @param screenPosition The point position on screen.\n     * @param pickCoordinates The picking position on screen.\n     * @param index The index of the point in the [[THREE.Geometry]].\n     * @param distance The distance between the point and the ray origin.\n     * @param intersects The results array.\n     */\n    abstract testPoint(\n        point: THREE.Vector3,\n        screenPosition: THREE.Vector2,\n        pickCoordinates: THREE.Vector2,\n        index: number,\n        distance: number,\n        intersects: THREE.Intersection[]\n    ): void;\n\n    /**\n     * This method is similar to the original method `raycast` in [[THREE.Points]] except that it\n     * then calls the tailored `testPoint` method in the children classes to test intersections\n     * depending on whether the points are circles or squares, which [[THREE.Points]] cannot do.\n     *\n     * @param raycaster The raycaster.\n     * @param intersects The array to fill with the results.\n     */\n    raycast(raycaster: PickingRaycaster, intersects: THREE.Intersection[]) {\n        if (!this.enableRayTesting) {\n            return;\n        }\n\n        const geometry = this.geometry;\n        const matrixWorld = this.matrixWorld;\n        const screenCoords = raycaster.ray.origin\n            .clone()\n            .add(raycaster.ray.direction)\n            .project(raycaster.mapView.camera);\n        const { clientWidth, clientHeight } = raycaster.mapView.canvas;\n        const mouseCoords = new THREE.Vector2(\n            Math.ceil(((screenCoords.x + 1) / 2) * clientWidth),\n            Math.ceil(((1 - screenCoords.y) / 2) * clientHeight)\n        );\n\n        if (geometry instanceof THREE.BufferGeometry) {\n            const point = new THREE.Vector3();\n            const index = geometry.index;\n            const attributes = geometry.attributes;\n            const positions = attributes.position.array;\n            if (index !== null) {\n                const indices = index.array;\n                for (let i = 0, il = indices.length; i < il; i++) {\n                    const a = indices[i];\n                    point.fromArray(positions as number[], a * 3);\n                    const pointInfo = getPointInfo(\n                        point,\n                        matrixWorld,\n                        raycaster,\n                        clientWidth,\n                        clientHeight\n                    );\n                    if (pointInfo.pointIsOnScreen) {\n                        this.testPoint(\n                            point,\n                            pointInfo.absoluteScreenPosition!,\n                            mouseCoords,\n                            i,\n                            pointInfo.distance!,\n                            intersects\n                        );\n                    }\n                }\n            } else {\n                for (let i = 0, l = positions.length / 3; i < l; i++) {\n                    point.fromArray(positions as number[], i * 3);\n                    const pointInfo = getPointInfo(\n                        point,\n                        matrixWorld,\n                        raycaster,\n                        clientWidth,\n                        clientHeight\n                    );\n                    if (pointInfo.pointIsOnScreen) {\n                        this.testPoint(\n                            point,\n                            pointInfo.absoluteScreenPosition!,\n                            mouseCoords,\n                            i,\n                            pointInfo.distance!,\n                            intersects\n                        );\n                    }\n                }\n            }\n        } else {\n            const vertices = geometry.vertices;\n            for (let index = 0; index < vertices.length; index++) {\n                const point = vertices[index];\n                const pointInfo = getPointInfo(\n                    point,\n                    matrixWorld,\n                    raycaster,\n                    clientWidth,\n                    clientHeight\n                );\n                if (pointInfo.pointIsOnScreen) {\n                    this.testPoint(\n                        point,\n                        pointInfo.absoluteScreenPosition!,\n                        mouseCoords,\n                        index,\n                        pointInfo.distance!,\n                        intersects\n                    );\n                }\n            }\n        }\n    }\n}\n\nfunction getPointInfo(\n    point: THREE.Vector3,\n    matrixWorld: THREE.Matrix4,\n    raycaster: PickingRaycaster,\n    width: number,\n    height: number\n): {\n    pointIsOnScreen: boolean;\n    absoluteScreenPosition?: THREE.Vector2;\n    distance?: number;\n} {\n    const worldPosition = point.clone();\n    worldPosition.applyMatrix4(matrixWorld);\n    const distance = worldPosition.distanceTo(raycaster.ray.origin);\n    worldPosition.project(raycaster.mapView.camera);\n    const relativeScreenPosition = new THREE.Vector2(worldPosition.x, worldPosition.y);\n    const pointIsOnScreen =\n        relativeScreenPosition.x < 1 &&\n        relativeScreenPosition.x > -1 &&\n        relativeScreenPosition.y < 1 &&\n        relativeScreenPosition.y > -1;\n    if (pointIsOnScreen) {\n        worldPosition.x = ((worldPosition.x + 1) / 2) * width;\n        worldPosition.y = ((1 - worldPosition.y) / 2) * height;\n        const absoluteScreenPosition = new THREE.Vector2(worldPosition.x, worldPosition.y);\n        return {\n            absoluteScreenPosition,\n            pointIsOnScreen,\n            distance\n        };\n    }\n    return {\n        pointIsOnScreen\n    };\n}\n\n/**\n * Point object that implements the raycasting of circles in screen space.\n */\nexport class Circles extends MapViewPoints {\n    testPoint(\n        point: THREE.Vector3,\n        screenPosition: THREE.Vector2,\n        pickCoordinates: THREE.Vector2,\n        index: number,\n        distance: number,\n        intersects: THREE.Intersection[]\n    ) {\n        const dx = screenPosition.x - pickCoordinates.x;\n        const dy = screenPosition.y - pickCoordinates.y;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n        const radius = (this.material as THREE.PointsMaterial).size / 2;\n\n        if (dist <= radius) {\n            intersects.push({\n                point,\n                distance,\n                index,\n                object: this\n            });\n        }\n    }\n}\n\n/**\n * Point object that implements the raycasting of squares in screen space.\n */\nexport class Squares extends MapViewPoints {\n    testPoint(\n        point: THREE.Vector3,\n        screenPosition: THREE.Vector2,\n        pickCoordinates: THREE.Vector2,\n        index: number,\n        distance: number,\n        intersects: THREE.Intersection[]\n    ) {\n        const dx = screenPosition.x - pickCoordinates.x;\n        const dy = screenPosition.y - pickCoordinates.y;\n        const halfSize = (this.material as THREE.PointsMaterial).size / 2;\n\n        if (Math.abs(dx) <= halfSize && Math.abs(dy) <= halfSize) {\n            intersects.push({\n                point,\n                distance,\n                index,\n                object: this\n            });\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\n/**\n * Usage in Modules:\n *\n * import { DebugContext, debugContext } from \"../lib/DebugContext\";\n *\n * Declare a debug option:\n * debugContext.settings.setOption(\"MY_DBG_OPT\", \"default\");\n *\n * Access an option:\n * if (debugContext.settings.option(\"MY_DBG_OPT\")) {\n *     ...\n * }\n *\n *\n * Access in browser console:\n *\n * window.__debugContext.settings.addEventListener(\"MY_DBG_OPT\", function(event) {\n *  console.log(\"name:\", event.type, \"value:\", event.value)});\n *\n */\n\n/**\n * Allows access to the global `window` object here. The constructor of [[DebugContext]] adds the\n * instance to `window`, so it is available from the browser console.\n */\n\ninterface DebugInfo {\n    __debugContext?: DebugContext;\n}\n\nconst isNode = typeof window === \"undefined\";\n\n/**\n * A `DebugOption` is a pair that consists of an option value and an array of change listeners.\n * Listeners are called up when setting the option's value.\n */\nclass DebugOption extends THREE.EventDispatcher {\n    static SET_EVENT_TYPE: string = \"set\";\n\n    /**\n     * Constructs the `DebugOption`.\n     *\n     * @param value The value of the option.\n     */\n    constructor(public value: any) {\n        super();\n    }\n\n    /**\n     * Updates the value of a given option.\n     *\n     * @param value The new value for the option.\n     * @param name The name of the option to set.\n     */\n    set(value: any, name: string) {\n        this.value = value;\n        this.dispatchEvent({ type: DebugOption.SET_EVENT_TYPE, name, value });\n    }\n}\n\n/**\n * Maintains a map of [[DebugOption]]s. You can add listeners to debug options by passing their\n * names.\n */\nexport class DebugContext {\n    private m_optionsMap: Map<string, DebugOption>;\n\n    /**\n     * Builds a `DebugContext`.\n     */\n    constructor() {\n        this.m_optionsMap = new Map<string, DebugOption>();\n\n        // If we have a `window` object, we store the context in it to make it available in the\n        // console.\n        if (!isNode && typeof window !== \"undefined\" && window) {\n            const debugInfo = window as DebugInfo;\n            debugInfo.__debugContext = this;\n        }\n    }\n\n    /**\n     * Sets the value of an option. Calls change listeners of that option, even if the value has\n     * not been changed. The change listeners provided here are not called during this set\n     * operation.\n     *\n     * @param name Name of the option.\n     * @param value Value of the option.\n     */\n    setValue(name: string, value: any): void {\n        let opt = this.m_optionsMap.get(name);\n        if (!opt) {\n            opt = new DebugOption(value);\n            this.m_optionsMap.set(name, opt);\n        } else {\n            opt.set(value, name);\n        }\n    }\n\n    /**\n     * Gets the option value.\n     *\n     * @param name Name of option.\n     */\n    getValue(name: string): any {\n        const opt = this.m_optionsMap.get(name);\n        return opt ? opt.value : undefined;\n    }\n\n    /**\n     * Determines if the option is registered.\n     *\n     * @param name Name of option.\n     */\n    hasOption(name: string): boolean {\n        return this.m_optionsMap.get(name) !== undefined;\n    }\n\n    /**\n     * Adds a listener to a debug option.\n     *\n     * @param name Name of the option that requires a listener.\n     * @param listener The listener function to add.\n     */\n    addEventListener(name: string, listener: (event: THREE.Event) => void) {\n        const opt = this.m_optionsMap.get(name);\n        if (opt) {\n            opt.addEventListener(DebugOption.SET_EVENT_TYPE, listener);\n        } else {\n            throw Error(\"Unknown option: \" + name);\n        }\n    }\n\n    /**\n     * Checks for a listener in a debug option.\n     *\n     * @param name Name of the option to check for.\n     * @param listener The listener function to check for.\n     */\n    hasEventListener(name: string, listener: (event: THREE.Event) => void) {\n        const opt = this.m_optionsMap.get(name);\n        if (opt) {\n            return opt.hasEventListener(DebugOption.SET_EVENT_TYPE, listener);\n        } else {\n            throw Error(\"Unknown option: \" + name);\n        }\n    }\n\n    /**\n     * Removes a listener from a debug option.\n     *\n     * @param name Name of the option from which to remove a listener.\n     * @param listener The listener function to remove.\n     */\n    removeEventListener(name: string, listener: (event: THREE.Event) => void) {\n        const opt = this.m_optionsMap.get(name);\n        if (opt) {\n            opt.removeEventListener(DebugOption.SET_EVENT_TYPE, listener);\n        } else {\n            throw Error(\"Unknown option: \" + name);\n        }\n    }\n\n    /**\n     * Provides access to the options map. This method is useful for creating an automatic\n     * browser GUI.\n     */\n    get options(): Map<string, any> {\n        return this.m_optionsMap;\n    }\n\n    /**\n     * Clears away all debug options. Currently, `THREE.EventDispatcher` does not provide an API\n     * to remove all event listeners.\n     */\n    clear() {\n        this.m_optionsMap.forEach(option => {\n            option.set(undefined, \"\");\n        });\n    }\n}\n\nexport const debugContext = new DebugContext();\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {\n    DecodedTile,\n    GeometryKind,\n    GeometryKindSet,\n    isExtrudedLineTechnique,\n    isExtrudedPolygonTechnique,\n    isFillTechnique,\n    isLineMarkerTechnique,\n    isLineTechnique,\n    isPoiTechnique,\n    isSegmentsTechnique,\n    isSolidLineTechnique,\n    isTextTechnique,\n    Technique\n} from \"@here/harp-datasource-protocol\";\nimport { PerformanceTimer } from \"@here/harp-utils\";\n\nimport { PerformanceStatistics } from \"../Statistics\";\nimport { Tile } from \"../Tile\";\nimport { TileGeometryCreator } from \"./TileGeometryCreator\";\n\n/**\n * Loads the geometry for its [[Tile]]. Derived classes allow for different loading strategies.\n */\nexport interface TileGeometryLoader {\n    /**\n     * The [[Tile]] this `TileGeometryLoader` is managing.\n     */\n    tile: Tile;\n\n    /**\n     * `True` if all geometry of the `Tile` has been loaded and the loading process is finished.\n     */\n    isFinished: boolean;\n\n    /**\n     * `True` if the basic geometry has been loaded, and the `Tile` is ready  for display.\n     */\n    basicGeometryLoaded: boolean;\n\n    /**\n     * `True` if all geometry of the `Tile` has been loaded.\n     */\n    allGeometryLoaded: boolean;\n\n    /**\n     * The kinds of geometry stored in this [[Tile]].\n\n     */\n    availableGeometryKinds: GeometryKindSet | undefined;\n\n    /**\n     * Start with or continue with loading geometry. Called repeatedly until `isFinished` is `true`.\n     */\n    update(\n        enabledKinds: GeometryKindSet | undefined,\n        disabledKinds: GeometryKindSet | undefined\n    ): void;\n\n    /**\n     * Dispose of any resources.\n     */\n    dispose(): void;\n\n    /**\n     * Reset the loader to its initial state and cancels any asynchronous work.\n     */\n    reset(): void;\n}\n\nexport namespace TileGeometryLoader {\n    /**\n     * Make sure that all technique have their geometryKind set, either from the theme or their\n     * default value.\n     *\n     * Also gather set of the [[GeometryKind]]s found in the techniques and return it.\n     *\n     * @param {DecodedTile} decodedTile\n     * @returns {GeometryKindSet} The set of kinds used in the decodeTile.\n     */\n    export function prepareDecodedTile(decodedTile: DecodedTile): GeometryKindSet {\n        const foundSet: GeometryKindSet = new GeometryKindSet();\n\n        for (const technique of decodedTile.techniques) {\n            let geometryKind = technique.kind;\n\n            // Set default kind based on technique.\n            if (geometryKind === undefined) {\n                geometryKind = setDefaultGeometryKind(technique);\n            }\n\n            if (Array.isArray(geometryKind)) {\n                geometryKind = new GeometryKindSet(geometryKind);\n            }\n\n            if (geometryKind instanceof Set) {\n                for (const kind of geometryKind) {\n                    foundSet.add(kind);\n                }\n            } else {\n                foundSet.add(geometryKind);\n            }\n        }\n        return foundSet;\n    }\n\n    /**\n     * Make sure that the technique has its geometryKind set, either from the theme or their default\n     * value.\n     *\n     * @param {Technique} technique\n     */\n    export function setDefaultGeometryKind(technique: Technique): GeometryKind | GeometryKindSet {\n        let geometryKind = technique.kind;\n\n        // Set default kind based on technique.\n        if (geometryKind === undefined) {\n            if (isFillTechnique(technique)) {\n                geometryKind = GeometryKind.Area;\n            } else if (\n                isLineTechnique(technique) ||\n                isSolidLineTechnique(technique) ||\n                isSegmentsTechnique(technique) ||\n                isExtrudedLineTechnique(technique)\n            ) {\n                geometryKind = GeometryKind.Line;\n            } else if (isExtrudedPolygonTechnique(technique)) {\n                geometryKind = GeometryKind.Building;\n            } else if (\n                isPoiTechnique(technique) ||\n                isLineMarkerTechnique(technique) ||\n                isTextTechnique(technique)\n            ) {\n                geometryKind = GeometryKind.Label;\n            } else {\n                geometryKind = GeometryKind.All;\n            }\n\n            technique.kind = geometryKind;\n        }\n\n        return geometryKind;\n    }\n}\n\n/**\n * Simplest implementation of a [[TileGeometryLoader]]. It loads all geometry in a single step.\n */\nexport class SimpleTileGeometryLoader implements TileGeometryLoader {\n    private m_decodedTile?: DecodedTile;\n    private m_isFinished: boolean = false;\n    private m_availableGeometryKinds: GeometryKindSet | undefined;\n    private m_timeout: any;\n\n    constructor(private m_tile: Tile) {}\n\n    get tile(): Tile {\n        return this.m_tile;\n    }\n\n    get isFinished(): boolean {\n        return this.m_isFinished;\n    }\n\n    get basicGeometryLoaded(): boolean {\n        return this.m_tile.hasGeometry;\n    }\n\n    get allGeometryLoaded(): boolean {\n        return this.m_isFinished;\n    }\n\n    /**\n     * Set the [[DecodedTile]] of the tile. Is called after the decoded tile has been loaded, and\n     * prepares its content for later processing in the 'updateXXX' methods.\n     *\n     * @param {DecodedTile} decodedTile The decoded tile with the flat geometry data belonging to\n     *      this tile.\n     * @returns {DecodedTile} The processed decoded tile.\n     */\n    setDecodedTile(decodedTile: DecodedTile): DecodedTile {\n        this.m_decodedTile = decodedTile;\n\n        if (this.m_decodedTile !== undefined) {\n            this.m_availableGeometryKinds = TileGeometryLoader.prepareDecodedTile(\n                this.m_decodedTile\n            );\n        }\n        return this.m_decodedTile;\n    }\n\n    get availableGeometryKinds(): GeometryKindSet | undefined {\n        return this.m_availableGeometryKinds;\n    }\n\n    update(\n        enabledKinds: GeometryKindSet | undefined,\n        disabledKinds: GeometryKindSet | undefined\n    ): void {\n        const tile = this.tile;\n\n        // First time this tile is handled:\n        if (this.m_decodedTile === undefined && tile.decodedTile !== undefined) {\n            TileGeometryCreator.instance.processTechniques(\n                tile.decodedTile,\n                enabledKinds,\n                disabledKinds\n            );\n\n            this.setDecodedTile(tile.decodedTile);\n            this.prepareForRender(enabledKinds, disabledKinds);\n        }\n    }\n\n    dispose(): void {\n        this.m_decodedTile = undefined;\n    }\n\n    reset(): void {\n        this.m_decodedTile = undefined;\n        this.m_isFinished = false;\n        if (this.m_availableGeometryKinds !== undefined) {\n            this.m_availableGeometryKinds.clear();\n        }\n        if (this.m_timeout !== undefined) {\n            clearTimeout(this.m_timeout);\n        }\n    }\n\n    private finish() {\n        this.m_tile.loadingFinished();\n        this.m_tile.removeDecodedTile();\n        this.m_isFinished = true;\n        this.m_timeout = undefined;\n    }\n\n    /**\n     * Called by [[VisibleTileSet]] to mark that [[Tile]] is visible and it should prepare geometry.\n     */\n    private prepareForRender(\n        enabledKinds: GeometryKindSet | undefined,\n        disabledKinds: GeometryKindSet | undefined\n    ) {\n        // If the tile is not ready for display, or if it has become invisible while being loaded,\n        // for example by moving the camera, the tile is not finished and its geometry is not\n        // created. This is an optimization for fast camera movements and zooms.\n        const tile = this.tile;\n        const decodedTile = this.m_decodedTile;\n        this.m_decodedTile = undefined;\n        if (decodedTile === undefined || tile.disposed || !tile.isVisible) {\n            this.finish();\n            return;\n        }\n        this.m_timeout = setTimeout(() => {\n            const stats = PerformanceStatistics.instance;\n            // If the tile has become invisible while being loaded, for example by moving the\n            // camera, the tile is not finished and its geometry is not created. This is an\n            // optimization for fast camera movements and zooms.\n            if (!tile.isVisible) {\n                // Dispose the tile from the visible set, so it can be reloaded properly next time\n                // it is needed.\n                tile.mapView.visibleTileSet.disposeTile(tile);\n\n                if (stats.enabled) {\n                    stats.currentFrame.addMessage(\n                        // tslint:disable-next-line: max-line-length\n                        `Decoded tile: ${tile.dataSource.name} # lvl=${tile.tileKey.level} col=${tile.tileKey.column} row=${tile.tileKey.row} DISCARDED - invisible`\n                    );\n                }\n                this.finish();\n                return;\n            }\n            let now = 0;\n            if (stats.enabled) {\n                now = PerformanceTimer.now();\n            }\n\n            const geometryCreator = TileGeometryCreator.instance;\n\n            tile.clear();\n            geometryCreator.initDecodedTile(decodedTile, enabledKinds, disabledKinds);\n\n            geometryCreator.createAllGeometries(tile, decodedTile);\n\n            if (stats.enabled) {\n                const geometryCreationTime = PerformanceTimer.now() - now;\n                const currentFrame = stats.currentFrame;\n                currentFrame.addValue(\"geometry.geometryCreationTime\", geometryCreationTime);\n                currentFrame.addValue(\"geometryCount.numGeometries\", decodedTile.geometries.length);\n                currentFrame.addValue(\"geometryCount.numTechniques\", decodedTile.techniques.length);\n                currentFrame.addValue(\n                    \"geometryCount.numPoiGeometries\",\n                    decodedTile.poiGeometries !== undefined ? decodedTile.poiGeometries.length : 0\n                );\n                currentFrame.addValue(\n                    \"geometryCount.numTextGeometries\",\n                    decodedTile.textGeometries !== undefined ? decodedTile.textGeometries.length : 0\n                );\n                currentFrame.addValue(\n                    \"geometryCount.numTextPathGeometries\",\n                    decodedTile.textPathGeometries !== undefined\n                        ? decodedTile.textPathGeometries.length\n                        : 0\n                );\n                currentFrame.addValue(\n                    \"geometryCount.numPathGeometries\",\n                    decodedTile.pathGeometries !== undefined ? decodedTile.pathGeometries.length : 0\n                );\n                currentFrame.addMessage(\n                    // tslint:disable-next-line: max-line-length\n                    `Decoded tile: ${tile.dataSource.name} # lvl=${tile.tileKey.level} col=${tile.tileKey.column} row=${tile.tileKey.row}`\n                );\n            }\n            this.finish();\n            tile.dataSource.requestUpdate();\n        }, 0);\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ITileDecoder } from \"@here/harp-datasource-protocol\";\nimport { ConcurrentWorkerSet } from \"./ConcurrentWorkerSet\";\nimport { WorkerBasedDecoder } from \"./WorkerBasedDecoder\";\n\n/**\n * Default concurrent decoder helper.\n *\n * A convenient singleton that maintains a separate [[ConcurrentWorkerSet]] for each bundle\n * requested. Provides easy access to [[WorkerBasedDecoder]]s for data sources.\n */\nexport class ConcurrentDecoderFacade {\n    /**\n     * The URL containing a script to fall back (default) to when looking for worker sets\n     * and decoders.\n     */\n    static defaultScriptUrl: string = \"./decoder.bundle.js\";\n\n    /**\n     * The default number of workers.\n     */\n    static defaultWorkerCount?: number = undefined;\n\n    /**\n     * Returns a [[WorkerBasedDecoder]] instance.\n     *\n     * @param decoderServiceType The name of the decoder service type.\n     * @param scriptUrl The optional URL with the workers' script.\n     * @param workerCount The number of web workers to use.\n     */\n    static getTileDecoder(\n        decoderServiceType: string,\n        scriptUrl?: string,\n        workerCount?: number\n    ): ITileDecoder {\n        const workerSet = this.getWorkerSet(scriptUrl, workerCount);\n\n        return new WorkerBasedDecoder(workerSet, decoderServiceType);\n    }\n\n    /**\n     * Returns a [[ConcurrentWorkerSet]] instance based on the script URL specified.\n     *\n     * @param scriptUrl The optional URL with the workers' script. If not specified,\n     * the function uses [[defaultScriptUrl]] instead.\n     * @param workerCount The number of web workers to use.\n     */\n    static getWorkerSet(scriptUrl?: string, workerCount?: number): ConcurrentWorkerSet {\n        if (scriptUrl === undefined) {\n            scriptUrl = this.defaultScriptUrl;\n        }\n\n        let workerSet = this.workerSets[scriptUrl];\n        if (workerSet === undefined) {\n            workerSet = new ConcurrentWorkerSet({\n                scriptUrl,\n                workerCount: workerCount === undefined ? this.defaultWorkerCount : workerCount\n            });\n            this.workerSets[scriptUrl] = workerSet;\n        }\n        return workerSet;\n    }\n\n    /**\n     * Destroys a [[ConcurrentWorkerSet]] instance.\n     *\n     * @param scriptUrl The worker script URL that was used to create the [[ConcurrentWorkerSet]].\n     */\n    static destroyWorkerSet(scriptUrl: string) {\n        const workerSet = this.workerSets[scriptUrl];\n        if (workerSet !== undefined) {\n            workerSet.destroy();\n            delete this.workerSets[scriptUrl];\n        }\n    }\n\n    /**\n     * Destroys all managed [[ConcurrentWorkerSet]]s.\n     */\n    static destroy() {\n        Object.keys(this.workerSets).forEach(name => {\n            this.workerSets[name].destroy();\n        });\n        this.workerSets = {};\n    }\n\n    /**\n     * The [[ConcurrentWorkerSet]] instances which are stored by the script URL.\n     */\n    private static workerSets: {\n        [bundleUrl: string]: ConcurrentWorkerSet;\n    } = {};\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { getOptionValue, MathUtils } from \"@here/harp-utils\";\n\n/**\n * Copyright info attached to data displayed on map. Provided by [[DataSource]] and attached\n * to [[Tile]]s.\n *\n * In most cases, an application should display this information on [[MapView]] to conform with\n * licencing terms of its map data providers.\n *\n * @see [[CopyrightElementHandler]]\n */\nexport interface CopyrightInfo {\n    /**\n     * Unique id of the copyright holder.\n     *\n     * `id`s should be unique. It is recommended to build them from unique identifiers like\n     * registered domain names.\n     *\n     * Examples:\n     *\n     *  * `openstreetmap.org` - for data originating from OpenStreetMap project\n     *  * `naturalearthdata.com` - for data originating from Natural Earth dataset\n     *\n     * Note: [[DataSource]] may return [[CopyrightInfo]] with only `id`, thus defining only holder\n     * of copyright, however, valid attribution may require proper `label` and `link`.\n     *\n     * Entries with same `id` are deduplicated by [[CopyrightInfo.mergeArrays]].\n     */\n    id: string;\n\n    /**\n     * Copyright text to display after the copyright symbol on the map.\n     *\n     * If undefined, `id` is used as text label.\n     * Set it to empty string to not render a copyright info.\n     */\n    label?: string;\n\n    /**\n     * Optional URL pointing to further copyright information.\n     */\n    link?: string;\n\n    /**\n     * Optional, copyright notice year.\n     */\n    year?: number;\n}\n\nexport namespace CopyrightInfo {\n    /**\n     * Merge [[CopyrightInfo]] arrays, removing duplicates.\n     *\n     * `id` and `label` are considered keys in deduplication algorithm.\n     *\n     * @param sources non-duplicate elements from this array are added to `target`\n     * @returns merge of all copyright infos in `sources`\n     */\n    export function mergeArrays(a: CopyrightInfo[], b?: CopyrightInfo[]): CopyrightInfo[] {\n        const result: CopyrightInfo[] = [];\n        for (const source of [a, b]) {\n            if (source === undefined) {\n                continue;\n            }\n\n            for (const sourceInfo of source) {\n                const existingInfo = result.find(\n                    findItem =>\n                        findItem.id === sourceInfo.id ||\n                        (findItem.label !== undefined && findItem.label === sourceInfo.label)\n                );\n\n                if (existingInfo === undefined) {\n                    result.push({ ...sourceInfo });\n                } else {\n                    existingInfo.year = MathUtils.max2(sourceInfo.year, existingInfo.year);\n                    existingInfo.label = getOptionValue(sourceInfo.label, existingInfo.label);\n                    existingInfo.link = getOptionValue(sourceInfo.link, existingInfo.link);\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Format copyright information to a HTML string that can be displayed in the UI.\n     *\n     * * Empty list returns empty string.\n     * * Entries with empty (but defined) labels are skipped.\n     */\n    export function formatAsHtml(copyrightInfo: CopyrightInfo[]): string {\n        if (copyrightInfo.length === 0) {\n            return \"\";\n        }\n\n        const filtered = copyrightInfo.filter(entry => entry.label !== \"\");\n        if (filtered.length === 0) {\n            return \"\";\n        }\n\n        return (\n            \" \" +\n            filtered\n                .map(entry => {\n                    const label = entry.label !== undefined ? entry.label : entry.id;\n                    const text = entry.year !== undefined ? `${entry.year} ${label}` : label;\n                    return entry.link ? `<a href=\"${entry.link}\">${text}</a>` : `${text}`;\n                })\n                .join(\", \")\n        );\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    HighPrecisionLineMaterial,\n    HighPrecisionPointMaterial,\n    isHighPrecisionPointMaterial\n} from \"@here/harp-materials\";\nimport {\n    BufferAttribute,\n    BufferGeometry,\n    Camera,\n    Color,\n    Float32BufferAttribute,\n    InterleavedBuffer,\n    InterleavedBufferAttribute,\n    Matrix4,\n    PointsMaterialParameters,\n    ShaderMaterial,\n    ShaderMaterialParameters,\n    Vector3\n} from \"three\";\n\nimport * as HPL from \"./HighPrecisionLines\";\nimport * as HPP from \"./HighPrecisionPoints\";\nimport { triangulateLine } from \"./TriangulateLines\";\n\nexport namespace HighPrecisionUtils {\n    /**\n     * Extract the `float` parts of all vector members, Making this a `Vector3` of `float`.\n     * precision.\n     *\n     * @param v\n     */\n    export function doubleToFloatVec(v: Vector3): Vector3 {\n        return new Vector3(Math.fround(v.x), Math.fround(v.y), Math.fround(v.z));\n    }\n\n    /**\n     * Convert a `Vector3` to `float` (in place!) Returns the minor float vector, which is the\n     * difference of the double elements and their float counterparts.\n     *\n     * @param v Vector3 to convert to float IN-PLACE!\n     */\n    export function makeFloatVec(v: Vector3): Vector3 {\n        const majorX = Math.fround(v.x);\n        const majorY = Math.fround(v.y);\n        const majorZ = Math.fround(v.z);\n\n        const minorVec = new Vector3(v.x - majorX, v.y - majorY, v.z - majorZ);\n\n        v.x = Math.fround(majorX);\n        v.y = Math.fround(majorY);\n        v.z = Math.fround(majorZ);\n\n        return minorVec;\n    }\n\n    /**\n     * Describes addtional postion data needed to render high-precision vertices. Created by\n     * [[createHighPrecisionCameraPos]].\n     */\n    export interface HighPrecisionCameraInfo {\n        /**\n         * View Projection matrix of this high-precision camera.\n         */\n        viewProjection: Matrix4;\n\n        /**\n         * Low-order bits of the high-precision camera's position.\n         */\n        eyePosLo: Vector3;\n\n        /**\n         * High-order bits of the high-precision camera's position.\n         */\n        eyePosHi: Vector3;\n    }\n\n    /**\n     * Describes different properties used when creating a [[HighPrecisionLine]] or\n     * a [[HighPrecisionWireFrameLine]].\n     */\n    export interface HighPrecisionLineParams extends ShaderMaterialParameters {\n        /**\n         * Color of the rendered line.\n         */\n        color?: number | string | Color;\n\n        /**\n         * Width of the rendered line (specified in world units).\n         */\n        lineWidth?: number;\n\n        /**\n         * Add rounded caps to the extremes of the line if set to `true`.\n         */\n        addCircles?: boolean;\n\n        /**\n         * Opacity of the rendered line.\n         */\n        opacity?: number;\n\n        /**\n         * Renders a wireframe line if set to `true`.\n         */\n        wireFrame?: boolean;\n    }\n\n    /**\n     * Calculate high-precision camera position used in vertex shader of high-precision materials.\n     *\n     * @param camera Camera used to get the high-precision position.\n     * @param objectInverseWorldMatrix Inverse World Matrix of the rendered [[HighPrecisionObject]].\n     */\n    export function createHighPrecisionCameraPos(\n        camera: Camera,\n        objectInverseWorldMatrix: Matrix4\n    ): HighPrecisionCameraInfo {\n        const _projScreenMatrix = new Matrix4().copy(camera.projectionMatrix);\n        const mvp = _projScreenMatrix.multiply(camera.matrixWorldInverse);\n        const eyePos = new Vector3(0, 0, 0).applyMatrix4(objectInverseWorldMatrix);\n\n        // split the double float vector into hi and lo parts\n        const eyePosFloat = doubleToFloatVec(eyePos);\n\n        const eyePosLo = doubleToFloatVec(eyePos.sub(eyePosFloat));\n\n        return {\n            viewProjection: mvp,\n            eyePosHi: eyePosFloat,\n            eyePosLo\n        };\n    }\n\n    /**\n     * Updates the high-precision uniform data of a material used to render a\n     * [[HighPrecisionObject]].\n     *\n     * @param object [[HighPrecisionObject]] used for rendering.\n     * @param camera Camera used to get the high-precision position.\n     * @param shaderMaterial Material which uniforms will be updated.\n     */\n    export function updateHpUniforms(\n        object: HPL.HighPrecisionObject,\n        camera: Camera,\n        shaderMaterial: ShaderMaterial\n    ): void {\n        const highPrecisionCameraInfo = createHighPrecisionCameraPos(\n            camera,\n            object.matrixWorldInverse\n        );\n        const mvp = highPrecisionCameraInfo.viewProjection;\n\n        if (shaderMaterial !== undefined && shaderMaterial.isMaterial) {\n            if (\n                shaderMaterial.uniforms &&\n                shaderMaterial.uniforms.u_mvp &&\n                shaderMaterial.uniforms.u_eyepos &&\n                shaderMaterial.uniforms.u_eyepos_lowpart\n            ) {\n                shaderMaterial.uniforms.u_mvp.value = new Float32Array(mvp.elements);\n                shaderMaterial.uniforms.u_eyepos.value = new Float32Array(\n                    highPrecisionCameraInfo.eyePosHi.toArray()\n                );\n                shaderMaterial.uniforms.u_eyepos_lowpart.value = new Float32Array(\n                    highPrecisionCameraInfo.eyePosLo.toArray()\n                );\n            } else {\n                throw Error(\"High pecision material has missing uniforms\");\n            }\n        } else {\n            throw Error(\"High pecision line has no high precision material\");\n        }\n    }\n\n    /**\n     * Assembles the necessary attribute buffers needed to render [[HighPrecisionObject]].\n     *\n     * @param positions Array of positions.\n     */\n    export function createAttributes(\n        positions: ArrayLike<number> | ArrayLike<Vector3>\n    ): {\n        positionHigh: BufferAttribute;\n        positionLow: BufferAttribute;\n    } {\n        if (positions.length > 0) {\n            const v = positions[0];\n\n            if (v === undefined || v === null) {\n                throw Error(\"Empty element in positions\");\n            }\n\n            const positionVec = new Array<number>();\n            const positionVecLow = new Array<number>();\n\n            const addHPValue = (...values: number[]) => {\n                for (const value of values) {\n                    const major = Math.fround(value);\n                    positionVecLow.push(value - major);\n                    positionVec.push(major);\n                }\n            };\n\n            const addHPVector = (vec: Vector3) => {\n                addHPValue(vec.x, vec.y, vec.z);\n            };\n\n            const vAny = v as any;\n            if (vAny.z !== undefined) {\n                (positions as Vector3[]).forEach(vec => {\n                    addHPVector(vec);\n                });\n            } else {\n                if (positionVec.length % 3 !== 0) {\n                    throw Error(\"Positions must be 3D, not 2D\");\n                }\n                (positions as number[]).forEach((n: number): void => {\n                    addHPValue(n);\n                });\n            }\n\n            return {\n                positionHigh: new Float32BufferAttribute(positionVec, 3),\n                positionLow: new Float32BufferAttribute(positionVecLow, 3)\n            };\n        } else {\n            return {\n                positionHigh: new Float32BufferAttribute([], 3),\n                positionLow: new Float32BufferAttribute([], 3)\n            };\n        }\n    }\n\n    /**\n     * Assembles an interleaved buffer containing the position attribute data for a\n     * [[HighPrecisionObject]].\n     *\n     * @param positions Array of positions.\n     * @param stride Stride of the elements in the `positions` array.\n     * @param positionOffset Offset into the `positions` array.\n     */\n    export function addInterleavedAttributes3(\n        positions: ArrayLike<number>,\n        stride: number,\n        positionOffset = 0\n    ): ArrayLike<number> {\n        const newPositions = new Array<number>();\n\n        const end = positions.length;\n\n        for (let i = 0; i < end; i += stride) {\n            for (let j = 0; j < positionOffset; j++) {\n                newPositions.push(positions[i + j]);\n            }\n\n            const x = positions[i + positionOffset];\n            const y = positions[i + positionOffset + 1];\n            const z = positions[i + positionOffset + 2];\n            const majorX = Math.fround(x);\n            const minorX = x - majorX;\n            const majorY = Math.fround(y);\n            const minorY = y - majorY;\n            const majorZ = Math.fround(z);\n            const minorZ = z - majorZ;\n\n            // insert values in interleaved buffer\n            newPositions.push(majorX, majorY, majorZ, minorX, minorY, minorZ);\n\n            for (let j = positionOffset + 3; j < stride; j++) {\n                newPositions.push(positions[i + j]);\n            }\n        }\n\n        return newPositions;\n    }\n\n    /**\n     * Adds the high-precision position attribute data to a [[HighPrecisionObject]].\n     *\n     * @param object [[HighPrecisionObject]] which position attribute will be set.\n     * @param positions Array of positions.\n     */\n    export function setPositions(\n        object: HPL.HighPrecisionObject,\n        positions: ArrayLike<number> | ArrayLike<Vector3>\n    ): number {\n        const attributes = createAttributes(positions);\n\n        object.bufferGeometry.setAttribute(\"position\", attributes.positionHigh);\n        object.bufferGeometry.setAttribute(\"positionLow\", attributes.positionLow);\n\n        return attributes.positionHigh.itemSize;\n    }\n\n    /**\n     * Convert positions from `Array<Vector3>` to `Array<number>`.\n     *\n     * @param positions Array of positions.\n     */\n    export function convertPositions(\n        positions: ArrayLike<number> | ArrayLike<Vector3>\n    ): { positions: number[] } {\n        if (positions.length <= 0) {\n            return { positions: [] };\n        }\n\n        const v = positions[0];\n\n        if (v === undefined || v === null) {\n            throw Error(\"Empty element in positions\");\n        }\n\n        const vAny = v as any;\n        if (vAny.y === undefined && vAny.z === undefined) {\n            return { positions: positions as number[] };\n        }\n\n        const returnPositions = new Array<number>();\n        (positions as Vector3[]).forEach(vec => {\n            returnPositions.push(vec.x, vec.y, vec.z);\n        });\n\n        return { positions: returnPositions };\n    }\n\n    /**\n     * Creates a [[HighPrecisionLine]] or [[HighPrecisionWireFrameLine]] object.\n     *\n     * @param linePositions Array of 2D/3D positions.\n     * @param params Parameters used to configure the created [[HighPrecisionObject]].\n     */\n    export function createLine(\n        linePositions: ArrayLike<number>,\n        params: HighPrecisionLineParams\n    ): HPL.HighPrecisionLine | HPL.HighPrecisionWireFrameLine {\n        const lineWidth = params.lineWidth !== undefined ? params.lineWidth : 5;\n        const addCircles = params.addCircles !== undefined ? params.addCircles : false;\n        const wireFrame = params.wireFrame !== undefined ? params.wireFrame : false;\n\n        const positions: number[] = [];\n        const indices: number[] = [];\n\n        triangulateLine(linePositions, lineWidth, positions, indices, addCircles);\n\n        const hpLineGeometry = new BufferGeometry();\n        const hpPositions = addInterleavedAttributes3(positions, 3);\n        const buffer = new InterleavedBuffer(new Float32Array(hpPositions), 6);\n\n        const positionAttribute = new InterleavedBufferAttribute(buffer, 3, 0, false);\n        const positionLowAttribute = new InterleavedBufferAttribute(buffer, 3, 3, false);\n\n        hpLineGeometry.setAttribute(\"position\", positionAttribute);\n        hpLineGeometry.setAttribute(\"positionLow\", positionLowAttribute);\n        hpLineGeometry.setIndex(new BufferAttribute(new Uint32Array(indices), 1));\n\n        const hpSolidMaterial = new HighPrecisionLineMaterial(params);\n\n        const lineObject = wireFrame\n            ? new HPL.HighPrecisionWireFrameLine(hpLineGeometry, hpSolidMaterial)\n            : new HPL.HighPrecisionLine(hpLineGeometry, hpSolidMaterial);\n\n        lineObject.setupForRendering();\n\n        return lineObject;\n    }\n\n    /**\n     * Creates a group of [[HighPrecisionPoints]].\n     *\n     * @param pointPositions Array of 2D/3D positions.\n     * @param materialParameters Parameters used to configure the material used to render the\n     * created [[HighPrecisionPoints]].\n     */\n    export function createPoints(\n        pointPositions: ArrayLike<number>,\n        materialParameters?: PointsMaterialParameters | HighPrecisionPointMaterial\n    ): HPP.HighPrecisionPoints {\n        const indices: number[] = [];\n\n        // tslint:disable-next-line:prefer-for-of - pointPositions doesn't have iterable interface\n        for (let i = 0; i < pointPositions.length; i++) {\n            indices.push(indices.length / 3);\n        }\n\n        const hpPointsGeometry = new BufferGeometry();\n\n        const hpPointsMaterial = isHighPrecisionPointMaterial(materialParameters)\n            ? materialParameters\n            : new HighPrecisionPointMaterial(materialParameters);\n\n        const pointsObject = new HPP.HighPrecisionPoints(hpPointsGeometry, hpPointsMaterial);\n\n        setPositions(pointsObject, pointPositions);\n\n        pointsObject.setupForRendering();\n\n        return pointsObject;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { Value } from \"@here/harp-datasource-protocol/index-decoder\";\n\n/**\n * Feature Modifier ids to choose which OmvFeatureModifer should be used in OmvDecoder.\n */\nexport enum FeatureModifierId {\n    /**\n     * Identifier to use the OmvTomTomFeatureModifier in the OmvDecoder.\n     */\n    tomTom\n}\n\n/**\n * Definition of a filter.\n */\nexport interface OmvFilterString {\n    /**  String value */\n    value: string;\n    /** Match condition */\n    match: OmvFilterString.StringMatch;\n}\n\n/**\n * Adding the match condition type and the matching function to the namespace of `OmvFilterString`.\n */\nexport namespace OmvFilterString {\n    /**\n     * Match condition.\n     */\n    export enum StringMatch {\n        /** Matches any. */\n        Any,\n        /** Exact match. */\n        Match,\n        /** Matches if a test string starts with a filter string. */\n        StartsWith,\n        /** Matches if a test string contains a filter string. */\n        Contains,\n        /** Matches if a test string ends with a filter string. */\n        EndsWith\n    }\n\n    /**\n     * Check for a string against a filter.\n     *\n     * @param str The string to check against a filter.\n     * @param filterString The filter containing the match condition.\n     * @returns `true` if the match condition is satisfied.\n     */\n    export function matchString(str: string, filterString: OmvFilterString): boolean {\n        switch (filterString.match) {\n            case OmvFilterString.StringMatch.Any:\n                return true;\n            case OmvFilterString.StringMatch.Match:\n                return str === filterString.value;\n            case OmvFilterString.StringMatch.StartsWith:\n                return filterString.value.startsWith(str);\n            case OmvFilterString.StringMatch.EndsWith:\n                return filterString.value.endsWith(str);\n            default:\n                return str.indexOf(filterString.value) >= 0;\n        }\n    }\n}\n\n/**\n * Definition of a filter for a feature attribute\n */\nexport interface OmvFilterFeatureAttribute {\n    key: string;\n    value: Value;\n}\n\nexport enum OmvGeometryType {\n    UNKNOWN = 0,\n    POINT = 1,\n    LINESTRING = 2,\n    POLYGON = 3\n}\n\n/**\n * Internal type of a layer filter description, Should not be publicly available.\n *\n * @hidden\n */\nexport interface OmvLayerFilterDescription {\n    name: OmvFilterString;\n    minLevel: number;\n    maxLevel: number;\n}\n\n/**\n * Internal type of a single filter description, Should not be publicly available.\n *\n * @hidden\n */\nexport interface OmvFilterDescription {\n    layerName: OmvFilterString;\n    geometryTypes?: OmvGeometryType[];\n    classes?: OmvFilterString[];\n    minLevel: number;\n    maxLevel: number;\n    featureAttribute?: OmvFilterFeatureAttribute;\n}\n\n/**\n * Internal type of a complete [[OmvFeatureFilter]] description, should not be publicly available.\n *\n * @hidden\n */\nexport interface OmvFeatureFilterDescription {\n    processLayersDefault: boolean;\n    processPointsDefault: boolean;\n    processLinesDefault: boolean;\n    processPolygonsDefault: boolean;\n\n    layersToProcess: OmvLayerFilterDescription[];\n    layersToIgnore: OmvLayerFilterDescription[];\n    pointsToProcess: OmvFilterDescription[];\n    pointsToIgnore: OmvFilterDescription[];\n    linesToProcess: OmvFilterDescription[];\n    linesToIgnore: OmvFilterDescription[];\n    polygonsToProcess: OmvFilterDescription[];\n    polygonsToIgnore: OmvFilterDescription[];\n\n    // enabledKinds and disabledKinds\n    kindsToProcess: string[];\n    kindsToIgnore: string[];\n}\n\n/**\n * Internal interface for options passed from the [[OmvDataSource]] to the decoder.\n *\n * @hidden\n */\nexport interface OmvDecoderOptions {\n    /**\n     * If true, features that have no technique in the theme will be printed to the console (can be\n     * excessive!).\n     */\n    showMissingTechniques?: boolean;\n\n    /**\n     * Gather feature attributes from [[OmvData]]. Defaults to false.\n     */\n    gatherFeatureAttributes?: boolean;\n    createTileInfo?: boolean;\n    gatherRoadSegments?: boolean;\n\n    /**\n     * Optional storage level offset for [[Tile]]s. Default is -2.\n     */\n    storageLevelOffset?: number;\n\n    /**\n     * If not set to `false` very short text labels will be skipped during decoding based on a\n     * heuristic.\n     */\n    skipShortLabels?: boolean;\n\n    /**\n     * A description for the feature filter which can be safely passed down to the web workers.\n     * It has to be generated with the help of the [[OmvFeatureFilterDescriptionBuilder]] (to\n     * guarantee the correctness).\n     */\n    filterDescription?: OmvFeatureFilterDescription | null;\n\n    /**\n     * Identifier used to choose OmvFeatureModifier, if undefined [[OmvGenericFeatureModifier]] is\n     * used.\n     */\n    featureModifierId?: FeatureModifierId;\n\n    enableElevationOverlay?: boolean;\n}\n\n/**\n * Default OMV tile decoder service type.\n *\n * Used for requesting decoder services using [[WorkerServiceManager]].\n */\nexport const OMV_TILE_DECODER_SERVICE_TYPE = \"omv-tile-decoder\";\n\n/**\n * Default OMV tiler service type.\n *\n * Used for requesting tiler services using [[WorkerServiceManager]].\n */\nexport const OMV_TILER_SERVICE_TYPE = \"omv-tiler\";\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { TileKey } from \"@here/harp-geoutils\";\nimport { DataSource, Tile } from \"@here/harp-mapview\";\n\nexport class OmvTile extends Tile {\n    constructor(dataSource: DataSource, tileKey: TileKey) {\n        super(dataSource, tileKey);\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { IChannel } from \"./IChannel\";\n\n/**\n * Class for the default console channel.\n */\n\nexport class ConsoleChannel implements IChannel {\n    error(message?: any, ...optionalParams: any[]) {\n        // tslint:disable-next-line:no-console\n        console.error(message, ...optionalParams);\n    }\n\n    debug(message?: any, ...optionalParams: any[]) {\n        // tslint:disable-next-line:no-console\n        console.debug(message, ...optionalParams);\n    }\n\n    info(message?: any, ...optionalParams: any[]) {\n        // tslint:disable-next-line:no-console\n        console.info(message, ...optionalParams);\n    }\n\n    log(message?: any, ...optionalParams: any[]) {\n        // tslint:disable-next-line:no-console\n        console.log(message, ...optionalParams);\n    }\n\n    trace(message?: any, ...optionalParams: any[]) {\n        // tslint:disable-next-line:no-console\n        console.trace(message, ...optionalParams);\n    }\n\n    warn(message?: any, ...optionalParams: any[]) {\n        // tslint:disable-next-line:no-console\n        console.warn(message, ...optionalParams);\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { IChannel } from \"./IChannel\";\nimport { ILogger, LoggerOptions, LogLevel } from \"./ILogger\";\n\n/**\n * Logger class.\n */\nexport class Logger implements ILogger {\n    enabled: boolean = true;\n    level: LogLevel = LogLevel.Trace;\n\n    constructor(readonly name: string, private m_channel: IChannel, options?: LoggerOptions) {\n        if (options !== undefined) {\n            this.update(options);\n        }\n    }\n\n    error(message?: any, ...optionalParams: any[]) {\n        if (this.enabled && this.level <= LogLevel.Error) {\n            this.m_channel.error(this.prefix, message, ...optionalParams);\n        }\n    }\n\n    debug(message?: any, ...optionalParams: any[]) {\n        if (this.enabled && this.level <= LogLevel.Debug) {\n            this.m_channel.debug(this.prefix, message, ...optionalParams);\n        }\n    }\n\n    info(message?: any, ...optionalParams: any[]) {\n        if (this.enabled && this.level <= LogLevel.Info) {\n            this.m_channel.info(this.prefix, message, ...optionalParams);\n        }\n    }\n\n    log(message?: any, ...optionalParams: any[]) {\n        if (this.enabled && this.level <= LogLevel.Log) {\n            this.m_channel.log(this.prefix, message, ...optionalParams);\n        }\n    }\n\n    trace(message?: any, ...optionalParams: any[]) {\n        if (this.enabled && this.level <= LogLevel.Trace) {\n            this.m_channel.trace(this.prefix, message, ...optionalParams);\n        }\n    }\n\n    warn(message?: any, ...optionalParams: any[]) {\n        if (this.enabled && this.level <= LogLevel.Warn) {\n            this.m_channel.warn(this.prefix, message, ...optionalParams);\n        }\n    }\n\n    update(options: LoggerOptions) {\n        this.enabled = options.enabled === undefined ? this.enabled : options.enabled;\n        this.level = options.level === undefined ? this.level : options.level;\n    }\n\n    private get prefix(): string {\n        return this.name + \":\";\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport * as THREE from \"three\";\n\n/**\n * The base shader to use for [[MapView]]'s composing passes, like [[MSAAMaterial]].\n */\n\nexport const CopyShader: THREE.Shader = {\n    uniforms: {\n        tDiffuse: { value: null },\n        opacity: { value: 1.0 }\n    },\n    vertexShader: `\n    varying vec2 vUv;\n    void main() {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }`,\n    fragmentShader: `\n    uniform float opacity;\n    uniform sampler2D tDiffuse;\n    varying vec2 vUv;\n    void main() {\n        vec4 texel = texture2D( tDiffuse, vUv );\n        gl_FragColor = opacity * texel;\n    }`\n};\n\n/**\n * The material is used for composing.\n */\nexport class CopyMaterial extends THREE.ShaderMaterial {\n    /**\n     * The constructor of `CopyMaterial`.\n     *\n     * @param uniforms The [[CopyShader]]'s uniforms.\n     */\n    constructor(uniforms: { [uniformName: string]: THREE.IUniform }) {\n        super({\n            name: \"CopyMaterial\",\n            uniforms,\n            vertexShader: CopyShader.vertexShader,\n            fragmentShader: CopyShader.fragmentShader,\n            premultipliedAlpha: true,\n            transparent: false,\n            blending: THREE.NoBlending,\n            depthTest: false,\n            depthWrite: false\n        });\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @hidden\n */\nexport type Value = null | boolean | number | string | object;\n\n/**\n * @hidden\n */\nexport interface ValueMap {\n    [name: string]: Value;\n}\n\n/**\n * @hidden\n */\nexport class Env {\n    /**\n     * Returns property in [[Env]] by name.\n     *\n     * @param name Name of property.\n     */\n    lookup(_name: string): Value | undefined {\n        return undefined;\n    }\n    /**\n     * Return an object containing all properties of this environment. (Here: empty object).\n     */\n    unmap(): ValueMap {\n        return {};\n    }\n}\n\n/**\n * Adds access to map specific environment properties.\n */\nexport class MapEnv extends Env {\n    constructor(readonly entries: ValueMap, private readonly parent?: Env) {\n        super();\n    }\n    /**\n     * Returns property in [[Env]] by name.\n     *\n     * @param name Name of property.\n     */\n    lookup(name: string): Value | undefined {\n        if (this.entries.hasOwnProperty(name)) {\n            const value = this.entries[name];\n            if (value !== undefined) {\n                return value;\n            }\n        }\n        return this.parent ? this.parent.lookup(name) : undefined;\n    }\n    /**\n     * Return an object containing all properties of this environment, takes care of the parent\n     * object.\n     */\n    unmap(): ValueMap {\n        const obj: any = this.parent ? this.parent.unmap() : {};\n        for (const key in this.entries) {\n            if (this.entries.hasOwnProperty(key)) {\n                obj[key] = this.entries[key];\n            }\n        }\n        return obj;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { assert } from \"@here/harp-utils\";\nimport { Color } from \"three\";\nimport { ColorUtils } from \"./ColorUtils\";\n\nconst tmpColor = new Color();\n\n/**\n * Enumeration of supported string encoded numerals.\n */\nexport enum StringEncodedNumeralType {\n    Meters,\n    Pixels,\n    Hex,\n    RGB,\n    RGBA,\n    HSL\n}\n\n/**\n * Interface containing information about a [[StringEncodedNumeral]] format, component size and\n * evaluation.\n */\nexport interface StringEncodedNumeralFormat {\n    readonly type: StringEncodedNumeralType;\n    readonly size: number;\n    readonly regExp: RegExp;\n    mask?: number;\n    decoder: (encodedValue: string, target: number[]) => boolean;\n}\nconst StringEncodedMeters: StringEncodedNumeralFormat = {\n    type: StringEncodedNumeralType.Meters,\n    size: 1,\n    regExp: /^((?=\\.\\d|\\d)(?:\\d+)?(?:\\.?\\d*))m$/,\n    decoder: (encodedValue: string, target: number[]) => {\n        const match = StringEncodedMeters.regExp.exec(encodedValue);\n        return match ? (target[0] = Number(match[1])) !== undefined : false;\n    }\n};\nconst StringEncodedPixels: StringEncodedNumeralFormat = {\n    type: StringEncodedNumeralType.Pixels,\n    size: 1,\n    mask: 1.0,\n    regExp: /^((?=\\.\\d|\\d)(?:\\d+)?(?:\\.?\\d*))px$/,\n    decoder: (encodedValue: string, target: number[]) => {\n        const match = StringEncodedPixels.regExp.exec(encodedValue);\n        if (match === null) {\n            return false;\n        }\n        target[0] = Number(match[1]);\n        return true;\n    }\n};\nconst StringEncodedHex: StringEncodedNumeralFormat = {\n    type: StringEncodedNumeralType.Hex,\n    size: 4,\n    regExp: /^\\#((?:[0-9A-Fa-f][0-9A-Fa-f]){3,4}|[0-9A-Fa-f]{3,4})$/,\n    decoder: (encodedValue: string, target: number[]) => {\n        const match = StringEncodedHex.regExp.exec(encodedValue);\n        if (match === null) {\n            return false;\n        }\n        const hex = match[1];\n        const size = hex.length;\n        // Only few sizes are possible for given reg-exp.\n        assert(\n            size === 3 || size === 4 || size === 6 || size === 8,\n            `Matched incorrect hex format: ${encodedValue}`\n        );\n        // Note that we simply ignore alpha channel value.\n        // TODO: To be resolved with HARP-7517\n        if (size === 3 || size === 4) {\n            // #RGB or #RGBA\n            target[0] = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;\n            target[1] = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;\n            target[2] = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;\n            target[3] = size === 4 ? parseInt(hex.charAt(3) + hex.charAt(3), 16) / 255 : 1;\n        } else if (size === 6 || size === 8) {\n            // #RRGGBB or #RRGGBBAA\n            target[0] = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;\n            target[1] = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;\n            target[2] = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;\n            target[3] = size === 8 ? parseInt(hex.charAt(6) + hex.charAt(7), 16) / 255 : 1;\n        }\n        return true;\n    }\n};\nconst StringEncodedRGB: StringEncodedNumeralFormat = {\n    type: StringEncodedNumeralType.RGB,\n    size: 3,\n    // tslint:disable-next-line:max-line-length\n    regExp: /^rgb\\( ?(?:([0-9]{1,2}|1[0-9]{1,2}|2[0-4][0-9]|25[0-5]), ?)(?:([0-9]{1,2}|1[0-9]{1,2}|2[0-4][0-9]|25[0-5]), ?)(?:([0-9]{1,2}|1[0-9]{1,2}|2[0-4][0-9]|25[0-5])) ?\\)$/,\n    decoder: (encodedValue: string, target: number[]) => {\n        const channels = StringEncodedRGB.regExp.exec(encodedValue);\n        if (channels === null) {\n            return false;\n        }\n        target[0] = parseInt(channels[1], 10) / 255;\n        target[1] = parseInt(channels[2], 10) / 255;\n        target[2] = parseInt(channels[3], 10) / 255;\n        return true;\n    }\n};\nconst StringEncodedRGBA: StringEncodedNumeralFormat = {\n    type: StringEncodedNumeralType.RGBA,\n    size: 4,\n    // tslint:disable-next-line:max-line-length\n    regExp: /^rgba\\( ?(?:([0-9]{1,2}|1[0-9]{1,2}|2[0-4][0-9]|25[0-5]), ?)(?:([0-9]{1,2}|1[0-9]{1,2}|2[0-4][0-9]|25[0-5]), ?)(?:([0-9]{1,2}|1[0-9]{1,2}|2[0-4][0-9]|25[0-5]), ?)(?:(0(?:\\.[0-9]+)?|1(?:\\.0+)?)) ?\\)$/,\n    decoder: (encodedValue: string, target: number[]) => {\n        const channels = StringEncodedRGBA.regExp.exec(encodedValue);\n        if (channels === null) {\n            return false;\n        }\n        target[0] = parseInt(channels[1], 10) / 255;\n        target[1] = parseInt(channels[2], 10) / 255;\n        target[2] = parseInt(channels[3], 10) / 255;\n        target[3] = parseInt(channels[4], 10);\n        return true;\n    }\n};\nconst StringEncodedHSL: StringEncodedNumeralFormat = {\n    type: StringEncodedNumeralType.HSL,\n    size: 3,\n    // tslint:disable-next-line:max-line-length\n    regExp: /^hsl\\( ?((?:[0-9]|[1-9][0-9]|1[0-9]{1,2}|2[0-9]{1,2}|3[0-5][0-9]|360)), ?(?:([0-9]|[1-9][0-9]|100)%), ?(?:([0-9]|[1-9][0-9]|100)%) ?\\)$/,\n    decoder: (encodedValue: string, target: number[]) => {\n        const channels = StringEncodedHSL.regExp.exec(encodedValue);\n        if (channels === null) {\n            return false;\n        }\n        tmpColor.setHSL(\n            parseInt(channels[1], 10) / 360,\n            parseInt(channels[2], 10) / 100,\n            parseInt(channels[3], 10) / 100\n        );\n        target[0] = tmpColor.r;\n        target[1] = tmpColor.g;\n        target[2] = tmpColor.b;\n        return true;\n    }\n};\n\n/**\n * Array of all supported [[StringEncodedNumeralFormat]]s describing sizes, lengths and distances.\n */\nexport const StringEncodedMetricFormats: StringEncodedNumeralFormat[] = [\n    StringEncodedMeters,\n    StringEncodedPixels\n];\n\nconst StringEncodedMetricFormatMaxSize = StringEncodedMetricFormats.reduce(\n    (a, b) => Math.max(a, b.size),\n    0\n);\n\n/**\n * Array of all supported [[StringEncodedNumeralFormat]]s describing color data.\n */\nexport const StringEncodedColorFormats: StringEncodedNumeralFormat[] = [\n    StringEncodedHex,\n    StringEncodedRGB,\n    StringEncodedRGBA,\n    StringEncodedHSL\n];\n\nconst StringEncodedColorFormatMaxSize = StringEncodedColorFormats.reduce(\n    (a, b) => Math.max(a, b.size),\n    0\n);\n\n/**\n * Array of supported [[StringEncodedNumeralFormat]]s (intended to be indexed with\n * [[StringEncodedNumeralType]] enum).\n */\nexport const StringEncodedNumeralFormats: StringEncodedNumeralFormat[] = [\n    ...StringEncodedMetricFormats,\n    ...StringEncodedColorFormats\n];\n\nexport const StringEncodedNumeralFormatMaxSize = Math.max(\n    StringEncodedColorFormatMaxSize,\n    StringEncodedMetricFormatMaxSize\n);\n\nconst tmpBuffer: number[] = new Array(StringEncodedNumeralFormatMaxSize);\n\n/**\n * Parse string encoded numeral values using all known [[StringEncodedNumeralFormats]].\n *\n * @param numeral The string representing numeric value.\n * @param pixelToMeters The ratio used to convert from meters to pixels (default 1.0).\n * @returns Number parsed or __undefined__ if non of the numeral patterns matches the expression\n * provided in [[numeral]].\n */\nexport function parseStringEncodedNumeral(\n    numeral: string,\n    pixelToMeters: number = 1.0\n): number | undefined {\n    let result: number | undefined;\n    const formatMatch = (format: StringEncodedNumeralFormat) => {\n        if (format.decoder(numeral, tmpBuffer)) {\n            switch (format.type) {\n                case StringEncodedNumeralType.Meters:\n                    result = tmpBuffer[0];\n                    break;\n                case StringEncodedNumeralType.Pixels:\n                    result = tmpBuffer[0] * pixelToMeters;\n                    break;\n                case StringEncodedNumeralType.Hex:\n                case StringEncodedNumeralType.RGBA:\n                    result = ColorUtils.getHexFromRgba(\n                        tmpBuffer[0],\n                        tmpBuffer[1],\n                        tmpBuffer[2],\n                        tmpBuffer[3]\n                    );\n                case StringEncodedNumeralType.RGB:\n                case StringEncodedNumeralType.HSL:\n                    result = ColorUtils.getHexFromRgb(tmpBuffer[0], tmpBuffer[1], tmpBuffer[2]);\n                    break;\n                default:\n                    result = tmpBuffer[0];\n                    break;\n            }\n            return true;\n        }\n        return false;\n    };\n    StringEncodedNumeralFormats.some(formatMatch);\n    return result;\n}\n\n/**\n * Parse string encoded color value using all known [[StringEncodedColorFormats]].\n *\n * @param color The string encoded color expression (i.e. '#FFF', 'rgb(255, 0, 0)', etc.).\n * @returns The color parsed or __undefined__ if non of the known representations matches\n * the expression provided in [[color]].\n */\nexport function parseStringEncodedColor(color: string): number | undefined {\n    const matchedFormat = matchFormat(StringEncodedColorFormats, color, tmpBuffer);\n    if (matchedFormat === undefined) {\n        return undefined;\n    }\n    switch (matchedFormat.type) {\n        case StringEncodedNumeralType.Hex:\n        case StringEncodedNumeralType.RGBA:\n            return ColorUtils.getHexFromRgba(\n                tmpBuffer[0],\n                tmpBuffer[1],\n                tmpBuffer[2],\n                tmpBuffer[3]\n            );\n        case StringEncodedNumeralType.RGB:\n        case StringEncodedNumeralType.HSL:\n            return ColorUtils.getHexFromRgb(tmpBuffer[0], tmpBuffer[1], tmpBuffer[2]);\n        default:\n            return tmpBuffer[0];\n    }\n}\n\nfunction matchFormat(\n    formats: StringEncodedNumeralFormat[],\n    numeral: string,\n    result: number[]\n): StringEncodedNumeralFormat | undefined {\n    return formats.find(format => {\n        return format.decoder(numeral, result) ? true : false;\n    });\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { JsonExpr } from \"./Expr\";\nimport { InterpolatedPropertyDefinition } from \"./InterpolatedPropertyDefs\";\n\n/**\n * Available line caps types(`\"None\"`, `\"Round\"`, `\"Square\"`, `\"TriangleOut\"`, `\"TriangleIn\"`).\n * Default is `\"Round\"`.\n */\nexport type LineCaps = \"Square\" | \"Round\" | \"None\" | \"TriangleOut\" | \"TriangleIn\";\n\n/**\n * The kind of geometry is used to\n *\n * a) Group objects together, allowing the group to be hidden or displayed.\n *\n * b) Assigning the objects a loading phase. If a [[PhasedTileGeometryManager]] is used, techniques\n *      without a `GeometryKind` may not be processed (at the desired phase).\n *\n * Any string can be used to specify the kind of the technique in a style in the theme file. Is is\n * suggested to specify multiple kinds for specific types of data. For a highway, the following list\n * of kinds is suggested:\n *\n *    [\"line\", \"road\", \"road:highway\"]\n *\n * If it is a tunnel for a highway:\n *\n *    [\"line\", \"road\", \"road:highway\", \"tunnel\", \"road:tunnel\", \"road:highway:tunnel\"]\n *\n * If specified in this way, specific types of data (here: highway roads) can be enabled and/or\n * disabled.\n */\nexport enum GeometryKind {\n    /**\n     * Used in the enabledKinds/disabledKinds filter to match any kind.\n     */\n    All = \"_all_\",\n\n    /**\n     * Background geometry.\n     */\n    Background = \"background\",\n\n    /**\n     * Terrain geometry.\n     */\n    Terrain = \"terrain\",\n\n    /**\n     * Default value for the FillTechnique.\n     */\n    Area = \"area\",\n\n    /**\n     * Default value for all line techniques.\n     */\n    Line = \"line\",\n\n    /**\n     * Default value for the FillTechnique.\n     */\n    Water = \"water\",\n\n    /**\n     * Political borders.\n     */\n    Border = \"border\",\n\n    /**\n     * Basis for all roads.\n     */\n    Road = \"road\",\n\n    /**\n     * Default value for the ExtrudedPolygonTechnique.\n     */\n    Building = \"building\",\n\n    /**\n     * Default value for the TextTechnique, LineMarkerTechnique and the PoiTechnique.\n     */\n    Label = \"label\",\n\n    /**\n     * Anything that may show up last.\n     */\n    Detail = \"detail\"\n}\n\n/**\n * Decorate property type with possible dynamic variants.\n */\nexport type DynamicProperty<T> = T | JsonExpr | InterpolatedPropertyDefinition<T>;\n\n/*\n * Description of length units inside a style. Supports literal values (interpreted as `m`), `m` and\n * `px`(i.e. `80`, `14px`, `0.6m`, etc.).\n */\nexport type StyleLength = string | number;\n\n/**\n * Description of colors inside a style. Supports hex values as well as CSS hex, rgb and hsl values\n * (i.e. `0xffffff`, `#f00fab`, `#aaa`, `rgb(255, 0 120)`, `hsl(360, 100%, 100%)`, etc.).\n */\nexport type StyleColor = string | number;\n\n/**\n * A set of [[GeometryKind]]s.\n */\nexport class GeometryKindSet extends Set {\n    /**\n     * Return `true` if the Set is a superset of the set 'subset'.\n     */\n    isSuperset(subset: Set<any>): boolean {\n        for (const elem of subset) {\n            if (!this.has(elem)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Return `true` if the Set intersects Set 'set'.\n     */\n    hasIntersection(set: any) {\n        for (const elem of set) {\n            if (this.has(elem)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return `true` if the Set either intersects Set 'set' (if set is a Set), of has element 'set'\n     * if set is not a Set.\n     */\n    hasOrIntersects(set: any) {\n        if (set instanceof Set) {\n            return this.hasIntersection(set);\n        }\n        return this.has(set);\n    }\n\n    /**\n     * Return `true` if this set and the array of elements share at least a single element.\n     */\n    hasOrIntersectsArray(subset: any[]) {\n        for (const elem of subset) {\n            if (this.has(elem)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n/**\n * Common attributes or all [[Technique]]s.\n */\nexport interface BaseTechniqueParams {\n    /**\n     * The name used to identify materials created from this technique.\n     */\n    id?: string;\n\n    /**\n     * The render order of the objects created using this technique.\n     *\n     * If not specified in style file, [[StyleSetEvaluator]] will assign monotonically increasing\n     * values according to style position in file.\n     */\n    renderOrder: number;\n\n    /**\n     *\n     */\n    renderOrderOffset?: number;\n\n    /**\n     * Optional. If `true`, no IDs will be saved for the geometry this technique creates.\n     */\n    transient?: boolean;\n\n    /**\n     * Distance to the camera (0.0 = camera position, 1.0 = farPlane) at which the object start\n     * fading out (opacity decreases).\n     */\n    fadeNear?: DynamicProperty<number>;\n\n    /**\n     * Distance to the camera (0.0 = camera position, 1.0 = farPlane) at which the object has zero\n     * opacity and stops fading out. An undefined value disables fading.\n     */\n    fadeFar?: DynamicProperty<number>;\n\n    /**\n     * Specified kind of geometry. One kind is set as default in the technique, and can be\n     * overridden in the style.\n     */\n    kind?: GeometryKind | GeometryKindSet;\n\n    /**\n     * Set to `true` if this `Technique`s kind is in the set of enabled [[GeometryKind]]s, set to\n     * `false` if is in the disabled [[GeometryKind]]s. Disabling overrules enabling.\n     */\n    enabled?: boolean;\n}\n\nexport enum TextureCoordinateType {\n    /**\n     * Texture coordinates are in tile space.\n     * SW of the tile will have (0,0) and NE will have (1,1).\n     */\n    TileSpace = \"tile-space\",\n    /**\n     * Texture coordinates are in equirectangular space.\n     * (u, v) = ( (longitude+180) / 360, (latitude+90) / 180).\n     */\n    EquirectangularSpace = \"equirectangular-space\"\n}\n\n/**\n * Standard technique parameters.\n */\nexport interface StandardTechniqueParams extends BaseTechniqueParams {\n    /**\n     * Color of the feature in hexadecimal or CSS-style notation, for example: `\"#e4e9ec\"`,\n     * `\"#fff\"`, `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * See https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.color.\n     * @format color-hex\n     */\n    color?: DynamicProperty<StyleColor>;\n    /**\n     * A value of `true` creates a wireframe geometry. (May not be supported with all techniques).\n     * See https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.wireframe.\n     */\n    wireframe?: boolean;\n    /**\n     * If `vertexColors` is `true`, every vertex has color information, which is interpolated\n     * between vertices.\n     * See https://threejs.org/docs/#api/en/materials/Material.vertexColors.\n     */\n    vertexColors?: boolean;\n    /**\n     * How rough the material appears. `0.0` means a smooth mirror reflection. `1.0` means fully\n     * diffuse. Default is `0.5`.\n     * See https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.roughness.\n     */\n    roughness?: DynamicProperty<number>;\n    /**\n     * How much the material is like a metal. Nonmetallic materials such as wood or stone use `0.0`,\n     * metallic ones use `1.0`, with nothing (usually) in between. Default is `0.5`. A value between\n     * `0.0` and `1.0` can be used for a rusty metal look. If `metalnessMap` is also provided, both\n     * values are multiplied.\n     * See https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.metalness.\n     */\n    metalness?: DynamicProperty<number>;\n    /**\n     * The material will not be rendered if the opacity is lower than this value.\n     * See https://threejs.org/docs/#api/en/materials/Material.alphaTest.\n     */\n    alphaTest?: DynamicProperty<number>;\n    /**\n     * Skip rendering clobbered pixels.\n     * See https://threejs.org/docs/#api/en/materials/Material.depthTest.\n     */\n    depthTest?: boolean;\n    /**\n     * Set to 'true' if line should appear transparent. Rendering transparent lines may come with a\n     * slight performance impact.\n     * See https://threejs.org/docs/#api/en/materials/Material.transparent.\n     */\n    transparent?: boolean;\n    /**\n     * For transparent lines, set a value between 0.0 for totally transparent, to 1.0 for totally\n     * opaque.\n     * See https://threejs.org/docs/#api/en/materials/Material.opacity.\n     */\n    opacity?: DynamicProperty<number>;\n    /**\n     * Emissive (light) color of the material, essentially a solid color unaffected by other\n     * lighting. Default is black.\n     * See https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.emissive.\n     * @format color-hex\n     */\n    emissive?: DynamicProperty<StyleColor>;\n    /**\n     * Intensity of the emissive light. Modulates the emissive color. Default is `1`.\n     * See https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.emissiveIntensity.\n     */\n    emissiveIntensity?: DynamicProperty<number>;\n    /**\n     * The index of refraction (IOR) of air (approximately 1) divided by the index of refraction of\n     * the material. It is used with environment mapping modes `THREE.CubeRefractionMapping` and\n     * `THREE.EquirectangularRefractionMapping`. The refraction ratio should not exceed `1`. Default\n     *  is `0.98`.\n     * See https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.refractionRatio.\n     */\n    refractionRatio?: DynamicProperty<number>;\n\n    /**\n     * Whether and how texture coordinates should be generated. No texture coordinates are\n     * generated if `undefined`.\n     * Should be set if any texture assigned (e.g. `map`, `normalMap`, ...).\n     */\n    textureCoordinateType?: TextureCoordinateType;\n\n    /*\n     * URL or texture buffer that should be used as color map. See:\n     * https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.map\n     */\n    map?: string | TextureBuffer;\n    mapProperties?: TextureProperties;\n\n    /**\n     * URL or texture buffer that should be used as normal map. See:\n     * https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.normalMap\n     */\n    normalMap?: string | TextureBuffer;\n    normalMapType?: number;\n    normalMapProperties?: TextureProperties;\n\n    /**\n     * URL or texture buffer that should be used as displacement map. See:\n     * https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.displacementMap\n     */\n    displacementMap?: string | TextureBuffer;\n    displacementMapProperties?: TextureProperties;\n\n    /**\n     * URL or texture buffer that should be used as roughness map. See:\n     * https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.roughnessMap\n     */\n    roughnessMap?: string | TextureBuffer;\n    roughnessMapProperties?: TextureProperties;\n\n    /**\n     * URL or texture buffer that should be used as emissive map. See:\n     * https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.emissiveMap\n     */\n    emissiveMap?: string | TextureBuffer;\n    emissiveMapProperties?: TextureProperties;\n\n    /**\n     * URL or texture buffer that should be used as bump map. See:\n     * https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.bumpMap\n     */\n    bumpMap?: string | TextureBuffer;\n    bumpMapProperties?: TextureProperties;\n\n    /**\n     * URL or texture buffer that should be used as metalness map. See:\n     * https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.metalnessMap\n     */\n    metalnessMap?: string | TextureBuffer;\n    metalnessMapProperties?: TextureProperties;\n\n    /**\n     * URL or texture buffer that should be used as alpha map. See:\n     * https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.alphaMap\n     */\n    alphaMap?: string | TextureBuffer;\n    alphaMapProperties?: TextureProperties;\n}\n\n/**\n * Possible parameters of [[PointTechnique]].\n */\nexport interface PointTechniqueParams extends BaseTechniqueParams {\n    /**\n     * Color of a point in hexadecimal or CSS-style notation, for example: `\"#e4e9ec\"`, `\"#fff\"`,\n     * `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * @format color-hex\n     */\n    color?: DynamicProperty<StyleColor>;\n    /**\n     * URL of a texture image to be loaded.\n     */\n    texture?: string;\n    /**\n     * Set to `true` if line should appear transparent. Rendering transparent lines may come with a\n     * slight performance impact.\n     */\n    transparent?: boolean;\n    /**\n     * For transparent lines, set a value between 0.0 for totally transparent, to 1.0 for totally\n     * opaque.\n     */\n    opacity?: DynamicProperty<number>;\n    /**\n     * Size of point in pixels.\n     */\n    size?: number;\n    /**\n     * Whether to enable picking on these points.\n     */\n    enablePicking?: boolean;\n}\n\n/**\n * Define the stacking option. Enum values for theme file are in \"kebab-case\".\n */\nexport enum PoiStackMode {\n    /**\n     * Show in a stack.\n     */\n    Show = \"show-in-stack\",\n    /**\n     * Do not show in a stack.\n     */\n    Hide = \"hide-in-stack\",\n    /**\n     * Show category parent in the stack.\n     */\n    ShowParent = \"show-parent\"\n}\n\n/**\n * Technique that describes icons with labels. Used in [[PoiTechnique]] and [[LineMarkerTechnique]]\n * (for road shields).\n */\nexport interface MarkerTechniqueParams extends BaseTechniqueParams {\n    /**\n     * Text to be displayed for feature.\n     *\n     * Defaults to first defined:\n     *  - feature property `label` if present in technique (depreacted)\n     *  - `[\"get\", \"name:short\"]` is `useAbbreviation` is true\n     *  - `[\"get\", \"iso_code\"]` is `useIsoCode` is true\n     *  - `[\"get\", \"name:$LANGUAGE\"]` for each specified language\n     *  - `[\"get\", \"name\"]`\n     *\n     * See [[ExtendedTileInfo.getFeatureText]]\n     */\n    text?: string;\n\n    /**\n     * Field name of object containing the text to be rendered.\n     *\n     * @deprecated, Use `[\"get\", \"FIELD\"]`.\n     */\n    label?: string;\n    /**\n     * If `true`, the abbreviation (field `name:short`) of the elements is used as text.\n     *\n     * @deprecated Use proper expression with [`get`, `name:short`] for this purpose.\n     */\n    useAbbreviation?: boolean;\n    /**\n     * If `true`, the iso code (field 'iso_code') of the elements is used as text.\n     * The `iso_code` field contains the ISO 3166-1 2-letter country code.\n     *\n     * @deprecated Use proper expression with [`get`, `iso_code`] for this purpose.\n     */\n    useIsoCode?: boolean;\n    /**\n     * Priority of marker, defaults to `0`. Markers with highest priority get placed first.\n     */\n    priority?: DynamicProperty<number>;\n    /**\n     * Minimum zoomLevel at which to display the label text. No default.\n     */\n    textMinZoomLevel?: number;\n    /**\n     * Maximum zoomLevel at which to display the label text. No default.\n     */\n    textMaxZoomLevel?: number;\n    /**\n     * Minimum zoomLevel at which to display the label icon. No default.\n     */\n    iconMinZoomLevel?: number;\n    /**\n     * Maximum zoomLevel at which to display the label icon. No default.\n     */\n    iconMaxZoomLevel?: number;\n    /**\n     * Scaling factor of icon. Defaults to 0.5, reducing the size ot 50% in the distance.\n     */\n    distanceScale?: number;\n    /**\n     * If `false`, text may overlap markers.\n     * @default `false`\n     */\n    textMayOverlap?: boolean;\n    /**\n     * If `false`, the icon may overlap text and other icons of lower priority. If not defined, the\n     * property value from `textMayOverlap` will be used.\n     * @default `false`\n     */\n    iconMayOverlap?: boolean;\n    /**\n     * If `false`, text will not reserve screen space, other markers will be able to overlap.\n     * @default `true`\n     */\n    textReserveSpace?: boolean;\n    /**\n     * If `false`, icon will not reserve screen space, other markers will be able to overlap. If not\n     * defined, the property value from `iconReserveSpace` will be used.\n     * @default `true`\n     */\n    iconReserveSpace?: boolean;\n    /**\n     * If `false`, text will not be rendered during animations. Defaults to `true`.\n     */\n    renderTextDuringMovements?: boolean;\n    /**\n     * If `true`, the label will always be rendered on top. If overlapping with other labels with\n     * this flag set, the render order is undefined.\n     * @default `false`\n     */\n    alwaysOnTop?: boolean;\n    /**\n     * If `true`, icon will appear even if the text part is blocked by other labels. Defaults to\n     * `false`.\n     */\n    textIsOptional?: boolean;\n    /**\n     * Should be displayed on map or not. Defaults to `true`.\n     */\n    showOnMap?: boolean;\n    /**\n     * Specify stack mode. Defaults to `ShowInStack`.\n     */\n    stackMode?: PoiStackMode;\n    /**\n     * Minimal distance between markers in screen pixels.\n     */\n    minDistance?: number;\n    /**\n     * If true, the text will appear even if the icon cannot be rendered because of missing icon\n     * graphics. Defaults to `true`.\n     */\n    iconIsOptional?: boolean;\n    /**\n     * Fading time for labels in seconds.\n     */\n    textFadeTime?: number;\n    /**\n     * Fading time for icons in seconds.\n     */\n    iconFadeTime?: number;\n    /**\n     * Horizontal offset (to the right) in screen pixels.\n     */\n    xOffset?: DynamicProperty<number>;\n    /**\n     * Vertical offset (up) in screen pixels.\n     */\n    yOffset?: DynamicProperty<number>;\n    /**\n     * Horizontal offset (to the right) in screen pixels.\n     */\n    iconXOffset?: DynamicProperty<number>;\n    /**\n     * Vertical offset (up) in screen pixels.\n     */\n    iconYOffset?: DynamicProperty<number>;\n    /**\n     * Scaling factor of icon.\n     */\n    iconScale?: number;\n    /**\n     * Vertical height in pixels, controls vertical scaling. Overrides `iconScale`.\n     */\n    screenHeight?: DynamicProperty<number>;\n    /**\n     * Horizontal height in pixels, controls horizontal scaling. Overrides `iconScale`.\n     */\n    screenWidth?: DynamicProperty<number>;\n    /**\n     * Name of the POI table which should be used for this POI.\n     */\n    poiTable?: string;\n    /**\n     * Fixed name to identify POI options in the POI table. If `poiName` has a value, this value\n     * supercedes any value read from the field referenced in `poiNameField`.\n     */\n    poiName?: string;\n    /**\n     * Name of the field to evaluate to get the name of the POI options in the POI table.\n     */\n    poiNameField?: string;\n    /**\n     * Name of [[ImageTexture]] definition to use.\n     */\n    imageTexture?: string;\n    /**\n     * Field name to extract imageTexture content from.\n     */\n    imageTextureField?: string;\n    /**\n     * Prefix for `imageTexture` if `imageTextureField` is used.\n     */\n    imageTexturePrefix?: string;\n    /**\n     * Postfix for `imageTexture` if `imageTextureField` is used.\n     */\n    imageTexturePostfix?: string;\n    /**\n     * Name of the text style.\n     */\n    style?: string;\n    /**\n     * Name of the preferred [[Font]] to be used when rendering.\n     */\n    fontName?: string;\n    /**\n     * Size of the text (pixels).\n     */\n    size?: DynamicProperty<number>;\n    /**\n     * Size of the text background (pixels).\n     */\n    backgroundSize?: DynamicProperty<number>;\n    /**\n     * Glyph style to apply for the currently active [[Font]].\n     */\n    fontStyle?: \"Regular\" | \"Bold\" | \"Italic\" | \"BoldItalic\";\n    /**\n     * Glyph variant to apply for the currently active [[Font]].\n     */\n    fontVariant?: \"Regular\" | \"AllCaps\" | \"SmallCaps\";\n    /**\n     * Glyph local rotation (radians).\n     */\n    rotation?: number;\n    /**\n     * Text color in hexadecimal or CSS-style notation, for example: `\"#e4e9ec\"`, `\"#fff\"`,\n     * `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * @format color-hex\n     */\n    color?: DynamicProperty<StyleColor>;\n    /**\n     * Text background color in hexadecimal or CSS-style notation, for example: `\"#e4e9ec\"`,\n     * `\"#fff\"`, `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * @format color-hex\n     */\n    backgroundColor?: DynamicProperty<StyleColor>;\n    /**\n     * For transparent text, set a value between 0.0 for totally transparent, to 1.0 for totally\n     * opaque.\n     */\n    opacity?: DynamicProperty<number>;\n    /**\n     * Background text opacity value.\n     */\n    backgroundOpacity?: DynamicProperty<number>;\n    /**\n     * Inter-glyph spacing (pixels). Scaled by `size`.\n     */\n    tracking?: number;\n    /**\n     * Inter-line spacing (pixels). Scaled by `size`.\n     */\n    leading?: number;\n    /**\n     * Maximum number of lines for this label.\n     */\n    maxLines?: number;\n    /**\n     * Maximum line width (pixels).\n     */\n    lineWidth?: number;\n    /**\n     * [[TextCanvas]] rotation (radians).\n     */\n    canvasRotation?: number;\n    /**\n     * Line typesetting rotation (radians).\n     */\n    lineRotation?: number;\n    /**\n     * Wrapping (line-breaking) mode.\n     */\n    wrappingMode?: \"None\" | \"Character\" | \"Word\";\n    /**\n     * Text position regarding the baseline.\n     */\n    hAlignment?: DynamicProperty<\"Left\" | \"Center\" | \"Right\">;\n    /**\n     * Text position inside a line.\n     */\n    vAlignment?: DynamicProperty<\"Above\" | \"Center\" | \"Below\">;\n}\n\nexport interface LineTechniqueParams extends BaseTechniqueParams {\n    /**\n     * Color of a line in hexadecimal or CSS-style notation, for example: `\"#e4e9ec\"`, `\"#fff\"`,\n     * `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * @format color-hex\n     */\n    color: DynamicProperty<StyleColor>;\n    /**\n     * Set to true if line should appear transparent. Rendering transparent lines may come with a\n     * slight performance impact.\n     */\n    transparent?: boolean;\n    /**\n     * For transparent lines, set a value between 0.0 for totally transparent, to 1.0 for totally\n     * opaque.\n     */\n    opacity?: DynamicProperty<number>;\n    /**\n     * Width of line in pixels. WebGL implementations will normally render all lines with 1 pixel\n     * width, and ignore this value.\n     */\n    lineWidth: DynamicProperty<number>;\n}\n\n/**\n * Declares a geometry as a segment.\n */\nexport interface SegmentsTechniqueParams extends BaseTechniqueParams {\n    /**\n     * Color of segments in a hexadecimal notation, for example: `\"#e4e9ec\"` or `\"#fff\"`.\n     * @format color-hex\n     */\n    color: DynamicProperty<StyleColor>;\n    /**\n     * Set to `true` if line should appear transparent. Rendering transparent lines may come with a\n     * slight performance impact.\n     */\n    transparent?: boolean;\n    /**\n     * For transparent lines, set a value between `0.0` for fully transparent, to `1.0` for fully\n     * opaque.\n     */\n    opacity?: DynamicProperty<number>;\n    /**\n     * Width of a line in meters.\n     */\n    lineWidth: DynamicProperty<number>;\n}\n\n/**\n * Declares a a geometry as a polygon.\n */\nexport interface PolygonalTechniqueParams {\n    /**\n     * Whether to use polygon offset. Default is false. This corresponds to the\n     * GL_POLYGON_OFFSET_FILL WebGL feature.\n     *\n     * PolygonOffset is used to raise the geometry towards the geometry (for depth calculation\n     * only). Default is false.\n     *\n     * See here: https://sites.google.com/site/threejstuts/home/polygon_offset\n     *\n     * To activate polygonOffset these values have to be set to pull the line \"forwards\":\n     *\n     * transparent: true\n     *\n     * polygonOffset: true\n     *\n     * polygonOffsetFactor : -1.0, (as an example, see link above)\n     *\n     * polygonOffsetUnits: -1 (as an example, see link above)\n     */\n    polygonOffset?: boolean;\n\n    /**\n     * Sets the polygon offset factor. Default is 0.\n     */\n    polygonOffsetFactor?: DynamicProperty<number>;\n\n    /**\n     * Sets the polygon offset units. Default is 0.\n     */\n    polygonOffsetUnits?: DynamicProperty<number>;\n\n    /**\n     * Sets the polygon outline color.\n     * @format color-hex\n     */\n    lineColor?: DynamicProperty<StyleColor>;\n\n    /**\n     * Distance to the camera (0.0 = nearPlane, 1.0 = farPlane) at which the object edges start\n     * fading out.\n     */\n    lineFadeNear?: DynamicProperty<number>;\n\n    /**\n     * Distance to the camera (0.0 = nearPlane, 1.0 = farPlane) at which the object edges become\n     * transparent. A value of <= 0.0 disables fading.\n     */\n    lineFadeFar?: DynamicProperty<number>;\n}\n\n/**\n * Declares a a geometry as a basic extruded line.\n */\nexport interface BasicExtrudedLineTechniqueParams\n    extends BaseTechniqueParams,\n        PolygonalTechniqueParams {\n    /**\n     * A value determining the shading technique. Valid values are \"Basic\" and \"Standard\". Default\n     * is \"Basic\".\n     *\n     * `\"basic\"`   : Simple shading, faster to render. Only simple color and opacity are effective.\n     * `\"standard\"`: Elaborate shading, with metalness, and roughness.\n     *\n     * TODO: is this TechniqueParams or Style prop ?\n     */\n    shading?: \"basic\";\n    /**\n     * Color of a line in hexadecimal or CSS-style notation, for example: `\"#e4e9ec\"`, `\"#fff\"`,\n     * `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * @format color-hex\n     */\n    color: DynamicProperty<StyleColor>;\n    /**\n     * Set to `true` if line should appear transparent. Rendering transparent lines may come with a\n     * slight performance impact.\n     */\n    transparent?: boolean;\n    /**\n     * For transparent lines, set a value between 0.0 for totally transparent, to 1.0 for totally\n     * opaque.\n     */\n    opacity?: DynamicProperty<number>;\n    /**\n     * Width of line in meters for different zoom levels.\n     */\n    lineWidth: DynamicProperty<number>;\n    /**\n     * A value of `true` creates a wireframe geometry. (May not be supported with all techniques).\n     */\n    wireframe?: boolean;\n    /**\n     * Style of both end caps. Possible values: `\"None\"`, `\"Circle\"`. A value of undefined maps to\n     * `\"Circle\"`.\n     */\n    caps?: \"None\" | \"Circle\";\n}\n\n/**\n * Declares a a geometry as a standard extruded line.\n */\nexport interface StandardExtrudedLineTechniqueParams\n    extends StandardTechniqueParams,\n        PolygonalTechniqueParams {\n    /**\n     * A value determining the shading technique. Valid values are `\"basic\"` and `\"standard\"`.\n     * Default is `\"basic\"`.\n     *\n     * `\"basic\"` : Simple shading, faster to render. Only simple color and opacity are effective.\n     * `\"standard\"` : Elaborate shading, with metalness, and roughness.\n     */\n    shading: \"standard\";\n    /**\n     * Width of a line in meters for different zoom levels.\n     */\n    lineWidth: DynamicProperty<number>;\n    /**\n     * Style of both end caps. Possible values: `\"None\"`, `\"Circle\"`. A value of undefined maps to\n     * `\"Circle\"`.\n     */\n    caps?: \"None\" | \"Circle\";\n}\n\n/**\n * Declares a a geometry as a solid line.\n */\nexport interface SolidLineTechniqueParams extends BaseTechniqueParams, PolygonalTechniqueParams {\n    /**\n     * Color of a line in hexadecimal or CSS-style notation, for example: `\"#e4e9ec\"`, `\"#fff\"`,\n     * `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * @format color-hex\n     */\n    color: DynamicProperty<StyleColor>;\n    /**\n     * Color of a line outline in hexadecimal or CSS-style notation,\n     * for example: `\"#e4e9ec\"`, `\"#fff\"`, `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * @format color-hex\n     */\n    outlineColor?: DynamicProperty<StyleColor>;\n    /**\n     * Set to `true` if line should appear transparent. Rendering transparent lines may come with a\n     * slight performance impact.\n     */\n    transparent?: boolean;\n    /**\n     * For transparent lines, set a value between `0.0` for fully transparent, to `1.0` for fully\n     * opaque.\n     */\n    opacity?: DynamicProperty<number>;\n    // TODO: Make pixel units default.\n    /**\n     * @deprecated Specify metrics units as part of the value instead.\n     * Units in which different size properties are specified. Either `Meter` (default) or `Pixel`.\n     */\n    metricUnit?: string;\n    /**\n     * Width of a line in `metricUnit` for different zoom levels.\n     */\n    lineWidth: DynamicProperty<StyleLength>;\n    /**\n     * Outline width of a line in `metricUnit`s for different zoom levels.\n     */\n    outlineWidth?: DynamicProperty<StyleLength>;\n    /**\n     * Clip the line outside the tile if `true`.\n     */\n    clipping?: boolean;\n    /**\n     * Describes line caps type (`\"None\"`, `\"Round\"`, `\"Square\"`, `\"TriangleOut\"`, `\"TriangleIn\"`).\n     * Default is `\"Round\"`.\n     */\n    caps?: LineCaps;\n    /**\n     * Color of secondary line geometry in hexadecimal or CSS-style notation, for example:\n     * `\"#e4e9ec\"`, `\"#fff\"`, `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * @format color-hex\n     */\n    secondaryColor?: DynamicProperty<StyleColor>;\n    /**\n     * Width of secondary line geometry in `metricUnit`s for different zoom levels.\n     */\n    secondaryWidth?: DynamicProperty<StyleLength>;\n    /**\n     * The render order of the secondary line geometry object created using this technique.\n     */\n    secondaryRenderOrder?: number;\n    /**\n     * Describes secondary line caps type (`\"None\"`, `\"Round\"`, `\"Square\"`, `\"TriangleOut\"`,\n     * `\"TriangleIn\"`).\n     * Default is `\"Round\"`.\n     */\n    secondaryCaps?: LineCaps;\n    /**\n     * Describes the starting drawing position for the line (in the range [0...1]).\n     * Default is `0.0`.\n     */\n    drawRangeStart?: number;\n    /**\n     * Describes the ending drawing position for the line (in the range [0...1]).\n     * Default is `1.0`.\n     */\n    drawRangeEnd?: number;\n    /**\n     * Color of a line dashes in hexadecimal or CSS-style notation,\n     * for example: `\"#e4e9ec\"`, `\"#fff\"`, `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * @format color-hex\n     */\n    dashColor?: DynamicProperty<StyleColor>;\n    /**\n     * Length of a line in meters for different zoom levels.\n     */\n    dashSize?: DynamicProperty<StyleLength>;\n    /**\n     * Size of a gap between lines in meters for different zoom levels.\n     */\n    gapSize?: DynamicProperty<StyleLength>;\n}\n\n/**\n * Technique used to draw filled polygons.\n */\nexport interface FillTechniqueParams extends BaseTechniqueParams, PolygonalTechniqueParams {\n    /**\n     * Fill color in hexadecimal or CSS-style notation, for example: `\"#e4e9ec\"`, `\"#fff\"`,\n     * `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * @format color-hex\n     */\n    color?: DynamicProperty<StyleColor>;\n    /**\n     * Set to `true` if line should appear transparent. Rendering transparent lines may come with a\n     * slight performance impact.\n     */\n    transparent?: boolean;\n    /**\n     * For transparent lines, set a value between `0.0` for fully transparent, to `1.0` for fully\n     * opaque.\n     */\n    opacity?: DynamicProperty<number>;\n    /**\n     * A value of `true` creates a wireframe geometry. (May not be supported with all techniques).\n     */\n    wireframe?: boolean;\n    /**\n     * Width of the lines. Currently limited to the [0, 1] range.\n     */\n    lineWidth?: DynamicProperty<number>;\n}\n\n/**\n * Technique used to draw a geometry as an extruded polygon, for example extruded buildings.\n */\nexport interface ExtrudedPolygonTechniqueParams extends StandardTechniqueParams {\n    /**\n     * Renders the footprint lines if set to 'true'.\n     */\n    footprint?: boolean;\n    /**\n     * Set to a negative value to remove all the vertical lines, and to a value between 0.0 and 1.0\n     * to modulate the amount of vertical lines rendered.\n     */\n    maxSlope?: number;\n    /**\n     * Width of the lines. Currently limited to the [0, 1] range.\n     */\n    lineWidth: DynamicProperty<number>;\n    /**\n     * Fill color in hexadecimal or CSS-style notation, for example: `\"#e4e9ec\"`, `\"#fff\"`,\n     * `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * @format color-hex\n     */\n    lineColor?: DynamicProperty<StyleColor>;\n    /**\n     * Mix value between the lineColor(0.0) and the geometry's vertex colors(1.0).\n     */\n    lineColorMix?: number;\n\n    /**\n     * Distance to the camera (0.0 = nearPlane, 1.0 = farPlane) at which the object edges start\n     * fading out.\n     */\n    lineFadeNear?: DynamicProperty<number>;\n    /**\n     * Distance to the camera (0.0 = nearPlane, 1.0 = farPlane) at which the object edges become\n     * transparent. A value of <= 0.0 disables fading.\n     */\n    lineFadeFar?: DynamicProperty<number>;\n\n    /**\n     * Height above ground in world units of extruded polygon.\n     *\n     * Usually, unique per feature, so defaults to `[\"get\", \"height\"]`.\n     */\n    height?: number;\n\n    /**\n     * Height of \"floor\" of extruded polygon in world units of extruded polygon.\n     *\n     * Usually, unique per feature, so defaults to `[\"number\", [\"get\", \"min_height\"], 0]`.\n     */\n    floorHeight?: number;\n\n    /**\n     * In some data sources, for example Tilezen, building extrusion information might be missing.\n     * This attribute allows to define a default height of an extruded polygon in the theme.\n     *\n     * @deprecated use [[height]]\n     */\n    defaultHeight?: number;\n\n    /**\n     * Default color used if feature doesn't provide color attribute\n     * and [[MapEnv]] did not return it too.\n     * @format color-hex\n     */\n    defaultColor?: DynamicProperty<StyleColor>;\n\n    /**\n     * If `true`, the height of the extruded buildings will not be modified by the mercator\n     * projection distortion that happens around the poles.\n     *\n     * @default `false`\n     */\n    constantHeight?: boolean;\n\n    /**\n     * If `false`, wall geometry will not be added along the tile boundaries.\n     * @default `true`\n     */\n    boundaryWalls?: boolean;\n\n    /**\n     * Animate the extrusion of the buildings if set to `true`.\n     */\n    animateExtrusion?: DynamicProperty<boolean>;\n\n    /**\n     * Duration of the building's extrusion in milliseconds\n     */\n    animateExtrusionDuration?: number;\n\n    /**\n     * Control rendering of depth prepass before the actual geometry.\n     *\n     * Depth prepass is a method to render translucent meshes, hence only the visible front faces of\n     * a mesh are actually rendered, removing artifacts caused by blending with internal faces of\n     * the mesh. This method is used for drawing translucent buildings over map background.\n     *\n     * By default, each [[DataSource]] determines how/if enable the depth pre-pass. A value of\n     * `false` forcefully disables depth prepass.\n     */\n    enableDepthPrePass?: boolean;\n}\n\nexport interface ShaderTechniqueMaterialParameters {\n    [name: string]: any;\n}\n\n/**\n * Special technique for user-defined shaders. See\n * https://threejs.org/docs/#api/harp-materials/ShaderMaterial for details.\n */\nexport interface ShaderTechniqueParams extends BaseTechniqueParams {\n    /**\n     * Parameters for shader. See `THREE.ShaderMaterialParameters`.\n     */\n    params: ShaderTechniqueMaterialParameters;\n\n    /**\n     * Type of primitive for the shader technique. Valid values are \"point\" | \"line\" | \"segments\" |\n     * \"mesh\"\n     */\n    primitive: \"point\" | \"line\" | \"segments\" | \"mesh\";\n}\n\n/**\n * Technique used to render a terrain geometry with a texture.\n * When using this technique, the datasource will produce texture coordinates in\n * local tile space (i.e. [0,0] at south-west and [1,1] at north-east tile corner).\n */\nexport interface TerrainTechniqueParams extends StandardTechniqueParams {\n    /**\n     * Colors to be applied at different heights (as a results of a `displacementMap`).\n     */\n    heightBasedColors?: HeightBasedColors;\n\n    /**\n     * If `heightBasedColors` is defined, this value defines the interpolation method used to\n     * generate the height-based gradient texture (defaults to `Discrete`).\n     */\n    heightGradientInterpolation?: \"Discrete\" | \"Linear\" | \"Cubic\";\n\n    /**\n     * If `heightBasedColors` is defined, this value defines the width (in pixels) of the generated\n     * gradient texture (defaults to `128`).\n     */\n    heightGradientWidth?: number;\n}\n\n/**\n * Render geometry as a text.\n */\nexport interface TextTechniqueParams extends BaseTechniqueParams {\n    /**\n     * Text to be displayed for feature.\n     *\n     * Defaults to first defined:\n     *  - feature property `label` if present in technique (depreacted);\n     *  - `[\"get\", \"name:short\"]` is `useAbbreviation` is true;\n     *  - `[\"get\", \"iso_code\"]` is `useIsoCode` is true;\n     *  - `[\"get\", \"name:$LANGUAGE\"]` for each specified language;\n     *  - `[\"get\", \"name\"]`.\n     *\n     * See [[ExtendedTileInfo.getFeatureText]].\n     */\n    text?: string;\n\n    /**\n     * Field name of object containing the text to be rendered.\n     *\n     * @deprecated, Use `[\"get\", \"FIELD\"]`.\n     */\n    label?: string;\n    /**\n     * If `true`, the abbreviation (field `name:short`) of the elements is used as text.\n     *\n     * @deprecated Use proper expression with [`get`, `name:short`] for this purpose.\n     */\n    useAbbreviation?: boolean;\n    /**\n     * If `true`, the iso code (field 'iso_code') of the elements is used as text.\n     * The `iso_code` field contains the ISO 3166-1 2-letter country code.\n     *\n     * @deprecated Use proper expression with [`get`, `iso_code`] for this purpose.\n     */\n    useIsoCode?: boolean;\n    /**\n     * Priority of text, defaults to `0`. Elements with highest priority get placed first.\n     */\n    priority?: DynamicProperty<number>;\n    /**\n     * Minimal zoom level. If the current zoom level is smaller, the technique will not be used.\n     */\n    minZoomLevel?: number;\n    /**\n     * Maximum zoom level. If the current zoom level is larger, the technique will not be used.\n     */\n    maxZoomLevel?: number;\n    /**\n     * Scaling factor of the text. Defaults to 0.5, reducing the size ot 50% in the distance.\n     */\n    distanceScale?: number;\n    /**\n     * If `true`, icon is allowed to overlap other labels or icons of lower priority.\n     * @default `false`\n     */\n    mayOverlap?: boolean;\n    /**\n     * If `true`, element will reserve screen space, other markers of lower priority will not be\n     * able to overlap.\n     * @default `true`\n     */\n    reserveSpace?: boolean;\n    /**\n     * Fading time for labels in seconds.\n     */\n    textFadeTime?: number;\n    /**\n     * Horizontal offset (to the right) in screen pixels.\n     */\n    xOffset?: number;\n    /**\n     * Vertical offset (up) in screen pixels.\n     */\n    yOffset?: number;\n    /**\n     * Name of the text style.\n     */\n    style?: string;\n    /**\n     * Name of the preferred [[Font]] to be used when rendering.\n     */\n    fontName?: string;\n    /**\n     * Size of the text (pixels).\n     */\n    size?: DynamicProperty<number>;\n    /**\n     * Size of the text background (pixels).\n     */\n    backgroundSize?: DynamicProperty<number>;\n    /**\n     * Glyph style to apply for the currently active [[Font]].\n     */\n    fontStyle?: \"Regular\" | \"Bold\" | \"Italic\" | \"BoldItalic\";\n    /**\n     * Glyph variant to apply for the currently active [[Font]].\n     */\n    fontVariant?: \"Regular\" | \"AllCaps\" | \"SmallCaps\";\n    /**\n     * Glyph local rotation (radians).\n     */\n    rotation?: number;\n    /**\n     * Text color in hexadecimal or CSS-style notation, for example: `\"#e4e9ec\"`, `\"#fff\"`,\n     * `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * @format color-hex\n     */\n    color?: DynamicProperty<StyleColor>;\n    /**\n     * Text background color in hexadecimal or CSS-style notation, for example: `\"#e4e9ec\"`,\n     * `\"#fff\"`, `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * @format color-hex\n     */\n    backgroundColor?: DynamicProperty<StyleColor>;\n    /**\n     * For transparent text, set a value between 0.0 for totally transparent, to 1.0 for totally\n     * opaque.\n     */\n    opacity?: DynamicProperty<number>;\n    /**\n     * Background text opacity value.\n     */\n    backgroundOpacity?: DynamicProperty<number>;\n    /**\n     * Inter-glyph spacing (pixels). Scaled by `size`.\n     */\n    tracking?: number;\n    /**\n     * Inter-line spacing (pixels). Scaled by `size`.\n     */\n    leading?: number;\n    /**\n     * Maximum number of lines for this label.\n     */\n    maxLines?: number;\n    /**\n     * Maximum line width (pixels).\n     */\n    lineWidth?: number;\n    /**\n     * [[TextCanvas]] rotation (radians).\n     */\n    canvasRotation?: number;\n    /**\n     * Line typesetting rotation (radians).\n     */\n    lineRotation?: number;\n    /**\n     * Wrapping (line-breaking) mode.\n     */\n    wrappingMode?: \"None\" | \"Character\" | \"Word\";\n    /**\n     * Text position regarding the baseline.\n     */\n    hAlignment?: \"Left\" | \"Center\" | \"Right\";\n    /**\n     * Text position inside a line.\n     */\n    vAlignment?: \"Above\" | \"Center\" | \"Below\";\n}\n\n/**\n * Buffer holding a texture.\n */\nexport interface TextureBuffer {\n    /**\n     * Buffer containing the (compressed) image or the raw texture data.\n     */\n    buffer: ArrayBuffer;\n\n    /**\n     * Mime type of the image or 'image/raw' in case of raw texture data.\n     */\n    type: string;\n\n    /**\n     * Properties for creating a three.js DataTexture\n     * (https://threejs.org/docs/#api/en/textures/DataTexture).\n     */\n    dataTextureProperties?: DataTextureProperties;\n}\n\n/**\n * Type guard to check if an object is an instance of `TextureBuffer`.\n */\nexport function isTextureBuffer(object: any): object is TextureBuffer {\n    return object && object.buffer && typeof object.type === \"string\";\n}\n\n/**\n * Properties of a DataTexture (https://threejs.org/docs/#api/en/textures/DataTexture).\n */\nexport interface DataTextureProperties {\n    width: number;\n    height: number;\n\n    format?: PixelFormat;\n    type?: TextureDataType;\n}\n\n/**\n * Properties of a Texture (https://threejs.org/docs/#api/en/textures/Texture).\n */\nexport interface TextureProperties {\n    /**\n     * Texture horizontal wrapping mode.\n     * See: https://threejs.org/docs/#api/en/textures/Texture.wrapS.\n     */\n    wrapS?: WrappingMode;\n\n    /**\n     * Texture vertical wrapping mode.\n     * See: https://threejs.org/docs/#api/en/textures/Texture.wrapT.\n     */\n    wrapT?: WrappingMode;\n\n    /**\n     * Texture magnification filter.\n     */\n    magFilter?: MagFilter;\n\n    /**\n     * Texture minification filter.\n     */\n    minFilter?: MinFilter;\n\n    /**\n     * Flip texture vertically.\n     * See: https://threejs.org/docs/#api/en/textures/Texture.flipY.\n     */\n    flipY?: boolean;\n\n    /**\n     * Texture horizontal repetition rate.\n     * See: https://threejs.org/docs/#api/en/textures/Texture.repeat.\n     */\n    repeatU?: number;\n\n    /**\n     * Texture vertical repetition rate.\n     * See: https://threejs.org/docs/#api/en/textures/Texture.repeat.\n     */\n    repeatV?: number;\n}\n\n/**\n * Interface containing the definition of different colors to be used at different heights with the\n * [[TerrainTechnique]].\n */\nexport interface HeightBasedColors {\n    heightArray: number[];\n    colorArray: string[];\n}\n\nexport type PixelFormat =\n    | \"Alpha\"\n    | \"RGB\"\n    | \"RGBA\"\n    | \"Luminance\"\n    | \"LuminanceAlpha\"\n    | \"RGBE\"\n    | \"Depth\"\n    | \"DepthStencil\"\n    | \"Red\";\n\nexport type TextureDataType =\n    | \"UnsignedByte\"\n    | \"Byte\"\n    | \"Short\"\n    | \"UnsignedShort\"\n    | \"Int\"\n    | \"UnsignedInt\"\n    | \"Float\"\n    | \"HalfFloat\";\n\n/**\n * Available texture wrapping modes.\n */\nexport type WrappingMode = \"clamp\" | \"repeat\" | \"mirror\";\n\n/**\n * Available texture magnification filters.\n */\nexport type MagFilter = \"nearest\" | \"linear\";\n\n/**\n * Available texture minification filters.\n */\nexport type MinFilter =\n    | \"nearest\"\n    | \"nearestMipMapNearest\"\n    | \"nearestMipMapLinear\"\n    | \"linear\"\n    | \"linearMipMapNearest\"\n    | \"linearMipMapLinear\";\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Technique } from \"./Techniques\";\n\nexport enum AttrScope {\n    /**\n     * Attributes that affect generation of feature geometry and thus must be resolved at decoding\n     * time.\n     *\n     * They may have huge variancy as they are implemented as vertex attributes or embedded in\n     * generated meshes.\n     *\n     * These attributes are available only in decoding scope.\n     */\n    FeatureGeometry,\n\n    /**\n     * Attributes that are common to whole group of features drawn with this technique.\n     * These attributes affect generated geometry and  thus must be resolved at decoding time.\n     *\n     * They shouldn't have big variancy and evaluate to at least dozens of values as each\n     * combination of these attributes consitute new technique and material.\n     *\n     * These attributes are available in decoding and rendering scope.\n     */\n    TechniqueGeometry,\n\n    /**\n     * Attributes that are common to whole group of features drawn with this technique.\n     * Attributes that can be changed in resulting object/material from frame to frame. They are\n     * usually implemented as uniforms.\n     *\n     * These attributes may be available only at rendering scope.\n     */\n    TechniqueRendering\n}\n\n/**\n * Extract  property names from [[Technique]]-like interface (excluding `name`) as union of string\n * literals.\n *\n * TechniquePropName<Base\n *\n */\nexport type TechniquePropNames<T> = T extends { name: any } ? keyof Omit<T, \"name\"> : keyof T;\n\nexport type TechniquePropScopes<T> = {\n    [P in TechniquePropNames<T>]?: AttrScope;\n};\n\nexport interface TechniqueDescriptor<T> {\n    attrTransparencyColor?: string;\n    attrScopes: TechniquePropScopes<T>;\n}\n\ntype OneThatMatches<T, P> = T extends P ? T : never;\ntype TechniqueByName<K extends Technique[\"name\"]> = OneThatMatches<Technique, { name: K }>;\n\nexport type TechniqueDescriptorRegistry = {\n    [P in Technique[\"name\"]]?: TechniqueDescriptor<TechniqueByName<P>>;\n};\n\nexport function mergeTechniqueDescriptor<T>(\n    ...descriptors: Array<Partial<TechniqueDescriptor<T>>>\n): TechniqueDescriptor<T> {\n    const result: TechniqueDescriptor<T> = {\n        attrScopes: {}\n    };\n    for (const descriptor of descriptors) {\n        if (descriptor.attrTransparencyColor !== undefined) {\n            result.attrTransparencyColor = descriptor.attrTransparencyColor;\n        }\n        if (descriptor.attrScopes !== undefined) {\n            result.attrScopes = { ...result.attrScopes, ...descriptor.attrScopes };\n        }\n    }\n    return result;\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    equirectangularProjection,\n    mercatorProjection,\n    normalizedEquirectangularProjection,\n    OrientedBox3,\n    Projection,\n    sphereProjection,\n    Vector3Like,\n    webMercatorProjection\n} from \"@here/harp-geoutils\";\nimport { Technique } from \"./Techniques\";\nimport { TileInfo } from \"./TileInfo\";\n\n/**\n * This object has geometry data in the form of geometries buffers ready to be used by WebGL.\n * These geometries are not `three.js` objects. They are pure data stored as `ArrayBuffer`s and\n * metadata describing these buffers.\n */\nexport interface DecodedTile {\n    techniques: Technique[];\n    geometries: Geometry[];\n    pathGeometries?: PathGeometry[];\n    textPathGeometries?: TextPathGeometry[];\n    textGeometries?: TextGeometry[]; // ### deprecate\n    poiGeometries?: PoiGeometry[];\n    tileInfo?: TileInfo;\n    maxGeometryHeight?: number;\n    decodeTime?: number; // time used to decode (in ms)\n\n    /**\n     * The default bounding box in [[Tile]] is based on the geo box of the tile.\n     * For data-sources that have 3d data this is not sufficient so the data-source can provide a\n     * more accurate bounding box once the data is decoded.\n     */\n    boundingBox?: OrientedBox3;\n\n    /**\n     * Tile data Copyright holder identifiers.\n     *\n     * `id`s should be unique. It is recommended to build them from unique identifiers like\n     * registered domain names.\n     *\n     * @see [[CopyrightInfo]]\n     */\n    copyrightHolderIds?: string[];\n}\n\n/**\n * This object keeps the path of the geometry. Space of the path depends on the\n * use case, so could be either world or local tile space.\n */\nexport interface PathGeometry {\n    path: Vector3Like[];\n}\n\n/**\n * Attributes corresponding to some decoded geometry. It may be either a map\n * of multiple attributes or just a number with the geometry's feature id.\n */\nexport type AttributeMap = {} | number;\n\n/**\n * This object keeps textual data together with metadata to place it on the map.\n */\nexport interface TextPathGeometry {\n    path: number[];\n    pathLengthSqr: number;\n    text: string;\n    technique: number;\n    objInfos?: AttributeMap;\n}\n\n/**\n * Returns an array with the data type specified as parameter.\n *\n * @param attr specifies which type of data is being stored in the array\n */\nexport function getArrayConstructor(attr: BufferElementType) {\n    switch (attr) {\n        case \"float\":\n            return Float32Array;\n        case \"uint8\":\n            return Uint8Array;\n        case \"uint16\":\n            return Uint16Array;\n        case \"uint32\":\n            return Uint32Array;\n        case \"int8\":\n            return Int8Array;\n        case \"int16\":\n            return Int16Array;\n        case \"int32\":\n            return Int32Array;\n    }\n}\n\n/**\n * Structured clone compliant WebGL interleaved buffer with its metadata attached.\n */\nexport interface InterleavedBufferAttribute {\n    buffer: ArrayBufferLike;\n    stride: number;\n    type: BufferElementType;\n    attributes: Array<{\n        name: string;\n        itemSize: number;\n        offset: number;\n    }>;\n}\n\n/**\n * Geometry types supported by [[Geometry]] objects.\n */\nexport enum GeometryType {\n    Unspecified = 0,\n    Point,\n    Line,\n    SolidLine,\n    Text,\n    TextPath,\n    ExtrudedLine,\n    Polygon,\n    ExtrudedPolygon,\n    Object3D,\n    Other = 1000\n}\n\n/**\n * Structured clone compliant version of a `three.js` geometry object, consisting of buffers with\n * metadata for map features and objects for example roads, trees or parks.\n */\nexport interface Geometry {\n    type: GeometryType;\n    vertexAttributes: BufferAttribute[];\n    interleavedVertexAttributes?: InterleavedBufferAttribute[];\n    index?: BufferAttribute;\n    edgeIndex?: BufferAttribute;\n    groups: Group[];\n    uuid?: string;\n\n    /**\n     * Optional list of feature start indices. The indices point into the index attribute.\n     */\n    featureStarts?: number[];\n\n    /**\n     * Optional array of objects. It can be used to pass user data from the geometry to the mesh.\n     */\n    objInfos?: AttributeMap[];\n}\n\n/**\n * The data stored in Buffers' elements can be of the following elementary types: float, signed or\n * unsigned integers (8-bit, 16-bit or 32-bit long).\n */\nexport type BufferElementType =\n    | \"float\"\n    | \"uint8\"\n    | \"uint16\"\n    | \"uint32\"\n    | \"int8\"\n    | \"int16\"\n    | \"int32\";\n\n/**\n * Structured clone compliant WebGL buffer and its metadata.\n */\nexport interface BufferAttribute {\n    name: string;\n    buffer: ArrayBufferLike;\n    type: BufferElementType;\n    itemCount: number;\n    normalized?: boolean;\n}\n\n/**\n * Structured clone compliant version of a `three.js` geometry object with text to be rendered.\n * It is composed of buffers with metadata for text objects.\n */\nexport interface TextGeometry {\n    positions: BufferAttribute;\n    texts: number[];\n    technique?: number;\n    stringCatalog?: Array<string | undefined>;\n    objInfos?: AttributeMap[];\n}\n\n/**\n * Structured clone compliant version of a `three.js` geometry object with points of interest (POIs)\n * to be rendered. It is composed of buffers with metadata for POI objects.\n */\nexport interface PoiGeometry {\n    positions: BufferAttribute;\n    texts: number[];\n    /**\n     * Names of the image texture or the name of the POI as indices into the array `stringCatalog`.\n     */\n    imageTextures?: number[];\n    technique?: number;\n    stringCatalog?: Array<string | undefined>;\n    objInfos?: AttributeMap[];\n}\n\n/**\n * Structured clone compliant WebGL group object and its metadata.\n * Its purpose is to make working with groups of objects easier.\n */\nexport interface Group {\n    start: number;\n    count: number;\n    technique: number;\n\n    /**\n     * Offset added to [[Technique]]'s [[renderOrder]] when calculating final `renderOrder` of\n     * geometry object from given group.\n     */\n    renderOrderOffset?: number;\n    featureId?: number;\n\n    /**\n     * Contains tile offsets if its [[Geometry]] has been created.\n     */\n    createdOffsets?: number[];\n}\n\n/**\n * Returns the projection object specified in the parameter.\n *\n * @param projectionName string describing projection to be used\n */\nexport function getProjection(projectionName: string): Projection | never {\n    switch (projectionName) {\n        case \"mercator\":\n            return mercatorProjection;\n        case \"webMercator\":\n            return webMercatorProjection;\n        case \"sphere\":\n            return sphereProjection;\n        case \"normalizedEquirectangular\":\n            return normalizedEquirectangularProjection;\n        case \"equirectangular\":\n            return equirectangularProjection;\n        default:\n            throw new Error(`Unknown projection ${projectionName}`);\n    } // switch\n}\n\n/**\n * String with the projection's name.\n *\n * @param projection `Projection` object containing the name of the projection to retrieve\n */\nexport function getProjectionName(projection: Projection): string | never {\n    if (projection === mercatorProjection) {\n        return \"mercator\";\n    } else if (projection === webMercatorProjection) {\n        return \"webMercator\";\n    } else if (projection === sphereProjection) {\n        return \"sphere\";\n    } else if (projection === normalizedEquirectangularProjection) {\n        return \"normalizedEquirectangular\";\n    } else if (projection === equirectangularProjection) {\n        return \"equirectangular\";\n    }\n    throw new Error(\"Unknown projection\");\n}\n\n/**\n * @returns Feature id from the provided attribute map.\n */\nexport function getFeatureId(attributeMap: AttributeMap | undefined): number {\n    if (attributeMap === undefined) {\n        return 0;\n    }\n\n    if (typeof attributeMap === \"number\") {\n        return attributeMap;\n    }\n\n    if (attributeMap.hasOwnProperty(\"$id\")) {\n        return (attributeMap as any).$id as number;\n    }\n\n    return 0;\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Represents an object with `GeoCoordinates` like interface.\n */\nexport interface GeoCoordinatesLike {\n    /** The latitude in degrees. */\n    latitude: number;\n\n    /** The longitude in degrees. */\n    longitude: number;\n\n    /** The optional altitude in meters. */\n    altitude?: number;\n}\n\n/**\n * Type guard to assert that `object` conforms to [[GeoCoordinatesLike]] data interface.\n */\nexport function isGeoCoordinatesLike(object: any): object is GeoCoordinatesLike {\n    return (\n        object &&\n        typeof object.latitude === \"number\" &&\n        typeof object.longitude === \"number\" &&\n        (typeof object.altitude === \"number\" || typeof object.altitude === \"undefined\")\n    );\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * An [[Array]] following the order longitude, latitude, altitude.\n */\nexport type GeoPointLike = [number, number, number?];\n\n/**\n * Type guard to assert that `object` conforms to [[GeoPointLike]] interface.\n */\nexport function isGeoPointLike(geoPoint: any): geoPoint is GeoPointLike {\n    if (Array.isArray(geoPoint)) {\n        const [longitude, latitude, altitude] = geoPoint;\n        return (\n            typeof longitude === \"number\" &&\n            typeof latitude === \"number\" &&\n            (altitude === undefined || typeof altitude === \"number\")\n        );\n    }\n    return false;\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Represents an object with `LatLng` like interface.\n */\nexport interface LatLngLike {\n    /** The latitude in degrees. */\n    lat: number;\n\n    /** The longitude in degrees. */\n    lng: number;\n}\n\n/**\n * Type guard to assert that `object` conforms to [[LatLngLike]] interface.\n */\nexport function isLatLngLike(object: any): object is LatLngLike {\n    return object && typeof object.lat === \"number\" && typeof object.lng === \"number\";\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeoBox } from \"../coordinates/GeoBox\";\nimport { GeoCoordinates } from \"../coordinates/GeoCoordinates\";\nimport { GeoCoordinatesLike } from \"../coordinates/GeoCoordinatesLike\";\nimport { Box3Like, isBox3Like } from \"../math/Box3Like\";\nimport { MathUtils } from \"../math/MathUtils\";\nimport { isOrientedBox3Like, OrientedBox3Like } from \"../math/OrientedBox3Like\";\nimport { Vector3Like } from \"../math/Vector3Like\";\nimport { EarthConstants } from \"./EarthConstants\";\nimport { Projection, ProjectionType } from \"./Projection\";\n\nimport * as THREE from \"three\";\n\nclass EquirectangularProjection extends Projection {\n    static geoToWorldScale: number = 1.0 / (2.0 * Math.PI);\n    static worldToGeoScale: number = (2.0 * Math.PI) / 1.0;\n\n    readonly type: ProjectionType = ProjectionType.Planar;\n\n    getScaleFactor(_worldPoint: Vector3Like): number {\n        return 1;\n    }\n\n    worldExtent<WorldBoundingBox extends Box3Like>(\n        minAltitude: number,\n        maxAltitude: number,\n        result?: WorldBoundingBox\n    ): WorldBoundingBox {\n        if (!result) {\n            result = MathUtils.newEmptyBox3() as WorldBoundingBox;\n        }\n        result.min.x = 0.0;\n        result.min.y = 0.0;\n        result.min.z = minAltitude;\n        result.max.x = this.unitScale;\n        result.max.y = this.unitScale / 2;\n        result.max.z = maxAltitude;\n        return result;\n    }\n\n    projectPoint<WorldCoordinates extends Vector3Like>(\n        geoPoint: GeoCoordinatesLike,\n        result?: WorldCoordinates\n    ): WorldCoordinates {\n        if (result === undefined) {\n            /*\n             * The following tslint:disable is due to the fact that the [[WorldCoordinates]]\n             * might be a concrete class which is not available at runtime.\n             * Consider the following example:\n             *\n             *  const x: THREE.Vector3 = new THREE.Vector3(0,0,0);\n             *  const result = EquirectangularProjection.projectPoint<THREE.Vector3>(x);\n             *\n             * Note: type of `result` is Vector3Like and not as expected: THREE.Vector3!\n             */\n            // tslint:disable-next-line:no-object-literal-type-assertion\n            result = { x: 0, y: 0, z: 0 } as WorldCoordinates;\n        }\n        result.x =\n            (THREE.Math.degToRad(geoPoint.longitude) + Math.PI) *\n            EquirectangularProjection.geoToWorldScale *\n            this.unitScale;\n        result.y =\n            (THREE.Math.degToRad(geoPoint.latitude) + Math.PI * 0.5) *\n            EquirectangularProjection.geoToWorldScale *\n            this.unitScale;\n        result.z = geoPoint.altitude || 0;\n        return result;\n    }\n\n    unprojectPoint(worldPoint: Vector3Like): GeoCoordinates {\n        const geoPoint = GeoCoordinates.fromRadians(\n            (worldPoint.y * EquirectangularProjection.worldToGeoScale) / this.unitScale -\n                Math.PI * 0.5,\n            (worldPoint.x * EquirectangularProjection.worldToGeoScale) / this.unitScale - Math.PI,\n            worldPoint.z\n        );\n        return geoPoint;\n    }\n\n    unprojectAltitude(worldPoint: Vector3Like): number {\n        return worldPoint.z;\n    }\n\n    projectBox<WorldBoundingBox extends Box3Like | OrientedBox3Like>(\n        geoBox: GeoBox,\n        result?: WorldBoundingBox\n    ): WorldBoundingBox {\n        const worldCenter = this.projectPoint(\n            new GeoCoordinates(geoBox.center.latitude, geoBox.center.longitude, 0)\n        );\n        const { latitudeSpanInRadians, longitudeSpanInRadians, altitudeSpan } = geoBox;\n        const sizeX = longitudeSpanInRadians * EquirectangularProjection.geoToWorldScale;\n        const sizeY = latitudeSpanInRadians * EquirectangularProjection.geoToWorldScale;\n        if (!result) {\n            result = MathUtils.newEmptyBox3() as WorldBoundingBox;\n        }\n        if (isBox3Like(result)) {\n            result.min.x = worldCenter.x - sizeX * 0.5 * this.unitScale;\n            result.min.y = worldCenter.y - sizeY * 0.5 * this.unitScale;\n            result.max.x = worldCenter.x + sizeX * 0.5 * this.unitScale;\n            result.max.y = worldCenter.y + sizeY * 0.5 * this.unitScale;\n            if (altitudeSpan !== undefined) {\n                result.min.z = worldCenter.z - altitudeSpan * 0.5;\n                result.max.z = worldCenter.z + altitudeSpan * 0.5;\n            } else {\n                result.min.z = 0;\n                result.max.z = 0;\n            }\n        } else if (isOrientedBox3Like(result)) {\n            MathUtils.newVector3(1, 0, 0, result.xAxis);\n            MathUtils.newVector3(0, 1, 0, result.yAxis);\n            MathUtils.newVector3(0, 0, 1, result.zAxis);\n            result.position.x = worldCenter.x;\n            result.position.y = worldCenter.y;\n            result.position.z = worldCenter.z;\n            result.extents.x = sizeX * 0.5 * this.unitScale;\n            result.extents.y = sizeY * 0.5 * this.unitScale;\n            result.extents.z = Math.max(Number.EPSILON, (altitudeSpan || 0) * 0.5);\n        }\n        return result;\n    }\n\n    unprojectBox(worldBox: Box3Like): GeoBox {\n        const minGeo = this.unprojectPoint(worldBox.min);\n        const maxGeo = this.unprojectPoint(worldBox.max);\n        return GeoBox.fromCoordinates(minGeo, maxGeo);\n    }\n\n    groundDistance(worldPoint: Vector3Like): number {\n        return worldPoint.z;\n    }\n\n    scalePointToSurface(worldPoint: Vector3Like): Vector3Like {\n        worldPoint.z = 0;\n        return worldPoint;\n    }\n\n    surfaceNormal(_worldPoint: Vector3Like, normal?: Vector3Like) {\n        if (normal === undefined) {\n            normal = { x: 0, y: 0, z: 1 };\n        } else {\n            normal.x = 0;\n            normal.y = 0;\n            normal.z = 1;\n        }\n        return normal;\n    }\n}\n\n/**\n * Equirectangular [[Projection]] used to convert geo coordinates to unit coordinates and vice\n * versa.\n */\nexport const normalizedEquirectangularProjection: Projection = new EquirectangularProjection(1);\n\n/**\n * Equirectangular [[Projection]] used to convert geo coordinates to world coordinates and vice\n * versa.\n */\nexport const equirectangularProjection: Projection = new EquirectangularProjection(\n    EarthConstants.EQUATORIAL_CIRCUMFERENCE\n);\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeoBox } from \"../coordinates/GeoBox\";\nimport { GeoCoordinates } from \"../coordinates/GeoCoordinates\";\nimport { GeoCoordinatesLike } from \"../coordinates/GeoCoordinatesLike\";\nimport { Box3Like, isBox3Like } from \"../math/Box3Like\";\nimport { MathUtils } from \"../math/MathUtils\";\nimport { isOrientedBox3Like, OrientedBox3Like } from \"../math/OrientedBox3Like\";\nimport { Vector3Like } from \"../math/Vector3Like\";\nimport { EarthConstants } from \"./EarthConstants\";\nimport { Projection, ProjectionType } from \"./Projection\";\n\n/**\n *\n * https://en.wikipedia.org/wiki/Transverse_Mercator_projection\n * http://mathworld.wolfram.com/MercatorProjection.html\n *\n */\nclass TransverseMercatorProjection extends Projection {\n    /**\n     * Like in regular Mercator projection, there are two points on sphere\n     * with radius about 5 degrees, that is out of projected space.\n     *\n     *\n     * in regular Mercator these points are:\n     *     (90, any), (-90, any)\n     *\n     * and in transverse Mercator:\n     *     (0, 90), (0, -90)\n     *\n     * So, in transverse we need to compute distnce to poles, and clamp if\n     * radius is exceeded\n     */\n    static clampGeoPoint(geoPoint: GeoCoordinatesLike, unitScale: number) {\n        const lat = geoPoint.latitude;\n        const lon = geoPoint.longitude;\n\n        const r = TransverseMercatorUtils.POLE_RADIUS;\n        const rsq = TransverseMercatorUtils.POLE_RADIUS_SQ;\n\n        const nearestQuarter = Math.round(lon / 90);\n        const deltaLon = nearestQuarter * 90 - lon;\n        if (nearestQuarter % 2 === 0 || Math.abs(deltaLon) > r) {\n            return geoPoint;\n        }\n\n        const deltaLat = lat - 0;\n        const distanceToPoleSq = deltaLon * deltaLon + deltaLat * deltaLat;\n        if (distanceToPoleSq < rsq) {\n            const distanceToPole = Math.sqrt(distanceToPoleSq);\n            const scale = (r - distanceToPole) / distanceToPole;\n            // const quarter = ((nearestQuarter % 4) + 4) % 4;\n            // const dir = quarter === 1 ? -1 : quarter === 3 ? 1 : 0;\n            const dir = 1;\n            const offsetLon = deltaLon === 0 && deltaLat === 0 ? r * dir : deltaLon;\n            return new GeoCoordinates(lat + deltaLat * scale, lon + offsetLon * scale);\n        }\n\n        return geoPoint;\n    }\n\n    readonly type: ProjectionType = ProjectionType.Planar;\n\n    private m_phi0: number = 0;\n    private m_lambda0: number = 0;\n\n    constructor(readonly unitScale: number) {\n        super(unitScale);\n    }\n\n    getScaleFactor(worldPoint: Vector3Like): number {\n        return Math.cosh((worldPoint.x / this.unitScale - 0.5) * 2 * Math.PI);\n    }\n\n    worldExtent<WorldBoundingBox extends Box3Like>(\n        minAltitude: number,\n        maxAltitude: number,\n        result?: WorldBoundingBox\n    ): WorldBoundingBox {\n        if (!result) {\n            result = MathUtils.newEmptyBox3() as WorldBoundingBox;\n        }\n        result.min.x = 0;\n        result.min.y = 0;\n        result.min.z = minAltitude;\n        result.max.x = this.unitScale;\n        result.max.y = this.unitScale;\n        result.max.z = maxAltitude;\n        return result;\n    }\n\n    projectPoint<WorldCoordinates extends Vector3Like>(\n        geoPoint: GeoCoordinatesLike,\n        result?: WorldCoordinates\n    ): WorldCoordinates {\n        if (!result) {\n            // tslint:disable-next-line:no-object-literal-type-assertion\n            result = { x: 0, y: 0, z: 0 } as WorldCoordinates;\n        }\n\n        const clamped = TransverseMercatorProjection.clampGeoPoint(geoPoint, this.unitScale);\n        const normalLon = clamped.longitude / 360 + 0.5;\n        const offset = normalLon === 1 ? 0 : Math.floor(normalLon);\n        const phi = MathUtils.degToRad(clamped.latitude);\n        const lambda = MathUtils.degToRad(clamped.longitude - offset * 360) - this.m_lambda0;\n\n        const B = Math.cos(phi) * Math.sin(lambda);\n        // result.x = 1/2 * Math.log((1 + B) / (1 - B));\n        result.x = Math.atanh(B);\n        result.y = Math.atan2(Math.tan(phi), Math.cos(lambda)) - this.m_phi0;\n\n        const outScale = 0.5 / Math.PI;\n        result.x = this.unitScale * (MathUtils.clamp(result.x * outScale + 0.5, 0, 1) + offset);\n        result.y = this.unitScale * MathUtils.clamp(result.y * outScale + 0.5, 0, 1);\n\n        result.z = geoPoint.altitude || 0;\n        return result;\n    }\n\n    unprojectPoint(worldPoint: Vector3Like): GeoCoordinates {\n        const tau = Math.PI * 2;\n        const nx = worldPoint.x / this.unitScale;\n        const ny = worldPoint.y / this.unitScale;\n        const offset = nx === 1 ? 0 : Math.floor(nx);\n        const x = tau * (nx - 0.5 - offset);\n        const y = tau * (ny - 0.5);\n        const z = worldPoint.z || 0;\n\n        const D = y + this.m_phi0;\n\n        const phi = Math.asin(Math.sin(D) / Math.cosh(x));\n        const lambda = this.m_lambda0 + Math.atan2(Math.sinh(x), Math.cos(D)) + offset * tau;\n\n        const geoPoint = GeoCoordinates.fromRadians(phi, lambda, z);\n        return geoPoint;\n    }\n\n    projectBox<WorldBoundingBox extends Box3Like | OrientedBox3Like>(\n        geoBox: GeoBox,\n        result?: WorldBoundingBox\n    ): WorldBoundingBox {\n        const { north, south, east, west } = geoBox;\n\n        const pointsToCheck = [\n            geoBox.center,\n            geoBox.northEast,\n            geoBox.southWest,\n            new GeoCoordinates(south, east),\n            new GeoCoordinates(north, west)\n        ];\n\n        const E = TransverseMercatorUtils.POLE_EDGE_DEG;\n\n        const containsWestCut = west < -90 && east > -90;\n        const containsEastCut = west < 90 && east > 90;\n        const containsCenterX = west < 0 && east > 0;\n        const containsCenterY = west < E && east > -E && north > 0 && south < 0;\n\n        if (containsWestCut) {\n            pointsToCheck.push(new GeoCoordinates(north, -90));\n            pointsToCheck.push(new GeoCoordinates(south, -90));\n        }\n\n        if (containsEastCut) {\n            pointsToCheck.push(new GeoCoordinates(north, 90));\n            pointsToCheck.push(new GeoCoordinates(south, 90));\n        }\n\n        if (containsCenterX) {\n            pointsToCheck.push(new GeoCoordinates(north, 0));\n            pointsToCheck.push(new GeoCoordinates(south, 0));\n        }\n\n        if (containsCenterY) {\n            pointsToCheck.push(new GeoCoordinates(0, west));\n            pointsToCheck.push(new GeoCoordinates(0, east));\n        }\n\n        TransverseMercatorUtils.alignLatitude(pointsToCheck, pointsToCheck[0]);\n\n        const projected = pointsToCheck.map(p => this.projectPoint(p));\n        const vx = projected.map(p => p.x);\n        const vy = projected.map(p => p.y);\n        const vz = projected.map(p => p.z);\n\n        const minX = Math.min(...vx);\n        const minY = Math.min(...vy);\n        const minZ = Math.min(...vz);\n        const maxX = Math.max(...vx);\n        const maxY = Math.max(...vy);\n        const maxZ = Math.max(...vz);\n\n        if (!result) {\n            result = MathUtils.newEmptyBox3() as WorldBoundingBox;\n        }\n        if (isBox3Like(result)) {\n            result.min.x = minX;\n            result.min.y = minY;\n            result.min.z = minZ;\n            result.max.x = maxX;\n            result.max.y = maxY;\n            result.max.z = maxZ;\n        } else if (isOrientedBox3Like(result)) {\n            MathUtils.newVector3(1, 0, 0, result.xAxis);\n            MathUtils.newVector3(0, 1, 0, result.yAxis);\n            MathUtils.newVector3(0, 0, 1, result.zAxis);\n            result.position.x = (minX + maxX) / 2;\n            result.position.y = (minY + maxY) / 2;\n            result.position.z = (minZ + maxZ) / 2;\n            result.extents.x = (maxX - minX) / 2;\n            result.extents.y = (maxY - minY) / 2;\n            result.extents.z = (maxZ - minZ) / 2;\n        } else {\n            throw new Error(\"invalid bounding box\");\n        }\n        return result;\n    }\n\n    /**\n     * There are 8 sub-regions on entire projection space\n     * where both longitude and latitude preserve direction.\n     * If bounding box hits more than one region, it should be splitted\n     * into sub-boxes by regions, (un)projected and then united again.\n     *\n     *\n     * directions in form [latitude / longitude]:\n     *    1 |\n     *       dr / dl | dl / ul \n     * 0.75 ----------|----------\n     *       ur / dr | ul / ur \n     * 0.5  ----------|----------\n     *       ul / ur | ur / dr \n     * 0.25 ----------|----------\n     *       dl / ul | dr / dl \n     *      |\n     *     0         0.5        1\n     */\n    unprojectBox(worldBox: Box3Like): GeoBox {\n        const s = this.unitScale;\n\n        const min = worldBox.min;\n        const max = worldBox.max;\n        const pointsToCheck = [\n            { x: (min.x + max.x) / 2, y: (min.y + max.y) / 2, z: 0 },\n            min,\n            max,\n            { x: min.x, y: max.y, z: 0 },\n            { x: max.x, y: min.y, z: 0 }\n        ];\n\n        const center = 0.5 * s;\n        const lowerQ = 0.25 * s;\n        const upperQ = 0.75 * s;\n\n        const containsCenterX = min.x < center && max.x > center;\n        const containsCenterY = min.y < center && max.y > center;\n        const containsLowerQY = min.y < lowerQ && max.y > lowerQ;\n        const containsUpperQY = min.y < upperQ && max.y > upperQ;\n\n        if (containsCenterY) {\n            pointsToCheck.push({ x: min.x, y: center, z: 0 });\n            pointsToCheck.push({ x: max.x, y: center, z: 0 });\n\n            if (containsCenterX) {\n                pointsToCheck.push({ x: center, y: center, z: 0 });\n            }\n        }\n        if (containsLowerQY) {\n            pointsToCheck.push({ x: min.x, y: lowerQ, z: 0 });\n            pointsToCheck.push({ x: max.x, y: lowerQ, z: 0 });\n\n            if (containsCenterX) {\n                pointsToCheck.push({ x: center, y: lowerQ, z: 0 });\n            }\n        }\n        if (containsUpperQY) {\n            pointsToCheck.push({ x: min.x, y: upperQ, z: 0 });\n            pointsToCheck.push({ x: max.x, y: upperQ, z: 0 });\n\n            if (containsCenterX) {\n                pointsToCheck.push({ x: center, y: upperQ, z: 0 });\n            }\n        }\n\n        const geoPoints = pointsToCheck.map(p => this.unprojectPoint(p));\n        TransverseMercatorUtils.alignLongitude(geoPoints, geoPoints[0]);\n\n        const latitudes = geoPoints.map(g => g.latitude);\n        const longitudes = geoPoints.filter(g => Math.abs(g.latitude) < 90).map(g => g.longitude);\n        const altitudes = geoPoints.map(g => g.altitude || 0);\n\n        const minGeo = new GeoCoordinates(\n            Math.min(...latitudes),\n            Math.min(...longitudes),\n            Math.min(...altitudes)\n        );\n\n        const maxGeo = new GeoCoordinates(\n            Math.max(...latitudes),\n            Math.max(...longitudes),\n            Math.max(...altitudes)\n        );\n\n        const geoBox = GeoBox.fromCoordinates(minGeo, maxGeo);\n        return geoBox;\n    }\n\n    unprojectAltitude(worldPoint: Vector3Like): number {\n        return worldPoint.z;\n    }\n\n    groundDistance(worldPoint: Vector3Like): number {\n        return worldPoint.z;\n    }\n\n    scalePointToSurface(worldPoint: Vector3Like): Vector3Like {\n        worldPoint.z = 0;\n        return worldPoint;\n    }\n\n    surfaceNormal(_worldPoint: Vector3Like, normal?: Vector3Like) {\n        if (normal === undefined) {\n            normal = { x: 0, y: 0, z: -1 };\n        } else {\n            normal.x = 0;\n            normal.y = 0;\n            normal.z = -1;\n        }\n        return normal;\n    }\n}\n\nexport class TransverseMercatorUtils {\n    static POLE_EDGE: number = 1.4844222297453323;\n    static POLE_EDGE_DEG: number = MathUtils.radToDeg(TransverseMercatorUtils.POLE_EDGE);\n    static POLE_RADIUS: number = 90 - TransverseMercatorUtils.POLE_EDGE_DEG;\n    static POLE_RADIUS_SQ: number = Math.pow(TransverseMercatorUtils.POLE_RADIUS, 2);\n\n    /**\n     * There are two regions on projected space that have same geo coordinates,\n     * it's the entire lines   { x: [0..1], y: 0 } and { x: [0..1], y: 1 }\n     * they both have geo coordinates of   (0, [-90..+90])\n     * and should be aligned somehow to fall into first or second region\n     * to make proper bounding boxes, tile bounds, etc.\n     */\n    static alignLatitude(points: GeoCoordinatesLike[], referencePoint: GeoCoordinatesLike): void {\n        const EPSILON = 1e-9;\n\n        for (const point of points) {\n            if (point.latitude === 0) {\n                point.latitude = referencePoint.latitude * EPSILON;\n            }\n        }\n    }\n\n    /**\n     * There are two regions on projected plane,\n     * { x: 0.5, y: [0..0.25] }    and    { x: 0.5, y: [0.75..1] }\n     * that represent longitude edge where -180 and +180 met.\n     * Points falling in this regions should be aligned to get proper boxes etc.\n     */\n    static alignLongitude(points: GeoCoordinatesLike[], referencePoint: GeoCoordinatesLike): void {\n        const bad = referencePoint.longitude < 0 ? 180 : -180;\n        const good = referencePoint.longitude < 0 ? -180 : 180;\n\n        for (const point of points) {\n            if (point.longitude === bad) {\n                point.longitude = good;\n            }\n        }\n    }\n}\n\n/**\n * Transverse Mercator [[Projection]] used to convert geo coordinates to world coordinates\n * and vice versa.\n */\nexport const transverseMercatorProjection: Projection = new TransverseMercatorProjection(\n    EarthConstants.EQUATORIAL_CIRCUMFERENCE\n);\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeoBox } from \"../coordinates/GeoBox\";\nimport { Box3Like } from \"../math/Box3Like\";\nimport { MathUtils } from \"../math/MathUtils\";\nimport { Vector3Like } from \"../math/Vector3Like\";\nimport { Projection } from \"../projection/Projection\";\nimport { SubdivisionScheme } from \"./SubdivisionScheme\";\nimport { TileKey } from \"./TileKey\";\nimport { TilingScheme } from \"./TilingScheme\";\n\n/**\n * `FlatTileBoundingBoxGenerator` generates bounding boxes in world and geo coordinates for a given\n * TilingScheme.\n */\nexport class FlatTileBoundingBoxGenerator {\n    private readonly m_tilingScheme: TilingScheme;\n    private readonly m_worldDimensions: Vector3Like;\n    private readonly m_worldBox: Box3Like;\n    /**\n     * Creates a new `FlatTileBoundingBoxGenerator` that can generate bounding boxes for the given\n     * TilingScheme.\n     *\n     * @param tilingScheme The [[TilingScheme]] used to compute bounding boxes.\n     * @param minElevation The minimum elevation in meters.\n     * @param maxElevation The maximum elevation in meters.\n     */\n    constructor(\n        readonly tilingScheme: TilingScheme,\n        readonly minElevation: number = 0,\n        readonly maxElevation: number = 0\n    ) {\n        this.m_tilingScheme = tilingScheme;\n        this.m_worldBox = tilingScheme.projection.worldExtent(minElevation, maxElevation);\n        const { min, max } = this.m_worldBox;\n        this.m_worldDimensions = { x: max.x - min.x, y: max.y - min.y, z: max.z - min.z };\n    }\n\n    /**\n     * Returns the [[Projection]] of the [[TilingScheme]].\n     */\n    get projection(): Projection {\n        return this.m_tilingScheme.projection;\n    }\n\n    /**\n     * Returns the [[SubdivisionScheme]] of the [[TilingScheme]].\n     */\n    get subdivisionScheme(): SubdivisionScheme {\n        return this.m_tilingScheme.subdivisionScheme;\n    }\n\n    /**\n     * Returns the bounding box in world coordinates of the given [[TileKey]].\n     *\n     * Example:\n     * ```typescript\n     * const worldBounds = new THREE.Box3();\n     * generator.getWorldBox(geoBox, worldBounds);\n     * console.log(worldBounds.getCenter());\n     * ```\n     *\n     * @param tileKey The TileKey.\n     * @param result The optional object used to store the resulting bounding box in world\n     * coordinates.\n     */\n    getWorldBox(tileKey: TileKey, result?: Box3Like): Box3Like {\n        const level = tileKey.level;\n        const levelDimensionX = this.subdivisionScheme.getLevelDimensionX(level);\n        const levelDimensionY = this.subdivisionScheme.getLevelDimensionY(level);\n        const sizeX = this.m_worldDimensions.x / levelDimensionX;\n        const sizeY = this.m_worldDimensions.y / levelDimensionY;\n        const originX = this.m_worldBox.min.x + sizeX * tileKey.column;\n        const originY = this.m_worldBox.min.y + sizeY * tileKey.row;\n\n        if (!result) {\n            result = MathUtils.newEmptyBox3();\n        }\n\n        result.min.x = originX;\n        result.min.y = originY;\n        result.min.z = this.m_worldBox.min.z;\n        result.max.x = originX + sizeX;\n        result.max.y = originY + sizeY;\n        result.max.z = this.m_worldBox.max.z;\n        return result;\n    }\n\n    /**\n     * Returns the bounding box in geo coordinates for the given [[TileKey]].\n     *\n     * Example:\n     * ```typescript\n     * const geoBox = generator.getGeoBox(worldBounds);\n     * console.log(geoBox.center);\n     * ```\n     *\n     * @param tileKey The [[TileKey]].\n     */\n    getGeoBox(tileKey: TileKey): GeoBox {\n        const worldBox = this.getWorldBox(tileKey);\n        return this.projection.unprojectBox(worldBox);\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { SubdivisionScheme } from \"./SubdivisionScheme\";\n\nclass HalfQuadTreeSubdivisionScheme implements SubdivisionScheme {\n    getSubdivisionX(): number {\n        return 2;\n    }\n    getSubdivisionY(level: number): number {\n        return level === 0 ? 1 : 2;\n    }\n    getLevelDimensionX(level: number): number {\n        // tslint:disable-next-line:no-bitwise\n        return 1 << level;\n    }\n    getLevelDimensionY(level: number): number {\n        // tslint:disable-next-line:no-bitwise\n        return level !== 0 ? 1 << (level - 1) : 1;\n    }\n}\n\n/**\n * A [[SubdivisionScheme]] used to represent half quadtrees. This particular subdivision scheme is\n * used by the HERE tiling scheme.\n */\nexport const halfQuadTreeSubdivisionScheme: SubdivisionScheme = new HalfQuadTreeSubdivisionScheme();\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { TileKey } from \"./TileKey\";\n\nexport class SubTiles implements Iterable<TileKey> {\n    constructor(public tileKey: TileKey, public sizeX: number, public sizeY: number) {}\n\n    [Symbol.iterator](): Iterator<TileKey> {\n        return this.sizeX === 2 && this.sizeY === 2\n            ? SubTiles.ZCurveIterator(this.tileKey)\n            : SubTiles.RowColumnIterator(this.tileKey, this.sizeX, this.sizeY);\n    }\n}\n\nexport namespace SubTiles {\n    export function* RowColumnIterator(\n        parentKey: TileKey,\n        sizeX: number,\n        sizeY: number\n    ): Iterator<TileKey> {\n        for (let y = 0; y < sizeY; y++) {\n            for (let x = 0; x < sizeX; x++) {\n                yield TileKey.fromRowColumnLevel(\n                    parentKey.row * sizeY + y,\n                    parentKey.column * sizeX + x,\n                    parentKey.level + 1\n                );\n            }\n        }\n    }\n\n    export function* ZCurveIterator(parentKey: TileKey): Iterator<TileKey> {\n        // tslint:disable:no-bitwise\n        for (let i = 0; i < 4; i++) {\n            yield TileKey.fromRowColumnLevel(\n                (parentKey.row << 1) | (i >> 1),\n                (parentKey.column << 1) | (i & 1),\n                parentKey.level + 1\n            );\n        }\n        // tslint:enableno-bitwise\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeoBox } from \"../coordinates/GeoBox\";\nimport { GeoCoordinates } from \"../coordinates/GeoCoordinates\";\nimport { GeoCoordinatesLike } from \"../coordinates/GeoCoordinatesLike\";\nimport { Vector3Like } from \"../math/Vector3Like\";\nimport { TileKey } from \"./TileKey\";\nimport { TilingScheme } from \"./TilingScheme\";\n\nexport class TileKeyUtils {\n    static geoCoordinatesToTileKey(\n        tilingScheme: TilingScheme,\n        geoPoint: GeoCoordinatesLike,\n        level: number\n    ): TileKey | null {\n        const projection = tilingScheme.projection;\n        const worldPoint = projection.projectPoint(geoPoint);\n\n        return this.worldCoordinatesToTileKey(tilingScheme, worldPoint, level);\n    }\n\n    static worldCoordinatesToTileKey(\n        tilingScheme: TilingScheme,\n        worldPoint: Vector3Like,\n        level: number\n    ): TileKey | null {\n        const projection = tilingScheme.projection;\n        const subdivisionScheme = tilingScheme.subdivisionScheme;\n\n        const cx = subdivisionScheme.getLevelDimensionX(level);\n        const cy = subdivisionScheme.getLevelDimensionY(level);\n\n        const { min, max } = projection.worldExtent(0, 0);\n        const worldSizeX = max.x - min.x;\n        const worldSizeY = max.y - min.y;\n\n        if (worldPoint.x < min.x || worldPoint.x > max.x) {\n            return null;\n        }\n\n        if (worldPoint.y < min.y || worldPoint.y > max.y) {\n            return null;\n        }\n\n        const column = Math.min(cx - 1, Math.floor((cx * (worldPoint.x - min.x)) / worldSizeX));\n        const row = Math.min(cy - 1, Math.floor((cy * (worldPoint.y - min.y)) / worldSizeY));\n\n        return TileKey.fromRowColumnLevel(row, column, level);\n    }\n\n    static geoRectangleToTileKeys(\n        tilingScheme: TilingScheme,\n        geoBox: GeoBox,\n        level: number\n    ): TileKey[] {\n        const wrap = (value: number, lower: number, upper: number) => {\n            if (value < lower) {\n                return upper - ((lower - value) % (upper - lower));\n            }\n\n            return lower + ((value - lower) % (upper - lower));\n        };\n\n        const clamp = (x: number, minVal: number, maxVal: number) => {\n            return Math.min(Math.max(x, minVal), maxVal);\n        };\n\n        // Clamp at the poles and wrap around the international date line.\n        const southWestLongitude = wrap(geoBox.southWest.longitudeInRadians, -Math.PI, Math.PI);\n        const southWestLatitude = clamp(\n            geoBox.southWest.latitudeInRadians,\n            -(Math.PI * 0.5),\n            Math.PI * 0.5\n        );\n        const northEastLongitude = wrap(geoBox.northEast.longitudeInRadians, -Math.PI, Math.PI);\n        const northEastLatitude = clamp(\n            geoBox.northEast.latitudeInRadians,\n            -(Math.PI * 0.5),\n            Math.PI * 0.5\n        );\n        const minTileKey = TileKeyUtils.geoCoordinatesToTileKey(\n            tilingScheme,\n            GeoCoordinates.fromRadians(southWestLatitude, southWestLongitude),\n            level\n        );\n        const maxTileKey = TileKeyUtils.geoCoordinatesToTileKey(\n            tilingScheme,\n            GeoCoordinates.fromRadians(northEastLatitude, northEastLongitude),\n            level\n        );\n        const columnCount = tilingScheme.subdivisionScheme.getLevelDimensionX(level);\n\n        if (!minTileKey || !maxTileKey) {\n            throw new Error(\"Invalid coordinates\");\n        }\n\n        const minColumn = minTileKey.column;\n        let maxColumn = maxTileKey.column;\n\n        // wrap around case\n        if (southWestLongitude > northEastLongitude) {\n            if (maxColumn !== minColumn) {\n                maxColumn += columnCount;\n            } else {\n                // do not duplicate\n                maxColumn += columnCount - 1;\n            }\n        }\n\n        const minRow = Math.min(minTileKey.row, maxTileKey.row);\n        const maxRow = Math.max(minTileKey.row, maxTileKey.row);\n\n        const keys = new Array<TileKey>();\n\n        for (let row = minRow; row <= maxRow; ++row) {\n            for (let column = minColumn; column <= maxColumn; ++column) {\n                keys.push(TileKey.fromRowColumnLevel(row, column % columnCount, level));\n            }\n        }\n\n        return keys;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { SubdivisionScheme } from \"./SubdivisionScheme\";\nimport { SubTiles } from \"./SubTiles\";\nimport { TileKey } from \"./TileKey\";\n\nexport class TileTreeTraverse {\n    private m_subdivisionScheme: SubdivisionScheme;\n\n    constructor(subdivisionScheme: SubdivisionScheme) {\n        this.m_subdivisionScheme = subdivisionScheme;\n    }\n\n    subTiles(tileKey: TileKey): Iterable<TileKey> {\n        const divX = this.m_subdivisionScheme.getSubdivisionX(tileKey.level);\n        const divY = this.m_subdivisionScheme.getSubdivisionY(tileKey.level);\n\n        return new SubTiles(tileKey, divX, divY);\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { LoggerManager } from \"@here/harp-utils\";\n\nimport {\n    BooleanLiteralExpr,\n    CallExpr,\n    CaseExpr,\n    ContainsExpr,\n    Env,\n    Expr,\n    ExprScope,\n    ExprVisitor,\n    HasAttributeExpr,\n    isJsonExpr,\n    JsonExpr,\n    MatchExpr,\n    NullLiteralExpr,\n    NumberLiteralExpr,\n    ObjectLiteralExpr,\n    StringLiteralExpr,\n    Value,\n    VarExpr\n} from \"./Expr\";\nimport { ExprPool } from \"./ExprPool\";\nimport { isInterpolatedPropertyDefinition } from \"./InterpolatedProperty\";\nimport { interpolatedPropertyDefinitionToJsonExpr } from \"./InterpolatedPropertyDefs\";\nimport { AttrScope, mergeTechniqueDescriptor, TechniquePropNames } from \"./TechniqueDescriptor\";\nimport { IndexedTechnique, Technique, techniqueDescriptors } from \"./Techniques\";\nimport {\n    Definitions,\n    isActualSelectorDefinition,\n    isJsonExprReference,\n    LineStyle,\n    Style,\n    StyleDeclaration,\n    StyleSelector,\n    StyleSet\n} from \"./Theme\";\n\nconst logger = LoggerManager.instance.create(\"StyleSetEvaluator\");\n\nconst emptyTechniqueDescriptor = mergeTechniqueDescriptor<Technique>({});\n\ninterface StyleInternalParams {\n    /**\n     * Optimization: Lazy creation and storage of expression in a style object.\n     */\n    _whenExpr?: Expr;\n    _minZoomLevelExpr?: Expr;\n    _maxZoomLevelExpr?: Expr;\n\n    _staticAttributes?: Array<[string, Value]>;\n\n    /**\n     * These attributes are used to instantiate Technique variants.\n     *\n     * @see [[TechiqueDescriptor.techniquePropNames]]\n     */\n    _dynamicTechniqueAttributes?: Array<[string, Expr]>;\n\n    /**\n     * These attributes must be evaluated basing with feature env.\n     *\n     * They are not propagated to rendering scope.\n     *\n     * @see [[TechniqueAttrScope.Feature]]\n     */\n    _dynamicFeatureAttributes?: Array<[string, Expr]>;\n\n    /**\n     * These attributes are forwarded as serialized by decoder to main thread, so they are resolved\n     * directly in render loop.\n     *\n     * Will contain attributes from these lists\n     *  - interpolants from [[TechiqueDescriptor.techniquePropNames]]\n     *  - expressions [[TechniqueDescriptor.dynamicPropNames]] (Future)\n     */\n    _dynamicForwardedAttributes?: Array<[string, Expr]>;\n    _dynamicTechniques?: Map<string, IndexedTechnique>;\n\n    /**\n     * Optimization: Index into table in StyleSetEvaluator.\n     * @hidden\n     */\n    _staticTechnique?: IndexedTechnique;\n\n    /**\n     * Optimization: StyleSet index.\n     * @hidden\n     */\n    _styleSetIndex?: number;\n\n    /**\n     * Optimization: Requested $geometryType.\n     * @hidden\n     */\n    _geometryType?: string;\n}\n\ntype InternalStyle = Style & StyleSelector & StyleInternalParams;\n\n/**\n * [[StyleConditionClassifier]] searches for usages of `$layer` in `when` conditions\n * associated with styling rules.\n *\n * @hidden\n */\nclass StyleConditionClassifier implements ExprVisitor<Expr | undefined, Expr | undefined> {\n    private _style!: InternalStyle;\n\n    classify(style: InternalStyle) {\n        if (style._whenExpr) {\n            const savedStyle = this.switchStyle(style);\n            style._whenExpr = style._whenExpr.accept(this, undefined);\n            this._style = savedStyle;\n        }\n    }\n\n    visitNullLiteralExpr(expr: NullLiteralExpr, enclosingExpr: Expr | undefined): Expr {\n        return expr;\n    }\n\n    visitBooleanLiteralExpr(expr: BooleanLiteralExpr, enclosingExpr: Expr | undefined): Expr {\n        return expr;\n    }\n\n    visitNumberLiteralExpr(expr: NumberLiteralExpr, enclosingExpr: Expr | undefined): Expr {\n        return expr;\n    }\n\n    visitStringLiteralExpr(expr: StringLiteralExpr, enclosingExpr: Expr | undefined): Expr {\n        return expr;\n    }\n\n    visitObjectLiteralExpr(expr: ObjectLiteralExpr, enclosingExpr: Expr | undefined): Expr {\n        return expr;\n    }\n\n    visitVarExpr(expr: VarExpr, enclosingExpr: Expr | undefined): Expr {\n        return expr;\n    }\n\n    visitHasAttributeExpr(expr: HasAttributeExpr, enclosingExpr: Expr | undefined): Expr {\n        return expr;\n    }\n\n    visitContainsExpr(expr: ContainsExpr, enclosingExpr: Expr | undefined): Expr {\n        return expr;\n    }\n\n    visitMatchExpr(expr: MatchExpr, enclosingExpr: Expr | undefined): Expr {\n        return expr;\n    }\n\n    visitCaseExpr(expr: CaseExpr, enclosingExpr: Expr | undefined): Expr {\n        return expr;\n    }\n\n    visitCallExpr(call: CallExpr, enclosingExpr: Expr | undefined): Expr | undefined {\n        if (call.op === \"all\") {\n            // processing of an `[\"all\", e1, e2, ... eN]` expression. In this case\n            // search for expressions matching comparison of `$layer` and string literals\n            // in the sub expressions.\n            const children = call.args\n                .map(childExpr => childExpr.accept(this, call))\n                .filter(childExpr => childExpr !== undefined) as Expr[];\n\n            return new CallExpr(call.op, children);\n        } else if (enclosingExpr) {\n            // `call` is a direct child expression of an `\"all\"` operator.\n            const matched = this.matchVarStringComparison(call);\n\n            if (matched) {\n                if (this._style.layer === undefined && matched.name === \"$layer\") {\n                    // found a subexpression `[\"==\", [\"get\", \"$layer\"], \"some layer name\"]`\n                    // enclosed in an `[\"all\", e1...eN]` expression. Remove it from\n                    // its parent expression and store the value of the expected $layer in\n                    // [[StyleInternalParams]].\n\n                    this._style.layer = matched.value;\n\n                    // return `undefined` to remove this sub expression from its parent.\n                    return undefined;\n                } else if (\n                    this._style._geometryType === undefined &&\n                    matched.name === \"$geometryType\"\n                ) {\n                    // found a subexpression `[\"==\", [\"get\", \"$geometryType\"], \"geometry\"]`\n                    // enclosed in an `[\"all\", e1...eN]` expression. Remove it from\n                    // its parent expression and store the value of the expected $geometryType in\n                    // [[StyleInternalParams]].\n\n                    this._style._geometryType = matched.value;\n\n                    // return `undefined` to remove this sub expression from its parent.\n                    return undefined;\n                }\n            }\n        }\n\n        return call;\n    }\n\n    /**\n     * Tests if the given `call` matches the structure [\"==\", [\"get\", name], value].\n     * If a match is found returns an object containing the `name` and the `value`;\n     *\n     * @param call The expression to match.\n     */\n    private matchVarStringComparison(call: CallExpr) {\n        if (call.op === \"==\") {\n            const left = call.args[0];\n            const right = call.args[1];\n\n            if (left instanceof VarExpr && right instanceof StringLiteralExpr) {\n                return { name: left.name, value: right.value };\n            }\n\n            if (right instanceof VarExpr && left instanceof StringLiteralExpr) {\n                return { name: right.name, value: left.value };\n            }\n        }\n\n        return undefined;\n    }\n\n    /**\n     * Sets the given `style` as current.\n     *\n     * @returns The previous `style`.\n     */\n    private switchStyle(style: InternalStyle) {\n        const saved = this._style;\n        this._style = style;\n        return saved;\n    }\n}\n\nclass OptimizedSubSetKey {\n    key: string;\n    layer: string | undefined;\n    geometryType: string | undefined;\n\n    cachedStyleSet?: InternalStyle[];\n\n    constructor(layer?: string | undefined, geometryType?: string | undefined) {\n        this.key = \"\";\n        this.set(layer, geometryType);\n    }\n\n    set(\n        layer: string | undefined,\n        geometryType: string | undefined,\n        env?: Env\n    ): OptimizedSubSetKey {\n        let keyUpdateNeeded: boolean = false;\n        if (layer === undefined) {\n            const envLayer = env !== undefined ? env.lookup(\"$layer\") : undefined;\n            layer = typeof envLayer === \"string\" ? envLayer : undefined;\n        }\n        if (this.layer !== layer) {\n            this.layer = layer;\n            keyUpdateNeeded = true;\n        }\n\n        if (geometryType === undefined) {\n            const envGeometryType = env !== undefined ? env.lookup(\"$geometryType\") : undefined;\n            geometryType = typeof envGeometryType === \"string\" ? envGeometryType : undefined;\n        }\n        if (this.geometryType !== geometryType) {\n            this.geometryType = geometryType;\n            keyUpdateNeeded = true;\n        }\n\n        if (keyUpdateNeeded) {\n            this.updateKey();\n        }\n        return this;\n    }\n\n    private updateKey() {\n        if (this.layer !== undefined) {\n            // tslint:disable-next-line:prefer-conditional-expression\n            if (this.geometryType !== undefined) {\n                this.key = `${this.layer}:${this.geometryType}`;\n            } else {\n                this.key = `${this.layer}:`;\n            }\n        } else {\n            if (this.geometryType !== undefined) {\n                this.key = `:${this.geometryType}`;\n            } else {\n                this.key = \"all\";\n            }\n        }\n        this.cachedStyleSet = undefined;\n    }\n}\n\n/**\n * Combine data from datasource and apply the rules from a specified theme to show it on the map.\n */\nexport class StyleSetEvaluator {\n    readonly styleSet: InternalStyle[];\n\n    private readonly m_techniques: IndexedTechnique[] = [];\n    private readonly m_exprPool = new ExprPool();\n    private readonly m_cachedResults = new Map<Expr, Value>();\n    private readonly m_styleConditionClassifier = new StyleConditionClassifier();\n    private readonly m_subStyleSetCache = new Map<string, InternalStyle[]>();\n    private readonly m_definitions?: Definitions;\n    private readonly m_definitionExprCache = new Map<string, Expr>();\n    private readonly m_tmpOptimizedSubSetKey: OptimizedSubSetKey = new OptimizedSubSetKey();\n    private readonly m_emptyEnv = new Env();\n    private m_layer: string | undefined;\n    private m_geometryType: string | undefined;\n    private m_zoomLevel: number | undefined;\n\n    constructor(styleSet: StyleSet, definitions?: Definitions) {\n        this.m_definitions = definitions;\n        this.styleSet = resolveReferences(styleSet, definitions);\n        computeDefaultRenderOrder(this.styleSet);\n        this.compileStyleSet();\n    }\n\n    /**\n     * Find all techniques that fit the current objects' environment.\n     * *The techniques in the resulting array may not be modified* since they are being reused for\n     * identical objects.\n     *\n     * @param env The objects environment, i.e. the attributes that are relevant for its\n     * representation.\n     * @param layer The optional layer name used to filter techniques.\n     * @param geometryType The optional geometryType used to filter techniques.\n     */\n    getMatchingTechniques(\n        env: Env,\n        layer?: string | undefined,\n        geometryType?: string | undefined\n    ): IndexedTechnique[] {\n        const result: IndexedTechnique[] = [];\n        this.m_cachedResults.clear();\n\n        const optimizedSubSetKey = this.m_tmpOptimizedSubSetKey;\n        optimizedSubSetKey.set(layer, geometryType, env);\n\n        // get the requested $layer and $geometryType, if any.\n        this.m_layer = optimizedSubSetKey.layer;\n        this.m_geometryType = optimizedSubSetKey.geometryType;\n        this.m_zoomLevel = env.lookup(\"$zoom\") as number | undefined;\n\n        const searchedStyleSet = this.getOptimizedStyleSet(optimizedSubSetKey);\n\n        for (const currStyle of searchedStyleSet) {\n            if (this.processStyle(env, currStyle, result)) {\n                break;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Check if `styleSet` contains any rule related to `layer`.\n     *\n     * @param layer name of layer\n     */\n    wantsLayer(layer: string): boolean {\n        return (\n            this.getOptimizedStyleSet(this.m_tmpOptimizedSubSetKey.set(layer, undefined)).length > 0\n        );\n    }\n\n    /**\n     * Check if `styleSet` contains any rule related to particular `[layer, geometryType]` pair.\n     *\n     * @param layer name of layer\n     * @param geometryType type of layer - `point`, `line` or `polygon`\n     */\n    wantsFeature(layer: string, geometryType?: string): boolean {\n        return (\n            this.getOptimizedStyleSet(this.m_tmpOptimizedSubSetKey.set(layer, geometryType))\n                .length > 0\n        );\n    }\n\n    /**\n     * Get the expression evaluation cache, for further feature processing.\n     *\n     * This object is valid until next `getMatchingTechniques` call.\n     */\n    get expressionEvaluatorCache() {\n        return this.m_cachedResults;\n    }\n\n    /**\n     * Reset array of techniques.\n     *\n     * Cleans technique array and indices, so it doesn't accumulate accross several decoding runs.\n     */\n    resetTechniques() {\n        for (const techinque of this.m_techniques) {\n            techinque._index = undefined!;\n        }\n        this.m_techniques.length = 0;\n    }\n\n    /**\n     * Get the (current) array of techniques that have been created during decoding.\n     */\n    get techniques(): IndexedTechnique[] {\n        return this.m_techniques;\n    }\n\n    /**\n     * Get the (current) array of techniques that have been created during decoding.\n     */\n    get decodedTechniques(): IndexedTechnique[] {\n        return this.m_techniques.map(makeDecodedTechnique);\n    }\n\n    private getOptimizedStyleSet(subSetKey: OptimizedSubSetKey): InternalStyle[] {\n        if (subSetKey.cachedStyleSet !== undefined) {\n            return subSetKey.cachedStyleSet;\n        }\n        let optimizedStyleSet = this.m_subStyleSetCache.get(subSetKey.key);\n        if (optimizedStyleSet !== undefined) {\n            subSetKey.cachedStyleSet = optimizedStyleSet;\n            return optimizedStyleSet;\n        }\n        optimizedStyleSet = this.createPreFilteredStyleSet(subSetKey);\n        this.m_subStyleSetCache.set(subSetKey.key, optimizedStyleSet);\n        subSetKey.cachedStyleSet = optimizedStyleSet;\n        return optimizedStyleSet;\n    }\n\n    private createPreFilteredStyleSet(subSetKey: OptimizedSubSetKey) {\n        const { layer, geometryType } = subSetKey;\n\n        return this.styleSet.filter(style => {\n            if (layer !== undefined && style.layer !== undefined && style.layer !== layer) {\n                return false;\n            }\n            if (\n                geometryType !== undefined &&\n                style._geometryType !== undefined &&\n                style._geometryType !== geometryType\n            ) {\n                return false;\n            }\n            return true;\n        });\n    }\n\n    /**\n     * Compile the `when` conditions found when traversting the styling rules.\n     */\n    private compileStyleSet() {\n        this.styleSet.forEach(style => this.compileStyle(style));\n\n        // Create optimized styleSets for each `layer` & `geometryType` tuple.\n        this.styleSet.forEach(style => {\n            this.getOptimizedStyleSet(\n                this.m_tmpOptimizedSubSetKey.set(style.layer, style._geometryType)\n            );\n        });\n    }\n\n    /**\n     * Compile the `when` conditions reachable from the given `style`.\n     *\n     * @param style The current style.\n     */\n    private compileStyle(style: InternalStyle) {\n        if (style.when !== undefined) {\n            try {\n                style._whenExpr = Array.isArray(style.when)\n                    ? Expr.fromJSON(style.when, this.m_definitions, this.m_definitionExprCache)\n                    : Expr.parse(style.when);\n\n                // search for usages of '$layer' and any other\n                // special symbol that can be used to speed up the evaluation\n                // of the `when` conditions associated to this `style`.\n                this.m_styleConditionClassifier.classify(style);\n\n                if (style._whenExpr !== undefined) {\n                    style._whenExpr = style._whenExpr.intern(this.m_exprPool);\n                }\n\n                if (isJsonExpr(style.minZoomLevel)) {\n                    style._minZoomLevelExpr = Expr.fromJSON(style.minZoomLevel).intern(\n                        this.m_exprPool\n                    );\n                }\n\n                if (isJsonExpr(style.maxZoomLevel)) {\n                    style._maxZoomLevelExpr = Expr.fromJSON(style.maxZoomLevel).intern(\n                        this.m_exprPool\n                    );\n                }\n            } catch (err) {\n                logger.log(\n                    \"failed to evaluate expression\",\n                    JSON.stringify(style.when),\n                    \"error\",\n                    String(err)\n                );\n            }\n        }\n    }\n\n    /**\n     * Process a style (and its sub-styles) hierarchically to look for the technique that fits the\n     * current objects' environment. The attributes of the styles are assembled to create a unique\n     * technique for every object.\n     *\n     * @param env The objects environment, i.e. the attributes that are relevant for its\n     *            representation.\n     * @param style Current style (could also be top of stack).\n     * @param result The array of resulting techniques. There may be more than one technique per\n     *               object, resulting in multiple graphical objects for representation.\n     * @returns `true` if style has been found and processing is finished. `false` if not found, or\n     *          more than one technique should be applied.\n     */\n    private processStyle(env: Env, style: InternalStyle, result: Technique[]): boolean {\n        if (!this.checkZoomLevel(env, style)) {\n            return false;\n        }\n\n        if (\n            this.m_layer !== undefined &&\n            style.layer !== undefined &&\n            style.layer !== this.m_layer\n        ) {\n            return false;\n        }\n        if (\n            this.m_geometryType !== undefined &&\n            style._geometryType !== undefined &&\n            style._geometryType !== this.m_geometryType\n        ) {\n            return false;\n        }\n\n        if (style._whenExpr) {\n            try {\n                if (!style._whenExpr.evaluate(env, ExprScope.Condition, this.m_cachedResults)) {\n                    // Stop processing this styling rule. The `when` condition\n                    // associated with the current `style` evaluates to false so\n                    // no techinque defined by this style should be applied.\n                    return false;\n                }\n            } catch (error) {\n                logger.error(\n                    `failed to evaluate expression '${JSON.stringify(style.when)}': ${error}`\n                );\n                return false;\n            }\n        }\n\n        if (style.technique === undefined) {\n            return false;\n        }\n        // we found a technique!\n        if (style.technique !== \"none\") {\n            result.push(this.getTechniqueForStyleMatch(env, style));\n        }\n        // stop processing if \"final\" is set\n        return style.final === true;\n    }\n\n    private checkZoomLevel(env: Env, style: InternalStyle) {\n        if (style.minZoomLevel === undefined && style.maxZoomLevel === undefined) {\n            return true;\n        }\n\n        const zoomLevel = this.m_zoomLevel;\n        if (zoomLevel === undefined) {\n            return true;\n        }\n\n        if (style.minZoomLevel !== undefined) {\n            let minZoomLevel: Value = style.minZoomLevel;\n\n            if (style._minZoomLevelExpr) {\n                // the constraint is defined as expression, evaluate it and\n                // use its value\n                try {\n                    minZoomLevel = style._minZoomLevelExpr.evaluate(\n                        env,\n                        ExprScope.Condition,\n                        this.m_cachedResults\n                    );\n                } catch (error) {\n                    logger.error(\n                        `failed to evaluate expression '${JSON.stringify(\n                            style._minZoomLevelExpr\n                        )}': ${error}`\n                    );\n                }\n            }\n\n            if (typeof minZoomLevel === \"number\" && zoomLevel < minZoomLevel) {\n                return false;\n            }\n        }\n\n        if (style.maxZoomLevel !== undefined) {\n            let maxZoomLevel: Value = style.maxZoomLevel;\n\n            if (style._maxZoomLevelExpr) {\n                try {\n                    maxZoomLevel = style._maxZoomLevelExpr.evaluate(\n                        env,\n                        ExprScope.Condition,\n                        this.m_cachedResults\n                    );\n                } catch (error) {\n                    logger.error(\n                        `failed to evaluate expression '${JSON.stringify(\n                            style._maxZoomLevelExpr\n                        )}': ${error}`\n                    );\n                }\n            }\n\n            if (typeof maxZoomLevel === \"number\" && zoomLevel > maxZoomLevel) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private getTechniqueForStyleMatch(env: Env, style: InternalStyle) {\n        this.checkStyleDynamicAttributes(style);\n\n        let technique: IndexedTechnique | undefined;\n        if (style._dynamicTechniques !== undefined) {\n            const dynamicAttributes = this.evaluateTechniqueProperties(style, env);\n            const key = this.getDynamicTechniqueKey(style, dynamicAttributes);\n            technique = style._dynamicTechniques!.get(key);\n            if (technique === undefined) {\n                technique = this.createTechnique(style, key, dynamicAttributes);\n                style._dynamicTechniques!.set(key, technique);\n            }\n        } else {\n            technique = style._staticTechnique;\n            if (technique === undefined) {\n                style._staticTechnique = technique = this.createTechnique(\n                    style,\n                    `${style._styleSetIndex}`,\n                    []\n                ) as IndexedTechnique;\n            }\n        }\n\n        if (technique._index === undefined) {\n            technique._index = this.m_techniques.length;\n            this.m_techniques.push(technique);\n        }\n        return technique;\n    }\n\n    private getDynamicTechniqueKey(\n        style: InternalStyle,\n        dynamicAttributes: Array<[string, Value]>\n    ) {\n        const dynamicAttrKey = dynamicAttributes\n            .map(([_attrName, attrValue]) => {\n                if (attrValue === undefined) {\n                    return \"U\";\n                } else {\n                    return JSON.stringify(attrValue);\n                }\n            })\n            .join(\":\");\n        return `${style._styleSetIndex!}:${dynamicAttrKey}`;\n    }\n\n    private checkStyleDynamicAttributes(style: InternalStyle) {\n        if (style._dynamicTechniqueAttributes !== undefined || style.technique === \"none\") {\n            return;\n        }\n\n        style._dynamicTechniqueAttributes = [];\n        style._dynamicFeatureAttributes = [];\n        style._dynamicForwardedAttributes = [];\n        style._staticAttributes = [];\n\n        const dynamicFeatureAttributes = style._dynamicFeatureAttributes;\n        const dynamicTechniqueAttributes = style._dynamicTechniqueAttributes;\n        const dynamicForwardedAttributes = style._dynamicForwardedAttributes;\n        const targetStaticAttributes = style._staticAttributes;\n\n        const techniqueDescriptor =\n            techniqueDescriptors[style.technique] || emptyTechniqueDescriptor;\n\n        const processAttribute = (\n            attrName: TechniquePropNames<Technique>,\n            attrValue: Value | JsonExpr | undefined\n        ) => {\n            if (attrValue === undefined) {\n                return;\n            }\n\n            if (isJsonExpr(attrValue)) {\n                attrValue = Expr.fromJSON(\n                    attrValue,\n                    this.m_definitions,\n                    this.m_definitionExprCache\n                ).intern(this.m_exprPool);\n            } else if (isInterpolatedPropertyDefinition(attrValue)) {\n                // found a property using an object-like interpolation definition.\n                attrValue = Expr.fromJSON(\n                    interpolatedPropertyDefinitionToJsonExpr(attrValue)\n                ).intern(this.m_exprPool);\n            }\n\n            if (Expr.isExpr(attrValue)) {\n                const deps = attrValue.dependencies();\n\n                if (!deps.zoom && deps.properties.size === 0) {\n                    // no data-dependencies detected.\n                    attrValue = attrValue.evaluate(this.m_emptyEnv);\n                }\n            }\n\n            if (Expr.isExpr(attrValue)) {\n                let attrScope: AttrScope | undefined = (techniqueDescriptor.attrScopes as any)[\n                    attrName as any\n                ];\n\n                if (attrScope === undefined) {\n                    // Use [[AttrScope.TechniqueGeometry]] as default scope for the attribute.\n                    attrScope = AttrScope.TechniqueGeometry;\n                }\n\n                const deps = attrValue.dependencies();\n\n                switch (attrScope) {\n                    case AttrScope.FeatureGeometry:\n                        dynamicFeatureAttributes.push([attrName, attrValue]);\n                        break;\n                    case AttrScope.TechniqueGeometry:\n                        dynamicTechniqueAttributes.push([attrName, attrValue]);\n                        break;\n                    case AttrScope.TechniqueRendering:\n                        if (deps.properties.size === 0) {\n                            dynamicForwardedAttributes.push([attrName, attrValue]);\n                        } else {\n                            dynamicTechniqueAttributes.push([attrName, attrValue]);\n                        }\n                        break;\n                }\n            } else if (attrValue !== undefined && attrValue !== null) {\n                targetStaticAttributes.push([attrName, attrValue]);\n            }\n        };\n\n        processAttribute(\"renderOrder\", style.renderOrder);\n\n        // TODO: What the heck is that !?\n        processAttribute(\"label\", style.labelProperty);\n\n        // line & solid-line secondaryRenderOrder should be generic attr\n        // TODO: maybe just warn and force move it to `attr` ?\n        processAttribute(\"secondaryRenderOrder\", (style as LineStyle).secondaryRenderOrder);\n\n        if (style.attr !== undefined) {\n            for (const attrName in style.attr) {\n                if (!style.attr.hasOwnProperty(attrName)) {\n                    continue;\n                }\n                processAttribute(\n                    attrName as TechniquePropNames<Technique>,\n                    (style.attr as any)[attrName]\n                );\n            }\n        }\n\n        if (dynamicTechniqueAttributes.length > 0) {\n            style._dynamicTechniques = new Map();\n        }\n    }\n\n    private evaluateTechniqueProperties(style: InternalStyle, env: Env): Array<[string, Value]> {\n        if (style._dynamicTechniqueAttributes === undefined) {\n            return [];\n        }\n\n        const instantiationContext = { env };\n\n        return style._dynamicTechniqueAttributes.map(([attrName, attrExpr]) => {\n            try {\n                if (attrExpr.isDynamic()) {\n                    const reducedExpr = attrExpr.instantiate(instantiationContext);\n                    return [attrName, reducedExpr];\n                }\n\n                const evaluatedValue = attrExpr.evaluate(\n                    env,\n                    ExprScope.Value,\n                    this.m_cachedResults\n                );\n                return [attrName, evaluatedValue];\n            } catch (error) {\n                logger.error(`failed to evaluate expression '${attrExpr.toJSON()}': ${error}`);\n                return [attrName, null];\n            }\n        });\n    }\n\n    private createTechnique(\n        style: InternalStyle,\n        key: string,\n        dynamicAttrs: Array<[string, Value]>\n    ) {\n        const technique: any = {};\n        technique.name = style.technique;\n        if (style._staticAttributes !== undefined) {\n            for (const [attrName, attrValue] of style._staticAttributes) {\n                if (attrValue !== null) {\n                    technique[attrName] = attrValue;\n                }\n            }\n        }\n        for (const [attrName, attrValue] of dynamicAttrs) {\n            if (attrValue !== null) {\n                technique[attrName] = attrValue;\n            }\n        }\n\n        if (style._dynamicFeatureAttributes !== undefined) {\n            for (const [attrName, attrValue] of style._dynamicFeatureAttributes) {\n                technique[attrName] = attrValue;\n            }\n        }\n\n        if (style._dynamicForwardedAttributes !== undefined) {\n            for (const [attrName, attrValue] of style._dynamicForwardedAttributes) {\n                // tslint:disable-next-line: prefer-conditional-expression\n                if (Expr.isExpr(attrValue)) {\n                    technique[attrName] = attrValue.toJSON();\n                } else {\n                    technique[attrName] = attrValue;\n                }\n            }\n        }\n\n        technique._index = this.m_techniques.length;\n        technique._styleSetIndex = style._styleSetIndex!;\n        technique._key = key;\n        this.m_techniques.push(technique as IndexedTechnique);\n        return technique as IndexedTechnique;\n    }\n}\n\nfunction computeDefaultRenderOrder(styleSet: InternalStyle[]) {\n    let techniqueRenderOrder = 0;\n    let styleSetIndex = 0;\n    for (const style of styleSet) {\n        style._styleSetIndex = styleSetIndex++;\n        if (style.technique !== undefined && style.renderOrder === undefined) {\n            style.renderOrder = techniqueRenderOrder++;\n        }\n    }\n}\n\nfunction resolveReferences(styleSet: StyleDeclaration[], definitions: Definitions | undefined) {\n    return styleSet.map(style => resolveStyleReferences(style, definitions));\n}\n\nfunction resolveStyleReferences(\n    style: StyleDeclaration,\n    definitions: Definitions | undefined\n): InternalStyle {\n    if (isJsonExpr(style)) {\n        if (!isJsonExprReference(style)) {\n            throw new Error(\"invalid expression in this context, only 'ref's are supported\");\n        }\n        // expand and instantiate references to style definitions.\n        const definitionName = style[1];\n        const def = definitions && definitions[definitionName];\n        if (!def) {\n            throw new Error(`invalid reference '${definitionName}' - not found`);\n        }\n        if (!isActualSelectorDefinition(def)) {\n            throw new Error(`invalid reference '${definitionName}' - expected style definition`);\n        }\n        // instantiate the style\n        return resolveStyleReferences(def, definitions);\n    }\n\n    return { ...style };\n}\n\n/**\n * Create transferable representation of dynamic technique.\n *\n * As for now, we remove all `Expr` as they are not supported on other side.\n */\nexport function makeDecodedTechnique(technique: IndexedTechnique): IndexedTechnique {\n    const result: Partial<IndexedTechnique> = {};\n    for (const attrName in technique) {\n        if (!technique.hasOwnProperty(attrName)) {\n            continue;\n        }\n        let attrValue: any = (technique as any)[attrName];\n        if (Expr.isExpr(attrValue)) {\n            attrValue = attrValue.toJSON();\n        }\n        (result as any)[attrName] = attrValue;\n    }\n    return (result as any) as IndexedTechnique;\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nconst SdfShaderChunks = {\n    sdf_attributes: `\n        attribute vec4 position;\n        attribute vec4 uv;\n        attribute vec4 color;\n        attribute vec4 bgColor;\n        `,\n    sdf_varying: `\n        varying vec4 vColor;\n        varying float vWeight;\n        varying vec2 vUv;\n        varying float vRotation;\n        `,\n    sdf_varying_computation: `\n        #if BG_TEXT\n        vColor = bgColor;\n        vWeight = uv.w;\n        #else\n        vColor = color;\n        vWeight = uv.z;\n        #endif\n        vUv = vec2(uv.xy);\n        vRotation = position.w;\n        `,\n    sdf_frag_uniforms: `\n        uniform sampler2D sdfTexture;\n        uniform vec4 sdfParams;\n        `,\n    sdf_sampling_functions: `\n        float median(float r, float g, float b) {\n            return max(min(r, g), min(max(r, g), b));\n        }\n\n        float getDistance(vec2 uvOffset) {\n            vec3 sample = texture2D(sdfTexture, vUv.xy + uvOffset).rgb;\n            #if MSDF\n            return median(sample.r, sample.g, sample.b);\n            #else\n            return sample.r;\n            #endif\n        }\n\n        float getOpacity(vec2 uvOffset, float weight) {\n            vec2 uv = vUv + uvOffset;\n            vec2 rotatedUVs = abs(vec2(\n                cos(vRotation) * uv.x - sin(vRotation) * uv.y,\n                sin(vRotation) * uv.x + cos(vRotation) * uv.y));\n\n            float dx = dFdx(rotatedUVs.x) * sdfParams.x;\n            float dy = dFdy(rotatedUVs.y) * sdfParams.y;\n            float toPixels = sdfParams.w * inversesqrt( dx * dx + dy * dy );\n\n            float dist = getDistance(uvOffset) + min(weight, 0.5 - 1.0 / sdfParams.w) - 0.5;\n            return clamp(dist * toPixels + 0.5, 0.0, 1.0);\n        }\n        `\n};\nObject.assign(THREE.ShaderChunk, SdfShaderChunks);\n\nconst clearVertexSource: string = `\n    attribute vec2 position;\n\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n\n    void main() {\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xy, 0.0, 1.0);\n    }`;\n\nconst clearFragmentSource: string = `\n    precision highp float;\n    precision highp int;\n\n    void main() {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }`;\n\nconst copyVertexSource: string = `\n    attribute vec3 position;\n    attribute vec2 uv;\n\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n\n    varying vec3 vUv;\n\n    void main() {\n        vUv = vec3(uv.xy, position.z);\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xy, 0.0, 1.0);\n    }`;\n\nconst copyFragmentSource: string = `\n    precision highp float;\n    precision highp int;\n\n    uniform float pageOffset;\n    uniform sampler2D page0;\n    uniform sampler2D page1;\n    uniform sampler2D page2;\n    uniform sampler2D page3;\n    uniform sampler2D page4;\n    uniform sampler2D page5;\n    uniform sampler2D page6;\n    uniform sampler2D page7;\n\n    varying vec3 vUv;\n\n    void main() {\n        vec4 sample = vec4(0.0);\n        if (vUv.z < pageOffset || vUv.z > (pageOffset + 7.0)) discard;\n        else if (vUv.z < pageOffset + 1.0) sample = texture2D(page0, vUv.xy);\n        else if (vUv.z < pageOffset + 2.0) sample = texture2D(page1, vUv.xy);\n        else if (vUv.z < pageOffset + 3.0) sample = texture2D(page2, vUv.xy);\n        else if (vUv.z < pageOffset + 4.0) sample = texture2D(page3, vUv.xy);\n        else if (vUv.z < pageOffset + 5.0) sample = texture2D(page4, vUv.xy);\n        else if (vUv.z < pageOffset + 6.0) sample = texture2D(page5, vUv.xy);\n        else if (vUv.z < pageOffset + 7.0) sample = texture2D(page6, vUv.xy);\n        else sample = texture2D(page7, vUv.xy);\n\n        gl_FragColor = sample;\n    }`;\n\nconst sdfTextVertexSource: string = `\n    #include <sdf_attributes>\n    #include <sdf_varying>\n\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n\n    void main() {\n        #include <sdf_varying_computation>\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xyz, 1.0);\n    }`;\n\nconst sdfTextFragmentSource: string = `\n    precision highp float;\n    precision highp int;\n\n    #include <sdf_varying>\n    #include <sdf_frag_uniforms>\n    #include <sdf_sampling_functions>\n\n    void main() {\n        vec4 color = vColor;\n        color.a *= getOpacity(vec2(0.0), vWeight);\n        if (color.a < 0.05) {\n            discard;\n        }\n        gl_FragColor = color;\n    }`;\n\n/**\n * @hidden\n * Material used for clearing glyphs from a [[GlyphTextureCache]].\n */\nexport class GlyphClearMaterial extends THREE.RawShaderMaterial {\n    /**\n     * Creates a new `GlyphClearMaterial`.\n     *\n     * @returns New `GlyphClearMaterial`.\n     */\n    constructor() {\n        const shaderParams: THREE.ShaderMaterialParameters = {\n            name: \"GlyphClearMaterial\",\n            vertexShader: clearVertexSource,\n            fragmentShader: clearFragmentSource,\n            uniforms: {},\n            depthTest: false,\n            depthWrite: false\n        };\n        super(shaderParams);\n    }\n}\n\n/**\n * @hidden\n * Material used for copying glyphs into a [[GlyphTextureCache]].\n */\nexport class GlyphCopyMaterial extends THREE.RawShaderMaterial {\n    /**\n     * Creates a new `GlyphCopyMaterial`.\n     *\n     * @returns New `GlyphCopyMaterial`.\n     */\n    constructor() {\n        const shaderParams: THREE.ShaderMaterialParameters = {\n            name: \"GlyphCopyMaterial\",\n            vertexShader: copyVertexSource,\n            fragmentShader: copyFragmentSource,\n            uniforms: {\n                pageOffset: new THREE.Uniform(0.0),\n                page0: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),\n                page1: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),\n                page2: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),\n                page3: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),\n                page4: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),\n                page5: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),\n                page6: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),\n                page7: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE)\n            },\n            depthTest: false,\n            depthWrite: false\n        };\n        super(shaderParams);\n    }\n}\n\n/**\n * @hidden\n * Material parameters passed on [[SdfTextMaterial]] creation.\n */\nexport interface SdfTextMaterialParameters {\n    texture: THREE.Texture;\n    textureSize: THREE.Vector2;\n    size: number;\n    distanceRange: number;\n    isMsdf: boolean;\n    isBackground: boolean;\n    vertexSource?: string;\n    fragmentSource?: string;\n}\n\n/**\n * @hidden\n * Material designed to render transformable, high quality SDF text.\n */\nexport class SdfTextMaterial extends THREE.RawShaderMaterial {\n    /**\n     * Creates a new `SdfTextMaterial`.\n     *\n     * @param params Material parameters.\n     *\n     * @returns New `SdfTextMaterial`.\n     */\n    constructor(params: SdfTextMaterialParameters) {\n        const shaderParams: THREE.ShaderMaterialParameters = {\n            name: \"SdfTextMaterial\",\n            vertexShader:\n                params.vertexSource !== undefined ? params.vertexSource : sdfTextVertexSource,\n            fragmentShader:\n                params.fragmentSource !== undefined ? params.fragmentSource : sdfTextFragmentSource,\n            uniforms: {\n                sdfTexture: new THREE.Uniform(params.texture),\n                sdfParams: new THREE.Uniform(\n                    new THREE.Vector4(\n                        params.textureSize.x,\n                        params.textureSize.y,\n                        params.size,\n                        params.distanceRange\n                    )\n                )\n            },\n            defines: {\n                MSDF: params.isMsdf ? 1.0 : 0.0,\n                BG_TEXT: params.isBackground ? 1.0 : 0.0\n            },\n            depthTest: true,\n            depthWrite: true,\n            side: THREE.DoubleSide,\n            transparent: true\n        };\n        super(shaderParams);\n        this.extensions.derivatives = true;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\nimport { GlyphData } from \"./GlyphData\";\nimport { TextLayoutStyle, TextRenderStyle } from \"./TextStyle\";\n\n/**\n * Object containing vertex buffer data generated by [[TextCanvas]].\n */\nexport class TextBufferObject {\n    /**\n     * Constructs a new `TextBufferObject`.\n     *\n     * @param glyphs Input glyphs.\n     * @param buffer Buffer containing the data generated by [[TextCanvas]].\n     * @param bounds Optional text bounds.\n     * @param characterBounds Optional character bounds.\n     * @param textRenderStyle [[TextRenderStyle]] applied by [[TextCanvas]].\n     * @param textLayoutStyle [[TextLayoutStyle]] applied by [[TextCanvas]].\n     *\n     * @returns New `TextBufferObject`.\n     */\n    constructor(\n        readonly glyphs: GlyphData[],\n        readonly buffer: Float32Array,\n        readonly bounds?: THREE.Box2,\n        readonly characterBounds?: THREE.Box2[],\n        readonly textRenderStyle?: TextRenderStyle,\n        readonly textLayoutStyle?: TextLayoutStyle\n    ) {}\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { FontCatalog } from \"../rendering/FontCatalog\";\nimport { SdfTextMaterial } from \"../rendering/TextMaterials\";\n\n/**\n * Material parameters passed on [[SdfTextMaterial]] creation when using the `\n * `createSdfTextMaterial` helper function.\n */\nexport interface SdfTextMaterialParameters {\n    fontCatalog: FontCatalog;\n    isBackground?: boolean;\n    vertexSource?: string;\n    fragmentSource?: string;\n}\n\n/**\n * Helper function designed to create [[SdfTextMaterials]] that can be rendered using\n * [[TextCanvas]].\n *\n * @param params Material parameters.\n *\n * @returns New `SdfTextMaterial`.\n */\nexport function createSdfTextMaterial(params: SdfTextMaterialParameters): SdfTextMaterial {\n    return new SdfTextMaterial({\n        texture: params.fontCatalog.texture,\n        textureSize: params.fontCatalog.textureSize,\n        size: params.fontCatalog.size,\n        distanceRange: params.fontCatalog.distanceRange,\n        isMsdf: params.fontCatalog.type === \"msdf\",\n        isBackground: params.isBackground === true,\n        vertexSource: params.vertexSource,\n        fragmentSource: params.fragmentSource\n    });\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport {\n    Light,\n    MagFilter,\n    MinFilter,\n    PixelFormat,\n    TextureDataType,\n    WrappingMode\n} from \"@here/harp-datasource-protocol\";\n\n/**\n * Returns `three.js` pixel format object basing on a [[PixelFormat]] specified.\n */\nexport function toPixelFormat(format: PixelFormat): THREE.PixelFormat {\n    switch (format) {\n        case \"Alpha\":\n            return THREE.AlphaFormat;\n        case \"RGB\":\n            return THREE.RGBFormat;\n        case \"RGBA\":\n            return THREE.RGBAFormat;\n        case \"Luminance\":\n            return THREE.LuminanceFormat;\n        case \"LuminanceAlpha\":\n            return THREE.LuminanceAlphaFormat;\n        case \"RGBE\":\n            return THREE.RGBEFormat;\n        case \"Depth\":\n            return THREE.DepthFormat;\n        case \"DepthStencil\":\n            return THREE.DepthStencilFormat;\n        case \"Red\":\n            return THREE.RedFormat;\n        default:\n            throw new Error(`invalid pixel format: ${format}`);\n    }\n}\n\n/**\n * Returns `three.js` texture data types based on a [[TextureDataType]] specified.\n */\nexport function toTextureDataType(dataType: TextureDataType): THREE.TextureDataType {\n    switch (dataType) {\n        case \"UnsignedByte\":\n            return THREE.UnsignedByteType;\n        case \"Byte\":\n            return THREE.ByteType;\n        case \"Short\":\n            return THREE.ShortType;\n        case \"UnsignedShort\":\n            return THREE.UnsignedShortType;\n        case \"Int\":\n            return THREE.IntType;\n        case \"UnsignedInt\":\n            return THREE.UnsignedIntType;\n        case \"Float\":\n            return THREE.FloatType;\n        case \"HalfFloat\":\n            return THREE.HalfFloatType;\n        default:\n            throw new Error(`invalid texture data type: ${dataType}`);\n    }\n}\n\n/**\n * Returns `three.js` wrapping mode object based on a [[WrappingMode]] specified.\n */\nexport function toWrappingMode(mode: WrappingMode): THREE.Wrapping {\n    switch (mode) {\n        case \"clamp\":\n            return THREE.ClampToEdgeWrapping;\n        case \"repeat\":\n            return THREE.RepeatWrapping;\n        case \"mirror\":\n            return THREE.MirroredRepeatWrapping;\n        default:\n            throw new Error(`invalid wrapping mode: ${mode}`);\n    }\n}\n\n/**\n * Returns `three.js` texture filter object based on a [[MagFilter]] or [[MinFilter]] specified.\n */\nexport function toTextureFilter(filter: MagFilter | MinFilter): THREE.TextureFilter {\n    switch (filter) {\n        case \"nearest\":\n            return THREE.NearestFilter;\n        case \"nearestMipMapNearest\":\n            return THREE.NearestMipMapNearestFilter;\n        case \"nearestMipMapLinear\":\n            return THREE.NearestMipMapLinearFilter;\n        case \"linear\":\n            return THREE.LinearFilter;\n        case \"linearMipMapNearest\":\n            return THREE.LinearMipMapNearestFilter;\n        case \"linearMipMapLinear\":\n            return THREE.LinearMipMapLinearFilter;\n        default:\n            throw new Error(`invalid texture filter: ${filter}`);\n    }\n}\n\n/**\n * Create a specific light for lightening the map.\n */\nexport function createLight(lightDescription: Light): THREE.Light {\n    switch (lightDescription.type) {\n        case \"ambient\": {\n            const light = new THREE.AmbientLight(\n                lightDescription.color,\n                lightDescription.intensity\n            );\n            light.name = lightDescription.name;\n            return light;\n        }\n        case \"directional\": {\n            const light = new THREE.DirectionalLight(\n                lightDescription.color,\n                lightDescription.intensity\n            );\n            light.name = lightDescription.name;\n            if (lightDescription.castShadow !== undefined) {\n                light.castShadow = lightDescription.castShadow;\n            }\n            light.position.set(\n                lightDescription.direction.x,\n                lightDescription.direction.y,\n                lightDescription.direction.z\n            );\n            light.position.normalize();\n            return light;\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { ExtrudedPolygonTechnique } from \"@here/harp-datasource-protocol\";\nimport { ColorUtils } from \"@here/harp-datasource-protocol/lib/ColorUtils\";\nimport { enforceBlending, MapMeshStandardMaterial } from \"@here/harp-materials\";\nimport { evaluateBaseColorProperty } from \"./DecodedTileHelpers\";\n\n/**\n * Bitmask used for the depth pre-pass to prevent multiple fragments in the same screen position\n * from rendering color.\n */\nexport const DEPTH_PRE_PASS_STENCIL_MASK = 0x01;\n\n/**\n * Render order offset for the depth pre-pass to ensure that it's rendered first.\n */\nconst DEPTH_PRE_PASS_RENDER_ORDER_OFFSET = 1e-6;\n\n/**\n * Check if technique requires (and not disables) use of depth prepass.\n *\n * Depth prepass is enabled if correct opacity is specified (in range `(0,1)`) _and_ not explicitly\n * disabled by `enableDepthPrePass` option.\n *\n * @param technique [[BaseStandardTechnique]] instance to be checked\n */\nexport function isRenderDepthPrePassEnabled(technique: ExtrudedPolygonTechnique) {\n    // Depth pass explicitly disabled\n    if (technique.enableDepthPrePass === false) {\n        return false;\n    }\n    let transparent =\n        technique.opacity !== undefined && technique.opacity > 0.0 && technique.opacity < 1.0;\n    // If not opaque then check if transparency may be modified via alpha in base color.\n    // Otherwise we don't need to even test base color because opacity mixed with any base alpha,\n    // will always produce some transparency effect.\n    if (!transparent) {\n        // We do not support switching depth pass during alpha interpolation, ignore zoom level\n        // when calculating base color value.\n        const color = evaluateBaseColorProperty(technique);\n        if (color !== undefined) {\n            const alpha = ColorUtils.getAlphaFromHex(color);\n            transparent = alpha > 0.0 && alpha < 1.0;\n        }\n    }\n    return transparent;\n}\n\n/**\n * Creates material for depth prepass.\n *\n * Creates material that writes only to the z-buffer. Updates the original material instance, to\n * support depth prepass.\n *\n * @param baseMaterial The base material of mesh that is updated to work with depth prepass\n *     and then used. This parameter is a template for depth prepass material that is returned.\n * @returns depth prepass material, which is a clone of `baseMaterial` with the adapted settings.\n */\nexport function createDepthPrePassMaterial(baseMaterial: THREE.Material): THREE.Material {\n    baseMaterial.depthWrite = false;\n    baseMaterial.depthFunc = THREE.EqualDepth;\n    baseMaterial.colorWrite = true;\n    enforceBlending(baseMaterial);\n\n    const depthPassMaterial = baseMaterial.clone();\n    depthPassMaterial.depthWrite = true;\n    depthPassMaterial.depthTest = true;\n    depthPassMaterial.depthFunc = THREE.LessDepth;\n    depthPassMaterial.colorWrite = false;\n    depthPassMaterial.opacity = 1.0;\n    depthPassMaterial.blending = THREE.NoBlending;\n    return depthPassMaterial;\n}\n\n// tslint:disable:max-line-length\n/**\n * Clones a given mesh to render it in the depth prepass with another material. Both the original\n * and depth prepass meshes, when rendered in the correct order, create the proper depth prepass\n * effect. The original mesh material is slightly modified by [[createDepthPrePassMaterial]] to\n * support the depth prepass. This method is usable only if the material of this mesh has an\n * opacity value in the range `(0,1)`.\n *\n * The DepthPrePass object is created wis a slightly smaller `renderOrder` as the original mesh\n * to ensure that it's rendered first.\n *\n * @param mesh original mesh\n * @returns `Mesh` depth pre pass\n */\n// tslint:enable:max-line-length\nexport function createDepthPrePassMesh(mesh: THREE.Mesh): THREE.Mesh {\n    const originalGeometry = mesh.geometry;\n\n    if (!(originalGeometry instanceof THREE.BufferGeometry)) {\n        throw new Error(\"#createDepthPassMesh only BufferGeometry is supported\");\n    }\n    const positionAttribute = originalGeometry.getAttribute(\"position\");\n    if (!positionAttribute) {\n        throw new Error(\"#createDepthPassMesh position attribute not found\");\n    }\n\n    const depthPassGeometry = new THREE.BufferGeometry();\n    depthPassGeometry.setAttribute(\"position\", positionAttribute);\n    const uvAttribute = originalGeometry.getAttribute(\"uv\");\n    if (uvAttribute) {\n        depthPassGeometry.setAttribute(\"uv\", uvAttribute);\n    }\n    const normalAttribute = originalGeometry.getAttribute(\"normal\");\n    if (normalAttribute) {\n        depthPassGeometry.setAttribute(\"normal\", normalAttribute);\n    }\n    const extrusionAxisAttribute = originalGeometry.getAttribute(\"extrusionAxis\");\n    if (extrusionAxisAttribute) {\n        depthPassGeometry.setAttribute(\"extrusionAxis\", extrusionAxisAttribute);\n    }\n\n    if (originalGeometry.index) {\n        depthPassGeometry.setIndex(originalGeometry.index);\n    }\n\n    for (const group of originalGeometry.groups) {\n        const { start, count, materialIndex } = group;\n        depthPassGeometry.addGroup(start, count, materialIndex);\n    }\n\n    const depthPassMaterial =\n        mesh.material instanceof Array\n            ? mesh.material.map(createDepthPrePassMaterial)\n            : createDepthPrePassMaterial(mesh.material);\n\n    const depthPassMesh = new THREE.Mesh(depthPassGeometry, depthPassMaterial);\n    depthPassMesh.renderOrder = mesh.renderOrder - DEPTH_PRE_PASS_RENDER_ORDER_OFFSET;\n\n    return depthPassMesh;\n}\n\n/**\n * Sets up all the needed stencil logic needed for the depth pre-pass.\n *\n * This logic is in place to avoid z-fighting artifacts that can appear in geometries that have\n * coplanar triangles inside the same mesh.\n *\n * @param depthMesh Mesh created by `createDepthPrePassMesh`.\n * @param colorMesh Original mesh.\n */\nexport function setDepthPrePassStencil(depthMesh: THREE.Mesh, colorMesh: THREE.Mesh) {\n    // Set up depth mesh stencil logic.\n    // Set the depth pre-pass stencil bit for all processed fragments. We use\n    // `THREE.AlwaysStencilFunc` and not `THREE.NotEqualStencilFunc` to force all fragments to pass\n    // the stencil test and write the correct depth value.\n    const depthMaterial = depthMesh.material as MapMeshStandardMaterial;\n    depthMaterial.stencilWrite = true;\n    depthMaterial.stencilFail = THREE.KeepStencilOp;\n    depthMaterial.stencilZFail = THREE.KeepStencilOp;\n    depthMaterial.stencilZPass = THREE.ReplaceStencilOp;\n    depthMaterial.stencilFunc = THREE.AlwaysStencilFunc;\n    depthMaterial.stencilRef = 0xff;\n    (depthMaterial as any).stencilFuncMask = DEPTH_PRE_PASS_STENCIL_MASK;\n\n    // Set up color mesh stencil logic.\n    // Only write color for pixels with the depth pre-pass stencil bit set. Also, once a pixel is\n    // rendered, set the stencil bit to 0 to prevent subsequent pixels in the same clip position\n    // from rendering color again.\n    const colorMaterial = colorMesh.material as MapMeshStandardMaterial;\n    colorMaterial.stencilWrite = true;\n    colorMaterial.stencilFail = THREE.KeepStencilOp;\n    colorMaterial.stencilZFail = THREE.KeepStencilOp;\n    colorMaterial.stencilZPass = THREE.ZeroStencilOp;\n    colorMaterial.stencilFunc = THREE.EqualStencilFunc;\n    colorMaterial.stencilRef = 0xff;\n    (colorMaterial as any).stencilFuncMask = DEPTH_PRE_PASS_STENCIL_MASK;\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    ExtendedTileInfo,\n    getPropertyValue,\n    LineTechnique,\n    SolidLineTechnique\n} from \"@here/harp-datasource-protocol\";\nimport { Expr } from \"@here/harp-datasource-protocol/lib/Expr\";\nimport { assert, LoggerManager, Math2D } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\nimport { MapView } from \"./MapView\";\nimport { PickObjectType, PickResult } from \"./PickHandler\";\nimport { RoadIntersectionData, Tile } from \"./Tile\";\n\nconst logger = LoggerManager.instance.create(\"RoadPicker\");\n\nexport interface RoadPickResult extends PickResult {\n    distFromCenter: number;\n    positions: number[];\n}\n\nconst MAX_DISTANCE_ERROR = 0.01;\n\n/**\n * Optional flags in the style that can be used to optimize the evaluation.\n */\ninterface CustomLineTechnique extends LineTechnique {\n    isBackground?: boolean;\n}\n\n/**\n * The `RoadPicker` class manages picking of roads, which may not be pickable in THREE.js, since\n * their geometry is generated in the vertex shader.\n */\nexport class RoadPicker {\n    constructor(private m_mapView: MapView) {}\n    /**\n     * Registers a tile with the `RoadPicker`. This function extracts line data from the [[Tile]],\n     * but only if the tile has the necessary [[ExtendedTileInfo]] that allows for road features to\n     * be reconstructed.\n     *\n     * @param tile The tile to register.\n     */\n    registerTile(tile: Tile): RoadIntersectionData | undefined {\n        assert(tile.decodedTile !== undefined);\n        if (tile.decodedTile === undefined || tile.decodedTile.tileInfo === undefined) {\n            return undefined;\n        }\n        const extendedTileInfo: ExtendedTileInfo = tile.decodedTile.tileInfo as ExtendedTileInfo;\n        const lineFeatures = extendedTileInfo.lineGroup;\n\n        if (lineFeatures === undefined || lineFeatures.numFeatures === 0) {\n            // tileInfo not of expected type [[ExtendedTileInfo]]\n            return undefined;\n        }\n\n        const widths: RoadIntersectionData[\"widths\"] = [];\n        widths.length = lineFeatures.numFeatures;\n\n        const mapView = this.m_mapView;\n        for (let i = 0; i < lineFeatures.numFeatures; i++) {\n            const technique = extendedTileInfo.techniqueCatalog[\n                lineFeatures.techniqueIndex[i]\n            ] as SolidLineTechnique;\n\n            const isDynamic =\n                technique.metricUnit === \"Pixel\" ||\n                Expr.isExpr(technique.lineWidth) ||\n                typeof technique.lineWidth === \"string\";\n\n            widths[i] =\n                technique.lineWidth !== undefined\n                    ? isDynamic\n                        ? () => {\n                              const unitFactor =\n                                  technique.metricUnit === \"Pixel\" ? mapView.pixelToWorld : 1.0;\n                              return (\n                                  getPropertyValue(\n                                      technique.lineWidth,\n                                      mapView.zoomLevel,\n                                      mapView.pixelToWorld\n                                  ) *\n                                  unitFactor *\n                                  0.5\n                              );\n                          }\n                        : (technique.lineWidth as number)\n                    : 1.0;\n        }\n        const objInfos = extendedTileInfo.lineGroup.userData;\n\n        const roadIntersectionData = {\n            ids: lineFeatures.featureIds,\n            techniqueIndex: lineFeatures.techniqueIndex,\n            starts: lineFeatures.positionIndex,\n            widths,\n            positions: lineFeatures.positions,\n            techniques: extendedTileInfo.techniqueCatalog,\n            objInfos\n        };\n\n        return roadIntersectionData;\n    }\n\n    /**\n     * Tests the `pickPos` point for intersection with all roads on a tile.\n     *\n     * @param tile The tile to pick.\n     * @param eyePos The WorldPosition of eye or camera to compute distances.\n     * @param pickPos The WorldPosition of the picked point, on the plane.\n     * @param results The existing array of [[PickResult]]; new results should be appended.\n     */\n    intersectRoads(\n        tile: Tile,\n        eyePos: THREE.Vector3,\n        pickPos: THREE.Vector3,\n        results: PickResult[]\n    ): boolean {\n        if (tile.boundingBox.distanceToPoint(pickPos) > MAX_DISTANCE_ERROR) {\n            // outside of bounding box of tile\n            return false;\n        }\n\n        const roadIntersectionData = tile.roadIntersectionData;\n        if (roadIntersectionData === undefined) {\n            return false;\n        }\n\n        const ids = roadIntersectionData.ids;\n        const techniques = roadIntersectionData.techniques;\n        const techniqueIndices = roadIntersectionData.techniqueIndex;\n        const numFeatures = ids.length;\n        const positions = roadIntersectionData.positions;\n        const widths = roadIntersectionData.widths;\n        const px = pickPos.x - tile.center.x;\n        const py = pickPos.y - tile.center.y;\n        const pickDistance = pickPos.distanceTo(eyePos);\n\n        if (\n            widths.length !== ids.length ||\n            ids.length !== techniqueIndices.length ||\n            techniqueIndices.length !== roadIntersectionData.starts.length\n        ) {\n            logger.error(\n                \"The amount of widths, ids, techniqueIndices and starts has to be the same\"\n            );\n            return false;\n        }\n\n        for (let i = 0; i < numFeatures; i++) {\n            const technique = techniques[techniqueIndices[i]] as CustomLineTechnique;\n\n            // if the technique is marked as background or as transient, we ignore it for picking\n            if (/*technique.isBackground === true ||*/ technique.transient === true) {\n                continue;\n            }\n\n            const featureStart = roadIntersectionData.starts[i];\n            const featureEnd =\n                i < numFeatures - 1\n                    ? roadIntersectionData.starts[i + 1]\n                    : roadIntersectionData.positions.length;\n\n            let startX = positions[featureStart];\n            let startY = positions[featureStart + 1];\n\n            const widthEntry = widths[i];\n            const actualWidth = Math.max(\n                1,\n                typeof widthEntry === \"function\" ? widthEntry() : widthEntry\n            );\n            const lineWidthSqr = actualWidth * actualWidth;\n\n            let closestDistSqr = Number.MAX_VALUE;\n\n            for (let j = featureStart + 2; j < featureEnd; j += 2) {\n                const endX = positions[j];\n                const endY = positions[j + 1];\n\n                const distSqr = Math2D.distToSegmentSquared(px, py, startX, startY, endX, endY);\n                if (distSqr < lineWidthSqr) {\n                    if (distSqr < closestDistSqr) {\n                        closestDistSqr = distSqr;\n                    }\n                }\n\n                startX = endX;\n                startY = endY;\n            }\n\n            if (closestDistSqr < Number.MAX_VALUE) {\n                const roadPickResult: RoadPickResult = {\n                    type: PickObjectType.Line,\n                    point: pickPos,\n                    distance: pickDistance,\n                    distFromCenter: Math.sqrt(closestDistSqr),\n                    featureId: ids[i],\n                    positions: positions.slice(featureStart, featureEnd),\n                    technique\n                };\n                this.addUserData(roadPickResult, i, roadIntersectionData.objInfos);\n                results.push(roadPickResult);\n            }\n        }\n\n        return false;\n    }\n\n    private addUserData(\n        roadPickResult: RoadPickResult,\n        index: number,\n        objInfos?: Array<{} | undefined>\n    ) {\n        if (objInfos !== undefined && objInfos.length > 0) {\n            roadPickResult.userData = { ...objInfos[index] };\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { getPropertyValue, ImageTexture } from \"@here/harp-datasource-protocol\";\nimport { IconMaterial } from \"@here/harp-materials\";\nimport { MemoryUsage, TextCanvas } from \"@here/harp-text-canvas\";\nimport { assert, LoggerManager, Math2D } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { ColorCache } from \"../ColorCache\";\nimport { ImageItem } from \"../image/Image\";\nimport { MapView } from \"../MapView\";\nimport { ScreenCollisions } from \"../ScreenCollisions\";\nimport { PoiInfo, TextElement } from \"../text/TextElement\";\nimport { BoxBuffer } from \"./BoxBuffer\";\nimport { IconTexture } from \"./Poi\";\n\nconst logger = LoggerManager.instance.create(\"PoiRenderer\");\n\nconst INVALID_RENDER_BATCH = -1;\n\nconst tempPos = new THREE.Vector3(0);\n\n/**\n * The `PoiRenderBufferBatch` contains the geometry and the material for all POIs that share the\n * same icon image ([[ImageTexture]]). If the image is the same, all the objects in this batch can\n * share the same material, which makes them renderable in the same draw call, whatever the number\n * of actual objects (WebGL limits apply!).\n *\n * There is a `PoiRenderBufferBatch` for every icon in a texture atlas, since the size of the icon\n * in the atlas as well as the texture coordinates are specified in the `PoiRenderBufferBatch`.\n */\nclass PoiRenderBufferBatch {\n    color: THREE.Color = ColorCache.instance.getColor(\"#000000\");\n\n    boxBuffer: BoxBuffer | undefined;\n\n    private m_material?: THREE.Material | THREE.Material[];\n\n    /**\n     * Create the `PoiRenderBufferBatch`.\n     *\n     * @param mapView The [[MapView]] instance.\n     * @param scene The three.js scene to add the POIs to.\n     * @param imageItem The icon that will have his material shared.\n     * @param renderOrder RenderOrder of the batch geometry's [[Mesh]].\n     */\n    constructor(\n        readonly mapView: MapView,\n        readonly scene: THREE.Scene,\n        readonly imageItem: ImageItem,\n        readonly renderOrder: number\n    ) {}\n\n    /**\n     * Initialize with the [[ImageTexture]]. Loads the image and sets up the icon size, the texture\n     * coordinates and material of the batch. Since image loading is done asynchronously, this\n     * batch cannot be rendered right away. MapView#update is being triggered if it loaded\n     * successfully.\n     */\n    init() {\n        if (this.boxBuffer === undefined) {\n            this.setup();\n        }\n    }\n\n    /**\n     * Clean the `PoiRenderBufferBatch`, remove all icon boxes. Called before starting a new frame.\n     */\n    reset(): void {\n        if (this.boxBuffer === undefined) {\n            this.init();\n        }\n        this.boxBuffer!.reset();\n    }\n\n    /**\n     * Update the geometry with all the added boxes during the frame.\n     */\n    update(): void {\n        if (this.boxBuffer === undefined) {\n            this.init();\n        }\n        this.boxBuffer!.updateBufferGeometry();\n    }\n\n    /**\n     * Update the info with the memory footprint caused by objects owned by the\n     * `PoiRenderBufferBatch`.\n     *\n     * @param info The info object to increment with the values from this `PoiRenderBufferBatch`.\n     */\n    updateMemoryUsage(info: MemoryUsage) {\n        if (this.boxBuffer !== undefined) {\n            this.boxBuffer.updateMemoryUsage(info);\n        }\n    }\n\n    /**\n     * Setup texture and material for the batch.\n     */\n    private setup() {\n        const bilinear = true;\n\n        // Texture images should be generated with premultiplied alpha\n        const premultipliedAlpha = true;\n\n        const iconTexture = new IconTexture(this.imageItem);\n        const texture = new THREE.Texture(\n            iconTexture.image.imageData as any,\n            THREE.UVMapping,\n            undefined,\n            undefined,\n            bilinear ? THREE.LinearFilter : THREE.NearestFilter,\n            bilinear ? THREE.LinearFilter : THREE.NearestFilter,\n            THREE.RGBAFormat\n        );\n        texture.needsUpdate = true;\n        texture.premultiplyAlpha = premultipliedAlpha;\n        texture.generateMipmaps = false; // not needed, always rendered in full size\n\n        this.m_material = new IconMaterial({\n            map: texture\n        });\n\n        this.boxBuffer = new BoxBuffer(this.m_material, this.renderOrder);\n\n        const mesh = this.boxBuffer.mesh;\n\n        mesh.frustumCulled = false;\n\n        this.scene.add(mesh);\n\n        this.mapView.update();\n    }\n}\n\n/**\n * Contains all [[PoiRenderBufferBatch]]es. Selects (and initializes) the correct batch for a POI.\n */\nclass PoiRenderBuffer {\n    readonly batches: PoiRenderBufferBatch[] = [];\n    private readonly m_batchMap: Map<string, Map<number, number>> = new Map();\n\n    /**\n     * Create the `PoiRenderBuffer`.\n     *\n     * @param mapView The [[MapView]] to be rendered to.\n     * @param textCanvas The [[TextCanvas]] to which scenes this `PoiRenderBuffer` adds geometry to.\n     * The actual scene a [[TextElement]] is added to is specified by the renderOrder of the\n     * [[TextElement]].\n     */\n    constructor(readonly mapView: MapView, readonly textCanvas: TextCanvas) {}\n\n    /**\n     * Register the POI and prepare the [[PoiRenderBufferBatch]] for the POI at first usage.\n     *\n     * @param poiInfo Describes the POI icon.\n     */\n    registerPoi(poiInfo: PoiInfo): number {\n        const { imageItem, imageTexture, imageTextureName } = poiInfo;\n\n        if (\n            imageItem === undefined ||\n            imageTextureName === undefined ||\n            imageTexture === undefined\n        ) {\n            // No image -> invisible -> ignore\n            return INVALID_RENDER_BATCH;\n        }\n\n        const renderOrder = poiInfo.renderOrder!;\n\n        // There is a batch for every ImageDefinition, which could be a texture atlas with many\n        // ImageTextures in it.\n        const batchKey = imageTexture.image;\n        let batchSet = this.m_batchMap.get(batchKey);\n        let mappedIndex: number | undefined;\n        let bufferBatch: PoiRenderBufferBatch;\n\n        if (batchSet === undefined) {\n            batchSet = new Map<number, number>();\n            this.m_batchMap.set(batchKey, batchSet);\n        }\n\n        mappedIndex = batchSet.get(renderOrder);\n        if (mappedIndex !== undefined) {\n            return mappedIndex;\n        }\n        mappedIndex = this.batches.length;\n\n        let layer = this.textCanvas.getLayer(renderOrder);\n        if (layer === undefined) {\n            this.textCanvas.addText(\"\", tempPos, { layer: renderOrder });\n            layer = this.textCanvas.getLayer(renderOrder);\n        }\n\n        bufferBatch = new PoiRenderBufferBatch(\n            this.mapView,\n            layer!.storage.scene,\n            imageItem,\n            renderOrder\n        );\n        bufferBatch.init();\n        batchSet.set(renderOrder, mappedIndex);\n        this.batches.push(bufferBatch);\n        return mappedIndex;\n    }\n\n    /**\n     * Render a POI image at the specified location.\n     *\n     * @param poiInfo PoiInfo containing information for rendering the POI icon.\n     * @param screenBox Box to render icon into in 2D coordinates.\n     * @param viewDistance Box's distance to camera.\n     * @param opacity Opacity of icon to allow fade in/out.\n     */\n    addPoi(poiInfo: PoiInfo, screenBox: Math2D.Box, viewDistance: number, opacity: number): number {\n        const poiRegistered =\n            poiInfo.poiRenderBatch !== undefined && poiInfo.poiRenderBatch !== INVALID_RENDER_BATCH;\n        const batchIndex = poiRegistered ? poiInfo.poiRenderBatch! : this.registerPoi(poiInfo);\n        if (batchIndex === INVALID_RENDER_BATCH) {\n            return INVALID_RENDER_BATCH;\n        }\n        assert(batchIndex >= 0);\n        assert(batchIndex < this.batches.length);\n        assert(poiInfo.uvBox !== undefined);\n\n        if (this.batches[batchIndex].boxBuffer === undefined) {\n            this.batches[batchIndex].init();\n        }\n\n        this.batches[batchIndex].boxBuffer!.addBox(\n            screenBox,\n            poiInfo.uvBox!,\n            this.batches[batchIndex].color,\n            opacity,\n            viewDistance,\n            poiInfo.textElement\n        );\n\n        return batchIndex;\n    }\n\n    /**\n     * Retrieve the [[PoiRenderBufferBatch]] from the array at the specified index. May be invalid\n     * if the imageTexture could not be found\n     *\n     * @param index Index into batch array.\n     */\n    getBatch(index: number): PoiRenderBufferBatch | undefined {\n        if (index >= 0) {\n            assert(index < this.batches.length);\n            return this.batches[index];\n        }\n        // may be invalid if the imageTexture could not be found\n        return undefined;\n    }\n\n    /**\n     * Reset all batches, removing all content from the [[PoiRenderBufferBatch]]es. Called at the\n     * beginning of a frame before the POIs are placed.\n     */\n    reset(): void {\n        for (const batch of this.batches) {\n            batch.reset();\n        }\n    }\n\n    /**\n     * Update the geometry of all [[PoiRenderBufferBatch]]es. Called before rendering.\n     */\n    update(): void {\n        for (const batch of this.batches) {\n            batch.update();\n        }\n    }\n\n    /**\n     * Fill the picking results for the pixel with the given screen coordinate. If multiple\n     * [[PoiInfo]]s are found, the order of the results is unspecified.\n     *\n     * @param screenPosition Screen coordinate of picking position.\n     * @param pickCallback Callback to be called for every picked element.\n     */\n    pickTextElements(\n        screenPosition: THREE.Vector2,\n        pickCallback: (pickData: any | undefined) => void\n    ) {\n        for (const batch of this.batches) {\n            if (batch.boxBuffer === undefined) {\n                batch.init();\n            }\n            batch.boxBuffer!.pickBoxes(screenPosition, pickCallback, batch.imageItem.imageData);\n        }\n    }\n\n    /**\n     * Update the info with the memory footprint caused by objects owned by the `PoiRenderBuffer`.\n     *\n     * @param info The info object to increment with the values from this `PoiRenderBuffer`.\n     */\n    updateMemoryUsage(info: MemoryUsage) {\n        for (const batch of this.batches) {\n            if (batch.imageItem.imageData !== undefined) {\n                const imageBytes =\n                    batch.imageItem.imageData.width * batch.imageItem.imageData.height * 4;\n                info.heapSize += imageBytes;\n                info.gpuSize += imageBytes;\n            }\n            if (batch.boxBuffer !== undefined) {\n                batch.boxBuffer.updateMemoryUsage(info);\n            }\n        }\n    }\n}\n\n/**\n * Manage POI rendering. Uses a [[PoiRenderBuffer]] to actually create the geometry that is being\n * rendered.\n */\nexport class PoiRenderer {\n    /**\n     * Compute screen box for icon. It is required that `prepareRender` has been successfully called\n     * before `computeScreenBox` may be called.\n     *\n     * @param poiInfo PoiInfo containing information for rendering the POI icon.\n     * @param screenPosition Position on screen (2D).\n     * @param scale Scale to apply to icon.\n     * @param zoomLevel Current zoom level.\n     * @param screenBox Box that will be used to store the result.\n     * @returns The computed screen box for the icon.\n     */\n    static computeIconScreenBox(\n        poiInfo: PoiInfo,\n        screenPosition: THREE.Vector2,\n        scale: number,\n        zoomLevel: number,\n        /* out */ screenBox: Math2D.Box = new Math2D.Box()\n    ): Math2D.Box {\n        assert(poiInfo.poiRenderBatch !== undefined);\n        assert(poiInfo.poiRenderBatch !== INVALID_RENDER_BATCH);\n\n        const width = poiInfo.computedWidth! * scale;\n        const height = poiInfo.computedHeight! * scale;\n        const technique = poiInfo.technique;\n        const iconXOffset = getPropertyValue(technique.iconXOffset, zoomLevel);\n        const iconYOffset = getPropertyValue(technique.iconYOffset, zoomLevel);\n\n        const centerX = screenPosition.x + (typeof iconXOffset === \"number\" ? iconXOffset : 0);\n        const centerY = screenPosition.y + (typeof iconYOffset === \"number\" ? iconYOffset : 0);\n\n        screenBox.x = centerX - width / 2;\n        screenBox.y = centerY - height / 2;\n        screenBox.w = width;\n        screenBox.h = height;\n\n        return screenBox;\n    }\n    // keep track of the missing textures, but only warn once\n    private static m_missingTextureName: Map<string, boolean> = new Map();\n\n    // the render buffer containing all batches, one batch per texture/material.\n    private m_renderBuffer: PoiRenderBuffer;\n\n    // temporary variable to save allocations\n    private m_tempScreenBox = new Math2D.Box();\n\n    /**\n     * Create the `PoiRenderer` for the specified [[MapView]].\n     *\n     * @param mapView The MapView to be rendered to.\n     * @param textCanvas The [[TextCanvas]] this `PoiRenderer` is associated to. POIs are added to\n     * the different layers of this [[TextCanvas]] based on renderOrder.\n     */\n    constructor(readonly mapView: MapView, readonly textCanvas: TextCanvas) {\n        this.m_renderBuffer = new PoiRenderBuffer(mapView, textCanvas);\n    }\n\n    /**\n     * Prepare the POI for rendering, and determine which `poiRenderBatch` should be used. If a\n     * `poiRenderBatch` is assigned, the POI is ready to be rendered.\n     *\n     * @param pointLabel TextElement with PoiInfo for rendering the POI icon.\n     * @param zoomLevel The current zoom level of [[MapView]]\n     *\n     * @returns `True` if the space is not already allocated by another object (text label or POI)\n     */\n    prepareRender(pointLabel: TextElement, zoomLevel: number): boolean {\n        const poiInfo = pointLabel.poiInfo;\n        if (poiInfo === undefined) {\n            return false;\n        }\n        if (poiInfo.poiRenderBatch === undefined) {\n            this.preparePoi(pointLabel, zoomLevel);\n        }\n        return poiInfo.poiRenderBatch !== undefined;\n    }\n\n    /**\n     * Reset all batches, removing all content from the [[PoiRenderBuffer]]es. Called at the\n     * beginning of a frame before the POIs are placed.\n     */\n    reset(): void {\n        this.m_renderBuffer.reset();\n    }\n\n    /**\n     * Render the icon.\n     *\n     * @param poiInfo PoiInfo containing information for rendering the POI icon.\n     * @param screenPosition Position on screen (2D):\n     * @param screenCollisions Object handling the collision checks for screen-aligned 2D boxes.\n     * @param viewDistance Box's distance to camera.\n     * @param scale Scaling factor to apply to text and icon.\n     * @param allocateScreenSpace If `true` screen space will be allocated for the icon.\n     * @param opacity Opacity of icon to allow fade in/out.\n     */\n    renderPoi(\n        poiInfo: PoiInfo,\n        screenPosition: THREE.Vector2,\n        screenCollisions: ScreenCollisions,\n        viewDistance: number,\n        scale: number,\n        allocateScreenSpace: boolean,\n        opacity: number,\n        zoomLevel: number\n    ): void {\n        assert(poiInfo.poiRenderBatch !== undefined);\n\n        PoiRenderer.computeIconScreenBox(\n            poiInfo,\n            screenPosition,\n            scale,\n            zoomLevel,\n            this.m_tempScreenBox\n        );\n\n        if (allocateScreenSpace) {\n            screenCollisions.allocate(this.m_tempScreenBox);\n        }\n\n        this.m_renderBuffer.addPoi(poiInfo, this.m_tempScreenBox, viewDistance, opacity);\n    }\n\n    /**\n     * Update the geometry of all [[PoiRenderBuffer]]es. Called before rendering.\n     */\n    update(): void {\n        this.m_renderBuffer.update();\n    }\n\n    /**\n     * Fill the picking results for the pixel with the given screen coordinate. If multiple\n     * [[PoiInfo]]s are found, the order of the results is unspecified.\n     *\n     * @param screenPosition Screen coordinate of picking position.\n     * @param pickCallback Callback to be called for every picked element.\n     */\n    pickTextElements(\n        screenPosition: THREE.Vector2,\n        pickCallback: (pickData: any | undefined) => void\n    ) {\n        this.m_renderBuffer.pickTextElements(screenPosition, pickCallback);\n    }\n\n    /**\n     * Update the info with the memory footprint caused by objects owned by the `PoiRenderer`.\n     *\n     * @param info The info object to increment with the values from this `PoiRenderer`.\n     */\n    getMemoryUsage(info: MemoryUsage) {\n        this.m_renderBuffer.updateMemoryUsage(info);\n    }\n\n    /**\n     * Register the POI at the [[PoiRenderBuffer]] which may require some setup, for example loading\n     * of the actual image.\n     */\n    private preparePoi(pointLabel: TextElement, zoomLevel: number): void {\n        const poiInfo = pointLabel.poiInfo;\n        if (poiInfo === undefined || !pointLabel.visible) {\n            return;\n        }\n\n        if (poiInfo.poiRenderBatch !== undefined || poiInfo.isValid === false) {\n            // Already set up, nothing to be done here.\n            return;\n        }\n\n        if (poiInfo.poiTableName !== undefined) {\n            if (this.mapView.poiManager.updatePoiFromPoiTable(pointLabel)) {\n                if (!pointLabel.visible) {\n                    // PoiTable set this POI to not visible.\n                    return;\n                }\n            } else {\n                // PoiTable has not been loaded, but is required to determine visibility.\n                return;\n            }\n        }\n\n        const imageTextureName = poiInfo.imageTextureName;\n\n        const imageTexture = this.mapView.poiManager.getImageTexture(imageTextureName);\n        if (imageTexture === undefined) {\n            // Warn about a missing texture, but only once.\n            if (PoiRenderer.m_missingTextureName.get(imageTextureName) === undefined) {\n                PoiRenderer.m_missingTextureName.set(imageTextureName, true);\n                logger.error(`preparePoi: No imageTexture with name '${imageTextureName}' found`);\n            }\n            poiInfo.isValid = false;\n            return;\n        }\n\n        const imageDefinition = imageTexture.image;\n\n        let imageItem = this.mapView.imageCache.findImageByName(imageDefinition);\n        if (imageItem === undefined) {\n            logger.error(`init: No imageItem found with name '${imageDefinition}'`);\n            poiInfo.isValid = false;\n            return;\n        }\n\n        if (!imageItem.loaded) {\n            if (imageItem.loadingPromise !== undefined) {\n                // already being loaded, will be rendered once available\n                return;\n            }\n            const imageUrl = imageItem.url;\n            const loading = this.mapView.imageCache.loadImage(imageItem);\n            if (loading instanceof Promise) {\n                loading\n                    .then(loadedImageItem => {\n                        if (loadedImageItem === undefined) {\n                            logger.error(`preparePoi: Failed to load imageItem: '${imageUrl}`);\n                            return;\n                        }\n                        this.setupPoiInfo(poiInfo, imageTexture, loadedImageItem, zoomLevel);\n                    })\n                    .catch(error => {\n                        logger.error(`preparePoi: Failed to load imageItem: '${imageUrl}`, error);\n                        poiInfo.isValid = false;\n                    });\n                return;\n            } else {\n                imageItem = loading;\n            }\n        }\n\n        this.setupPoiInfo(poiInfo, imageTexture, imageItem, zoomLevel);\n    }\n\n    /**\n     * Setup texture and material for the batch.\n     *\n     * @param poiInfo [[PoiInfo]] to initialize.\n     * @param imageTexture Shared [[ImageTexture]], defines used area in atlas.\n     * @param imageItem Shared [[ImageItem]], contains cached image for texture.\n     * @param zoomLevel The current zoom level of [[MapView]]\n     */\n    private setupPoiInfo(\n        poiInfo: PoiInfo,\n        imageTexture: ImageTexture,\n        imageItem: ImageItem,\n        zoomLevel: number\n    ) {\n        assert(poiInfo.uvBox === undefined);\n\n        if (imageItem === undefined || imageItem.imageData === undefined) {\n            logger.error(\"setupPoiInfo: No imageItem/imageData found\");\n            // invalid render batch number\n            poiInfo.poiRenderBatch = INVALID_RENDER_BATCH;\n            poiInfo.isValid = false;\n            return;\n        }\n\n        const technique = poiInfo.technique;\n\n        const imageWidth = imageItem.imageData.width;\n        const imageHeight = imageItem.imageData.height;\n\n        const iconWidth = imageTexture.width !== undefined ? imageTexture.width : imageWidth;\n        const iconHeight = imageTexture.height !== undefined ? imageTexture.height : imageHeight;\n\n        let minS = 0;\n        let maxS = 1;\n        let minT = 0;\n        let maxT = 1;\n\n        let iconScaleH = technique.iconScale !== undefined ? technique.iconScale : 1;\n        let iconScaleV = technique.iconScale !== undefined ? technique.iconScale : 1;\n\n        const width = imageTexture.width !== undefined ? imageTexture.width : imageWidth;\n        const height = imageTexture.height !== undefined ? imageTexture.height : imageHeight;\n        const xOffset = imageTexture.xOffset !== undefined ? imageTexture.xOffset : 0;\n        const yOffset = imageTexture.yOffset !== undefined ? imageTexture.yOffset : 0;\n\n        minS = xOffset / imageWidth;\n        maxS = (xOffset + width) / imageWidth;\n\n        const flipY = true;\n        if (flipY) {\n            minT = (imageHeight - yOffset) / imageHeight;\n            maxT = (imageHeight - yOffset - height) / imageHeight;\n        } else {\n            minT = yOffset / imageHeight;\n            maxT = (yOffset + height) / imageHeight;\n        }\n\n        // minS += 0.5 / imageWidth;\n        // maxS += 0.5 / imageWidth;\n        // minT += 0.5 / imageHeight;\n        // maxT += 0.5 / imageHeight;\n\n        // By default, iconScaleV should be equal to iconScaleH, whatever is set in the style.\n        const screenWidth = getPropertyValue(technique.screenWidth, zoomLevel);\n        if (screenWidth !== undefined) {\n            iconScaleV = iconScaleH = screenWidth / iconWidth;\n        }\n\n        const screenHeight = getPropertyValue(technique.screenHeight, zoomLevel);\n        if (screenHeight !== undefined) {\n            iconScaleV = screenHeight / iconHeight;\n            if (screenWidth !== undefined) {\n                iconScaleH = iconScaleV;\n            }\n        }\n\n        // compute stored values in imageTexture\n        poiInfo.computedWidth = iconWidth * iconScaleH;\n        poiInfo.computedHeight = iconHeight * iconScaleV;\n        poiInfo.uvBox = {\n            s0: minS,\n            t0: maxT,\n            s1: maxS,\n            t1: minT\n        };\n        poiInfo.imageItem = imageItem;\n        poiInfo.imageTexture = imageTexture;\n        poiInfo.poiRenderBatch = this.m_renderBuffer.registerPoi(poiInfo);\n        poiInfo.isValid = true;\n\n        assert(poiInfo.poiRenderBatch !== undefined);\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ImageItem } from \"../image/Image\";\n\nimport * as THREE from \"three\";\n\nexport type ExtendedMesh = THREE.Mesh & {\n    /**\n     * Distance of this object from the Tile's center.\n     */\n    displacement?: THREE.Vector3;\n};\n\n/**\n * This enum defines the possible origin points for an image.\n */\nexport enum ImageOrigin {\n    TopLeft,\n    BottomLeft\n}\n\n/**\n * Available rendering parameters for the POIs.\n */\nexport interface ImageOptions {\n    /**\n     * The point of origin of the texture as supported in [[ImageOrigin]].\n     */\n    origin?: ImageOrigin;\n\n    /**\n     * Missing Typedoc\n     */\n    width: number;\n\n    /**\n     * Missing Typedoc\n     */\n    height: number;\n\n    /**\n     * Missing Typedoc\n     */\n    xOffset?: number;\n\n    /**\n     * Missing Typedoc\n     */\n    yOffset?: number;\n\n    /**\n     * Missing Typedoc\n     */\n    flipH?: boolean;\n\n    /**\n     * Missing Typedoc\n     */\n    flipV?: boolean;\n\n    /**\n     * Missing Typedoc\n     */\n    opacity?: number;\n}\n\n/**\n * Defines a part (or all) of an image as a texture.\n */\nexport class IconTexture {\n    /**\n     * The constructor of an `IconTexture`.\n     *\n     * @param image An [[ImageItem]] instance.\n     * @param options The rendering parameters.\n     */\n    constructor(public image: ImageItem) {}\n}\n\n// export enum TextAlign {\n//     Center,\n//     Left,\n//     Right,\n\n//     // ??? expands lines to have same length.\n//     Justify\n// }\n\n// export interface LayoutOptions {\n//     paddingH?: number;\n//     paddingV: number;\n//     transFormCenterX?: number;\n//     transFormCenterY?: number;\n//     rotation?: number;\n//     /** Set to `true` to enlarge the box after rotation to include all rotated corners. */\n//     rotationEnlargesBox: boolean;\n// }\n\n// export interface TextOptions {\n//     bgColor?: THREE.Color;\n//     wrapWords?: boolean;\n//     maxNumLines?: number;\n//     maxWidth?: number;\n//     /** Replace with ellipsis if wider than maxWidth. */\n//     addEllipsis?: boolean;\n//     /** Handle right-to-left texts */\n//     isRightToLeft?: boolean;\n\n//     textAlignH?: AlignH; // = AlignH.Center;\n//     textAlignV?: AlignV; // = AlignV.Center;\n// }\n\n// export class IconLabel {\n//     constructor(text: string, options: LayoutOptions | TextOptions) {}\n\n//     /**\n//      * Setup a box with size and padding.\n//      *\n//      * @param box Target box to set up.\n//      */\n//     getBox(box: THREE.Box2) {}\n\n//     /**\n//      * Compute width and height from text and font.\n//      */\n//     computeBox() {}\n\n//     /**\n//      * Generate the glyphs and keep them in a buffer. Generates a fixed layout.\n//      */\n//     prepareRendering() {}\n// }\n\n// export enum AlignH {\n//     Center,\n//     Left,\n//     Right\n// }\n\n// export enum AlignV {\n//     Center,\n//     Top,\n//     Bottom\n// }\n\n// export enum AnchorTarget {\n//     /** Anchor point relative to Icon */\n//     Icon,\n//     /** Anchor point is transform center of icon */\n//     IconCenter,\n//     /** Anchor point relative to Icon including padding */\n//     IconBox,\n//     /** Anchor point relative to Label */\n//     Label,\n//     /** Anchor point relative to combination of Icon and Label */\n//     Box\n// }\n\n// export class AnchorPosition {\n//     targetH: AnchorTarget = AnchorTarget.Icon;\n//     targetV: AnchorTarget = AnchorTarget.Icon;\n//     alignH: AlignH = AlignH.Center;\n//     alignV: AlignV = AlignV.Center;\n// }\n\n// export enum IconPinMode {\n//     /** Pinned down, anchor point is the same at all angles. */\n//     PinDown,\n//     /**\n//      * Icon stands up. \"StreetLevel\"-style. The anchor point moves to the bottom of the icon when\n//      * the view direction gets parallel to the ground.\n//      */\n//     StandUp\n// }\n\n// export interface IconScaleOptions {\n//     depthScale?: boolean;\n//     minimumScale?: number;\n// }\n\n// export interface IconOptions {\n//     useScreenSpace?: boolean; // = true\n//     priority?: number;\n\n//     scaleOptions?: IconScaleOptions;\n\n//     /** Optional offset in screen space */\n//     screenOffsetX?: number;\n//     screenOffsetY?: number;\n\n//     /** Optional 3D height above terrain. */\n//     heightAboveGround?: number;\n// }\n\n// export class SimplePoiIcon {\n//     constructor(\n//         readonly pos: THREE.Vector3,\n//         readonly image ?: IconTexture,\n//         options ?: IconOptions\n//     ) { }\n// }\n\n// export class PoiIcon {\n//     constructor(\n//         readonly pos: THREE.Vector3,\n//         readonly image?: IconTexture,\n//         readonly label?: IconLabel,\n//         options?: IconOptions\n//     ) {}\n// }\n\n// export interface PoiOptions {\n//     featureId?: number;\n//     minZoomLevel?: number;\n// }\n\n// export class SimplePoi {\n//     private m_featureId?: number;\n//     private m_minZoomLevel: number = 0;\n\n//     constructor(readonly icon: SimplePoiIcon, options?: PoiOptions) {\n//         if (options !== undefined) {\n//             this.m_featureId = options.featureId;\n//             this.m_minZoomLevel = options.minZoomLevel !== undefined ? options.minZoomLevel : 0;\n//         }\n//     }\n// }\n\n// export class Poi {\n//     /** store multiple icons, one for every LOD */\n//     private m_icons: PoiIcon[] = [];\n//     private m_lod = 0;\n//     private m_featureId?: number;\n//     private m_minZoomLevel: number = 0;\n\n//     constructor(icon: PoiIcon, options?: PoiOptions) {\n//         this.m_icons.push(icon);\n\n//         if (options !== undefined) {\n//             this.m_featureId = options.featureId;\n//             this.m_minZoomLevel = options.minZoomLevel !== undefined ? options.minZoomLevel : 0;\n//         }\n//     }\n\n//     icon(): PoiIcon | undefined {\n//         return this.m_icons[this.m_lod];\n//     }\n\n//     /**\n//      * Select the level of detail that should be used.\n//      *\n//      * @param levelOfDetail Level of detail to render.\n//      */\n//     selectIcon(levelOfDetail: number) {}\n// }\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ProjectionType } from \"@here/harp-geoutils\";\nimport { HorizontalAlignment, VerticalAlignment } from \"@here/harp-text-canvas\";\nimport { assert, MathUtils } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\nimport { PoiManager } from \"../poi/PoiManager\";\nimport { poiIsRenderable, TextElement } from \"./TextElement\";\nimport { TextElementType } from \"./TextElementType\";\nimport { ViewState } from \"./ViewState\";\n\n/**\n * Functions related to text element placement.\n */\n\nconst tmpPosition = new THREE.Vector3(0, 0, 0);\nconst tmpCameraDir = new THREE.Vector3(0, 0, 0);\nconst COS_TEXT_ELEMENT_FALLOFF_ANGLE = 0.5877852522924731; // Math.cos(0.3 * Math.PI)\n\n/**\n * Checks whether the distance of the specified text element to the center of the given view is\n * lower than a maximum threshold.\n * @param textElement The textElement of which the view distance will be checked, with coordinates\n * in world space.\n * @param mapView The view that will be used as reference to calculate the distance.\n * @param maxViewDistance The maximum distance value.\n * @returns The text element view distance if it's lower than the maximum value, otherwise\n * `undefined`.\n */\nfunction checkViewDistance(\n    worldCenter: THREE.Vector3,\n    textElement: TextElement,\n    projectionType: ProjectionType,\n    camera: THREE.Camera,\n    maxViewDistance: number\n): number | undefined {\n    const textDistance = computeViewDistance(worldCenter, textElement);\n\n    if (projectionType !== ProjectionType.Spherical) {\n        return textDistance <= maxViewDistance ? textDistance : undefined;\n    }\n\n    // For sphere projection: Filter labels that are close to the horizon\n    tmpPosition.copy(textElement.position).normalize();\n    camera.getWorldPosition(tmpCameraDir).normalize();\n    const cosAlpha = tmpPosition.dot(tmpCameraDir);\n    const viewDistance =\n        cosAlpha > COS_TEXT_ELEMENT_FALLOFF_ANGLE && textDistance <= maxViewDistance\n            ? textDistance\n            : undefined;\n\n    return viewDistance;\n}\n\n/**\n * Computes the distance of the specified text element to the given position.\n * @param refPosition The world coordinates used a reference position to calculate the distance.\n * @param textElement The textElement of which the view distance will be checked. It must have\n * coordinates in world space.\n * @returns The text element view distance.\n * `undefined`.\n */\nexport function computeViewDistance(refPosition: THREE.Vector3, textElement: TextElement): number {\n    let viewDistance: number;\n\n    if (Array.isArray(textElement.points) && textElement.points.length > 1) {\n        const viewDistance0 = refPosition.distanceTo(textElement.points[0]);\n        const viewDistance1 = refPosition.distanceTo(\n            textElement.points[textElement.points.length - 1]\n        );\n\n        viewDistance = Math.min(viewDistance0, viewDistance1);\n    } else {\n        viewDistance = refPosition.distanceTo(textElement.points as THREE.Vector3);\n    }\n\n    return viewDistance;\n}\n\n/**\n * Computes the maximum view distance for text elements as a ratio of the given view's maximum far\n * plane distance.\n * @param viewState The view for which the maximum view distance will be calculated.\n * @param farDistanceLimitRatio The ratio to apply to the maximum far plane distance.\n * @returns Maximum view distance.\n */\nexport function getMaxViewDistance(viewState: ViewState, farDistanceLimitRatio: number): number {\n    return viewState.maxVisibilityDist * farDistanceLimitRatio;\n}\n\n/**\n * State of fading.\n */\nexport enum PrePlacementResult {\n    Ok = 0,\n    NotReady,\n    Invisible,\n    TooFar,\n    Duplicate,\n    Count\n}\n\n/**\n * Applies early rejection tests for a given text element meant to avoid trying to place labels\n * that are not visible, not ready, duplicates etc...\n * @param textElement The Text element to check.\n * @param viewState The view for which the text element will be placed.\n * @param viewCamera The view's camera.\n * @param m_poiManager To prepare pois for rendering.\n * @param projectionType The projection type currently used from geo to world space.\n * @param [maxViewDistance] If specified, text elements farther than this max distance will be\n * rejected.\n * @returns An object with the result code and the text element view distance\n * ( or `undefined` of the checks failed) as second.\n */\nexport function checkReadyForPlacement(\n    textElement: TextElement,\n    viewState: ViewState,\n    viewCamera: THREE.Camera,\n    poiManager: PoiManager,\n    projectionType: ProjectionType,\n    maxViewDistance?: number\n): { result: PrePlacementResult; viewDistance: number | undefined } {\n    let viewDistance: number | undefined;\n\n    if (!textElement.visible) {\n        return { result: PrePlacementResult.Invisible, viewDistance };\n    }\n\n    // If a PoiTable is specified in the technique, the table is required to be\n    // loaded before the POI can be rendered.\n    if (!poiManager.updatePoiFromPoiTable(textElement)) {\n        // PoiTable has not been loaded, but is required to determine\n        // visibility.\n        return { result: PrePlacementResult.NotReady, viewDistance };\n    }\n\n    // Text element visibility and zoom level ranges must be checked after calling\n    // updatePoiFromPoiTable, since that function may change those values.\n    if (\n        !textElement.visible ||\n        !MathUtils.isClamped(\n            viewState.zoomLevel,\n            textElement.minZoomLevel,\n            textElement.maxZoomLevel\n        )\n    ) {\n        return { result: PrePlacementResult.Invisible, viewDistance };\n    }\n\n    viewDistance =\n        maxViewDistance === undefined\n            ? computeViewDistance(viewState.worldCenter, textElement)\n            : checkViewDistance(\n                  viewState.worldCenter,\n                  textElement,\n                  projectionType,\n                  viewCamera,\n                  maxViewDistance\n              );\n\n    if (viewDistance === undefined) {\n        return { result: PrePlacementResult.TooFar, viewDistance };\n    }\n\n    return { result: PrePlacementResult.Ok, viewDistance };\n}\n\n/**\n * Computes the offset for a point text accordingly to text alignment (and icon, if any).\n * @param textElement The text element of which the offset will computed. It must be a point\n * label with [[layoutStyle]] and [[bounds]] already computed.\n * @param offset The offset result.\n */\nexport function computePointTextOffset(\n    textElement: TextElement,\n    offset: THREE.Vector2 = new THREE.Vector2()\n): THREE.Vector2 {\n    assert(textElement.type === TextElementType.PoiLabel);\n    assert(textElement.layoutStyle !== undefined);\n    assert(textElement.bounds !== undefined);\n\n    const hAlign = textElement.layoutStyle!.horizontalAlignment;\n    const vAlign = textElement.layoutStyle!.verticalAlignment;\n\n    switch (hAlign) {\n        case HorizontalAlignment.Right:\n            offset.x = -textElement.xOffset;\n            break;\n        default:\n            offset.x = textElement.xOffset;\n            break;\n    }\n\n    switch (vAlign) {\n        case VerticalAlignment.Below:\n            offset.y = -textElement.yOffset;\n            break;\n        case VerticalAlignment.Above:\n            offset.y = textElement.yOffset - textElement.bounds!.min.y;\n            break;\n        default:\n            offset.y = textElement.yOffset;\n            break;\n    }\n\n    if (textElement.poiInfo !== undefined && poiIsRenderable(textElement.poiInfo)) {\n        assert(textElement.poiInfo.computedWidth !== undefined);\n        assert(textElement.poiInfo.computedHeight !== undefined);\n\n        offset.x += textElement.poiInfo.computedWidth! * (0.5 + hAlign);\n        offset.y += textElement.poiInfo.computedHeight! * (0.5 + vAlign);\n    }\n    return offset;\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    ColorUtils,\n    getPropertyValue,\n    IndexedTechniqueParams,\n    LineMarkerTechnique,\n    PoiTechnique,\n    Technique,\n    TextStyleDefinition,\n    TextTechnique,\n    Theme\n} from \"@here/harp-datasource-protocol\";\nimport {\n    FontStyle,\n    FontUnit,\n    FontVariant,\n    HorizontalAlignment,\n    TextCanvas,\n    TextLayoutParameters,\n    TextLayoutStyle,\n    TextRenderParameters,\n    TextRenderStyle,\n    VerticalAlignment,\n    WrappingMode\n} from \"@here/harp-text-canvas\";\nimport { getOptionValue, LoggerManager } from \"@here/harp-utils\";\nimport { ColorCache } from \"../ColorCache\";\nimport { evaluateColorProperty } from \"../DecodedTileHelpers\";\nimport { PoiRenderer } from \"../poi/PoiRenderer\";\nimport { Tile } from \"../Tile\";\nimport { TextCanvasRenderer } from \"./TextCanvasRenderer\";\n\nconst logger = LoggerManager.instance.create(\"TextStyleCache\");\n\n/**\n * [[TextStyle]] id for the default value inside a [[TextRenderStyleCache]] or a\n * [[TextLayoutStyleCache]].\n */\nexport const DEFAULT_TEXT_STYLE_CACHE_ID = \"Default\";\n\n/**\n * Calculates the [[TextStyle]] id that identifies either a [[TextRenderStyle]] or a\n * [[TextLayoutStyle]] inside a [[TextRenderStyleCache]] or a [[TextLayoutStyleCache]],\n * respectively.\n *\n * @param technique Technique defining the [[TextStyle]].\n * @param zoomLevel Zoom level for which to interpret the technique.\n *\n * @returns [[TextStyle]] id.\n */\nexport function computeStyleCacheId(\n    datasourceName: string,\n    technique: Technique & Partial<IndexedTechniqueParams>,\n    zoomLevel: number\n): string {\n    return `${datasourceName}_${technique._key}_${zoomLevel}`;\n}\n\n/**\n * Cache storing [[MapView]]'s [[TextRenderStyle]]s.\n */\nexport class TextRenderStyleCache {\n    private m_map: Map<string, TextRenderStyle> = new Map();\n    constructor() {\n        this.m_map.set(\n            DEFAULT_TEXT_STYLE_CACHE_ID,\n            new TextRenderStyle({\n                fontSize: {\n                    unit: FontUnit.Pixel,\n                    size: 32,\n                    backgroundSize: 8\n                },\n                color: ColorCache.instance.getColor(\"#6d7477\"),\n                backgroundColor: ColorCache.instance.getColor(\"#f7fbfd\"),\n                backgroundOpacity: 0.5\n            })\n        );\n    }\n\n    get size(): number {\n        return this.m_map.size;\n    }\n\n    get(id: string): TextRenderStyle | undefined {\n        return this.m_map.get(id);\n    }\n\n    set(id: string, value: TextRenderStyle): void {\n        this.m_map.set(id, value);\n    }\n\n    clear(): void {\n        this.m_map.clear();\n        this.m_map.set(\n            DEFAULT_TEXT_STYLE_CACHE_ID,\n            new TextRenderStyle({\n                fontSize: {\n                    unit: FontUnit.Pixel,\n                    size: 32,\n                    backgroundSize: 8\n                },\n                color: ColorCache.instance.getColor(\"#6d7477\"),\n                backgroundColor: ColorCache.instance.getColor(\"#f7fbfd\"),\n                backgroundOpacity: 0.5\n            })\n        );\n    }\n}\n\n/**\n * Cache storing [[MapView]]'s [[TextLayoutStyle]]s.\n */\nexport class TextLayoutStyleCache {\n    private m_map: Map<string, TextLayoutStyle> = new Map();\n    constructor() {\n        this.m_map.set(\n            DEFAULT_TEXT_STYLE_CACHE_ID,\n            new TextLayoutStyle({\n                verticalAlignment: VerticalAlignment.Center,\n                horizontalAlignment: HorizontalAlignment.Center\n            })\n        );\n    }\n\n    get size(): number {\n        return this.m_map.size;\n    }\n\n    get(id: string): TextLayoutStyle | undefined {\n        return this.m_map.get(id);\n    }\n\n    set(id: string, value: TextLayoutStyle): void {\n        this.m_map.set(id, value);\n    }\n\n    clear(): void {\n        this.m_map.clear();\n        this.m_map.set(\n            DEFAULT_TEXT_STYLE_CACHE_ID,\n            new TextLayoutStyle({\n                verticalAlignment: VerticalAlignment.Center,\n                horizontalAlignment: HorizontalAlignment.Center\n            })\n        );\n    }\n}\n\nconst DEFAULT_STYLE_NAME = \"default\";\n\n/**\n * [[TextElementsRenderer]] representation of a [[Theme]]'s TextStyle.\n */\nexport interface TextElementStyle {\n    name: string;\n    fontCatalog: string;\n    renderParams: TextRenderParameters;\n    layoutParams: TextLayoutParameters;\n    textCanvas?: TextCanvas;\n    poiRenderer?: PoiRenderer;\n}\n\nexport class TextStyleCache {\n    private m_textRenderStyleCache = new TextRenderStyleCache();\n    private m_textLayoutStyleCache = new TextLayoutStyleCache();\n    /**\n     * Cache for named colors.\n     */\n    private m_colorMap: Map<string, THREE.Color> = new Map();\n\n    private m_textStyles: Map<string, TextElementStyle> = new Map();\n    private m_defaultStyle: TextElementStyle = {\n        name: DEFAULT_STYLE_NAME,\n        fontCatalog: \"\",\n        renderParams: this.m_textRenderStyleCache.get(DEFAULT_TEXT_STYLE_CACHE_ID)!.params,\n        layoutParams: this.m_textLayoutStyleCache.get(DEFAULT_TEXT_STYLE_CACHE_ID)!.params\n    };\n\n    constructor(private m_theme: Theme) {}\n\n    initializeDefaultTextElementStyle(defaultFontCatalogName: string) {\n        if (this.m_theme.textStyles === undefined) {\n            this.m_theme.textStyles = [];\n        }\n        const styles = this.m_theme.textStyles;\n\n        const themedDefaultStyle = styles.find(style => style.name === DEFAULT_STYLE_NAME);\n        if (themedDefaultStyle !== undefined) {\n            this.m_defaultStyle = this.createTextElementStyle(\n                themedDefaultStyle,\n                DEFAULT_STYLE_NAME\n            );\n        } else if (this.m_theme.defaultTextStyle !== undefined) {\n            this.m_defaultStyle = this.createTextElementStyle(\n                this.m_theme.defaultTextStyle,\n                DEFAULT_STYLE_NAME\n            );\n        } else if (styles.length > 0) {\n            this.m_defaultStyle = this.createTextElementStyle(styles[0], DEFAULT_STYLE_NAME);\n        }\n        this.m_defaultStyle.fontCatalog = defaultFontCatalogName;\n    }\n\n    initializeTextElementStyles(\n        defaultPoiRenderer: PoiRenderer,\n        defaultTextCanvas: TextCanvas,\n        textRenderers: TextCanvasRenderer[]\n    ) {\n        // Initialize default text style.\n        if (this.m_defaultStyle.fontCatalog !== undefined) {\n            const styledTextRenderer = textRenderers.find(\n                textRenderer => textRenderer.fontCatalog === this.m_defaultStyle.fontCatalog\n            );\n            this.m_defaultStyle.textCanvas =\n                styledTextRenderer !== undefined ? styledTextRenderer.textCanvas : undefined;\n            this.m_defaultStyle.poiRenderer =\n                styledTextRenderer !== undefined ? styledTextRenderer.poiRenderer : undefined;\n        }\n        if (this.m_defaultStyle.textCanvas === undefined) {\n            if (this.m_defaultStyle.fontCatalog !== undefined) {\n                logger.warn(\n                    `FontCatalog '${this.m_defaultStyle.fontCatalog}' set in TextStyle '${\n                        this.m_defaultStyle.name\n                    }' not found, using default fontCatalog(${\n                        defaultTextCanvas!.fontCatalog.name\n                    }).`\n                );\n            }\n            this.m_defaultStyle.textCanvas = defaultTextCanvas;\n            this.m_defaultStyle.poiRenderer = defaultPoiRenderer;\n        }\n\n        // Initialize theme text styles.\n        this.m_theme.textStyles!.forEach(element => {\n            this.m_textStyles.set(\n                element.name!,\n                this.createTextElementStyle(element, element.name!)\n            );\n        });\n        // tslint:disable-next-line:no-unused-variable\n        for (const [, style] of this.m_textStyles) {\n            if (style.textCanvas === undefined) {\n                if (style.fontCatalog !== undefined) {\n                    const styledTextRenderer = textRenderers.find(\n                        textRenderer => textRenderer.fontCatalog === style.fontCatalog\n                    );\n                    style.textCanvas =\n                        styledTextRenderer !== undefined\n                            ? styledTextRenderer.textCanvas\n                            : undefined;\n                    style.poiRenderer =\n                        styledTextRenderer !== undefined\n                            ? styledTextRenderer.poiRenderer\n                            : undefined;\n                }\n                if (style.textCanvas === undefined) {\n                    if (style.fontCatalog !== undefined) {\n                        logger.warn(\n                            `FontCatalog '${style.fontCatalog}' set in TextStyle '${\n                                style.name\n                            }' not found, using default fontCatalog(${\n                                defaultTextCanvas!.fontCatalog.name\n                            }).`\n                        );\n                    }\n                    style.textCanvas = defaultTextCanvas;\n                    style.poiRenderer = defaultPoiRenderer;\n                }\n            }\n        }\n    }\n\n    /**\n     * Retrieves a [[TextElementStyle]] for [[Theme]]'s [[TextStyle]] id.\n     */\n    getTextElementStyle(styleId?: string): TextElementStyle {\n        let result;\n        if (styleId === undefined) {\n            result = this.m_defaultStyle;\n        } else {\n            result = this.m_textStyles.get(styleId);\n            if (result === undefined) {\n                result = this.m_defaultStyle;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Gets the appropriate [[TextRenderStyle]] to use for a label. Depends heavily on the label's\n     * [[Technique]] and the current zoomLevel.\n     *\n     * @param technique Label's technique.\n     * @param techniqueIdx Label's technique index.\n     */\n    getRenderStyle(\n        tile: Tile,\n        technique: TextTechnique | PoiTechnique | LineMarkerTechnique\n    ): TextRenderStyle {\n        const mapView = tile.mapView;\n        const dataSource = tile.dataSource;\n        const zoomLevel = mapView.zoomLevel;\n\n        const cacheId = computeStyleCacheId(dataSource.name, technique, Math.floor(zoomLevel));\n        let renderStyle = this.m_textRenderStyleCache.get(cacheId);\n        if (renderStyle === undefined) {\n            const defaultRenderParams = this.m_defaultStyle.renderParams;\n\n            let opacity = getPropertyValue(\n                getOptionValue(technique.opacity, defaultRenderParams.opacity),\n                Math.floor(zoomLevel)\n            );\n\n            if (technique.color !== undefined) {\n                let hexColor = evaluateColorProperty(technique.color, Math.floor(zoomLevel));\n                if (ColorUtils.hasAlphaInHex(hexColor)) {\n                    const alpha = ColorUtils.getAlphaFromHex(hexColor);\n                    opacity = opacity * alpha;\n                    hexColor = ColorUtils.removeAlphaFromHex(hexColor);\n                }\n                this.m_colorMap.set(cacheId, ColorCache.instance.getColor(hexColor));\n            }\n\n            let backgroundOpacity =\n                technique.backgroundOpacity !== undefined\n                    ? getPropertyValue(technique.backgroundOpacity, Math.floor(zoomLevel))\n                    : technique.backgroundColor !== undefined &&\n                      technique.backgroundSize !== undefined &&\n                      getPropertyValue(technique.backgroundSize, Math.floor(zoomLevel)) > 0\n                    ? 1.0 // make label opaque when backgroundColor and backgroundSize are set\n                    : defaultRenderParams.backgroundOpacity;\n\n            if (technique.backgroundColor !== undefined) {\n                let hexBgColor = evaluateColorProperty(\n                    technique.backgroundColor,\n                    Math.floor(zoomLevel)\n                );\n                if (ColorUtils.hasAlphaInHex(hexBgColor)) {\n                    const alpha = ColorUtils.getAlphaFromHex(hexBgColor);\n                    backgroundOpacity = backgroundOpacity * alpha;\n                    hexBgColor = ColorUtils.removeAlphaFromHex(hexBgColor);\n                }\n                this.m_colorMap.set(cacheId + \"_bg\", ColorCache.instance.getColor(hexBgColor));\n            }\n\n            const renderParams = {\n                fontName: getOptionValue(technique.fontName, defaultRenderParams.fontName),\n                fontSize: {\n                    unit: FontUnit.Pixel,\n                    size:\n                        technique.size !== undefined\n                            ? getPropertyValue(technique.size, Math.floor(zoomLevel))\n                            : defaultRenderParams.fontSize!.size,\n                    backgroundSize:\n                        technique.backgroundSize !== undefined\n                            ? getPropertyValue(technique.backgroundSize, Math.floor(zoomLevel))\n                            : defaultRenderParams.fontSize!.backgroundSize\n                },\n                fontStyle:\n                    technique.fontStyle === \"Regular\" ||\n                    technique.fontStyle === \"Bold\" ||\n                    technique.fontStyle === \"Italic\" ||\n                    technique.fontStyle === \"BoldItalic\"\n                        ? FontStyle[technique.fontStyle]\n                        : defaultRenderParams.fontStyle,\n                fontVariant:\n                    technique.fontVariant === \"Regular\" ||\n                    technique.fontVariant === \"AllCaps\" ||\n                    technique.fontVariant === \"SmallCaps\"\n                        ? FontVariant[technique.fontVariant]\n                        : defaultRenderParams.fontVariant,\n                rotation: getOptionValue(technique.rotation, defaultRenderParams.rotation),\n                color: getOptionValue(this.m_colorMap.get(cacheId), defaultRenderParams.color),\n                backgroundColor: getOptionValue(\n                    this.m_colorMap.get(cacheId + \"_bg\"),\n                    defaultRenderParams.backgroundColor\n                ),\n                opacity,\n                backgroundOpacity\n            };\n\n            const themeRenderParams = this.getTextElementStyle(technique.style).renderParams;\n            renderStyle = new TextRenderStyle({\n                ...themeRenderParams,\n                ...renderParams\n            });\n            this.m_textRenderStyleCache.set(cacheId, renderStyle);\n        }\n\n        return renderStyle;\n    }\n\n    /**\n     * Gets the appropriate [[TextRenderStyle]] to use for a label. Depends heavily on the label's\n     * [[Technique]] and the current zoomLevel.\n     *\n     * @param tile The [[Tile]] to process.\n     * @param technique Label's technique.\n     */\n    getLayoutStyle(\n        tile: Tile,\n        technique: TextTechnique | PoiTechnique | LineMarkerTechnique\n    ): TextLayoutStyle {\n        const floorZoomLevel = Math.floor(tile.mapView.zoomLevel);\n        const cacheId = computeStyleCacheId(tile.dataSource.name, technique, floorZoomLevel);\n        let layoutStyle = this.m_textLayoutStyleCache.get(cacheId);\n\n        if (layoutStyle === undefined) {\n            const defaultLayoutParams = this.m_defaultStyle.layoutParams;\n\n            const hAlignment = getPropertyValue(technique.hAlignment, floorZoomLevel) as\n                | string\n                | undefined;\n            const vAlignment = getPropertyValue(technique.vAlignment, floorZoomLevel) as\n                | string\n                | undefined;\n\n            const horizontalAlignment: HorizontalAlignment | undefined =\n                hAlignment === \"Left\" || hAlignment === \"Center\" || hAlignment === \"Right\"\n                    ? HorizontalAlignment[hAlignment]\n                    : defaultLayoutParams.horizontalAlignment;\n\n            const verticalAlignment: VerticalAlignment | undefined =\n                vAlignment === \"Above\" || vAlignment === \"Center\" || vAlignment === \"Below\"\n                    ? VerticalAlignment[vAlignment]\n                    : defaultLayoutParams.verticalAlignment;\n\n            const layoutParams = {\n                tracking: getOptionValue(technique.tracking, defaultLayoutParams.tracking),\n                leading: getOptionValue(technique.leading, defaultLayoutParams.leading),\n                maxLines: getOptionValue(technique.maxLines, defaultLayoutParams.maxLines),\n                lineWidth: getOptionValue(technique.lineWidth, defaultLayoutParams.lineWidth),\n                canvasRotation: getOptionValue(\n                    technique.canvasRotation,\n                    defaultLayoutParams.canvasRotation\n                ),\n                lineRotation: getOptionValue(\n                    technique.lineRotation,\n                    defaultLayoutParams.lineRotation\n                ),\n                wrappingMode:\n                    technique.wrappingMode === \"None\" ||\n                    technique.wrappingMode === \"Character\" ||\n                    technique.wrappingMode === \"Word\"\n                        ? WrappingMode[technique.wrappingMode]\n                        : defaultLayoutParams.wrappingMode,\n                horizontalAlignment,\n                verticalAlignment\n            };\n\n            const themeLayoutParams = this.getTextElementStyle(technique.style);\n            layoutStyle = new TextLayoutStyle({\n                ...themeLayoutParams,\n                ...layoutParams\n            });\n            this.m_textLayoutStyleCache.set(cacheId, layoutStyle);\n        }\n\n        return layoutStyle;\n    }\n\n    private createTextElementStyle(\n        style: TextStyleDefinition,\n        styleName: string\n    ): TextElementStyle {\n        return {\n            name: styleName,\n            fontCatalog: getOptionValue(style.fontCatalogName, this.m_defaultStyle.fontCatalog),\n            renderParams: {\n                fontName: style.fontName,\n                fontSize: {\n                    unit: FontUnit.Pixel,\n                    size: 32,\n                    backgroundSize: style.backgroundSize || 8\n                },\n                fontStyle:\n                    style.fontStyle === \"Regular\" ||\n                    style.fontStyle === \"Bold\" ||\n                    style.fontStyle === \"Italic\" ||\n                    style.fontStyle === \"BoldItalic\"\n                        ? FontStyle[style.fontStyle]\n                        : undefined,\n                fontVariant:\n                    style.fontVariant === \"Regular\" ||\n                    style.fontVariant === \"AllCaps\" ||\n                    style.fontVariant === \"SmallCaps\"\n                        ? FontVariant[style.fontVariant]\n                        : undefined,\n                rotation: style.rotation,\n                color:\n                    style.color !== undefined\n                        ? ColorCache.instance.getColor(style.color)\n                        : undefined,\n                backgroundColor:\n                    style.backgroundColor !== undefined\n                        ? ColorCache.instance.getColor(style.backgroundColor)\n                        : undefined,\n                opacity: style.opacity,\n                backgroundOpacity: style.backgroundOpacity\n            },\n            layoutParams: {\n                tracking: style.tracking,\n                leading: style.leading,\n                maxLines: style.maxLines,\n                lineWidth: style.lineWidth,\n                canvasRotation: style.canvasRotation,\n                lineRotation: style.lineRotation,\n                wrappingMode:\n                    style.wrappingMode === \"None\" ||\n                    style.wrappingMode === \"Character\" ||\n                    style.wrappingMode === \"Word\"\n                        ? WrappingMode[style.wrappingMode]\n                        : WrappingMode.Word,\n                verticalAlignment:\n                    style.vAlignment === \"Above\" ||\n                    style.vAlignment === \"Center\" ||\n                    style.vAlignment === \"Below\"\n                        ? VerticalAlignment[style.vAlignment]\n                        : VerticalAlignment.Center,\n                horizontalAlignment:\n                    style.hAlignment === \"Left\" ||\n                    style.hAlignment === \"Center\" ||\n                    style.hAlignment === \"Right\"\n                        ? HorizontalAlignment[style.hAlignment]\n                        : HorizontalAlignment.Center\n            }\n        };\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Vector3 } from \"three\";\n\nimport { MapView } from \"./MapView\";\nimport { MapViewUtils } from \"./Utils\";\n\n/**\n * The default value for camera movement throttling, in milliseconds.\n */\nconst DEFAULT_THROTTLING_TIMEOUT = 300;\n\n/**\n * The `CameraMovementDetector` class checks for changes in camera position and orientation, to\n * detect continuous movements without the animation mode activated in [[MapView]]. If the\n * interaction is not continuous enough, you can use a throttling timer to reduce the number of\n * callbacks.\n */\nexport class CameraMovementDetector {\n    private m_lastAttitude?: MapViewUtils.Attitude;\n    private m_lastCameraPos = new Vector3();\n    private m_newCameraPos = new Vector3();\n    private m_cameraMovedLastFrame: boolean | undefined;\n    private m_throttlingTimerId?: number = undefined;\n    private m_movementDetectorDeadline: number = 0;\n\n    /**\n     * Initializes the detector with timeout value and callbacks. [[MapView]] also provides\n     * events for client code to be notified when these cues occur.\n     *\n     * @param m_throttlingTimeout The delay, in milliseconds, between the last user interaction\n     * detected and the call to `m_movementFinishedFunc`; the default is `300`.\n     * @param m_movementStartedFunc Callback function, called when the user starts interacting.\n     * @param m_movementFinishedFunc Callback function, called when the user stops interacting.\n     */\n    constructor(\n        private m_throttlingTimeout: number | undefined,\n        private m_movementStartedFunc: (() => void) | undefined,\n        private m_movementFinishedFunc: (() => void) | undefined\n    ) {\n        if (this.m_throttlingTimeout === undefined) {\n            this.m_throttlingTimeout = DEFAULT_THROTTLING_TIMEOUT;\n        }\n    }\n\n    /**\n     * Checks if the camera has moved since the last time it was checked. The\n     * `m_movementStartedFunc` is called when a movement starts. If no movement\n     * is detected, a timer for `m_movementFinishedFunc` starts.\n     *\n     * @param mapView [[Mapview]]'s position and camera are checked for modifications.\n     */\n    checkCameraMoved(mapView: MapView, now: number): boolean {\n        const newAttitude = MapViewUtils.extractAttitude(mapView, mapView.camera);\n        const newCameraPos = mapView.camera.getWorldPosition(this.m_newCameraPos);\n\n        if (this.m_lastAttitude === undefined) {\n            this.m_lastCameraPos.copy(newCameraPos);\n            this.m_lastAttitude = newAttitude;\n            return false;\n        }\n        const cameraMoved =\n            !this.m_lastCameraPos.equals(newCameraPos) ||\n            newAttitude.yaw !== this.m_lastAttitude.yaw ||\n            newAttitude.pitch !== this.m_lastAttitude.pitch ||\n            newAttitude.roll !== this.m_lastAttitude.roll;\n\n        if (cameraMoved) {\n            this.m_lastCameraPos.copy(newCameraPos);\n            this.m_lastAttitude = newAttitude;\n        }\n\n        if (cameraMoved !== this.m_cameraMovedLastFrame) {\n            if (cameraMoved) {\n                this.movementStarted();\n            }\n            this.m_cameraMovedLastFrame = cameraMoved;\n        }\n        if (cameraMoved) {\n            // Start timer\n            this.m_movementDetectorDeadline = now + this.m_throttlingTimeout!;\n            this.startMovementFinishedTimer(now);\n        }\n\n        return this.m_cameraMovedLastFrame;\n    }\n\n    /**\n     * Reset the saved camera position. Next time checkCameraMoved is called, it will return\n     * `false`.\n     */\n    clear(mapView: MapView) {\n        const newCameraPos = mapView.camera.getWorldPosition(this.m_newCameraPos);\n        this.m_lastCameraPos.set(newCameraPos.x, newCameraPos.y, newCameraPos.z);\n\n        const newAttitude = MapViewUtils.extractAttitude(mapView, mapView.camera);\n        this.m_lastAttitude = newAttitude;\n    }\n\n    /**\n     * Force change of camera position. Next time checkCameraMoved is called, it will return `true`.\n     */\n    forceMoved() {\n        this.m_lastCameraPos.set(Number.NaN, Number.NaN, Number.NaN);\n    }\n\n    /**\n     * Returns `true` if the camera of this [[MapView]] is currently moving. In this case the\n     * `m_movementFinishedFunc` is waiting to be called after the throttling timer runs out.\n     */\n    get cameraIsMoving() {\n        return this.m_throttlingTimerId !== undefined;\n    }\n\n    /**\n     * Disposes resources and kills the throttling timer.\n     */\n    dispose() {\n        this.removeMovementFinishedTimer();\n        this.m_movementStartedFunc = undefined;\n        this.m_movementFinishedFunc = undefined;\n    }\n\n    /**\n     * Returns `true` if the camera has moved in the last frame.\n     */\n    get cameraMovedLastFrame(): boolean {\n        return this.m_cameraMovedLastFrame === true;\n    }\n\n    private movementStarted() {\n        if (this.m_movementStartedFunc !== undefined) {\n            this.m_movementStartedFunc();\n        }\n    }\n\n    private movementFinished() {\n        this.removeMovementFinishedTimer();\n        if (this.m_movementFinishedFunc !== undefined) {\n            this.m_movementFinishedFunc();\n        }\n    }\n\n    private startMovementFinishedTimer(now: number) {\n        if (this.m_throttlingTimerId === undefined) {\n            const remainingTime = Math.max(0, this.m_movementDetectorDeadline - now);\n            this.m_throttlingTimerId = setTimeout(this.onDeadlineTimer, remainingTime) as any;\n        }\n    }\n\n    private onDeadlineTimer = () => {\n        this.m_throttlingTimerId = undefined;\n        const now = performance.now();\n        if (now >= this.m_movementDetectorDeadline) {\n            this.movementFinished();\n        } else {\n            this.startMovementFinishedTimer(now);\n        }\n    };\n\n    private removeMovementFinishedTimer() {\n        if (this.m_throttlingTimerId !== undefined) {\n            clearTimeout(this.m_throttlingTimerId);\n            this.m_throttlingTimerId = undefined;\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ViewRanges } from \"@here/harp-datasource-protocol/lib/ViewRanges\";\nimport { EarthConstants, Projection, ProjectionType } from \"@here/harp-geoutils\";\nimport { assert } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\nimport { MapView } from \"./MapView\";\nimport { MapViewUtils } from \"./Utils\";\n\nconst epsilon = 0.000001;\n\nexport interface ClipPlanesEvaluator {\n    /**\n     * Minimum elevation to be rendered, values beneath the sea level are negative.\n     */\n    minElevation: number;\n\n    /**\n     * Set maximum elevation to be rendered, values above sea level are positive.\n     */\n    maxElevation: number;\n\n    /**\n     * Compute near and far clipping planes distance.\n     *\n     * Evaluation method should be called on every frame  and camera clip planes updated.\n     * This is related to evaluator implementation and its input data, that may suddenly change\n     * such as camera position or angle, projection type or so.\n     * Some evaluators may not depend on all or even any of input objects, but to preserve\n     * compatibility with any evaluator type it is strongly recommended to update on every frame.\n     * @param mapView The [[MapView]] in use.\n     * @note Camera clipping planes aren't automatically updated via #evaluateClipPlanes()\n     * call, user should do it manually if needed.\n     */\n    evaluateClipPlanes(mapView: MapView): ViewRanges;\n}\n\n/**\n * Simplest camera clip planes evaluator, interpolates near/far planes based on ground distance.\n *\n * At general ground distance to camera along the surface normal is used as reference point for\n * planes evaluation, where near plane distance is set as fraction of this distance refereed as\n * [[nearMultiplier]]. Far plane equation has its own multiplier - [[nearFarMultiplier]],\n * which is applied to near plane and offset giving finally far plane distance.\n * This evaluator supports both planar and spherical projections, although it's behavior is\n * slightly different in each case. General algorithm sets near plane between camera and\n * ground level, while far plane is just calculated using scale and bias approach with far offset\n * and multiplier.\n * @deprecated Class contains the legacy (first and original) clip planes evaluation method, which\n * is widelly used in examples thus is still kept for backward compatibility and comparisons.\n */\nexport class InterpolatedClipPlanesEvaluator implements ClipPlanesEvaluator {\n    readonly farMin: number;\n\n    protected m_tmpVectors: THREE.Vector3[] = [\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3()\n    ];\n    protected m_tmpQuaternion: THREE.Quaternion = new THREE.Quaternion();\n\n    constructor(\n        readonly nearMin: number = 0.1,\n        readonly nearMultiplier: number = 0.1,\n        readonly nearFarMultiplier = 50.0,\n        readonly farOffset = 200.0\n    ) {\n        assert(nearMin > 0);\n        assert(nearFarMultiplier >= 0);\n        assert(farOffset >= 0);\n        this.farMin = nearMin * nearFarMultiplier + farOffset;\n    }\n\n    // tslint:disable-next-line: no-empty\n    set minElevation(elevation: number) {}\n\n    get minElevation(): number {\n        // This evaluator does not support elevation so its always set to 0.\n        return 0;\n    }\n\n    // tslint:disable-next-line: no-empty\n    set maxElevation(elevation: number) {}\n\n    get maxElevation(): number {\n        // This evaluator does not support elevation so its always set to 0.\n        return 0;\n    }\n\n    evaluateClipPlanes(mapView: MapView): ViewRanges {\n        const camera = mapView.camera;\n        const projection = mapView.projection;\n        let nearPlane: number = this.nearMin;\n        let farPlane: number = this.farMin;\n        if (projection.type === ProjectionType.Spherical) {\n            // near and far plane for a set up where\n            // the camera is looking at the center of the scene.\n            const r = EarthConstants.EQUATORIAL_RADIUS;\n            const d = camera.position.length();\n            const alpha = Math.asin(r / d);\n            // Extract X, Y, Z axes into tmp vectors array.\n            camera.matrixWorld.extractBasis(\n                this.m_tmpVectors[0],\n                this.m_tmpVectors[1],\n                this.m_tmpVectors[2]\n            );\n            // Setup quaternion based on X axis.\n            this.m_tmpQuaternion.setFromAxisAngle(this.m_tmpVectors[0], alpha);\n            // Acquire forward vector based on Z axis reversed (keep it in tmpVectors[2]).\n            const fwd = this.m_tmpVectors[2].negate();\n            // Apply quaternion rotation to forward vector, store it in tmpVectors[1].\n            const fwdRot = this.m_tmpVectors[1].copy(fwd).applyQuaternion(this.m_tmpQuaternion);\n            // Store camera position tmpVectors[0] and reference it with p.\n            const p = this.m_tmpVectors[0].copy(camera.position);\n            p.addScaledVector(fwdRot, Math.sqrt(d * d - r * r));\n            farPlane = p.sub(camera.position).dot(fwd);\n            nearPlane = Math.max(\n                this.nearMin,\n                projection.groundDistance(camera.position) * this.nearMultiplier\n            );\n        } else if (projection.type === ProjectionType.Planar) {\n            const groundDistance = projection.groundDistance(camera.position);\n            nearPlane = Math.max(this.nearMin, groundDistance * this.nearMultiplier);\n            // Will be already clamped to minFar due to clamping above.\n            farPlane = nearPlane * this.nearFarMultiplier + this.farOffset;\n        } else {\n            assert(false, \"Unsupported projection type\");\n        }\n\n        const viewRanges: ViewRanges = {\n            near: nearPlane,\n            far: farPlane,\n            minimum: this.nearMin,\n            maximum: farPlane\n        };\n        return viewRanges;\n    }\n}\n\n/**\n * Abstract evaluator class that adds support for elevation constraints.\n *\n * Classes derived from this should implement algorithms that takes into account rendered\n * features height (elevations), such as ground plane is no more flat (or spherical), but\n * contains geometry that should be overlapped by frustum planes.\n */\nexport abstract class ElevationBasedClipPlanesEvaluator implements ClipPlanesEvaluator {\n    private m_maxElevation: number;\n    private m_minElevation: number;\n\n    constructor(maxElevation: number, minElevation: number) {\n        assert(maxElevation >= minElevation);\n        this.m_minElevation = minElevation;\n        this.m_maxElevation = maxElevation;\n    }\n\n    abstract evaluateClipPlanes(mapView: MapView): ViewRanges;\n\n    /**\n     * Set maximum elevation above sea level to be rendered.\n     *\n     * @param elevation the elevation (altitude) value in world units (meters).\n     * @note If you set this exactly to the maximum rendered feature height (altitude above\n     * the sea, you may notice some flickering or even polygons disappearing related to rounding\n     * errors or depth buffer precision. In such cases increase [[nearFarMargin]] or add a little\n     * bit offset to your assumed maximum elevation.\n     * @note Reasonable values are in between (-DeadSeeDepression, MtEverestHeight>, both values\n     * are defined in [[EarthConstant]] as [[EarthConstant.MIN_ELEVATION]] and\n     * [[EarthConstant.MAX_ELEVATION]] respectively.\n     * @see minElevation for more information about precision and rounding errors.\n     */\n    set maxElevation(elevation: number) {\n        this.m_maxElevation = elevation;\n        // Min elevation should be at least equal or smaller to max elevation.\n        this.m_minElevation = Math.min(elevation, this.m_minElevation);\n    }\n\n    /**\n     * Get maximum elevation to be covered by camera frustum.\n     */\n    get maxElevation(): number {\n        return this.m_maxElevation;\n    }\n\n    /**\n     * Set minimum elevation to be rendered, values beneath the sea level are negative.\n     *\n     * @param elevation the minimum elevation (depression) in world units (meters).\n     * @note If you set this parameter to zero you may not see any features rendered if they are\n     * just below the sea level more than half of [[nearFarMargin]] assumed. Similarly if set to\n     * -100m and rendered features lays exactly in such depression, you may notice that problem.\n     * The errors usually come from projection precision loss and depth buffer nature (significant\n     * precision loss closer to far plane). Thus is such cases either increase the margin (if you\n     * are sure features are just at this elevation, or setup bigger offset for [[minElevation]].\n     * Reasonable values are between <-DeadSeaDepression, MtEverestHeight), where the first denotes\n     * lowest depression on the Earth defined as [[EarthConstants.MIN_ELEVATION]] and the second is\n     * the highest point our planet.\n     * @see https://developer.nvidia.com/content/depth-precision-visualized\n     */\n    set minElevation(elevation: number) {\n        this.m_minElevation = elevation;\n        // Max elevation should be at least equal or bigger than min elevation.\n        this.m_maxElevation = Math.max(elevation, this.m_maxElevation);\n    }\n\n    /**\n     * Get minimum elevation to be covered by camera frustum.\n     */\n    get minElevation(): number {\n        return this.m_minElevation;\n    }\n}\n\n/**\n * Top view, clip planes evaluator that computes view ranges based on ground distance and elevation.\n *\n * This evaluator supports both planar and spherical projections, although it behavior is\n * slightly different in each case. General algorithm sets near plane and far plane close\n * to ground level, but taking into account maximum and minimum elevation of features on the ground.\n *\n * @note This evaluator supports only cameras which are always looking down the ground surface\n * (top-down view) along surface normal and does not preserve correct clip planes when\n * modifying camera pitch (tilt) angle. In simple words it is suitable only for top view camera\n * settings.\n */\nexport class TopViewClipPlanesEvaluator extends ElevationBasedClipPlanesEvaluator {\n    /**\n     * Helper for reducing number of objects created at runtime.\n     */\n    protected m_tmpVectors: THREE.Vector3[] = [\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3()\n    ];\n    /**\n     * Helper object for reducing performance impact.\n     */\n    protected m_tmpQuaternion: THREE.Quaternion = new THREE.Quaternion();\n    private m_minimumViewRange: ViewRanges;\n\n    /**\n     * Allows to setup near/far offsets (margins), rendered geometry elevation relative to sea\n     * level as also minimum near plane and maximum far plane distance constraints.\n     * It is strongly recommended to set some reasonable [[nearFarMargin]] (offset) between near\n     * and far planes to avoid flickering.\n     * @param maxElevation defines near plane offset from the ground in the surface normal\n     * direction, positive values allows to render elevated terrain features (mountains,\n     * buildings). Defaults to Burj Khalifa building height.\n     * @param minElevation defines far plane offset from the ground surface, negative values moves\n     * far plane below the ground level (use it to render depressions). Default zero - sea level.\n     * @param nearMin minimum allowable near plane distance from camera, must be bigger than zero.\n     * @param nearFarMarginRatio minimum distance between near and far plane, as a ratio of average\n     * near/far plane distance, it have to be significantly bigger than zero (especially if\n     * [[maxElevation]] and [[minElevation]] are equal), otherwise you may notice flickering when\n     * rendering, or even render empty scene if frustum planes are almost equal.\n     * @param farMaxRatio maximum ratio between ground and far plane distance, allows to limit\n     * viewing distance at overall. Have to be bigger than 1.0.\n     * @note Keep in mind that this evaluator does not evaluate terrain (or building) elevation\n     * automatically, to keep such features rendered (between frustum planes) use [[minElevation]],\n     * [[maxElevation]] constraints. You may change this parameters at any time, but it requires\n     * repeating [[evaluatePlanes]] step, if your camera is moving you need to evaluate planes\n     * anyway.\n     * @note You may treat [[minElevation]] and [[maxElevation]] parameters as the maximum and\n     * minimum renderable elevation respectively along the surface normal, when camera is\n     * constantly looking downwards (top-down view). If you need [[ClipPlanesEvaluator]] for\n     * cameras that support tilt or yaw please use [[TiltViewClipPlanesEvaluator]].\n     * @note [[nearFarMaxRatio]] does not limit far plane when spherical projection is in use,\n     * the algorithm used there estimates distance to point on tangent where line from camera\n     * touches the sphere horizon and there is no reason to clamp it.\n     */\n    constructor(\n        maxElevation: number = EarthConstants.MAX_BUILDING_HEIGHT,\n        minElevation: number = 0,\n        readonly nearMin: number = 1.0,\n        readonly nearFarMarginRatio: number = 0.05,\n        readonly farMaxRatio = 1.8\n    ) {\n        super(maxElevation, minElevation);\n        assert(nearMin > 0);\n        assert(nearFarMarginRatio > epsilon);\n        assert(farMaxRatio > 1.0);\n        const nearFarMargin = nearFarMarginRatio * nearMin;\n        this.m_minimumViewRange = {\n            near: nearMin,\n            far: nearMin + nearFarMargin,\n            minimum: this.nearMin,\n            maximum: Math.max(nearMin * farMaxRatio, nearMin + nearFarMargin)\n        };\n    }\n\n    evaluateClipPlanes(mapView: MapView): ViewRanges {\n        if (mapView.projection.type === ProjectionType.Spherical) {\n            return this.evaluateDistanceSphericalProj(mapView);\n        } else if (mapView.projection.type === ProjectionType.Planar) {\n            return this.evaluateDistancePlanarProj(mapView);\n        }\n        assert(false, \"Unsupported projection type\");\n        return { ...this.minimumViewRange };\n    }\n\n    /**\n     * Get minimum view range that is possible to achieve with current evaluator settings.\n     * @note This value will not change after evaluator is constructed.\n     */\n    protected get minimumViewRange(): ViewRanges {\n        return this.m_minimumViewRange;\n    }\n\n    /**\n     * Calculate camera altitude (closest distance) to ground level in world units.\n     * @param camera\n     * @param projection\n     */\n    protected getCameraAltitude(camera: THREE.Camera, projection: Projection): number {\n        return projection.groundDistance(camera.position);\n    }\n\n    protected evaluateDistancePlanarProj(mapView: MapView): ViewRanges {\n        const { camera, projection } = mapView;\n        assert(projection.type !== ProjectionType.Spherical);\n\n        let nearPlane: number = this.nearMin;\n        let farPlane: number = this.nearMin * this.farMaxRatio;\n\n        // Calculate distance to closest point on the ground.\n        const groundDistance = this.getCameraAltitude(camera, projection);\n        const farMax = groundDistance * this.farMaxRatio;\n        // We could at least try to keep margins along the eye vector (center of the view) in\n        // tact with pitch angle changes, but this does not solve all tilt angle problems,\n        // rather use more sophisticated evaluator.\n        nearPlane = groundDistance - this.maxElevation;\n        farPlane = groundDistance - this.minElevation;\n\n        // Apply the constraints.\n        nearPlane = Math.max(nearPlane, this.nearMin);\n        farPlane = Math.min(farPlane, farMax);\n        // Apply margins\n        const nearFarMargin = (this.nearFarMarginRatio * (nearPlane + farPlane)) / 2;\n        nearPlane = Math.max(nearPlane - nearFarMargin / 2, this.nearMin);\n        farPlane = Math.max(farPlane + nearFarMargin / 2, nearPlane + nearFarMargin);\n\n        const viewRanges: ViewRanges = {\n            near: nearPlane,\n            far: farPlane,\n            minimum: this.nearMin,\n            maximum: Math.max(farMax, farPlane)\n        };\n        return viewRanges;\n    }\n\n    protected evaluateDistanceSphericalProj(mapView: MapView): ViewRanges {\n        const { camera, projection } = mapView;\n        assert(projection.type === ProjectionType.Spherical);\n\n        let nearPlane: number = this.nearMin;\n        let farPlane: number = this.nearMin * this.farMaxRatio;\n\n        // The near plane calculus is quite straight forward and works the same as for planar\n        // projections. We simply search for the closest point of the ground just above\n        // the camera, then we apply margin (elevation) to it along the sphere surface normal:\n        const cameraAltitude = this.getCameraAltitude(camera, projection);\n        nearPlane = cameraAltitude - this.maxElevation;\n        let farMax = cameraAltitude * this.farMaxRatio;\n\n        // Far plane calculation requires different approaches depending from camera projection:\n        // - perspective\n        // - orthographic\n\n        const r = EarthConstants.EQUATORIAL_RADIUS;\n        let d = camera.position.length();\n        d = d === 0 ? epsilon : d;\n        if (camera.type === \"PerspectiveCamera\") {\n            // This solution computes near and far plane for a set up where\n            // the camera is looking at the center of the scene.\n\n            // The far plane distance calculus requires finding the sphere tangent line that is\n            // co-linear with (goes thru) camera position, such tangent creates right angle\n            // with sphere diameter where it touches its surface (point T). Given that sphere is\n            // always at world origin and camera orbits around it we have (see\n            // #getTangentBasedFarPlane):\n            // angle(OTC) = 90\n            // sin(OCT) = sin(alpha) = r / d\n            // alpha = asin(r / d)\n            const alpha = Math.asin(r / d);\n            // If alpha it bigger than half fov angle, our visibility limit is set by tangent\n            // line, otherwise we need to find top (or right) plane intersection with sphere,\n            // which is definitely closer than the tangent point mentioned above.\n            const cam = camera as THREE.PerspectiveCamera;\n            // Take fov directly if it is vertical, otherwise we translate it using aspect ratio:\n            const aspect = cam.aspect > 1 ? cam.aspect : 1 / cam.aspect;\n            const halfFovAngle = THREE.Math.degToRad((cam.fov * aspect) / 2);\n\n            const farTangent = this.getTangentBasedFarPlane(cam, d, r, alpha);\n            farPlane =\n                halfFovAngle > alpha\n                    ? farTangent\n                    : this.getFovBasedFarPlane(cam, d, r, 2 * halfFovAngle, projection);\n            farMax = Math.max(farMax, farTangent);\n        }\n        // Orthographic camera projection\n        else {\n            farPlane = this.getOrthoBasedFarPlane(d, r);\n        }\n\n        // In extreme cases the largest depression assumed may be further than tangent\n        // based far plane distance, take it into account\n        const farMin = cameraAltitude - this.minElevation;\n        // Apply the constraints.\n        nearPlane = Math.max(nearPlane, this.nearMin);\n        farPlane = Math.max(farPlane, farMin);\n        // Apply margins\n        const nearFarMargin = (this.nearFarMarginRatio * (nearPlane + farPlane)) / 2;\n        nearPlane = Math.max(nearPlane - nearFarMargin / 2, this.nearMin);\n        farPlane = Math.max(farPlane + nearFarMargin / 2, nearPlane + nearFarMargin);\n\n        const viewRanges: ViewRanges = {\n            near: nearPlane,\n            far: farPlane,\n            minimum: this.nearMin,\n            maximum: farMax\n        };\n        return viewRanges;\n    }\n\n    /**\n     * Calculate distance from a point to the tangent point of a sphere.\n     *\n     * Returns zero if point is below surface or only very slightly above surface of sphere.\n     * @param d Distance from point to center of sphere\n     * @param r Radius of sphere\n     */\n    protected getTangentDistance(d: number, r: number): number {\n        // There may be situations when maximum elevation still remains below sea level\n        // (elevation < 0) or it is negligible (elevation ~ epsilon)\n        if (d - r < epsilon) {\n            return 0;\n        }\n\n        // The distance to tangent point may be described as:\n        // t = sqrt(d^2 - r^2)\n        return Math.sqrt(d * d - r * r);\n    }\n\n    /**\n     * Calculate far plane depending on furthest visible distance from camera position.\n     *\n     * Furthest visible distance is assumed to be distance from camera to horizon\n     * plus distance from elevated geometry to horizon(so that high objects behind horizon\n     * remain visible).\n     * @param camera The camera of the mapview\n     * @param d Distance from camera to origin\n     * @param r Radius of earth\n     * @param alpha Angle between camera eye vector and tangent\n     */\n    protected getTangentBasedFarPlane(\n        camera: THREE.PerspectiveCamera,\n        d: number,\n        r: number,\n        alpha: number\n    ): number {\n        // Find tangent point intersection distance\n        //         , - ~ ~ ~ - ,\n        //     , '               ' ,        E\n        //   ,           .           ,    . ' far + elev\n        //  ,            .   r + e   , '   /\n        // ,             .     ,  '    ,  /\n        // ,             . O '         , / te\n        // ,             | .           ,/\n        //  ,            |   .  r     ,/\n        //   ,           |      .    ,\n        //     ,         |        , '_____ far\n        //       ' -_, _ | _ ,  ' / T\n        //     near      |      /\n        //               |    / t\n        //             d |  /\n        //               |/\n        //               C\n        const t = this.getTangentDistance(d, r);\n\n        // Because we would like to see elevated geometry that may be visible beyond\n        // the tangent point on ground surface, we need to extend viewing distance along\n        // the tangent line by te (see graph above).\n        const te = this.getTangentDistance(r + this.maxElevation, r);\n\n        // Next step is to project CE vector(length t + te) onto camera eye (forward) vector\n        // to get maximum camera far plane distance.\n        //\n        // Knowing that:\n        // tangentVec.dot(cameraFwdVec) = cos(alpha) * len(tangentVec) * len(cameraFwdVec).\n        // where:\n        // ||cameraFwdVec|| == 1 ^ ||tangentVec|| == t + te\n        // Formula simplifies to:\n        const far = Math.cos(alpha) * (t + te);\n\n        return far;\n    }\n\n    protected getFovBasedFarPlane(\n        camera: THREE.PerspectiveCamera,\n        d: number,\n        r: number,\n        fovAngle: number,\n        projection: Projection\n    ) {\n        // Find intersection point that is closer to tangent point.\n        //\n        //         , - ~ ~ ~ - ,\n        //     , '               ' ,\n        //   ,           .           ,\n        //  ,            .     r     ,' T1\n        // ,             .     ,  '  / ,\n        // ,             . O.'  a   /  ,\n        // ,             | .  `  . /   ,\n        //  ,            |   .  r / TA,\n        //   ,           |    .  /   ,\n        //     ,         |     ./  ,'_____ far\n        //       ' -_, _ | _ , /' T0\n        //     near      |    /\n        //               |   / t\n        //             d | /\n        //               |/\n        //               C\n        //\n        // See:\n        // tslint:disable-next-line: max-line-length\n        // https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection\n\n        // Vector from camera to world center\n        const dVec = camera.position;\n        // Extract camera X, Y, Z orientation axes into tmp vectors array.\n        camera.matrixWorld.extractBasis(\n            this.m_tmpVectors[0],\n            this.m_tmpVectors[1],\n            this.m_tmpVectors[2]\n        );\n        // Setup quaternion (X axis based) for angle between frustum plane and camera eye.\n        this.m_tmpQuaternion.setFromAxisAngle(this.m_tmpVectors[0], fovAngle / 2);\n        // Acquire camera (eye) forward vector from Z axis (keep it in tmpVectors[2]).\n        const cameraFwdVec = this.m_tmpVectors[2];\n        // Apply quaternion to forward vector, creating intersection vector, which is\n        // parallel to top or right frustum plane (depending on the aspect ratio).\n        const tVec = this.m_tmpVectors[1].copy(cameraFwdVec).applyQuaternion(this.m_tmpQuaternion);\n        // Calculate camera to origin vector projection onto frustum plane (top or right).\n        // This gives us the length of CTA segment:\n        const cta = dVec.dot(tVec);\n        // If it is negative, it means that the dVec and the tVec points in\n        // opposite directions - there is no intersection - or intersection could\n        // potentially be behind the intersection ray's origin (camera position).\n        if (cta < 0) {\n            // Intersection points are behind camera, camera looks in wrong direction.\n            const groundDistance = this.getCameraAltitude(camera, projection);\n            // Setup far plane to maximum distance.\n            return groundDistance * this.farMaxRatio;\n        }\n        // Knowing the length of |CTA| we just need to subtract the length of |T0TA|\n        // segment from it to get far plane distance.\n        // In order to calculate |T0TA| we firstly need to use use Pythagorean theorem to\n        // find length of |OTA| = a. Here we use the right triangle formed by O-C-TA points:\n        // |OC|^2 = |CTA|^2 + |OTA|^2, where |OTA| = a, |OC| = d, |CTA| = cta\n        // a^2 = d^2 - cta^2\n        const a2 = dVec.dot(dVec) - cta * cta;\n        // Note that if a is greater than sphere radius the ray misses the sphere and\n        // thus there is no intersection at all.\n        const r2 = r * r;\n        assert(a2 <= r2, \"Please use this evaluator only for top view camera poses.\");\n        // Now to find the length of |T0TA| == |T1TA| we use the second right triangle\n        // formed by O-T0-TA points. Of course we know that |T0TA| segment length is\n        // equal to |T1TA|, and |OT0| segment is simply sphere radius.\n        // In order to find |T0TA| length we again use Pythagorean theorem, which says:\n        // |OT0|^2 = |OTA|^2 + |T0TA|^2, where |OTO| = r, |OTA| = a\n        // |T0TA|^2 = r^2 - a^2\n        const tota = Math.sqrt(r2 - a2);\n        // Finally our far plane (intersection point) is defined as:\n        return cta - tota;\n    }\n\n    protected getOrthoBasedFarPlane(d: number, r: number): number {\n        //         , - ~ ~ ~ - ,\n        //     , '               ' ,     E\n        //   ,            .--------- ,-.'- far + elev\n        // | ,            .   r + e , `, |\n        // |,             .     , '     ,| te\n        // |,             . O '.........,|..\n        // |,             |        r    ,|  far\n        // | ,            |            , |\n        // |  ,           |           ,  | t\n        // |    ,         |        , '   |\n        // |      ' -_, _ | _ ,  '       |\n        // |    near      | \\/___________| near - elev\n        // |              |              |\n        // |            d |              |\n        // |              |              |\n        //                C\n        // The distance to tangent point may be described as:\n        const t = d;\n        // Tangent extension due to terrain elevation behind the horizon may be calculated\n        // based on the right triangle:\n        // (r+maxElev)^2 = r^2 + te^2\n        // te = sqrt((r+maxElev)^2 - r^2)\n        // although we may not calculate it if elevation is negligible:\n        const te =\n            this.maxElevation < epsilon\n                ? 0\n                : Math.sqrt(r + this.maxElevation) * (r + this.maxElevation) - r * r;\n        // Both near and far planes distances are directly applied to frustum, because tangents'\n        // lines are parallel to camera look at vector.\n        // Now far plane distance is constituted with:\n        return t + te;\n    }\n}\n\n/**\n * Evaluates camera clipping planes taking into account ground distance and camera angles.\n *\n * This evaluator provides support for camera with varying tilt (pitch) angle, the angle\n * between camera __look at__ vector and the ground surface normal.\n */\nexport class TiltViewClipPlanesEvaluator extends TopViewClipPlanesEvaluator {\n    /**\n     * Calculate the camera distance to the ground in direction of look at vector.\n     * This is not equivalent to camera altitude cause value will change according to look at\n     * direction. It simply measures the distance of intersection point between ray from\n     * camera and ground level, yet without taking into account terrain elevation nor buildings.\n     * @param camera\n     * @param projection\n     * @note Use with extreme care cause due to optimizations the internal temporary vectors\n     * are used (m_tmpVectors[0], m_tmpVectors[1]). Those should not be used in outlining\n     * function scope (caller).\n     */\n    protected getCameraLookAtDistance(camera: THREE.Camera, projection: Projection): number {\n        assert(projection.type !== ProjectionType.Spherical);\n        // Using simple trigonometry we may approximate the distance of camera eye vector\n        // intersection with theoretical ground, knowing camera altitude and tilt angle:\n        // cos(tiltAngle) = altitude / groundDistance\n        // groundDistance = altitude / cos(tiltAngle)\n        // where:\n        // cos(tiltAngle) = dot(lookAt, eyeInverse)\n        const lookAt: THREE.Vector3 = this.m_tmpVectors[0];\n        camera.getWorldDirection(lookAt).normalize();\n        const normal: THREE.Vector3 = this.m_tmpVectors[1];\n        projection.surfaceNormal(camera.position, normal);\n        normal.negate();\n        let cosTiltAngle = lookAt.dot(normal);\n        cosTiltAngle = cosTiltAngle === 0 ? epsilon : cosTiltAngle;\n        return this.getCameraAltitude(camera, projection) / cosTiltAngle;\n    }\n\n    /**\n     * Calculate the lengths of frustum planes intersection with the ground plane.\n     * This evaluates distances between eye vector (or eye plane in orthographic projection) and\n     * ground intersections of top and bottom frustum planes.\n     * @note This method assumes the world surface (ground) to be flat and\n     * works only with planar projections.\n     *\n     * @param mapView The [[MapView]] instance in use.\n     */\n    protected getFrustumGroundIntersectionDist(mapView: MapView): { top: number; bottom: number } {\n        assert(mapView.projection.type !== ProjectionType.Spherical);\n        const camera = mapView.camera;\n        const projection = mapView.projection;\n        // This algorithm computes the length of frustum planes before intersecting with a flat\n        // ground surface. Entire computation is split over two projections method and performed\n        // for top and bottom plane, with addition of terrain (ground) elevation which is taken\n        // into account.\n        // The following diagram may help explain the algorithm below.\n        //   \n        //   C\n        //   |\\\n        //   |.\\ .\n        //   | . \\  . t\n        // z |  .  \\   .c2\n        //   |  c1.  \\e ___. max elev\n        //   |     .   \\      .\n        //___|a___D1.____\\E1_____.D2______ g\n        //   C1      .     \\ __. min elev\n        //            .      \\.E2\n        //          b  .    .\n        //              . .\n        //               .\n        // Where:\n        // - C gives the camera position.\n        // - z is the height of the camera above the ground.\n        // - z1 == z2 == z, for perspective camera all planes origin its the same\n        // - a is a right angle.\n        // - e is the look at vector of the camera.\n        // - t and b are the frustum planes of the camera (top and bottom respectively).\n        // - angle between c1 to c2 is the fov.\n        // - c1, c2 - vectors from camera to the ground along frustum planes.\n        // - angles between c1 and e or e and c2 splits fov on equal halves.\n        // - d1 and d2 are the intersection points of the frustum with the world/ground plane.\n        // - angle between z and e is the pitch of the camera.\n        // - angle between g and e is the tilt angle.\n        // - g is the ground/world surface\n        //\n        // The goal is to find distance for top/bottom planes intersections of frustum with ground\n        // plane.\n        // This are the distances from C->D1 and C->D2, and are described as\n        // c1 and c2. Then we may compensate/correct those distances with actual\n        // ground elevations, which is done by simply offsetting camera altitude, as it is\n        // opposite to elevating ground level.\n        const halfPiLimit = Math.PI / 2 - epsilon;\n        const cameraAltitude = this.getCameraAltitude(camera, projection);\n        const target = MapViewUtils.rayCastWorldCoordinates(mapView, 0, 0);\n        if (target === null) {\n            throw new Error(\"MapView does not support a view pointing in the void.\");\n        }\n        const cameraTilt = MapViewUtils.extractSphericalCoordinatesFromLocation(\n            mapView,\n            camera,\n            projection.unprojectPoint(target)\n        ).tilt;\n        // Angle between z and c2\n        let topAngleRad: number;\n        // Angle between z and c1\n        let bottomAngleRad: number;\n        // Bottom plane origin altitude\n        let z1: number;\n        // Top plane origin altitude\n        let z2: number;\n        // For perspective projection:\n        if (camera.type === \"PerspectiveCamera\") {\n            const cam = (camera as any) as THREE.PerspectiveCamera;\n            // Angle between z and c2, note, the fov is vertical, otherwise we would need to\n            // translate it using aspect ratio:\n            // let aspect = camera.aspect > 1 ? camera.aspect : 1 / camera.aspect;\n            const aspect = 1;\n            // Half fov angle in radians\n            const halfFovAngle = THREE.Math.degToRad((cam.fov * aspect) / 2);\n            topAngleRad = THREE.Math.clamp(cameraTilt + halfFovAngle, -halfPiLimit, halfPiLimit);\n            bottomAngleRad = THREE.Math.clamp(cameraTilt - halfFovAngle, -halfPiLimit, halfPiLimit);\n            z1 = z2 = cameraAltitude;\n        }\n        // For orthographic projection:\n        else {\n            const cam = (camera as any) as THREE.OrthographicCamera;\n            // For orthogonal camera projections we may simply ignore FOV and use 0 for FOV\n            // the top/bottom planes are simply parallel to the eye vector:\n            topAngleRad = bottomAngleRad = cameraTilt;\n            // Although the ray origin is not always the same (eye position) as for\n            // the perspective projections, thus we need to compensate for ortho-cube\n            // dimensions:\n            // sin(tilt) = zc2 / top\n            // sin(tilt) = zc1 / bottom\n            // zc2 = sin(tilt) * top\n            // zc1 = sin(tilt) * bottom\n            const sinBeta = Math.sin(cameraTilt);\n            z2 = cameraAltitude + sinBeta * cam.top;\n            z1 = cameraAltitude - sinBeta * cam.bottom;\n        }\n        // Distance along the top plane to the ground - c2\n        // cos(topAngle) = (z2 - minElev) / |c2|\n        // |c2| = (z2 - minElev) / cos(topAngle)\n        const topDist = (z2 - this.minElevation) / Math.cos(topAngleRad);\n        // Distance along the bottom plane to the ground - c1\n        // cos(bottomAngle) = (z - minElev) / |c1|\n        // |c1| = (z - minElev) / cos(bottomAngle)\n        const bottomDist = (z1 - this.maxElevation) / Math.cos(bottomAngleRad);\n\n        return {\n            top: Math.max(topDist, 0),\n            bottom: Math.max(bottomDist, 0)\n        };\n    }\n\n    protected evaluateDistancePlanarProj(mapView: MapView): ViewRanges {\n        assert(mapView.projection.type !== ProjectionType.Spherical);\n        const viewRanges = { ...this.minimumViewRange };\n\n        // Generally near/far planes are set to keep top/bottom planes intersection distance.\n        // Then elevations margins are applied. Here margins (min/max elevations) are meant to\n        // be defined as distance along the ground normal vector thus during camera\n        // tilt they may affect near/far planes positions differently.\n        const planesDist = this.getFrustumGroundIntersectionDist(mapView);\n        const { camera, projection } = mapView;\n        // Project clipping plane distances for the top/bottom frustum planes (edges), but\n        // only if we deal with perspective camera type, this step is not required\n        // for orthographic projections, cause all clip planes are parallel to eye vector.\n        if (camera.type === \"PerspectiveCamera\") {\n            const cam = camera as THREE.PerspectiveCamera;\n            // Angle between z and c2, note, the fov is vertical, otherwise we would need to\n            // translate it using aspect ratio:\n            // let aspect = camera.aspect > 1 ? camera.aspect : 1 / camera.aspect;\n            const aspect = 1;\n            // Half fov angle in radians\n            const halfFovAngle = THREE.Math.degToRad((cam.fov * aspect) / 2);\n            const cosHalfFov = Math.cos(halfFovAngle);\n            // cos(halfFov) = near / bottomDist\n            // near = cos(halfFov) * bottomDist\n            viewRanges.near = planesDist.bottom * cosHalfFov;\n            // cos(halfFov) = far / topDist\n            // far = cos(halfFov) * topDist\n            viewRanges.far = planesDist.top * cosHalfFov;\n        }\n        // Orthographic camera projection.\n        else {\n            viewRanges.near = planesDist.bottom;\n            viewRanges.far = planesDist.top;\n        }\n\n        // Clamp values to constraints.\n        const lookAtDist = this.getCameraLookAtDistance(camera, projection);\n        const farMax = lookAtDist * this.farMaxRatio;\n        viewRanges.near = Math.max(viewRanges.near, this.nearMin);\n        viewRanges.far = Math.min(viewRanges.far, farMax);\n        // Apply margins\n        const nearFarMargin = (this.nearFarMarginRatio * (viewRanges.near + viewRanges.far)) / 2;\n        viewRanges.near = Math.max(viewRanges.near - nearFarMargin / 2, this.nearMin);\n        viewRanges.far = Math.max(\n            viewRanges.far + nearFarMargin / 2,\n            viewRanges.near + nearFarMargin\n        );\n        viewRanges.minimum = this.nearMin;\n        viewRanges.maximum = farMax;\n        return viewRanges;\n    }\n\n    protected evaluateDistanceSphericalProj(mapView: MapView): ViewRanges {\n        const { camera, projection } = mapView;\n        assert(projection.type === ProjectionType.Spherical);\n        const viewRanges = { ...this.minimumViewRange };\n\n        // Near plane calculus is pretty straightforward and does not depend on camera tilt:\n        const cameraAltitude = this.getCameraAltitude(camera, projection);\n        viewRanges.near = cameraAltitude - this.maxElevation;\n\n        // Take fov directly if it is vertical, otherwise we translate it using aspect ratio:\n        const aspect = camera.aspect > 1 ? camera.aspect : 1 / camera.aspect;\n        const halfFovAngle = THREE.Math.degToRad((camera.fov * aspect) / 2);\n\n        if (camera instanceof THREE.PerspectiveCamera) {\n            // Now we need to account for camera tilt and frustum volume, so the longest\n            // frustum edge does not intersects with sphere, it takes the worst case\n            // scenario regardless of camera tilt, so may be improved little bit with more\n            // sophisticated algorithm.\n            viewRanges.near *= Math.cos(halfFovAngle);\n        }\n\n        // Far plane calculation requires different approaches depending from camera projection:\n        // - perspective\n        // - orthographic\n        const cameraToOrigin = this.m_tmpVectors[0].copy(camera.position).negate();\n        const r = EarthConstants.EQUATORIAL_RADIUS;\n        const d = cameraToOrigin.length();\n        let farPlane: number;\n        let farMax = mapView.lookAtDistance * this.farMaxRatio;\n        if (camera instanceof THREE.PerspectiveCamera) {\n            // Step-wise calculate angle between camera eye vector and tangent\n\n            // Calculate angle between surface normal(below camera position) and tangent.\n            const alpha = Math.asin(r / d);\n\n            // Calculate angle between look at and surface normal(below camera position)\n            const cameraPitch = this.getCameraPitch(cameraToOrigin, camera);\n\n            // Calculate angle between camera eye vector and tangent.\n            const modifiedAlpha = Math.abs(alpha - cameraPitch);\n\n            // Use tangent based far plane if horizon is within field of view\n            const farTangent = this.getTangentBasedFarPlane(camera, d, r, modifiedAlpha);\n            farPlane =\n                halfFovAngle >= modifiedAlpha\n                    ? farTangent\n                    : this.getTiltedFovBasedFarPlane(d, r, halfFovAngle, cameraPitch);\n            farMax = Math.max(farMax, farTangent);\n        } else {\n            farPlane = this.getOrthoBasedFarPlane(d, r);\n        }\n        viewRanges.far = farPlane;\n\n        // Apply the constraints.\n        const farMin = cameraAltitude - this.minElevation;\n        viewRanges.near = Math.max(viewRanges.near, this.nearMin);\n        viewRanges.far = Math.max(viewRanges.far, farMin);\n\n        // Apply margins.\n        const nearFarMargin = (this.nearFarMarginRatio * (viewRanges.near + viewRanges.far)) / 2;\n        viewRanges.near = Math.max(viewRanges.near - nearFarMargin / 2, this.nearMin);\n        viewRanges.far = Math.max(\n            viewRanges.far + nearFarMargin / 2,\n            viewRanges.near + nearFarMargin\n        );\n\n        // Set minimum and maximum view range.\n        viewRanges.minimum = this.nearMin;\n        viewRanges.maximum = farMax;\n\n        return viewRanges;\n    }\n\n    protected getTiltedFovBasedFarPlane(\n        d: number,\n        r: number,\n        halfFovAngle: number,\n        cameraPitch: number\n    ) {\n        // Find intersection point that is closer to tangent point.\n        //\n        //         , - ~ ~ ~ - ,\n        //     , '               ' ,\n        //   ,           .           ,\n        //  ,            .     r     ,' T1\n        // ,             .     ,  '  / ,\n        // ,             . O.'  a   /  ,\n        // ,             | .  `  . /   ,\n        //  ,            |   .  r / TA,\n        //   ,           |    .  /   ,\n        //     ,         |     ./  ,'_____ far\n        //       ' -_, _ | _ , /' T0\n        //     near      |    /\n        //               |   / t\n        //             d | /\n        //               |/\n        //               C\n        //\n        // See:\n        // tslint:disable-next-line: max-line-length\n        // https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection\n\n        // compute length of t (distance to fov intersection with sphere)\n        // with law of cosines:\n        // r = d + t - 2dt * cos(alpha)\n        // solved for t:\n        // t0 = d * cos(alpha) - sqrt(d*cos(alpha) - d + r)  <-- first intersection\n        // t1 = d * cos(alpha) + sqrt(d*cos(alpha) - d + r)  <-- second intersection\n        // Use first intersection:\n        const cosAlpha = Math.cos(cameraPitch + halfFovAngle);\n        const dSqr = d * d;\n        const t = d * cosAlpha - Math.sqrt(dSqr * cosAlpha * cosAlpha - dSqr + r * r);\n\n        assert(\n            !isNaN(t),\n            \"Field of view does not intersect sphere. Use tangent based far plane instead.\"\n        );\n\n        // project t onto camera fwd vector\n        const far = Math.cos(halfFovAngle) * t;\n\n        return far;\n    }\n\n    private getCameraPitch(cameraToOrigin: THREE.Vector3, camera: THREE.PerspectiveCamera) {\n        cameraToOrigin.normalize();\n        const lookAt = camera.getWorldDirection(this.m_tmpVectors[1]).normalize();\n        const cosAlpha1 = cameraToOrigin.dot(lookAt);\n        const cameraPitch = Math.acos(THREE.Math.clamp(cosAlpha1, -1.0, 1.0));\n\n        return cameraPitch;\n    }\n}\n\n/**\n * Provides the most basic evaluation concept giving fixed values with some constraints.\n */\nexport class FixedClipPlanesEvaluator implements ClipPlanesEvaluator {\n    readonly minFar: number;\n    private m_nearPlane: number;\n    private m_farPlane: number;\n\n    constructor(readonly minNear: number = 1, readonly minFarOffset: number = 10) {\n        this.minFar = minNear + minFarOffset;\n        this.m_nearPlane = minNear;\n        this.m_farPlane = this.minFar;\n    }\n\n    get nearPlane(): number {\n        return this.m_nearPlane;\n    }\n\n    set nearPlane(fixedNear: number) {\n        this.invalidatePlanes(fixedNear, this.m_farPlane);\n    }\n\n    get farPlane(): number {\n        return this.m_farPlane;\n    }\n\n    set farPlane(fixedFar: number) {\n        this.invalidatePlanes(this.m_nearPlane, fixedFar);\n    }\n\n    // tslint:disable-next-line: no-empty\n    set minElevation(elevation: number) {}\n\n    get minElevation(): number {\n        // This evaluator does not support elevation so its always set to 0.\n        return 0;\n    }\n\n    // tslint:disable-next-line: no-empty\n    set maxElevation(elevation: number) {}\n\n    get maxElevation(): number {\n        // This evaluator does not support elevation so its always set to 0.\n        return 0;\n    }\n\n    evaluateClipPlanes(mapView: MapView): ViewRanges {\n        // We do not need to perform actual evaluation cause results are precomputed and\n        // kept stable until somebody changes the properties.\n        const viewRanges: ViewRanges = {\n            near: this.m_nearPlane,\n            far: this.m_farPlane,\n            minimum: this.minNear,\n            maximum: this.m_farPlane\n        };\n        return viewRanges;\n    }\n\n    private invalidatePlanes(near: number, far: number) {\n        // When clamping prefer to extend far plane at about minimum distance, giving\n        // near distance setup priority over far.\n        const nearDist: number = Math.max(this.minNear, near);\n        const farDist: number = Math.max(this.minFar, far, nearDist + this.minFarOffset);\n        this.m_nearPlane = nearDist;\n        this.m_farPlane = farDist;\n    }\n}\n\n/**\n * Factory function that creates default [[ClipPlanesEvaluator]] that calculates near plane based\n * on ground distance and camera orientation.\n *\n * Creates [[TiltViewClipPlanesEvaluator]].\n */\nexport const createDefaultClipPlanesEvaluator = () => new TiltViewClipPlanesEvaluator();\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport { IPassManager } from \"./IPassManager\";\nexport {\n    IMapAntialiasSettings,\n    IMapRenderingManager,\n    MapRenderingManager\n} from \"./MapRenderingManager\";\nexport { IPass, Pass } from \"./Pass\";\nexport { MSAARenderPass, MSAASampling } from \"./MSAARenderPass\";\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { CopyShader, MSAAMaterial } from \"@here/harp-materials\";\nimport * as THREE from \"three\";\n\nimport { Pass } from \"./Pass\";\n\n/**\n * This enum represents the sampling level to apply to a [[MSAARenderPass]] instance. At level 0,\n * only one sample is performed, which is like disabling the MSAA pass.\n */\nexport enum MSAASampling {\n    \"Level_0\",\n    \"Level_1\",\n    \"Level_2\",\n    \"Level_3\",\n    \"Level_4\",\n    \"Level_5\"\n}\n\n/**\n * [[MapView]]'s MSAA implementation. MSAA stands for Multi Sampling Anti-Aliasing, and its concept\n * is to provide a rendering engine with additional color values for each pixel, so they can include\n * the missing bits between them on a screen. WebGL already comes with a native MSAA implementation\n * with four samples. Because of its native nature, it is more efficient and one may not want to use\n * MapView's MSAA implementation when these four samples are satisfying. However in some situations\n * they are not: on low devices, MSAA can impact the framerate and we may desire to reduce the\n * number of samples at runtime. On the other hand, when the interaction stops, the engine also\n * stops rendering the map, and because a map relies on many line-like patterns, aliasing can then\n * turn very noticeable. In such static renders, the number of samples could be dramatically\n * increased on a last frame to render.\n */\nexport class MSAARenderPass extends Pass {\n    /**\n     * The sampling level determines the number of samples that will be performed per frame.\n     * Renders will happen `2 ^ samplingLevel` time(s). `samplingLevel` stands between `0` and `5`.\n     * Therefore there can be between 1 and 32 samples.\n     *\n     * @default `SamplingLevel.Level_1`\n     */\n    samplingLevel: MSAASampling = MSAASampling.Level_1;\n\n    private m_renderTarget: THREE.WebGLRenderTarget | null = null;\n    private readonly m_localCamera: THREE.OrthographicCamera = new THREE.OrthographicCamera(\n        -1,\n        1,\n        1,\n        -1,\n        0,\n        1\n    );\n    private readonly m_quadScene: THREE.Scene = new THREE.Scene();\n    private readonly m_quadUniforms: { [uniformName: string]: THREE.IUniform } =\n        CopyShader.uniforms;\n    private readonly m_quadMaterial: THREE.ShaderMaterial = new MSAAMaterial(this.m_quadUniforms);\n    private readonly m_quad: THREE.Mesh = new THREE.Mesh(\n        new THREE.PlaneBufferGeometry(2, 2),\n        this.m_quadMaterial\n    );\n\n    /**\n     * The constructor for `MSAARenderPass`. It builds an internal scene with a camera looking at a\n     * quad.\n     *\n     * @param m_scene The scene to render.\n     * @param m_camera The camera to render the scene through.\n     */\n    constructor() {\n        super();\n        this.m_quad.frustumCulled = false;\n        this.m_quadScene.add(this.m_quad);\n    }\n\n    /**\n     * Releases all used resources.\n     */\n    dispose() {\n        if (this.m_renderTarget !== null) {\n            this.m_renderTarget.dispose();\n            this.m_renderTarget = null;\n        }\n    }\n\n    /**\n     * The render function of `MSAARenderPass`. At each call of this method, and for each sample,\n     * the [[MapView]] camera provided in the `render` method is offset within the dimension of a\n     * pixel on screen. It then renders the whole scene with this offset to a local\n     * `WebGLRenderTarget` instance, via a `WebGLRenderer` instance. Finally the local camera\n     * created in the constructor shoots the quad and renders to the write buffer or to the frame\n     * buffer. The quad material's opacity is modified so the renders can accumulate in the\n     * targetted buffer.\n     *\n     * The number of samples can be modified at runtime through the enum [[SamplingLevel]].\n     *\n     * If there is no further pass, the [[Pass.renderToScreen]] flag can be set to `true` to\n     * output directly to the framebuffer.\n     *\n     * @param renderer The ThreeJS WebGLRenderer instance to render the scene with.\n     * @param scene The ThreeJS Scene instance to render the scene with.\n     * @param camera The ThreeJS Camera instance to render the scene with.\n     * @param writeBuffer A ThreeJS WebGLRenderTarget instance to render the scene to.\n     * @param readBuffer A ThreeJS WebGLRenderTarget instance to render the scene.\n     */\n    render(\n        renderer: THREE.WebGLRenderer,\n        scene: THREE.Scene,\n        camera: THREE.PerspectiveCamera | THREE.OrthographicCamera,\n        writeBuffer: THREE.WebGLRenderTarget | null,\n        readBuffer: THREE.WebGLRenderTarget\n    ) {\n        if (!this.enabled) {\n            return;\n        }\n\n        // Initiates the local render target with the read buffer's dimensions, if not available.\n        if (this.m_renderTarget === null) {\n            this.m_renderTarget = new THREE.WebGLRenderTarget(readBuffer.width, readBuffer.height, {\n                minFilter: THREE.LinearFilter,\n                magFilter: THREE.LinearFilter,\n                format: THREE.RGBAFormat\n            });\n            this.m_renderTarget.texture.name = \"MSAARenderPass.sample\";\n        }\n        this.m_quadUniforms.tDiffuse.value = this.m_renderTarget.texture;\n\n        const offsets = MSAARenderPass.OffsetVectors[this.samplingLevel];\n\n        const rendererClearColor = renderer.getClearColor();\n        const oldClearColor = rendererClearColor !== undefined ? rendererClearColor.getHex() : 0;\n\n        // The method `camera.setViewOffset` will be called in the next loop. In order to maintain\n        // its usability externally (like for the triple view in mosaic demo) we must cache the\n        // previous values stored in `camera.view` and re-assign them at the end of the pass.\n\n        // 1. Create a default cache object, with default dimensions the size of our read buffer.\n        const oldView = {\n            enabled: camera.view !== null && camera.view.enabled,\n            fullWidth: readBuffer.width,\n            fullHeight: readBuffer.height,\n            x: 0,\n            y: 0,\n            width: readBuffer.width,\n            height: readBuffer.height\n        };\n\n        // 2. If `camera.view` has been enabled previously, then `setViewOffset` has been called\n        // externally: copy the existing `camera.view` values in the cache. Override the cache\n        // object with the values provided externally.\n        if (oldView.enabled && camera.view !== null) {\n            oldView.fullWidth = camera.view.fullWidth;\n            oldView.fullHeight = camera.view.fullHeight;\n            oldView.x = camera.view.offsetX;\n            oldView.y = camera.view.offsetY;\n            oldView.width = camera.view.width;\n            oldView.height = camera.view.height;\n        }\n\n        const oldRenderTarget = renderer.getRenderTarget();\n        for (let i = 0; i < offsets.length; i++) {\n            // 4. Then for each sample, call `setViewOffset` with our object. This also updates the\n            // `camera.view` object in Three.js.\n            const offset = offsets[i];\n            camera.setViewOffset(\n                oldView.fullWidth,\n                oldView.fullHeight,\n                oldView.x + offset[0] / 16,\n                oldView.y + offset[1] / 16,\n                oldView.width,\n                oldView.height\n            );\n\n            // 5. Divide the opacity of the quad by the number of samples to accumulate on the\n            // target buffer, and reduce the impact of the offset on color to reduce banding. Then\n            // render.\n            const uniformCenteredDistribution = -0.5 + (i + 0.5) / offsets.length;\n            const sampleWeight = 1.0 / offsets.length + uniformCenteredDistribution / 32;\n\n            this.m_quadUniforms.opacity.value = sampleWeight;\n\n            renderer.setRenderTarget(this.m_renderTarget);\n            renderer.clear();\n            renderer.render(scene, camera);\n\n            // 6. Render the quad on top of the previous renders.\n\n            // NOTE: three.js doesn't like undefined as renderTarget, but works with `null`\n            renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);\n            if (i === 0) {\n                renderer.setClearColor(0x000000);\n                renderer.clear();\n            }\n            renderer.render(this.m_quadScene, this.m_localCamera);\n            if (i === 0 && rendererClearColor !== undefined) {\n                renderer.setClearColor(oldClearColor);\n            }\n        }\n        renderer.setRenderTarget(oldRenderTarget);\n\n        // 7. Restore `camera.view` as set externally (or not).\n        if (camera.view !== null) {\n            camera.view.enabled = oldView.enabled;\n            camera.view.offsetX = oldView.x;\n            camera.view.offsetY = oldView.y;\n        }\n    }\n\n    /**\n     * Resize the internal render target to match the new size specified.\n     *\n     * @param width New width to apply to the render target.\n     * @param height New height to apply to the render target.\n     */\n    setSize(width: number, height: number) {\n        if (this.m_renderTarget) {\n            this.m_renderTarget.setSize(width, height);\n        }\n    }\n\n    // tslint:disable:max-line-length\n    /**\n     * The list of offsets to apply to the camera, per sampling level, adapted from :\n     *\n     * @see https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396\n     */\n    // tslint:enable:max-line-length\n    // tslint:disable-next-line:member-ordering\n    static readonly OffsetVectors: number[][][] = [\n        [[0, 0]],\n        [\n            [4, 4],\n            [-4, -4]\n        ],\n        [\n            [-2, -6],\n            [6, -2],\n            [-6, 2],\n            [2, 6]\n        ],\n        [\n            [1, -3],\n            [-1, 3],\n            [5, 1],\n            [-3, -5],\n            [-5, 5],\n            [-7, -1],\n            [3, 7],\n            [7, -7]\n        ],\n        [\n            [1, 1],\n            [-1, -3],\n            [-3, 2],\n            [4, -1],\n            [-5, -2],\n            [2, 5],\n            [5, 3],\n            [3, -5],\n            [-2, 6],\n            [0, -7],\n            [-4, -6],\n            [-6, 4],\n            [-8, 0],\n            [7, -4],\n            [6, 7],\n            [-7, -8]\n        ],\n        [\n            [-4, -7],\n            [-7, -5],\n            [-3, -5],\n            [-5, -4],\n            [-1, -4],\n            [-2, -2],\n            [-6, -1],\n            [-4, 0],\n            [-7, 1],\n            [-1, 2],\n            [-6, 3],\n            [-3, 3],\n            [-7, 6],\n            [-3, 6],\n            [-5, 7],\n            [-1, 7],\n            [5, -7],\n            [1, -6],\n            [6, -5],\n            [4, -4],\n            [2, -3],\n            [7, -2],\n            [1, -1],\n            [4, -1],\n            [2, 1],\n            [6, 2],\n            [0, 4],\n            [4, 4],\n            [2, 5],\n            [7, 5],\n            [5, 6],\n            [3, 7]\n        ]\n    ];\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { RequestController, WorkerServiceProtocol } from \"@here/harp-datasource-protocol\";\nimport {\n    getOptionValue,\n    IWorkerChannelMessage,\n    LoggerManager,\n    LogLevel,\n    WORKERCHANNEL_MSG_TYPE\n} from \"@here/harp-utils\";\n\nimport { WorkerLoader } from \"./workers/WorkerLoader\";\n\nimport * as THREE from \"three\";\n\nconst logger = LoggerManager.instance.create(\"ConcurrentWorkerSet\");\n\nexport function isLoggingMessage(message: IWorkerChannelMessage): message is IWorkerChannelMessage {\n    return message && typeof message.level === \"number\" && message.type === WORKERCHANNEL_MSG_TYPE;\n}\n\ninterface ReadyPromise {\n    count: number;\n    promise?: Promise<void>;\n    resolve: () => void;\n    reject: (reason: any) => void;\n    error?: any;\n}\n\ninterface RequestEntry {\n    promise: Promise<any>;\n    resolver: (error?: Error, response?: object) => void;\n}\n\nexport interface ConcurrentWorkerSetOptions {\n    /**\n     * The URL of the script for each worker to start.\n     */\n    scriptUrl: string;\n\n    /**\n     * The number of Web Workers for processing data.\n     *\n     * Defaults to CLAMP(`navigator.hardwareConcurrency` - 1, 1, 4) or [[DEFAULT_WORKER_COUNT]].\n     */\n    workerCount?: number;\n\n    /**\n     * Timeout in milliseconds, in which each worker should set initial message.\n     *\n     * @default 10 seconds, see [[DEFAULT_WORKER_INITIALIZATION_TIMEOUT]]\n     */\n    workerConnectionTimeout?: number;\n}\n\n/**\n * Interface for an item in the started worker list queue.\n */\ninterface WorkerEntry {\n    worker: Worker;\n    listener: EventListener;\n}\n\n/**\n * Interface for an item in the request queue. Stores the data to be decoded along with an\n * [[AbortController]].\n */\ninterface WorkerRequestEntry {\n    message: WorkerServiceProtocol.RequestMessage;\n    buffers?: ArrayBuffer[] | undefined;\n    requestController?: RequestController;\n}\n\n/**\n * The default number of Web Workers to use if `navigator.hardwareConcurrency` is unavailable.\n */\nconst DEFAULT_WORKER_COUNT = 2;\n\n/**\n * The default timeout for first message from worker.\n *\n * @see [[WorkerLoader.startWorker]]\n */\nexport const DEFAULT_WORKER_INITIALIZATION_TIMEOUT = 10000;\n\n/**\n * A set of concurrent Web Workers. Acts as a Communication Peer for [[WorkerService]] instances\n * running in Web Workers.\n *\n * Starts and manages a certain number of web workers and provides a means to communicate\n * with them using various communication schemes, such as:\n *  - [[addEventListener]] : receive a unidirectional messages\n *  - [[broadcastMessage]] : send unidirectional broadcast message\n *  - [[invokeRequest]] : send a request that waits for a response, with load balancing\n *  - [[postMessage]] : send a unidirectional message, with load balancing\n *\n * The request queue holds all requests before they are stuffed into the event queue, allows for\n * easy (and early) cancelling of requests. The workers now only get a single new RequestMessage\n * when they return their previous result, or if they are idle. When they are idle, they are stored\n * in m_availableWorkers.\n */\nexport class ConcurrentWorkerSet {\n    private m_workerChannelLogger = LoggerManager.instance.create(\"WorkerChannel\");\n    private readonly m_eventListeners = new Map<string, (message: any) => void>();\n    private m_workers = new Array<Worker>();\n\n    // List of idle workers that can be given the next job. It is using a LIFO scheme to reduce\n    // memory consumption in idle workers.\n    private m_availableWorkers = new Array<Worker>();\n    private m_workerPromises = new Array<Promise<WorkerEntry | undefined>>();\n    private m_workerCount: number | undefined;\n\n    private readonly m_readyPromises = new Map<string, ReadyPromise>();\n    private readonly m_requests: Map<number, RequestEntry> = new Map();\n    private m_workerRequestQueue: WorkerRequestEntry[] = [];\n\n    private m_nextMessageId: number = 0;\n    private m_stopped: boolean = true;\n\n    private m_referenceCount: number = 0;\n\n    /**\n     * Creates a new `ConcurrentWorkerSet`.\n     *\n     * Creates as many Web Workers as specified in `options.workerCount`, from the script provided\n     * in `options.scriptUrl`. If `options.workerCount` is not specified, the value specified in\n     * `navigator.hardwareConcurrency` is used instead.\n     *\n     * The worker set is implicitly started when constructed.\n     */\n    constructor(private m_options: ConcurrentWorkerSetOptions) {\n        this.start();\n    }\n\n    /**\n     * Adds an external reference and increments the internal reference counter by one.\n     *\n     * To implement a reference-count based automatic resource cleanup, use this function with\n     * [[removeReference]].\n     */\n    addReference() {\n        this.m_referenceCount += 1;\n        if (this.m_referenceCount === 1 && this.m_stopped) {\n            this.start();\n        }\n    }\n\n    /**\n     * Decrements the internal reference counter by 1.\n     *\n     * When the internal reference counter reaches 0, this function calls [[dispose]] to clear the\n     * resources.\n     *\n     * Use with [[addReference]] to implement reference-count based automatic resource cleanup.\n     */\n    removeReference() {\n        this.m_referenceCount -= 1;\n        if (this.m_referenceCount === 0) {\n            this.destroy();\n        }\n    }\n\n    /**\n     * Starts workers.\n     *\n     * Use to start workers already stopped by [[stop]] or [[destroy]] calls.\n     *\n     * Note: The worker set is implicitly started on construction - no need to call [[start]] on\n     * fresh instance.\n     *\n     * @param options optional, new worker set options\n     */\n    start(options?: ConcurrentWorkerSetOptions) {\n        if (options !== undefined) {\n            this.m_options = options;\n        }\n        if (!this.m_stopped) {\n            throw new Error(\"ConcurrentWorker set already started\");\n        }\n\n        this.m_workerCount = getOptionValue(\n            this.m_options.workerCount,\n            typeof navigator !== \"undefined\" && navigator.hardwareConcurrency !== undefined\n                ? // We need to have at least one worker\n                  THREE.Math.clamp(navigator.hardwareConcurrency - 1, 1, 2)\n                : undefined,\n            DEFAULT_WORKER_COUNT\n        );\n\n        // Initialize the workers. The workers now have an ID to identify specific workers and\n        // handle their busy state.\n        const timeout = getOptionValue(\n            this.m_options.workerConnectionTimeout,\n            DEFAULT_WORKER_INITIALIZATION_TIMEOUT\n        );\n        for (let workerId = 0; workerId < this.m_workerCount; ++workerId) {\n            const workerPromise = WorkerLoader.startWorker(this.m_options.scriptUrl, timeout).then(\n                worker => {\n                    const listener = (evt: Event): void => {\n                        this.onWorkerMessage(workerId, evt as MessageEvent);\n                    };\n\n                    worker.addEventListener(\"message\", listener);\n                    this.m_workers.push(worker);\n                    this.m_availableWorkers.push(worker);\n                    return {\n                        worker,\n                        listener\n                    };\n                }\n            );\n            this.m_workerPromises.push(workerPromise);\n        }\n        this.m_stopped = false;\n    }\n\n    /**\n     * The number of workers started for this worker set. The value is `undefined` until the workers\n     * have been created.\n     */\n    get workerCount(): number | undefined {\n        return this.m_workerCount;\n    }\n\n    /**\n     * Stops workers.\n     *\n     * Waits for all pending requests to be finished and stops all workers.\n     *\n     * Use [[start]] to start this worker again.\n     *\n     * @returns `Promise` that resolves when all workers are destroyed.\n     */\n    async stop() {\n        this.m_stopped = true;\n\n        await this.waitForAllResponses().then(() => {\n            this.terminateWorkers();\n        });\n    }\n\n    /**\n     * Destroys all workers immediately.\n     *\n     * Resolves all pending request promises with a `worker destroyed` error.\n     *\n     * Use [[start]] to start this worker again.\n     */\n    destroy() {\n        this.m_stopped = true;\n\n        // respond with all pending request\n        this.m_requests.forEach(entry => {\n            entry.resolver(new Error(\"worker destroyed\"));\n        });\n        this.m_requests.clear();\n        this.m_workerRequestQueue = [];\n\n        this.terminateWorkers();\n\n        // clean other stuff\n        this.m_eventListeners.clear();\n    }\n\n    /**\n     * Waits for `service` to be initialized in all workers.\n     *\n     * Each service that starts in a worker sends an [[isInitializedMessage]] to confirm that\n     * it has started successfully. This method resolves when all workers in a set have\n     * `service` initialized.\n     *\n     * Promise is rejected if any of worker fails to start.\n     *\n     * @param serviceId The service identifier.\n     */\n    async connect(serviceId: string): Promise<void> {\n        this.ensureStarted();\n        await Promise.all(this.m_workerPromises);\n        return this.getReadyPromise(serviceId).promise as Promise<void>;\n    }\n\n    /**\n     * Registers an event listener for events that originated in a web worker, for a given\n     * `serviceId`. You can only set one event listener per `serviceId`.\n     *\n     * @param serviceId The service to listen to.\n     * @param callback The callback to invoke for matching events.\n     */\n    addEventListener(serviceId: string, callback: (message: any) => void) {\n        this.m_eventListeners.set(serviceId, callback);\n    }\n\n    /**\n     * Removes a previously set event listener for the given `serviceId`.\n     *\n     * @param serviceId The service from which to remove the event listeners.\n     */\n    removeEventListener(serviceId: string) {\n        this.m_eventListeners.delete(serviceId);\n    }\n\n    /**\n     * Invokes a request that expects a response from a random worker.\n     *\n     * Sends [[RequestMessage]] and resolves when a matching [[ResponseMessage]] is received from\n     * workers. Use this function when interfacing with \"RPC-like\" calls to services.\n     *\n     * @param serviceId The name of service, as registered with the [[WorkerClient]] instance.\n     * @param request The request to process.\n     * @param transferList An optional array of `ArrayBuffer`s to transfer to the worker context.\n     * @param requestController An optional [[RequestController]] to store state of cancelling.\n     *\n     * @returns A `Promise` that resolves with a response from the service.\n     */\n    invokeRequest<Res>(\n        serviceId: string,\n        request: WorkerServiceProtocol.ServiceRequest,\n        transferList?: ArrayBuffer[],\n        requestController?: RequestController\n    ): Promise<Res> {\n        this.ensureStarted();\n\n        const messageId = this.m_nextMessageId++;\n        let resolver: ((error?: any, response?: any) => void) | undefined;\n\n        const promise = new Promise<Res>((resolve, reject) => {\n            resolver = (error?: Error, response?: Res) => {\n                this.m_requests.delete(messageId);\n\n                if (error !== undefined) {\n                    reject(error);\n                } else {\n                    resolve(response as Res);\n                }\n            };\n        });\n        this.m_requests.set(messageId, {\n            promise,\n            resolver: resolver!\n        });\n\n        const message: WorkerServiceProtocol.RequestMessage = {\n            service: serviceId,\n            type: WorkerServiceProtocol.ServiceMessageName.Request,\n            messageId,\n            request\n        };\n        this.postRequestMessage(message, transferList, requestController);\n        return promise;\n    }\n\n    /**\n     * Invokes a request that expects responses from all workers.\n     *\n     * Send [[RequestMessage]]  to all workers and resolves when all workers have sent a matching\n     * [[ResponseMessage]]. Use this function to wait on request that need to happen on all workers\n     * before proceeding (like synchronous worker service creation).\n     *\n     * @param serviceId The name of service, as registered with the [[WorkerClient]] instance.\n     * @param request The request to process.\n     * @param transferList An optional array of `ArrayBuffer`s to transfer to the worker context.\n     *\n     * @returns Array of `Promise`s that resolves with a response from each worker (unspecified\n     * order).\n     */\n    broadcastRequest<Res>(\n        serviceId: string,\n        request:\n            | WorkerServiceProtocol.WorkerServiceManagerRequest\n            | WorkerServiceProtocol.ServiceRequest,\n        transferList?: ArrayBuffer[]\n    ): Promise<Res[]> {\n        this.ensureStarted();\n\n        const promises = [];\n        for (const worker of this.m_workers) {\n            const messageId = this.m_nextMessageId++;\n\n            let resolver: ((error?: any, response?: any) => void) | undefined;\n            const promise = new Promise<Res>((resolve, reject) => {\n                resolver = (error: Error, response: Res) => {\n                    this.m_requests.delete(messageId);\n\n                    if (error !== undefined) {\n                        reject(error);\n                    } else {\n                        resolve(response as Res);\n                    }\n                };\n            });\n            promises.push(promise);\n\n            this.m_requests.set(messageId, {\n                promise,\n                resolver: resolver!\n            });\n\n            const message: WorkerServiceProtocol.RequestMessage = {\n                service: serviceId,\n                type: WorkerServiceProtocol.ServiceMessageName.Request,\n                messageId,\n                request\n            };\n            if (transferList !== undefined) {\n                worker.postMessage(message, transferList);\n            } else {\n                worker.postMessage(message);\n            }\n        }\n\n        return Promise.all(promises);\n    }\n\n    /**\n     * Posts a message to all workers.\n     *\n     * @param message The message to send.\n     * @param buffers Optional buffers to transfer to the workers.\n     */\n    broadcastMessage(message: any, buffers?: ArrayBuffer[] | undefined) {\n        this.ensureStarted();\n\n        if (buffers !== undefined) {\n            this.m_workers.forEach(worker => worker.postMessage(message, buffers));\n        } else {\n            this.m_workers.forEach(worker => worker.postMessage(message));\n        }\n    }\n\n    /**\n     * The size of the request queue for debugging and profiling.\n     */\n    get requestQueueSize() {\n        return this.m_workerRequestQueue.length;\n    }\n\n    /**\n     * The number of workers for debugging and profiling.\n     */\n    get numWorkers() {\n        return this.m_workers.length;\n    }\n\n    /**\n     * The number of workers for debugging and profiling.\n     */\n    get numIdleWorkers() {\n        return this.m_availableWorkers.length;\n    }\n\n    /**\n     * Subclasses must call this function when a worker emits an event.\n     *\n     * @param event The event to dispatch.\n     */\n    protected eventHandler(event: any) {\n        if (typeof event.data.type !== \"string\") {\n            return; // not an event generated by us, ignore.\n        }\n\n        this.dispatchEvent(event.data.type, event);\n    }\n\n    /**\n     * Handles messages received from workers. This method is protected so that the message\n     * reception can be simulated through an extended class, to avoid relying on real workers.\n     *\n     * @param workerId The workerId of the web worker.\n     * @param event The event to dispatch.\n     */\n    private onWorkerMessage = (workerId: number, event: MessageEvent) => {\n        if (WorkerServiceProtocol.isResponseMessage(event.data)) {\n            const response = event.data;\n            if (response.messageId === null) {\n                logger.error(`[${this.m_options.scriptUrl}]: Bad ResponseMessage: no messageId`);\n                return;\n            }\n            const entry = this.m_requests.get(response.messageId);\n            if (entry === undefined) {\n                logger.error(\n                    `[${this.m_options.scriptUrl}]: Bad ResponseMessage: invalid messageId`\n                );\n                return;\n            }\n\n            if (workerId >= 0 && workerId < this.m_workers.length) {\n                const worker = this.m_workers[workerId];\n                this.m_availableWorkers.push(worker);\n                // Check if any new work has been put into the queue.\n                this.checkWorkerRequestQueue();\n            } else {\n                logger.error(`[${this.m_options.scriptUrl}]: onWorkerMessage: invalid workerId`);\n            }\n            if (response.errorMessage !== undefined) {\n                const error = new Error(response.errorMessage);\n                if (response.errorStack !== undefined) {\n                    error.stack = response.errorStack;\n                }\n                entry.resolver(error);\n            } else {\n                entry.resolver(undefined, response.response);\n            }\n        } else if (WorkerServiceProtocol.isInitializedMessage(event.data)) {\n            const readyPromise = this.getReadyPromise(event.data.service);\n            if (++readyPromise.count === this.m_workerPromises.length) {\n                readyPromise.resolve();\n            }\n        } else if (isLoggingMessage(event.data)) {\n            switch (event.data.level) {\n                case LogLevel.Trace:\n                    this.m_workerChannelLogger.trace(...event.data.message);\n                    break;\n                case LogLevel.Debug:\n                    this.m_workerChannelLogger.debug(...event.data.message);\n                    break;\n                case LogLevel.Log:\n                    this.m_workerChannelLogger.log(...event.data.message);\n                    break;\n                case LogLevel.Info:\n                    this.m_workerChannelLogger.info(...event.data.message);\n                    break;\n                case LogLevel.Warn:\n                    this.m_workerChannelLogger.warn(...event.data.message);\n                    break;\n                case LogLevel.Error:\n                    this.m_workerChannelLogger.error(...event.data.message);\n                    break;\n            }\n        } else {\n            this.eventHandler(event);\n        }\n    };\n\n    /**\n     * Posts a [[WorkerServiceProtocol.RequestMessage]] to an available worker. If no worker is\n     * available, the request is put into a queue.\n     *\n     * @param message The message to send.\n     * @param buffers Optional buffers to transfer to the worker.\n     * @param requestController An optional [[RequestController]] to store state of cancelling.\n     */\n    private postRequestMessage(\n        message: WorkerServiceProtocol.RequestMessage,\n        buffers?: ArrayBuffer[] | undefined,\n        requestController?: RequestController\n    ) {\n        this.ensureStarted();\n        if (this.m_workers.length === 0) {\n            throw new Error(\"ConcurrentWorkerSet#postMessage: no workers started\");\n        }\n\n        // Check if the requestController has received the abort signal, in which case the request\n        // is ignored.\n        if (requestController !== undefined && requestController.signal.aborted) {\n            const entry = this.m_requests.get(message.messageId);\n            if (entry === undefined) {\n                logger.error(\n                    `[${this.m_options.scriptUrl}]: Bad RequestMessage: invalid messageId`\n                );\n                return;\n            }\n\n            const err = new Error(\"Aborted\");\n            err.name = \"AbortError\";\n\n            entry.resolver(err, undefined);\n            return;\n        }\n\n        if (this.m_availableWorkers.length > 0) {\n            const worker = this.m_availableWorkers.pop()!;\n\n            if (buffers !== undefined) {\n                worker.postMessage(message, buffers);\n            } else {\n                worker.postMessage(message);\n            }\n        } else {\n            // We need a priority to keep sorting stable, so we have to add a RequestController.\n            if (requestController === undefined) {\n                requestController = new RequestController(0);\n            }\n            if (requestController.priority === 0) {\n                // If the requests do not get a priority, they should keep their sorting order.\n                requestController.priority = -this.m_nextMessageId;\n            }\n            this.m_workerRequestQueue.unshift({\n                message,\n                buffers,\n                requestController\n            });\n        }\n    }\n\n    private ensureStarted() {\n        if (this.m_stopped) {\n            throw new Error(\"ConcurrentWorkerSet stopped\");\n        }\n    }\n\n    private async waitForAllResponses(): Promise<any> {\n        const promises = new Array<Promise<void>>();\n        this.m_requests.forEach(entry => {\n            promises.push(entry.promise);\n        });\n        await Promise.all(promises);\n    }\n\n    private dispatchEvent(id: string, message: any) {\n        const callback = this.m_eventListeners.get(id);\n        if (callback === undefined) {\n            return;\n        } // unknown event, ignore.\n        callback(message);\n    }\n\n    private terminateWorkers() {\n        // terminate all workers\n        this.m_workerPromises.forEach(workerPromise => {\n            workerPromise.then(workerEntry => {\n                if (workerEntry === undefined) {\n                    return;\n                }\n                workerEntry.worker.removeEventListener(\"message\", workerEntry.listener);\n                workerEntry.worker.terminate();\n            });\n        });\n        this.m_workers = [];\n        this.m_workerPromises = [];\n        this.m_availableWorkers = [];\n        this.m_readyPromises.clear();\n    }\n\n    private getReadyPromise(id: string): ReadyPromise {\n        const readyPromise = this.m_readyPromises.get(id);\n        if (readyPromise !== undefined) {\n            return readyPromise;\n        }\n\n        const newPromise: ReadyPromise = {\n            count: 0,\n            promise: undefined,\n            resolve: () => {\n                /* placeholder */\n            },\n            reject: (error: any) => {\n                newPromise.error = error;\n            },\n            error: undefined\n        };\n\n        newPromise.promise = new Promise<void>((resolve, reject) => {\n            const that = newPromise;\n\n            if (that.error !== undefined) {\n                reject(that.error);\n            } else if (that.count === this.m_workerPromises.length) {\n                resolve();\n            }\n\n            that.resolve = resolve;\n            that.reject = reject;\n        });\n\n        this.m_readyPromises.set(id, newPromise);\n        return newPromise;\n    }\n\n    /**\n     * Check the worker request queue, if there are any queued up decoding jobs and idle workers,\n     * they will be executed with postRequestMessage. The requests in the queue are sorted before\n     * the request with the highest priority is selected for processing.\n     */\n    private checkWorkerRequestQueue() {\n        if (this.m_workerRequestQueue.length === 0 || this.m_availableWorkers.length === 0) {\n            return;\n        }\n        this.m_workerRequestQueue.sort((a: WorkerRequestEntry, b: WorkerRequestEntry) => {\n            return a.requestController!.priority - b.requestController!.priority;\n        });\n\n        // Get the request with the highest priority and send it (again).\n        while (this.m_availableWorkers.length > 0 && this.m_workerRequestQueue.length > 0) {\n            const request = this.m_workerRequestQueue.pop()!;\n            this.postRequestMessage(request.message, request.buffers, request.requestController);\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport \"@here/harp-fetch\";\n\nimport { getUrlOrigin, LoggerManager } from \"@here/harp-utils\";\nimport { isWorkerBootstrapRequest, WorkerBootstrapResponse } from \"./WorkerBootstrapDefs\";\n\nconst logger = LoggerManager.instance.create(\"WorkerLoader\");\n\n/**\n * Set of `Worker` loading and initialization helpers:\n *  - starting Worker from URL with fallback to XHR+blob [[WorkerLoader.startWorker]]\n *  - waiting for proper worker initialization, see [[WorkerLoader.waitWorkerInitialized]]\n */\nexport class WorkerLoader {\n    static directlyFallbackToBlobBasedLoading: boolean = false;\n    static sourceLoaderCache = new Map<string, Promise<string>>();\n    static dependencyUrlMapping: { [name: string]: string } = {};\n\n    /**\n     * Starts worker by first attempting load from `scriptUrl` using native `Worker` constructor.\n     * Then waits (using [[waitWorkerInitialized]]) for first message that indicates successful\n     * initialization.\n     * If `scriptUrl`'s origin is different than `baseUrl`, then in case of error falls back to\n     * [[startWorkerBlob]].\n     *\n     * We must resolve/reject promise at some time, so it is expected that any sane application will\n     * be able to load worker code in some amount of time.\n     * By default, this method timeouts after 10 seconds (configurable using `timeout` argument).\n     *\n     * This method is needed as browsers in general forbid to load worker if it's not on 'same\n     * origin' regardless of Content-Security-Policy.\n     *\n     * For blob-based fallback work, one need to ensure that Content Security Policy (CSP) allows\n     * loading web worker code from `Blob`s. By default browsers, allow 'blob:' for workers, but\n     * this may change.\n     *\n     * Following snippet setups CSP, so workers can be started from blob urls:\n     *\n     *     <head>\n     *         <meta http-equiv=\"Content-Security-Policy\" content=\"child-src blob:\">\n     *     </head>\n     *\n     * Tested on:\n     *   * Chrome 67 / Linux, Window, OSX, Android\n     *   * Firefox 60 / Linux, Windows, OSX\n     *   * Edge 41 / Windows\n     *   * Safari 11 / OSX\n     *   * Samsung Internet 7.2\n     *\n     * See\n     *  * https://benohead.com/cross-domain-cross-browser-web-workers/\n     *  * MapBox\n     *    * https://stackoverflow.com/questions/21913673/execute-web-worker-from-different-origin\n     *    * https://github.com/mapbox/mapbox-gl-js/issues/2658\n     *    * https://github.com/mapbox/mapbox-gl-js/issues/559\n     *    * https://github.com/mapbox/mapbox-gl-js/issues/6058\n     *\n     * Findings:\n     *\n     * * Chrome reports CSP by exception when constructing [[Worker]] instance.\n     * * Firefox reports CSP errors when loading in first event:\n     *   https://bugzilla.mozilla.org/show_bug.cgi?id=1241888\n     * * Firefox 62, Chrome 67 obeys `<meta http-equiv=\"Content-Security-Policy\">` with\n     *   `worker-src blob:` but doesn't obey `worker-src URL` when used\n     * * Chrome 67 doesn't obey CSP `worker-src URL` despite it's documented as supported\n     *   (https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Security-Policy/worker-src)\n     *\n     * @param scriptUrl web worker script URL\n     * @param timeout timeout in milliseconds, in which worker should set initial message\n     *    (default 10 seconds)\n     */\n    static startWorker(scriptUrl: string, timeout: number = 10000): Promise<Worker> {\n        if (scriptUrl.startsWith(\"blob:\")) {\n            return this.startWorkerImmediately(scriptUrl, timeout);\n        }\n\n        if (this.directlyFallbackToBlobBasedLoading) {\n            return this.startWorkerBlob(scriptUrl, timeout);\n        }\n        return this.startWorkerImmediately(scriptUrl, timeout).catch(error => {\n            if (typeof window !== \"undefined\") {\n                const pageUrl = window.location.href;\n                const fullScriptUrl = new URL(scriptUrl, pageUrl).href;\n                if (getUrlOrigin(fullScriptUrl) === getUrlOrigin(pageUrl)) {\n                    throw error;\n                }\n                logger.log(\n                    \"#startWorker: cross-origin worker construction failed, trying load with blob\"\n                );\n                this.directlyFallbackToBlobBasedLoading = true;\n                return WorkerLoader.startWorkerBlob(scriptUrl, timeout);\n            } else {\n                throw error;\n            }\n        });\n    }\n\n    /**\n     * Start worker, loading it immediately from `scriptUrl`. Waits (using\n     * [[waitWorkerInitialized]]) for successful worker start.\n     *\n     * @param scriptUrl web worker script URL\n     */\n    static startWorkerImmediately(scriptUrl: string, timeout: number): Promise<Worker> {\n        try {\n            const worker = new Worker(scriptUrl);\n            return this.waitWorkerInitialized(worker, timeout);\n        } catch (error) {\n            return Promise.reject(error);\n        }\n    }\n\n    /**\n     * Start worker \"via blob\" by first loading worker script code with [[fetch]], creating `Blob`\n     * and attempting to start worker from blob url. Waits (using [[waitWorkerInitialized]]) for\n     * successful worker start.\n     *\n     * @param scriptUrl web worker script URL\n     */\n    static startWorkerBlob(scriptUrl: string, timeout: number): Promise<Worker> {\n        return this.fetchScriptSourceToBlobUrl(scriptUrl).then(blobUrl => {\n            return this.startWorkerImmediately(blobUrl, timeout);\n        });\n    }\n\n    /**\n     * Fetch script source as `Blob` url.\n     *\n     * Reuses results, if there are many simultaneous requests.\n     *\n     * @param scriptUrl web worker script URL\n     * @return promise that resolves to url of a `Blob` with script source code\n     */\n    static fetchScriptSourceToBlobUrl(scriptUrl: string): Promise<string> {\n        let loadingPromise = this.sourceLoaderCache.get(scriptUrl);\n        if (loadingPromise !== undefined) {\n            return loadingPromise;\n        }\n        loadingPromise = fetch(scriptUrl)\n            .then(response => response.text())\n            .catch(error => {\n                throw new Error(\n                    `WorkerLoader#fetchScriptSourceToBlob: failed to load worker script: ${error}`\n                );\n            })\n            .then(scriptSource => {\n                this.sourceLoaderCache.delete(scriptUrl);\n                const blob = new Blob([scriptSource], { type: \"application/javascript\" });\n                return URL.createObjectURL(blob);\n            });\n        this.sourceLoaderCache.set(scriptUrl, loadingPromise);\n        return loadingPromise;\n    }\n\n    /**\n     * Waits for successful Web Worker start.\n     *\n     * Expects that worker script sends initial message.\n     *\n     * If first event is `message` then assumes that worker has been loaded sussesfully and promise\n     * resolves to `worker` object passed as argument.\n     *\n     * If first event is 'error', then it is assumed that worker failed to load and promise is\n     * rejected.\n     *\n     * (NOTE: The initial 'message' - if received - is immediately replayed using worker's\n     * `dispatchEvent`, so application code can also consume it as confirmation of successful\n     * worker initialization.\n     *\n     * We must resolve/reject promise at some time, so it is expected that any sane application will\n     * be able to load worker code in some amount of time.\n     *\n     * @param worker [[Worker]] instance to be checked\n     * @param timeout timeout in milliseconds, in which worker should set initial message\n     * @returns `Promise` that resolves to `worker` on success\n     */\n    static waitWorkerInitialized(worker: Worker, timeout: number): Promise<Worker> {\n        return new Promise<Worker>((resolve, reject) => {\n            const firstMessageCallback = (event: MessageEvent) => {\n                const message = event.data;\n                if (isWorkerBootstrapRequest(message)) {\n                    const dependencies = message.dependencies;\n                    const resolvedDependencies: string[] = [];\n                    for (const dependency of dependencies) {\n                        const resolved = this.dependencyUrlMapping[dependency];\n                        if (!resolved) {\n                            cleanup();\n                            reject(\n                                new Error(\n                                    `#waitWorkerInitialized: Unable to resolve '${dependency}'` +\n                                        ` as needed by worker script.`\n                                )\n                            );\n                            return;\n                        }\n                        resolvedDependencies.push(resolved);\n                    }\n                    const response: WorkerBootstrapResponse = {\n                        type: \"worker-bootstrap-response\",\n                        resolvedDependencies\n                    };\n                    worker.postMessage(response);\n                    return;\n                }\n\n                cleanup();\n                resolve(worker);\n\n                // We've just consumed first message from worker before client has any chance to\n                // even call `addEventListener` on it, so here after resolve, we wait next tick and\n                // replay message so user has chance to intercept it in its own handler.\n                setTimeout(() => {\n                    worker.dispatchEvent(event);\n                }, 0);\n            };\n            const errorCallback = (error: ErrorEvent) => {\n                cleanup();\n                // Error events do not carry any useful information on tested browsers, so we assume\n                // that any error before 'firstMessageCallback' as failed Worker initialization.\n                let message = \"Error during worker initialization\";\n                if (error.message) {\n                    message = message + `: ${error.message}`;\n                }\n                if (typeof error.filename === \"string\" && typeof error.lineno === \"number\") {\n                    message = message + ` in ${error.filename}:${error.lineno}`;\n                }\n                reject(new Error(message));\n            };\n            const cleanup = () => {\n                clearTimeout(timerId);\n                worker.removeEventListener(\"message\", firstMessageCallback);\n                worker.removeEventListener(\"error\", errorCallback);\n            };\n\n            worker.addEventListener(\"error\", errorCallback);\n            worker.addEventListener(\"message\", firstMessageCallback);\n            const timerId = setTimeout(() => {\n                cleanup();\n                reject(new Error(\"Timeout exceeded when waiting for first message from worker.\"));\n            }, timeout);\n        });\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {\n    DecodedTile,\n    Definitions,\n    getProjectionName,\n    ITileDecoder,\n    OptionsMap,\n    RequestController,\n    StyleSet,\n    TileInfo,\n    WorkerDecoderProtocol,\n    WorkerServiceProtocol\n} from \"@here/harp-datasource-protocol\";\nimport { Projection, TileKey } from \"@here/harp-geoutils\";\n\nimport { ConcurrentWorkerSet } from \"./ConcurrentWorkerSet\";\n\n/**\n * Identifier of next decoder worker-service. Used to ensure uniqueness of service ids of decoders\n * dedicated to different datasources.\n */\nlet nextUniqueServiceId = 0;\n\n/**\n * Decoder based on [[ConcurrentWorkerSet]].\n *\n * Decodes tiles using workers running in separate contexts (also known as `WebWorkers`):\n * - connection establishment,\n * - sends decode requests,\n * - configuration.\n */\nexport class WorkerBasedDecoder implements ITileDecoder {\n    private serviceId: string;\n    private m_serviceCreated: boolean = false;\n\n    /**\n     * Creates a new `WorkerBasedDecoder`.\n     *\n     * @param workerSet [[ConcurrentWorkerSet]] this tiler will live in.\n     * @param decoderServiceType Service type identifier.\n     */\n    constructor(\n        private readonly workerSet: ConcurrentWorkerSet,\n        private readonly decoderServiceType: string\n    ) {\n        this.workerSet.addReference();\n        this.serviceId = `${this.decoderServiceType}-${nextUniqueServiceId++}`;\n    }\n\n    /**\n     * Dispose of dedicated tile decoder services in workers and remove reference to underlying\n     * [[ConcurrentWorkerSet]].\n     */\n    dispose() {\n        if (this.m_serviceCreated) {\n            this.workerSet\n                .broadcastRequest(WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {\n                    type: WorkerServiceProtocol.Requests.DestroyService,\n                    targetServiceId: this.serviceId\n                })\n                .catch(() => {\n                    /* Ignoring these errors as underlying workers possibly do not exist anymore. */\n                });\n        }\n\n        this.workerSet.removeReference();\n    }\n\n    /**\n     * Connects to [[WorkerServiceManager]]s in underlying [[ConcurrentWorkerSet]] and creates\n     * dedicated [[TileDecoderService]]s in all workers to serve decode requests.\n     */\n    async connect(): Promise<void> {\n        await this.workerSet.connect(WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID);\n        if (!this.m_serviceCreated) {\n            await this.workerSet.broadcastRequest(\n                WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID,\n                {\n                    type: WorkerServiceProtocol.Requests.CreateService,\n                    targetServiceType: this.decoderServiceType,\n                    targetServiceId: this.serviceId\n                }\n            );\n            this.m_serviceCreated = true;\n        }\n    }\n\n    /**\n     * Get [[Tile]] from tile decoder service in worker.\n     *\n     * Invokes [[DecodeTileRequest]] on [[TileDecoderService]] running in worker pool.\n     */\n    decodeTile(\n        data: ArrayBufferLike,\n        tileKey: TileKey,\n        projection: Projection,\n        requestController?: RequestController\n    ): Promise<DecodedTile> {\n        const tileKeyCode = tileKey.mortonCode();\n\n        const message: WorkerDecoderProtocol.DecodeTileRequest = {\n            type: WorkerDecoderProtocol.Requests.DecodeTileRequest,\n            tileKey: tileKeyCode,\n            data,\n            projection: getProjectionName(projection)\n        };\n\n        const transferList = data instanceof ArrayBuffer ? [data] : undefined;\n\n        return this.workerSet.invokeRequest(\n            this.serviceId,\n            message,\n            transferList,\n            requestController\n        );\n    }\n\n    /**\n     * Get [[TileInfo]] from tile decoder service in worker.\n     *\n     * Invokes [[TileInfoRequest]] on [[TileDecoderService]] running in worker pool.\n     */\n    getTileInfo(\n        data: ArrayBufferLike,\n        tileKey: TileKey,\n        projection: Projection,\n        requestController?: RequestController\n    ): Promise<TileInfo | undefined> {\n        const tileKeyCode = tileKey.mortonCode();\n\n        const message: WorkerDecoderProtocol.TileInfoRequest = {\n            type: WorkerDecoderProtocol.Requests.TileInfoRequest,\n            tileKey: tileKeyCode,\n            data,\n            projection: getProjectionName(projection)\n        };\n\n        const transferList = data instanceof ArrayBuffer ? [data] : undefined;\n        return this.workerSet.invokeRequest(\n            this.serviceId,\n            message,\n            transferList,\n            requestController\n        );\n    }\n\n    /**\n     * Configure tile decoder service in workers.\n     *\n     * Broadcasts [[ConfigurationMessage]] to all [[TileDecoderService]]s running in worker pool.\n     *\n     * @param styleSet  new [[StyleSet]], undefined means no change\n     * @param languages new list of languages\n     * @param options   new options, undefined options are not changed\n     */\n    configure(\n        styleSet?: StyleSet,\n        definitions?: Definitions,\n        languages?: string[],\n        options?: OptionsMap\n    ): void {\n        const message: WorkerDecoderProtocol.ConfigurationMessage = {\n            service: this.serviceId,\n            type: WorkerDecoderProtocol.DecoderMessageName.Configuration,\n            styleSet,\n            definitions,\n            options,\n            languages\n        };\n\n        this.workerSet.broadcastMessage(message);\n    }\n\n    /**\n     * The number of workers started for this decoder. The value is `undefined` until the workers\n     * have been created.\n     */\n    get workerCount(): number | undefined {\n        return this.workerSet.workerCount;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { TilingScheme } from \"@here/harp-geoutils\";\nimport { TileKey } from \"@here/harp-geoutils/lib/tiling/TileKey\";\n\n/**\n * Status of the elevation range calculation.\n */\nexport enum CalculationStatus {\n    // Calculated approximately. A more precise result may be available later.\n    PendingApproximate,\n    // Calculation completed. The result is final, won't improve upon retrying.\n    FinalPrecise\n}\n\n/**\n * Elevation range with an optional calculation status.\n */\nexport interface ElevationRange {\n    minElevation: number;\n    maxElevation: number;\n    calculationStatus?: CalculationStatus;\n}\n\n/**\n * Source for elevation ranges per tile. The returned elevation ranges will be used in the visible\n * tile computation to calculate proper bounding boxes.\n */\nexport interface ElevationRangeSource {\n    /**\n     * Compute the elevation range for a given [[TileKey]].\n     * @param tileKey The tile for which the elevation range should be computed.\n     */\n    getElevationRange(tileKey: TileKey): ElevationRange;\n\n    /**\n     * The tiling scheme of this [[ElevationRangeSource]]. [[MapView]] will only apply the elevation\n     * ranges returned by [[getElevationRange]] that have the same [[TilingScheme]].\n     */\n    getTilingScheme(): TilingScheme;\n\n    /**\n     * Connects to the underlying data.\n     */\n    connect(): Promise<void>;\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeometryKind, GeometryKindSet } from \"@here/harp-datasource-protocol\";\nimport { MapView } from \"../MapView\";\nimport { Tile } from \"../Tile\";\nimport { SimpleTileGeometryLoader, TileGeometryLoader } from \"./TileGeometryLoader\";\n\ntype TileUpdateCallback = (tile: Tile) => void;\n\n/**\n * Manages the content (the geometries) of a tile. Derived classes allow different strategies that\n * control the sequence in which the geometries of the tile are being loaded.\n */\nexport interface TileGeometryManager {\n    /**\n     * The set of geometry kinds that is enabled. Their geometry will be created after decoding.\n     */\n    enabledGeometryKinds: GeometryKindSet;\n\n    /**\n     * The set of geometry kinds that is disabled. Their geometry will not be created after\n     * decoding.\n     */\n    disabledGeometryKinds: GeometryKindSet;\n\n    /**\n     * The set of geometry kinds that is hidden. Their geometry may be created, but it is hidden\n     * until the method `hideKind` with an argument of `addOrRemoveToHiddenSet:false` is called.\n     */\n    hiddenGeometryKinds: GeometryKindSet;\n\n    /**\n     * If set to `true`, the filters of enabled/disabledGeometryKinds are applied, otherwise they\n     * are ignored.\n     */\n    enableFilterByKind: boolean;\n\n    /**\n     * Initialize the [[Tile]] with the TileGeometryManager.\n     */\n    initTile(tile: Tile): void;\n\n    /**\n     * Process the [[Tile]]s for rendering. May alter the content of the tile per frame.\n     */\n    updateTiles(tiles: Tile[]): void;\n\n    /**\n     * Clear the enabled, disabled and hidden sets.\n     */\n    clear(): void;\n\n    /**\n     * Enable a [[GeometryKind]] by adding it to the enabled set, or remove it from that set.\n     *\n     * @param {(GeometryKind | GeometryKind[] | GeometryKindSet)} kind The kind to add or remove\n     *      from the enabled set.\n     * @param {boolean} addOrRemoveToEnabledSet Pass in `true` to add the kind to the set, pass in\n     *      `false` to remove from that set.\n     */\n    enableKind(\n        kind: GeometryKind | GeometryKind[] | GeometryKindSet,\n        addOrRemoveToEnabledSet: boolean\n    ): void;\n\n    /**\n     * Disable a [[GeometryKind]] by adding it to the disabled set, or remove it from that set.\n     *\n     * @param {(GeometryKind | GeometryKind[] | GeometryKindSet)} kind The kind to add or remove\n     *      from the disabled set.\n     * @param {boolean} addOrRemoveToHiddenSet Pass in `true` to add the kind to the set, pass in\n     *      `false` to remove from that set.\n     */\n    disableKind(\n        kind: GeometryKind | GeometryKind[] | GeometryKindSet,\n        addOrRemoveToDisabledSet: boolean\n    ): void;\n\n    /**\n     * Hide a [[GeometryKind]] by adding it to the hidden set, or remove it from that set.\n     *\n     * @param {(GeometryKind | GeometryKind[] | GeometryKindSet)} kind The kind to add or remove\n     *      from the hidden set.\n     * @param {boolean} addOrRemoveToHiddenSet Pass in `true` to hide the kind(s), `false` to show\n     *      it again.\n     */\n    hideKind(\n        kind: GeometryKind | GeometryKind[] | GeometryKindSet,\n        addOrRemoveToHiddenSet: boolean\n    ): void;\n\n    /**\n     * Return all [[GeometryKind]]s that are contained in the tiles.\n     *\n     * @param {IterableIterator<Tile>} tiles The\n     * @returns {GeometryKindSet}\n     */\n    getAvailableKinds(tiles: IterableIterator<Tile>): GeometryKindSet;\n\n    /**\n     * Sets a callback that will be called for every updated tile on [[updateTiles]].\n     *\n     * @param {TileUpdateCallback} callback The callback that will be called after a tile has been\n     * updated, passing the updated tile as argument. If `undefined`, a previously set callback will\n     * be cleared.\n     */\n    setTileUpdateCallback(callback?: TileUpdateCallback): void;\n}\n\n/**\n * Base class for all [[TileGeometryManager]]s. Handles visibility as well as enabling/disabling of\n * kinds of geometry [[GeometryKind]].\n */\nexport abstract class TileGeometryManagerBase implements TileGeometryManager {\n    get enabledGeometryKinds(): GeometryKindSet {\n        return this.enabledKinds;\n    }\n\n    set enabledGeometryKinds(kinds: GeometryKindSet) {\n        this.enabledKinds = kinds;\n    }\n\n    get disabledGeometryKinds(): GeometryKindSet {\n        return this.disabledKinds;\n    }\n\n    set disabledGeometryKinds(kinds: GeometryKindSet) {\n        this.disabledKinds = kinds;\n    }\n\n    get hiddenGeometryKinds(): GeometryKindSet {\n        return this.hiddenKinds;\n    }\n\n    set hiddenGeometryKinds(kinds: GeometryKindSet) {\n        this.hiddenKinds = kinds;\n        this.incrementVisibilityCounter();\n    }\n\n    protected get visibilityCounter(): number {\n        return this.m_visibilityCounter;\n    }\n\n    enableFilterByKind: boolean = true;\n\n    protected enabledKinds: GeometryKindSet = new GeometryKindSet();\n    protected disabledKinds: GeometryKindSet = new GeometryKindSet();\n    protected hiddenKinds: GeometryKindSet = new GeometryKindSet();\n\n    protected m_tileUpdateCallback: TileUpdateCallback | undefined;\n\n    /**\n     * Optimization for evaluation in `update()` method. Only if a kind is hidden/unhidden, the\n     * visibility of the kinds is applied to their geometries.\n     */\n    private m_visibilityCounter: number = 1;\n\n    /**\n     * Creates an instance of `TileGeometryManagerBase` with a reference to the [[MapView]].\n     */\n    constructor(protected mapView: MapView) {}\n\n    abstract initTile(tile: Tile): void;\n\n    abstract updateTiles(tiles: Tile[]): void;\n\n    clear(): void {\n        this.enabledKinds.clear();\n        this.disabledKinds.clear();\n        this.hiddenKinds.clear();\n    }\n\n    enableKind(\n        kind: GeometryKind | GeometryKind[] | GeometryKindSet,\n        addOrRemoveToEnabledSet: boolean = true\n    ): void {\n        this.enableDisableKinds(this.enabledKinds, kind, addOrRemoveToEnabledSet);\n    }\n\n    disableKind(\n        kind: GeometryKind | GeometryKind[] | GeometryKindSet,\n        addOrRemoveToDisabledSet: boolean = true\n    ): void {\n        this.enableDisableKinds(this.disabledKinds, kind, addOrRemoveToDisabledSet);\n    }\n\n    hideKind(\n        kind: GeometryKind | GeometryKind[] | GeometryKindSet,\n        addOrRemoveToHiddenSet: boolean = true\n    ): void {\n        let visibilityHasChanged = false;\n        if (Array.isArray(kind)) {\n            for (const oneKind of kind as GeometryKind[]) {\n                visibilityHasChanged =\n                    visibilityHasChanged ||\n                    this.addRemove(this.hiddenKinds, oneKind, addOrRemoveToHiddenSet);\n            }\n        } else if (kind instanceof Set) {\n            const kindSet = kind as GeometryKindSet;\n            for (const oneKind of kindSet) {\n                visibilityHasChanged =\n                    visibilityHasChanged ||\n                    this.addRemove(this.hiddenKinds, oneKind, addOrRemoveToHiddenSet);\n            }\n        } else if (kind !== undefined) {\n            visibilityHasChanged =\n                visibilityHasChanged ||\n                this.addRemove(this.hiddenKinds, kind, addOrRemoveToHiddenSet);\n        }\n\n        // Will be evaluated in the next update()\n        if (visibilityHasChanged) {\n            this.incrementVisibilityCounter();\n        }\n    }\n\n    getAvailableKinds(tiles: IterableIterator<Tile>): GeometryKindSet {\n        const visibleKinds: GeometryKindSet = new GeometryKindSet();\n        for (const tile of tiles) {\n            const geometryLoader = tile.tileGeometryLoader as TileGeometryLoader;\n            if (geometryLoader !== undefined) {\n                const tileKinds = geometryLoader.availableGeometryKinds;\n                if (tileKinds !== undefined) {\n                    for (const kind of tileKinds) {\n                        visibleKinds.add(kind);\n                    }\n                }\n            }\n        }\n        return visibleKinds;\n    }\n\n    /**\n     * Apply the visibility status taken from the `hiddenKinds` to all geometries in the specified\n     * tiles.\n     *\n     * @param {Tile[]} tiles List of [[Tiles]] to process the visibility status of.\n     */\n    updateTileObjectVisibility(tiles: Tile[]): boolean {\n        let needUpdate = false;\n\n        for (const tile of tiles) {\n            if (tile.objects.length === 0 || tile.visibilityCounter === this.visibilityCounter) {\n                continue;\n            }\n            tile.visibilityCounter = this.visibilityCounter;\n\n            for (const object of tile.objects) {\n                const geometryKind: GeometryKind[] | undefined =\n                    object.userData !== undefined ? object.userData.kind : undefined;\n                if (geometryKind !== undefined) {\n                    const nowVisible = !geometryKind.some(kind => this.hiddenKinds.has(kind));\n                    needUpdate = needUpdate || object.visible !== nowVisible;\n                    object.visible = nowVisible;\n                }\n            }\n        }\n        return needUpdate;\n    }\n\n    setTileUpdateCallback(callback?: TileUpdateCallback): void {\n        this.m_tileUpdateCallback = callback;\n    }\n\n    protected incrementVisibilityCounter(): number {\n        return ++this.m_visibilityCounter;\n    }\n\n    /**\n     * Add or remove a kind|array of kinds|set of kinds from the specified kind set.\n     *\n     * @hidden\n     * @param {GeometryKindSet} set\n     * @param {(GeometryKind | GeometryKind[] | GeometryKindSet)} kind\n     * @param {boolean} addToSet\n     */\n    private enableDisableKinds(\n        set: GeometryKindSet,\n        kind: GeometryKind | GeometryKind[] | GeometryKindSet,\n        addToSet: boolean\n    ): void {\n        if (Array.isArray(kind)) {\n            for (const oneKind of kind as GeometryKind[]) {\n                this.addRemove(set, oneKind, addToSet);\n            }\n        } else if (kind instanceof Set) {\n            const kindSet = kind as GeometryKindSet;\n            for (const oneKind of kindSet) {\n                this.addRemove(set, oneKind, addToSet);\n            }\n        } else if (kind !== undefined) {\n            this.addRemove(set, kind, addToSet);\n        }\n    }\n\n    /**\n     * Add or remove a single kind from the specified kind set.\n     *\n     * @hidden\n     * @param {GeometryKindSet} set\n     * @param {(GeometryKind | GeometryKind[] | GeometryKindSet)} kind\n     * @param {boolean} addToSet\n     */\n    private addRemove(kindsSet: GeometryKindSet, kind: GeometryKind, addToSet: boolean): boolean {\n        if (addToSet) {\n            if (!kindsSet.has(kind)) {\n                kindsSet.add(kind);\n                return true;\n            }\n        } else {\n            if (kindsSet.has(kind)) {\n                kindsSet.delete(kind);\n                return true;\n            }\n        }\n        return false;\n    }\n}\n/**\n * Implements the simplest for of [[TileGeometryManager]]. Uses a [[SimpleTileGeometryLoader]] to\n * load the geometries of the [[Tile]].\n */\nexport class SimpleTileGeometryManager extends TileGeometryManagerBase {\n    /**\n     * Creates an instance of `SimpleTileGeometryManager` with a reference to the [[MapView]].\n     */\n    constructor(mapView: MapView) {\n        super(mapView);\n    }\n\n    initTile(tile: Tile): void {\n        if (tile.dataSource.useGeometryLoader) {\n            tile.tileGeometryLoader = new SimpleTileGeometryLoader(tile);\n        }\n    }\n\n    updateTiles(tiles: Tile[]): void {\n        for (const tile of tiles) {\n            const geometryLoader = tile.tileGeometryLoader as TileGeometryLoader;\n            if (geometryLoader !== undefined) {\n                geometryLoader.update(\n                    this.enableFilterByKind ? this.enabledGeometryKinds : undefined,\n                    this.enableFilterByKind ? this.disabledGeometryKinds : undefined\n                );\n                if (this.m_tileUpdateCallback) {\n                    this.m_tileUpdateCallback(tile);\n                }\n            }\n        }\n\n        // If the visibility status of the kinds changed since the last update, the new visibility\n        // status is applied (again).\n        if (this.updateTileObjectVisibility(tiles)) {\n            this.mapView.update();\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { MapView } from \"../MapView\";\nimport { ImageItem } from \"./Image\";\nimport { ImageCache } from \"./ImageCache\";\n\n/**\n * Cache images wrapped into [[ImageItem]]s for a [[MapView]]. An image may have multiple names in\n * a theme, the `MapViewImageCache` will take care of that. Registering multiple images with the\n * same name is invalid.\n *\n * The `MapViewImageCache` uses a global [[ImageCache]] to actually store (and generate) the\n * image data.\n */\nexport class MapViewImageCache {\n    private m_name2Url: Map<string, string> = new Map();\n    private m_url2Name: Map<string, string[]> = new Map();\n\n    /**\n     * The constructor for `MapViewImageCache`.\n     *\n     * @param mapView a [[MapView]] instance.\n     */\n    constructor(public mapView: MapView) {}\n\n    /**\n     * Register an existing image by name.\n     *\n     * @param name Name of the image from [[Theme]].\n     * @param url URL of image.\n     * @param image Optional [[ImageData]] of image.\n     */\n    registerImage(\n        name: string | undefined,\n        url: string,\n        image: ImageData | ImageBitmap | undefined\n    ): ImageItem {\n        if (name !== undefined) {\n            if (this.hasName(name)) {\n                throw new Error(\"duplicate name in cache\");\n            }\n\n            const oldNames = this.m_url2Name.get(url);\n            if (oldNames !== undefined) {\n                if (oldNames.indexOf(name) < 0) {\n                    oldNames.push(name);\n                }\n            } else {\n                this.m_url2Name.set(url, [name]);\n            }\n            this.m_name2Url.set(name, url);\n        }\n\n        const imageItem = ImageCache.instance.findImage(url);\n        if (imageItem === undefined) {\n            return ImageCache.instance.registerImage(this.mapView, url, image);\n        }\n        return imageItem;\n    }\n\n    /**\n     * Add an image and optionally start loading it. Once done, the [[ImageData]] or [[ImageBitmap]]\n     * will be stored in the [[ImageItem]].\n     *\n     * @param name Name of image from [[Theme]].\n     * @param url URL of image.\n     * @param startLoading Optional. Pass `true` to start loading the image in the background.\n     */\n    addImage(\n        name: string,\n        url: string,\n        startLoading = true\n    ): ImageItem | Promise<ImageItem | undefined> {\n        const imageItem = this.registerImage(name, url, undefined);\n        if (startLoading === true) {\n            return ImageCache.instance.loadImage(imageItem);\n        }\n\n        return imageItem;\n    }\n\n    /**\n     * Find [[ImageItem]] by its name.\n     *\n     * @param name Name of image.\n     */\n    findImageByName(name: string): ImageItem | undefined {\n        const url = this.m_name2Url.get(name);\n        if (url === undefined) {\n            return undefined;\n        }\n        return ImageCache.instance.findImage(url);\n    }\n\n    /**\n     * Find [[ImageItem]] by URL.\n     *\n     * @param url Url of image.\n     */\n    findImageByUrl(url: string): ImageItem | undefined {\n        return ImageCache.instance.findImage(url);\n    }\n\n    /**\n     * Load an [[ImageItem]]. Returns a promise or a loaded [[ImageItem]].\n     *\n     * @param imageItem ImageItem to load.\n     */\n    loadImage(imageItem: ImageItem): ImageItem | Promise<ImageItem | undefined> {\n        return ImageCache.instance.loadImage(imageItem);\n    }\n\n    /**\n     * Remove all [[ImageItem]]s from the cache. Also removes all [[ImageItem]]s that belong to this\n     * [[MapView]] from the global [[ImageCache]].\n     */\n    clear() {\n        ImageCache.instance.clear(this.mapView);\n        this.m_name2Url = new Map();\n        this.m_url2Name = new Map();\n    }\n\n    /**\n     * Returns number of image names stored in the cache.\n     */\n    get numberOfNames(): number {\n        return this.m_name2Url.size;\n    }\n\n    /**\n     * Returns number of image URLs in the cache.\n     */\n    get numberOfUrls(): number {\n        return this.m_url2Name.size;\n    }\n\n    /**\n     * Return `true` if an image with the given name is known.\n     *\n     * @param name Name of the image.\n     */\n    hasName(name: string): boolean {\n        return this.m_name2Url.get(name) !== undefined;\n    }\n\n    /**\n     * Return `true` if an image with the given URL is known.\n     * @param url URL of image.\n     */\n    hasUrl(url: string): boolean {\n        return this.m_url2Name.get(url) !== undefined;\n    }\n\n    /**\n     * Return the names under which an image with the given URL is saved.\n     */\n    findNames(url: string): string[] | undefined {\n        return this.m_url2Name.get(url);\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { LoggerManager } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { MapView } from \"../MapView\";\nimport { ImageItem } from \"./Image\";\n\nconst logger = LoggerManager.instance.create(\"ImageCache\");\n\n// override declaration of createImageBitmap, add optional options parameter that\n// was removed in typings for TypeScript 3.1\ndeclare function createImageBitmap(\n    image: ImageBitmapSource,\n    sx: number,\n    sy: number,\n    sw: number,\n    sh: number,\n    options?: any\n): Promise<ImageBitmap>;\n\n/**\n * Combines an [[ImageItem]] with a list of [[MapViews]] that reference it.\n */\nclass ImageCacheItem {\n    /**\n     * The list of [[MapView]]s referencing the [[ImageItem]].\n     */\n    mapViews: MapView[] = [];\n\n    /**\n     * Instantiates `ImageCacheItem`.\n     *\n     * @param imageItem The [[ImageItem]] referenced by the associated [[MapView]]s instances.\n     * @param mapView An optional first [[MapView]] referencing the [[ImageItem]].\n     */\n    constructor(public imageItem: ImageItem, mapView?: MapView) {\n        if (mapView !== undefined) {\n            this.mapViews.push(mapView);\n        }\n    }\n}\n\n/**\n * `ImageCache` is a singleton, so it can be used with multiple MapViews on a single page. This\n * allows to have an image loaded only once for multiple views. THREE is doing something similar,\n * but does not allow to share images that have been loaded from a canvas (which we may need to do\n * if we use SVG images for textures).\n *\n * One application that makes our own cache necessary is the generation of our own textures from\n * data that is not an URL.\n *\n * The `ImageCache` can be improved by adding satistics for memory footprint as well.\n */\nexport class ImageCache {\n    /**\n     * Returns the singleton `instance` of the `ImageCache`.\n     */\n    static get instance(): ImageCache {\n        if (ImageCache.m_instance === undefined) {\n            ImageCache.m_instance = new ImageCache();\n        }\n        return ImageCache.m_instance;\n    }\n\n    /**\n     * Dispose the singleton object. Not normally implemented for singletons, but good for\n     * debugging.\n     */\n    static dispose(): void {\n        ImageCache.m_instance = undefined;\n    }\n\n    private static m_instance: ImageCache | undefined;\n\n    private m_images: Map<string, ImageCacheItem> = new Map();\n\n    /**\n     * Add an image definition to the global cache. Useful when the image data is already loaded.\n     *\n     * @param mapView Specifiy which [[MapView]] requests the image.\n     * @param url URL of image.\n     * @param imageData Optional [ImageData]] containing the image content.\n     */\n    registerImage(\n        mapView: MapView,\n        url: string,\n        imageData: ImageData | ImageBitmap | undefined\n    ): ImageItem {\n        let imageCacheItem = this.findImageCacheItem(url);\n        if (imageCacheItem !== undefined) {\n            if (mapView !== undefined && imageCacheItem.mapViews.indexOf(mapView) < 0) {\n                imageCacheItem.mapViews.push(mapView);\n            }\n            return imageCacheItem.imageItem;\n        }\n\n        imageCacheItem = this.findImageCacheItem(url);\n        if (imageCacheItem !== undefined) {\n            if (mapView !== undefined && imageCacheItem.mapViews.indexOf(mapView) < 0) {\n                imageCacheItem.mapViews.push(mapView);\n            }\n            return imageCacheItem.imageItem;\n        }\n\n        const mapViews: MapView[] = [];\n        if (mapView !== undefined) {\n            mapViews.push(mapView);\n        }\n\n        imageCacheItem = {\n            imageItem: {\n                url,\n                imageData,\n                loaded: false\n            },\n            mapViews\n        };\n\n        this.m_images.set(url, imageCacheItem);\n\n        return imageCacheItem.imageItem;\n    }\n\n    /**\n     * Add an image definition, and optionally start loading the content.\n     *\n     * @param mapView [[MapView]] requesting the image.\n     * @param url URL of image.\n     * @param startLoading Optional flag. If `true` the image will be loaded in the background.\n     */\n    addImage(\n        mapView: MapView,\n        url: string,\n        startLoading = true\n    ): ImageItem | Promise<ImageItem | undefined> | undefined {\n        const imageItem = this.registerImage(mapView, url, undefined);\n        if (imageItem !== undefined && startLoading === true) {\n            return this.loadImage(imageItem);\n        }\n\n        return imageItem;\n    }\n\n    /**\n     * Find [[ImageItem]] for the specified URL.\n     *\n     * @param url URL of image.\n     * @returns `ImageItem` for the URL if the URL is registered, `undefined` otherwise.\n     */\n    findImage(url: string): ImageItem | undefined {\n        const imageItem = this.m_images.get(url);\n        if (imageItem !== undefined) {\n            return imageItem.imageItem;\n        }\n        return undefined;\n    }\n\n    /**\n     * Clear all [[ImageItem]]s belonging to a [[MapView]]. May remove cached items if no\n     * [[MapView]] are registered anymore.\n     *\n     * @param mapView MapView to remove all [[ImageItem]]s from.\n     */\n    clear(mapView: MapView) {\n        const itemsToRemove: string[] = [];\n\n        this.m_images.forEach(imageItem => {\n            const mapViewIndex = imageItem.mapViews.indexOf(mapView);\n            if (mapViewIndex >= 0) {\n                imageItem.mapViews.splice(mapViewIndex, 1);\n            }\n            if (imageItem.mapViews.length === 0) {\n                itemsToRemove.push(imageItem.imageItem.url);\n            }\n        });\n\n        for (const keyToDelete of itemsToRemove) {\n            this.m_images.delete(keyToDelete);\n        }\n    }\n\n    /**\n     * Clear all [[ImageItem]]s from all [[MapView]]s.\n     */\n    clearAll() {\n        this.m_images = new Map();\n    }\n\n    /**\n     * Returns the number of all cached [[ImageItem]]s.\n     */\n    get size(): number {\n        return this.m_images.size;\n    }\n\n    /**\n     * Load an [[ImageItem]]. If the loading process is already running, it returns the current\n     * promise.\n     *\n     * @param imageItem `ImageItem` containing the URL to load image from.\n     * @returns An [[ImageItem]] if the image has already been loaded, a promise otherwise.\n     */\n    loadImage(imageItem: ImageItem): ImageItem | Promise<ImageItem | undefined> {\n        if (imageItem.imageData !== undefined) {\n            return imageItem;\n        }\n\n        if (imageItem.loadingPromise !== undefined) {\n            return imageItem.loadingPromise;\n        }\n\n        const imageLoader = new THREE.ImageLoader();\n\n        imageItem.loadingPromise = new Promise(resolve => {\n            logger.debug(`Loading image: ${imageItem.url}`);\n            imageLoader.load(\n                imageItem.url,\n                image => {\n                    logger.debug(`... finished loading image: ${imageItem.url}`);\n                    this.renderImage(imageItem, image)\n                        .then(() => {\n                            imageItem.loadingPromise = undefined;\n                            resolve(imageItem);\n                        })\n                        .catch(ex => {\n                            logger.error(`... loading image failed: ${imageItem.url} : ${ex}`);\n                            resolve(undefined);\n                        });\n                },\n                // Loading events no longer supported\n                undefined,\n                errorEvent => {\n                    logger.error(`... loading image failed: ${imageItem.url} : ${errorEvent}`);\n\n                    imageItem.loadingPromise = undefined;\n                    resolve(undefined);\n                }\n            );\n        });\n        return imageItem.loadingPromise;\n    }\n\n    /**\n     * Find the cached [[ImageItem]] by URL.\n     *\n     * @param url URL of image.\n     */\n    private findImageCacheItem(url: string): ImageCacheItem | undefined {\n        return this.m_images.get(url);\n    }\n\n    /**\n     * Render the `ImageItem` by using `createImageBitmap()` or by rendering the image into a\n     * [[HTMLCanvasElement]].\n     *\n     * @param imageItem [[ImageItem]] to assign image data to.\n     * @param image [[HTMLImageElement]] to\n     */\n    private renderImage(\n        imageItem: ImageItem,\n        image: HTMLImageElement\n    ): Promise<ImageData | ImageBitmap | undefined> {\n        return new Promise((resolve, reject) => {\n            // use createImageBitmap if it is available. It should be available in webworkers as\n            // well\n            if (typeof createImageBitmap === \"function\") {\n                const options: ImageBitmapOptions = {\n                    premultiplyAlpha: \"default\",\n                    imageOrientation: \"flipY\"\n                };\n\n                logger.debug(`Creating bitmap image: ${imageItem.url}`);\n                createImageBitmap(image, 0, 0, image.width, image.height, options)\n                    .then(imageBitmap => {\n                        logger.debug(`... finished creating bitmap image: ${imageItem.url}`);\n\n                        imageItem.loadingPromise = undefined;\n                        imageItem.imageData = imageBitmap;\n                        imageItem.loaded = true;\n                        resolve(imageBitmap);\n                    })\n                    .catch(ex => {\n                        logger.error(`... loading image failed: ${imageItem.url} : ${ex}`);\n                        resolve(undefined);\n                    });\n            } else {\n                try {\n                    if (typeof document === \"undefined\") {\n                        logger.error(\"Error: document is not available, cannot generate image\");\n                        reject(\n                            new Error(\n                                \"ImageCache#renderImage: document is not available, cannot \" +\n                                    \"render image to create texture\"\n                            )\n                        );\n                    }\n\n                    // TODO: Extract the rendering to the canvas part and make it configurable for\n                    // the client, so it does not rely on the `document`.\n\n                    // use the image, e.g. draw part of it on a canvas\n                    const canvas = document.createElement(\"canvas\");\n                    canvas.width = image.width;\n                    canvas.height = image.height;\n\n                    const context = canvas.getContext(\"2d\");\n                    if (context !== null) {\n                        logger.debug(\n                            // tslint:disable-next-line: max-line-length\n                            `... finished creating bitmap image in canvas: ${imageItem.url} ${image}`\n                        );\n                        context.drawImage(\n                            image,\n                            0,\n                            0,\n                            image.width,\n                            image.height,\n                            0,\n                            0,\n                            canvas.width,\n                            canvas.height\n                        );\n                        const imageData = context.getImageData(0, 0, image.width, image.height);\n                        imageItem.imageData = imageData;\n                        imageItem.loaded = true;\n                        resolve(imageData);\n                    } else {\n                        logger.error(`renderImage: no context found`);\n                        reject(new Error(`ImageCache#renderImage: no context found`));\n                    }\n                } catch (ex) {\n                    logger.error(`renderImage failed: ${ex}`);\n                    imageItem.imageData = undefined;\n                    imageItem.loaded = true;\n                    reject(new Error(`ImageCache#renderImage failed: ${ex}`));\n                }\n            }\n        });\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Theme } from \"@here/harp-datasource-protocol\";\nimport { SolidLineMaterial } from \"@here/harp-materials\";\nimport { assert, MathUtils } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\nimport { MapView } from \"./MapView\";\nimport { MapViewUtils } from \"./Utils\";\n\n/**\n * Manages the fog display in [[MapView]].\n */\nexport class MapViewFog {\n    private m_enabled: boolean = true;\n    private m_fog: THREE.Fog = new THREE.Fog(0x000000); // Default color asked by DefinitelyTyped.\n    private m_fogIsDefined: boolean = false;\n    private m_cachedTheme: Theme = { styles: {} };\n\n    /**\n     * Constructs a `MapViewFog` instance.\n     *\n     * @param m_scene The scene used in [[MapView]] that contains the map objects.\n     */\n    constructor(private m_scene: THREE.Scene) {}\n\n    /**\n     * Allows for disabling the fog, even if it is defined in the theme. Use this property for\n     * custom views like the demo app's debug camera. However, if the theme does not define a\n     * fog, enabling this property here has no effect.\n     *\n     * @param value A boolean that specifies whether the fog should be enabled or disabled.\n     */\n    set enabled(enableFog: boolean) {\n        this.m_enabled = enableFog;\n        if (enableFog && this.m_fogIsDefined && this.m_scene.fog === null) {\n            this.add();\n        } else if (!enableFog && this.m_scene.fog !== null) {\n            this.remove();\n        }\n    }\n\n    /**\n     * Returns the current fog status, enabled or disabled.\n     */\n    get enabled(): boolean {\n        return this.m_enabled;\n    }\n\n    /**\n     * Sets the fog depending on the [[Theme]] instance provided. This function is called when a\n     * theme is loaded. Fog is added only if the theme contains a fog definition with a:\n     * - `color` property, used to set the fog color.\n     * - `startRatio` property, used to set the start distance of the fog as a ratio of the far\n     * clipping plane distance.\n     *\n     * @param theme A [[Theme]] instance.\n     */\n    reset(theme: Theme) {\n        this.m_cachedTheme = theme;\n        if (\n            theme !== undefined &&\n            theme.fog !== undefined &&\n            theme.fog.color !== undefined &&\n            theme.fog.startRatio !== undefined\n        ) {\n            this.m_fogIsDefined = true;\n            this.m_fog.color.set(theme.fog.color);\n            if (this.m_enabled && this.m_scene.fog === null) {\n                this.add();\n            }\n        } else {\n            this.m_fogIsDefined = false;\n            if (this.m_scene.fog !== null) {\n                this.remove();\n            }\n        }\n    }\n\n    /**\n     * Updates the fog at runtime, depending on the camera.\n     *\n     * @param camera An instance of a `THREE.Camera` with a `far` property.\n     */\n    update(mapView: MapView, viewDistance?: number) {\n        if (\n            this.m_scene.fog !== null &&\n            this.m_cachedTheme !== undefined &&\n            this.m_cachedTheme.fog &&\n            this.m_cachedTheme.fog.startRatio !== undefined &&\n            (mapView.camera.far !== undefined || viewDistance !== undefined)\n        ) {\n            // If maximum visibility range is available use it instead of camera.far distance,\n            // this makes fog independent from dynamic camera planes and keeps consistent\n            // distance based \"melting\" (fog) effect during a tilt.\n            const viewRange = viewDistance !== undefined ? viewDistance : mapView.camera.far;\n            // TODO: We may move below constants to theme Fog definition\n            // Density of the fog when viewing straight along the horizon line.\n            const horizontalDensity = 1.0;\n            // Theoretical density of the fog when viewing straight from top to down.\n            const verticalDensity = 0.0;\n            // The fraction of the maximum viewing distance along the eye vector\n            // to start applying the fog.\n            const startRatio = this.m_cachedTheme.fog.startRatio;\n            // The fraction of maximum viewing range at which fog fully covers geometry.\n            const endRatio = 1.0;\n            assert(startRatio <= endRatio);\n            const target = MapViewUtils.rayCastWorldCoordinates(mapView, 0, 0);\n            if (target === null) {\n                throw new Error(\"MapView does not support a view pointing in the void.\");\n            }\n            const t = Math.abs(\n                Math.cos(\n                    MapViewUtils.extractSphericalCoordinatesFromLocation(\n                        mapView,\n                        mapView.camera,\n                        mapView.projection.unprojectPoint(target)\n                    ).tilt\n                )\n            );\n            const density = MathUtils.smoothStep(horizontalDensity, verticalDensity, t);\n            this.m_fog.near = MathUtils.lerp(viewRange * startRatio, viewRange, 1.0 - density);\n            this.m_fog.far = MathUtils.lerp(viewRange * endRatio, viewRange, density);\n            this.m_fog.near = Math.min(this.m_fog.near, mapView.camera.far);\n            this.m_fog.far = Math.min(this.m_fog.far, mapView.camera.far);\n        }\n    }\n\n    /**\n     * Handles fog addition.\n     */\n    private add() {\n        // When the fog is changed, ThreeJS takes care of recompiling its built-in materials...\n        this.m_scene.fog = this.m_fog;\n        // ...except the `RawShaderMaterial`, on purpose, so it needs to be updated from the app.\n        this.setFogInRawShaderMaterials(true);\n    }\n\n    /**\n     * Handles fog removal.\n     */\n    private remove() {\n        // When the fog is changed, ThreeJS takes care of recompiling its built-in materials...\n        this.m_scene.fog = null;\n        // ...except the `RawShaderMaterial`, on purpose, so it needs to be updated from the app.\n        this.setFogInRawShaderMaterials(false);\n    }\n\n    /**\n     * ThreeJS lets users manage the `RawShaderMaterial` themselves, so they need to be modified\n     * explicitly.\n     *\n     * @see https://github.com/mrdoob/three.js/blob/dev/src/renderers/webgl/WebGLProgram.js#L298\n     */\n    private setFogInRawShaderMaterials(enableFog: boolean) {\n        this.m_scene.traverse(object => {\n            if (!(object instanceof THREE.Mesh)) {\n                return;\n            }\n            if (!(object.material instanceof THREE.Material)) {\n                return;\n            }\n            // HighPrecisionLineMaterial does not support fog\n            //if (object.material instanceof HighPrecisionLineMaterial) {\n                //return;\n            //}\n            // Redundant updates (enable twice) are already checked in higher level functions.\n            if (object.material instanceof SolidLineMaterial) {\n                object.material.updateFog(enableFog);\n            }\n            // We can skip `object.material.fog === enableFog` only after applying custom material\n            // settings (by default fog is set) so the first load may be faster.\n            if (object.material.fog === enableFog) {\n                return;\n            }\n            object.material.fog = enableFog;\n            // Fog properties can't be easily changed at runtime (once the material\n            // is rendered at least once) and thus requires building of new shader\n            // program - force material update.\n            object.material.needsUpdate = true;\n        });\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    AttributeMap,\n    composeTechniqueTextureName,\n    DecodedTile,\n    getFeatureId,\n    getPropertyValue,\n    ImageTexture,\n    isLineMarkerTechnique,\n    isPoiTechnique,\n    LineMarkerTechnique,\n    PoiGeometry,\n    PoiTechnique\n} from \"@here/harp-datasource-protocol\";\nimport { ContextualArabicConverter } from \"@here/harp-text-canvas\";\nimport { assert, assertExists, LoggerManager } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\nimport { MapView } from \"../MapView\";\nimport { TextElement } from \"../text/TextElement\";\nimport { DEFAULT_TEXT_DISTANCE_SCALE } from \"../text/TextElementsRenderer\";\nimport { Tile } from \"../Tile\";\nimport { PoiTable } from \"./PoiTableManager\";\n\nconst logger = LoggerManager.instance.create(\"PoiManager\");\n\n/**\n * Interface for the [[ImageTexture]]s that are defined in the atlas.\n */\ninterface ImageTextureDef {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    pixelRatio?: number;\n}\n\n/**\n * POI manager class, responsible for loading the [[PoiGeometry]] objects from the [[DecodedTile]],\n * and preparing them for rendering. Also loads and manages the texture atlases for the icons.\n */\nexport class PoiManager {\n    // Keep track of the missing POI table names, but only warn once.\n    private static m_missingPoiTableName: Map<string, boolean> = new Map();\n    private static m_missingPoiName: Map<string, boolean> = new Map();\n\n    /**\n     * Warn about a missing POI table name, but only once.\n     * @param poiTableName POI mapping table name.\n     * @param poiTable POI table instance.\n     */\n    private static notifyMissingPoiTable(\n        poiTableName: string,\n        poiTable: PoiTable | undefined\n    ): void {\n        if (poiTableName === undefined) {\n            poiTableName = \"undefined\";\n        }\n        if (PoiManager.m_missingPoiTableName.get(poiTableName) === undefined) {\n            PoiManager.m_missingPoiTableName.set(poiTableName, true);\n            if (poiTable !== undefined && !poiTable.loadedOk) {\n                logger.error(`updatePoiFromPoiTable: Could not load POI table '${poiTableName}'!`);\n            } else {\n                logger.error(\n                    `updatePoiFromPoiTable: No POI table with name '${poiTableName}' found!`\n                );\n            }\n        }\n    }\n\n    /**\n     * Warn about a missing POI name, but only once.\n     * @param poiName name of POI.\n     * @param poiTableName POI mapping table name.\n     */\n    private static notifyMissingPoi(poiName: string, poiTableName: string): void {\n        if (poiName === undefined) {\n            poiName = \"undefined\";\n        }\n        const key: string = `${poiTableName}[${poiName}]`;\n        if (PoiManager.m_missingPoiName.get(key) === undefined) {\n            PoiManager.m_missingPoiName.set(key, true);\n            logger.warn(\n                `updatePoiFromPoiTable: ` +\n                    `Cannot find POI info for '${poiName}' in table '${poiTableName}'.`\n            );\n        }\n    }\n\n    private m_imageTextures: Map<string, ImageTexture> = new Map();\n    private m_poiShieldGroups: Map<string, number> = new Map();\n\n    /**\n     * The constructor of the `PoiManager`.\n     *\n     * @param mapView The [[MapView]] instance that should display the POIs.\n     */\n    constructor(readonly mapView: MapView) {}\n\n    /**\n     * Add all POIs from a decoded tile and store them as [[TextElement]]s in the [[Tile]].\n     *\n     * Also handles LineMarkers, which is a recurring marker along a line (road).\n     *\n     * @param tile Tile to add POIs to.\n     * @param decodedTile DecodedTile containing the raw [[PoiGeometry]] objects describing the\n     *  POIs.\n     */\n    addPois(tile: Tile, decodedTile: DecodedTile): void {\n        const poiGeometries = assertExists(decodedTile.poiGeometries);\n        const worldOffsetX = tile.computeWorldOffsetX();\n\n        for (const poiGeometry of poiGeometries) {\n            assert(poiGeometry.technique !== undefined);\n            const techniqueIndex = assertExists(poiGeometry.technique);\n            const technique = decodedTile.techniques[techniqueIndex];\n\n            if (\n                technique.enabled === false ||\n                (!isLineMarkerTechnique(technique) && !isPoiTechnique(technique))\n            ) {\n                continue;\n            }\n\n            // The POI may be in the data, and there may be a Technique, but the technique may\n            // specify to not show it.\n            if (technique.showOnMap === false) {\n                continue;\n            }\n\n            const positions = new THREE.BufferAttribute(\n                new Float32Array(poiGeometry.positions.buffer),\n                poiGeometry.positions.itemCount\n            );\n\n            if (isLineMarkerTechnique(technique) && positions.count > 0) {\n                this.addLineMarker(tile, poiGeometry, technique, positions, worldOffsetX);\n            } else if (isPoiTechnique(technique)) {\n                this.addPoi(tile, poiGeometry, technique, positions, worldOffsetX);\n            }\n        }\n    }\n\n    /**\n     * Load the texture atlas that defines the segments of the texture that should be used for\n     * specific icons. Creates an [[ImageTexture]] for every element in the atlas, such that it can\n     * be addressed in the theme file.\n     *\n     * @param imageName Name of the image from the theme (NOT the url!).\n     * @param atlas URL of the JSON file defining the texture atlas.\n     */\n    addTextureAtlas(imageName: string, atlas: string) {\n        fetch(atlas)\n            .then(response => {\n                if (!response.ok) {\n                    throw new Error(\n                        `addTextureAtlas: Cannot load textureAtlas: ${response.statusText}`\n                    );\n                }\n\n                return response.json();\n            })\n            .then((jsonAtlas: any | undefined) => {\n                if (jsonAtlas === undefined) {\n                    logger.info(`addTextureAtlas: TextureAtlas empty: ${atlas}`);\n                    return;\n                }\n\n                try {\n                    logger.debug(\n                        `addTextureAtlas: Loading textureAtlas '${atlas}' for image '${imageName}'`\n                    );\n                    for (const textureName of Object.getOwnPropertyNames(jsonAtlas)) {\n                        const imageTextureDef = jsonAtlas[textureName] as ImageTextureDef;\n\n                        const imageTexture: ImageTexture = {\n                            name: textureName,\n                            image: imageName,\n                            xOffset: imageTextureDef.x,\n                            yOffset: imageTextureDef.y,\n                            width: imageTextureDef.width,\n                            height: imageTextureDef.height\n                        };\n\n                        this.addImageTexture(imageTexture);\n                    }\n                } catch (ex) {\n                    logger.error(\n                        `addTextureAtlas: Failed to load textureAtlas ` + `'${atlas}' : ${ex}`\n                    );\n                }\n                this.mapView.update();\n            })\n\n            .catch((reason: any) => {\n                logger.error(`addTextureAtlas: Failed to load textureAtlas '${atlas}' : ${reason}`);\n            });\n    }\n\n    /**\n     * Add an [[ImageTexture]] such that it is available as a named entity for techniques in theme\n     * files.\n     *\n     * @param imageTexture [[ImageTexture]] that should be available for POIs.\n     */\n    addImageTexture(imageTexture: ImageTexture) {\n        if (imageTexture.name === undefined) {\n            logger.error(\"addImageTexture: Name required\", imageTexture);\n            return;\n        }\n        if (this.m_imageTextures.get(imageTexture.name) !== undefined) {\n            logger.warn(\n                `addImageTexture: Name already used: ${imageTexture.name}` + ` (overriding it)`\n            );\n        }\n\n        this.m_imageTextures.set(imageTexture.name, imageTexture);\n    }\n\n    /**\n     * Return the [[ImageTexture]] registered under the specified name.\n     *\n     * @param name Name of the [[ImageTexture]].\n     */\n    getImageTexture(name: string): ImageTexture | undefined {\n        return this.m_imageTextures.get(name);\n    }\n\n    /**\n     * Update the [[TextElement]] with the information taken from the [[PoiTable]] which is\n     * referenced in the [[PoiInfo]] of the pointLabel.\n     *\n     * If the requested [[PoiTable]] is not available yet, the function returns `false`.\n     * If the [[PoiTable]] is not defined, or if the references POI has no entry in\n     * the [[PoiTable]], no action is taken, and the function returns `false`.\n     *\n     * If the [[PoiTable]] has been processed, it returns `true`, indicating that this function\n     * doesn't have to be called again.\n     *\n     * @param pointLabel The [[TextElement]] to update.\n     *\n     * @returns `true` if the [[PoiTable]] has been processed, and the function does not have to be\n     *          called again.\n     */\n    updatePoiFromPoiTable(pointLabel: TextElement): boolean {\n        const poiInfo = pointLabel.poiInfo;\n        // PoiTable requires poiName to be defined otherwise mapping via PoiTable is\n        // not possible, such as table key is not defined.\n        if (\n            poiInfo === undefined ||\n            poiInfo.poiTableName === undefined ||\n            poiInfo.poiName === undefined\n        ) {\n            return true;\n        }\n\n        // Try to acquire PoiTable\n        const poiTableName = poiInfo.poiTableName;\n        const poiTable = this.mapView.poiTableManager.getPoiTable(poiTableName);\n\n        // Check if PoiTable is found, but its still loading.\n        if (poiTable !== undefined && poiTable.isLoading) {\n            // The PoiTable is still loading, we have to try again.\n            return false;\n        }\n\n        // Remove poiTableName to mark this POI as processed.\n        poiInfo.poiTableName = undefined;\n\n        // PoiTable not found or can not be loaded.\n        if (poiTable === undefined || !poiTable.loadedOk) {\n            PoiManager.notifyMissingPoiTable(poiTableName, poiTable);\n            return true;\n        }\n\n        // Try to acquire PoiTableEntry.\n        const poiName = poiInfo.poiName;\n        const poiTableEntry = poiTable.getEntry(poiName);\n        if (poiTableEntry === undefined) {\n            PoiManager.notifyMissingPoi(poiName, poiTableName);\n            return true;\n        }\n\n        if (poiTableEntry.iconName !== undefined && poiTableEntry.iconName.length > 0) {\n            poiInfo.imageTextureName = composeTechniqueTextureName(\n                poiTableEntry.iconName,\n                poiInfo.technique\n            );\n        }\n\n        pointLabel.visible =\n            poiTableEntry.visible !== undefined ? poiTableEntry.visible : pointLabel.visible;\n        pointLabel.priority =\n            poiTableEntry.priority !== undefined ? poiTableEntry.priority : pointLabel.priority;\n        poiInfo.iconMinZoomLevel =\n            poiTableEntry.iconMinLevel !== undefined\n                ? poiTableEntry.iconMinLevel\n                : poiInfo.iconMinZoomLevel;\n        poiInfo.iconMaxZoomLevel =\n            poiTableEntry.iconMaxLevel !== undefined\n                ? poiTableEntry.iconMaxLevel\n                : poiInfo.iconMaxZoomLevel;\n        poiInfo.textMinZoomLevel =\n            poiTableEntry.textMinLevel !== undefined\n                ? poiTableEntry.textMinLevel\n                : poiInfo.textMinZoomLevel;\n        poiInfo.textMaxZoomLevel =\n            poiTableEntry.textMaxLevel !== undefined\n                ? poiTableEntry.textMaxLevel\n                : poiInfo.textMaxZoomLevel;\n\n        pointLabel.updateMinMaxZoomLevelsFromPoiInfo();\n\n        return true;\n    }\n\n    /**\n     * Clear internal state. Applicable when switching themes.\n     */\n    clear() {\n        this.m_imageTextures.clear();\n        this.m_poiShieldGroups.clear();\n    }\n\n    /**\n     * Add the LineMarker as a POI with a series of positions. Make sure that the LineMarkers\n     * having the same visual all get their `shieldGroupIndex` set appropriately, so it can be taken\n     * care of later that not too many of them are rendered (obey `minDistance` attribute).\n     */\n    private addLineMarker(\n        tile: Tile,\n        poiGeometry: PoiGeometry,\n        technique: LineMarkerTechnique,\n        positions: THREE.BufferAttribute,\n        worldOffsetX: number\n    ) {\n        let imageTextureName: string | undefined =\n            technique.imageTexture !== undefined\n                ? composeTechniqueTextureName(technique.imageTexture, technique)\n                : undefined;\n\n        let text: string = \"\";\n        let userData: AttributeMap | undefined;\n        let featureId: number | undefined;\n\n        if (poiGeometry.stringCatalog !== undefined) {\n            assert(poiGeometry.texts.length > 0);\n            text = poiGeometry.stringCatalog[poiGeometry.texts[0]] || \"\";\n            if (poiGeometry.objInfos !== undefined) {\n                userData = poiGeometry.objInfos[0];\n                featureId = getFeatureId(userData);\n            }\n\n            if (poiGeometry.imageTextures !== undefined) {\n                assert(poiGeometry.imageTextures.length > 0);\n                imageTextureName = poiGeometry.stringCatalog[poiGeometry.imageTextures[0]];\n            }\n        }\n\n        // let the combined image texture name (name of image in atlas, not the URL) and\n        // text of the shield be the group key, at worst scenario it may be:\n        // \"undefined-\"\n        const groupKey = String(imageTextureName) + \"-\" + text;\n        let shieldGroupIndex = this.m_poiShieldGroups.get(groupKey);\n        if (shieldGroupIndex === undefined) {\n            shieldGroupIndex = this.m_poiShieldGroups.size;\n            this.m_poiShieldGroups.set(groupKey, shieldGroupIndex);\n        }\n\n        // Debugging help to identify the group of a shield :\n        // text = groupKey + \": \" + text;\n\n        const positionArray: THREE.Vector3[] = [];\n        for (let i = 0; i < positions.count; i += 3) {\n            const x = positions.getX(i) + worldOffsetX;\n            const y = positions.getY(i);\n            const z = positions.getZ(i);\n            positionArray.push(new THREE.Vector3(x, y, z));\n        }\n        const textElement = this.checkCreateTextElement(\n            tile,\n            text,\n            technique,\n            imageTextureName,\n            undefined, // TBD for road shields\n            undefined,\n            shieldGroupIndex,\n            featureId,\n            positionArray,\n            undefined,\n            undefined,\n            userData\n        );\n\n        // If the poi icon is rendered, the label that shows text should also be rendered.\n        // The distance rule of the icon should apply, not the one for text (only) labels.\n        textElement.ignoreDistance = false;\n        tile.addTextElement(textElement);\n    }\n\n    /**\n     * Create and add POI [[TextElement]]s to tile with a series of positions.\n     */\n    private addPoi(\n        tile: Tile,\n        poiGeometry: PoiGeometry,\n        technique: PoiTechnique,\n        positions: THREE.BufferAttribute,\n        worldOffsetX: number\n    ) {\n        if (poiGeometry.stringCatalog === undefined) {\n            return;\n        }\n\n        const techniqueTextureName: string | undefined =\n            technique.imageTexture !== undefined\n                ? composeTechniqueTextureName(technique.imageTexture, technique)\n                : undefined;\n\n        const poiTechnique = technique as PoiTechnique;\n        const poiTableName = poiTechnique.poiTable;\n        let poiName = poiTechnique.poiName;\n\n        for (let i = 0; i < positions.count; ++i) {\n            const x = positions.getX(i) + worldOffsetX;\n            const y = positions.getY(i);\n            const z = positions.getZ(i);\n\n            assert(poiGeometry.texts.length > i);\n            let imageTextureName = techniqueTextureName;\n            const text: string = poiGeometry.stringCatalog[poiGeometry.texts[i]] || \"\";\n            const userData =\n                poiGeometry.objInfos !== undefined ? poiGeometry.objInfos[i] : undefined;\n            const featureId = getFeatureId(userData);\n            if (poiGeometry.imageTextures !== undefined && poiGeometry.imageTextures[i] >= 0) {\n                assert(poiGeometry.imageTextures.length > i);\n                imageTextureName = poiGeometry.stringCatalog[poiGeometry.imageTextures[i]];\n            }\n            if (poiTableName !== undefined) {\n                // The POI name to be used is taken from the data, since it will\n                // specify the name of the texture to use.\n\n                // The POI name in the technique may override the POI name from the\n                // data.\n                poiName =\n                    poiTechnique.poiName === undefined ? imageTextureName : poiTechnique.poiName;\n\n                imageTextureName = undefined;\n            }\n\n            const textElement = this.checkCreateTextElement(\n                tile,\n                text,\n                technique,\n                imageTextureName,\n                poiTableName,\n                poiName,\n                0,\n                featureId,\n                x,\n                y,\n                z,\n                userData\n            );\n\n            tile.addTextElement(textElement);\n        }\n    }\n\n    /**\n     * Create the [[TextElement]] for a POI. Even if the POI has no text, it is required that there\n     * is a [[TextElement]], since POIs are hooked onto [[TextElement]]s for sorting.(Sorted by\n     * priority attribute).\n     */\n    private checkCreateTextElement(\n        tile: Tile,\n        text: string,\n        technique: PoiTechnique | LineMarkerTechnique,\n        imageTextureName: string | undefined,\n        poiTableName: string | undefined,\n        poiName: string | undefined,\n        shieldGroupIndex: number,\n        featureId: number | undefined,\n        x: number | THREE.Vector3[],\n        y: number | undefined,\n        z: number | undefined,\n        userData?: {}\n    ): TextElement {\n        const textElementsRenderer = this.mapView.textElementsRenderer;\n        const priority = technique.priority !== undefined ? technique.priority : 0;\n        const positions = Array.isArray(x) ? (x as THREE.Vector3[]) : new THREE.Vector3(x, y, z);\n\n        // The current zoomlevel of mapview. Since this method is called for all tiles in the\n        // VisibleTileSet we can be sure that the current zoomlevel matches the zoomlevel where\n        // the tile should be shown.\n        const displayZoomLevel = this.mapView.zoomLevel;\n        const fadeNear =\n            technique.fadeNear !== undefined\n                ? getPropertyValue(technique.fadeNear, displayZoomLevel)\n                : technique.fadeNear;\n        const fadeFar =\n            technique.fadeFar !== undefined\n                ? getPropertyValue(technique.fadeFar, displayZoomLevel)\n                : technique.fadeFar;\n        const xOffset = getPropertyValue(technique.xOffset, displayZoomLevel);\n        const yOffset = getPropertyValue(technique.yOffset, displayZoomLevel);\n\n        const textElement: TextElement = new TextElement(\n            ContextualArabicConverter.instance.convert(text),\n            positions,\n            textElementsRenderer.styleCache.getRenderStyle(tile, technique),\n            textElementsRenderer.styleCache.getLayoutStyle(tile, technique),\n            getPropertyValue(priority, displayZoomLevel),\n            xOffset !== undefined ? xOffset : 0.0,\n            yOffset !== undefined ? yOffset : 0.0,\n            featureId,\n            technique.style,\n            fadeNear,\n            fadeFar,\n            tile.offset\n        );\n\n        textElement.mayOverlap = technique.textMayOverlap === true;\n        textElement.reserveSpace = technique.textReserveSpace !== false;\n        textElement.alwaysOnTop = technique.alwaysOnTop === true;\n        textElement.userData = userData;\n\n        // imageTextureName may be undefined if a poiTable is used.\n        if (imageTextureName === undefined && poiTableName !== undefined) {\n            imageTextureName = \"\";\n        } else if (imageTextureName !== undefined && poiTableName !== undefined) {\n            logger.warn(\n                \"Possible duplicate POI icon definition via imageTextureName and poiTable!\"\n            );\n        }\n\n        if (imageTextureName !== undefined) {\n            const textIsOptional = technique.textIsOptional === true;\n            const iconIsOptional = technique.iconIsOptional !== false;\n            const renderTextDuringMovements = !(technique.renderTextDuringMovements === false);\n            const iconMayOverlap =\n                technique.iconMayOverlap === undefined\n                    ? textElement.textMayOverlap\n                    : technique.iconMayOverlap === true;\n            const iconReserveSpace =\n                technique.iconReserveSpace === undefined\n                    ? textElement.textReservesSpace\n                    : technique.iconReserveSpace !== false;\n\n            textElement.poiInfo = {\n                technique,\n                imageTextureName,\n                poiTableName,\n                poiName,\n                shieldGroupIndex,\n                textElement,\n                textIsOptional,\n                iconIsOptional,\n                renderTextDuringMovements,\n                mayOverlap: iconMayOverlap,\n                reserveSpace: iconReserveSpace,\n                featureId,\n                iconMinZoomLevel: technique.iconMinZoomLevel,\n                iconMaxZoomLevel: technique.iconMaxZoomLevel,\n                textMinZoomLevel: technique.textMinZoomLevel,\n                textMaxZoomLevel: technique.textMaxZoomLevel\n            };\n            textElement.updateMinMaxZoomLevelsFromPoiInfo();\n        } else {\n            // Select the smaller/larger one of the two min/max values, because the TextElement\n            // is a container for both.\n            if (textElement.minZoomLevel === undefined) {\n                textElement.minZoomLevel = technique.textMinZoomLevel;\n            }\n\n            if (textElement.maxZoomLevel === undefined) {\n                textElement.maxZoomLevel = technique.textMaxZoomLevel;\n            }\n        }\n\n        textElement.distanceScale =\n            technique.distanceScale !== undefined\n                ? technique.distanceScale\n                : DEFAULT_TEXT_DISTANCE_SCALE;\n\n        return textElement;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {\n    PoiStackMode,\n    PoiTableDef,\n    PoiTableEntryDef,\n    PoiTableRef,\n    Theme\n} from \"@here/harp-datasource-protocol\";\nimport { LoggerManager } from \"@here/harp-utils\";\n\nimport { MapView } from \"../MapView\";\n\nconst logger = LoggerManager.instance.create(\"PoiTable\");\n\n/**\n * Class to store and maintain individual POI information for the [[PoiTable]].\n */\nclass PoiTableEntry implements PoiTableEntryDef {\n    /**\n     * Verify that the JSON description of the POI table entry is valid.\n     *\n     * @param jsonEntry JSON description of the POI table entry.\n     *\n     * @returns `true` if the `jsonEntry` is valid.\n     */\n    static verifyJSON(jsonEntry: PoiTableEntryDef): boolean {\n        let isOK =\n            typeof jsonEntry.name === \"string\" &&\n            jsonEntry.name.length > 0 &&\n            (jsonEntry.altNames === undefined || Array.isArray(jsonEntry.altNames)) &&\n            (jsonEntry.stackMode === undefined ||\n                jsonEntry.stackMode === \"yes\" ||\n                jsonEntry.stackMode === \"no\" ||\n                jsonEntry.stackMode === \"parent\") &&\n            (jsonEntry.visible === undefined || typeof jsonEntry.visible === \"boolean\") &&\n            (jsonEntry.priority === undefined || typeof jsonEntry.priority === \"number\") &&\n            (jsonEntry.iconMinLevel === undefined || typeof jsonEntry.iconMinLevel === \"number\") &&\n            (jsonEntry.iconMaxLevel === undefined || typeof jsonEntry.iconMaxLevel === \"number\") &&\n            (jsonEntry.textMinLevel === undefined || typeof jsonEntry.textMinLevel === \"number\") &&\n            (jsonEntry.textMaxLevel === undefined || typeof jsonEntry.textMaxLevel === \"number\");\n\n        if (isOK && jsonEntry.altNames !== undefined) {\n            const altNames = jsonEntry.altNames as string[];\n            for (const str in altNames) {\n                if (typeof str !== \"string\") {\n                    isOK = false;\n                    break;\n                }\n            }\n        }\n\n        return isOK;\n    }\n\n    /** Default name of the POI as the key for looking it up. */\n    name?: string;\n    /** Alternative names of the POI. */\n    altNames?: string[];\n    /** Visibility of the POI. If `false`, the POI will not be rendered. */\n    visible?: boolean;\n    /** Name of the icon, defined in the the texture atlases. */\n    iconName?: string;\n    /** Stacking mode of the POI. For future use. */\n    stackMode?: PoiStackMode;\n    /**\n     * Priority of the POI to select the visible set in case there are more POIs than can be\n     * handled.\n     */\n    priority?: number;\n    /** Minimum zoom level to render the icon on. */\n    iconMinLevel?: number;\n    /** Maximum zoom level to render the icon on. */\n    iconMaxLevel?: number;\n    /** Minimum zoom level to render the text label on. */\n    textMinLevel?: number;\n    /** Maximum zoom level to render the text label on. */\n    textMaxLevel?: number;\n\n    /**\n     * Setup the [[PoiTableEntry]] from the JSON description. It is assumed that the jsonEntry has\n     * been verified with [[PoiTableEntry#verifyJSON]].\n     *\n     * @param jsonEntry JSON description of the POI table entry. Expected to have been verified with\n     *          [[PoiTableEntry#verifyJSON]].\n     */\n    setup(jsonEntry: PoiTableEntryDef) {\n        this.name = jsonEntry.name;\n        this.altNames = jsonEntry.altNames;\n        this.iconName = jsonEntry.iconName;\n        this.visible = jsonEntry.visible;\n        this.priority = jsonEntry.priority;\n        this.iconMinLevel = jsonEntry.iconMinLevel;\n        this.iconMaxLevel = jsonEntry.iconMaxLevel;\n        this.textMinLevel = jsonEntry.textMinLevel;\n        this.textMaxLevel = jsonEntry.textMaxLevel;\n\n        switch (jsonEntry.stackMode) {\n            case \"yes\":\n                this.stackMode = PoiStackMode.Show;\n                break;\n            case \"no\":\n                this.stackMode = PoiStackMode.Hide;\n                break;\n            case \"parent\":\n                this.stackMode = PoiStackMode.ShowParent;\n                break;\n            default:\n        }\n    }\n}\n\n/**\n * The `PoiTable` stores individual information for each POI type. If a [[TextElement]] has a\n * reference to a PoiTable (if TextElement.poiInfo.poiTableName is set), information for the\n * TextElement and its icon are read from the PoiTable.\n *\n * The key to look up the POI is taken from the data, in case of OSM data with TileZen data, the\n * `poiNameField` is set to `kind`, which makes the content of the field `kind` in the data the key\n * to look up the POIs in the [[PoiTable]].\n *\n * On the side of the [[PoiTable]], the key to look up the PoiTableEntry is either the property\n * \"name\" of the [[PoiTableEntry]] (which should be unique), or the alternative list of names\n * `altNames`, where each value should also be unique. If the property `useAltNamesForKey` is set to\n * `true`, the `altNames` will be used.\n */\nexport class PoiTable {\n    /**\n     * Stores the list of [[PoiTableEntry]]s.\n     */\n    private readonly poiList: PoiTableEntry[] = new Array();\n    /**\n     * Dictionary to look up for [[PoiTableEntry]] quickly. The dictionary is either created for\n     * the `name` property of the [[PoiTableEntry]], which will identify POI, or for all of\n     * alternative the names defined in `altNames` of [[PoiTableEntry]] JSON object.\n     * Value assigned to key it is the index to [[poiList]] array which contain actual\n     * [[PoiTabelEntry]] objects.\n     */\n    private readonly poiDict: Map<string, number> = new Map();\n    private m_isLoading = false;\n    private m_loadedOk: boolean | undefined = undefined;\n\n    /**\n     * Creates an instance of PoiTable.\n     *\n     * @param {string} name Name of the `PoiTable`. Must be unique.\n     * @param {boolean} useAltNamesForKey Pass `true` to use the contents of the property `altNames`\n     *          to find a [[PoiTableEntry]] in the table.\n     */\n    constructor(readonly name: string, readonly useAltNamesForKey: boolean) {}\n\n    /**\n     * Returns `true` if the table is currently being loaded, `false` otherwise.\n     *\n     * @readonly\n     */\n    get isLoading(): boolean {\n        return this.m_isLoading;\n    }\n\n    /**\n     * Returns `true` if the table has been loaded correctly, `false` otherwise.\n     *\n     * @readonly\n     */\n    get loadedOk(): boolean {\n        return this.m_loadedOk === true;\n    }\n\n    /**\n     * Gets [[PoiTableEntry]] for poi name specified.\n     *\n     * @param poiName poi name or one of its alternative names if [[useAltNamesForKey]] is\n     * set to `true`.\n     * @returns [[PoiTableEntry]] object or undefined if name was not found in dictionary.\n     */\n    getEntry(poiName: string): PoiTableEntry | undefined {\n        const entryIdx: number | undefined = this.poiDict.get(poiName);\n        if (entryIdx !== undefined) {\n            if (entryIdx < this.poiList.length) {\n                return this.poiList[entryIdx];\n            } else {\n                throw new Error(\"Poi table entry index out of stored list!\");\n            }\n        }\n        return undefined;\n    }\n\n    /**\n     * Start to load the PoiTable from the specified URL. Can only be called once per table.\n     *\n     * @param {string} poiTableUrl URL that points to the JSON file.\n     *\n     * @returns {Promise<boolean>} Promise is being resolved once the JSON file has been fetched and\n     *          the `PoiTable` has been set up.\n     */\n    async load(poiTableUrl: string): Promise<boolean> {\n        if (this.m_loadedOk !== undefined) {\n            // Only load once.\n            return true;\n        }\n\n        this.m_loadedOk = false;\n\n        const response = await fetch(poiTableUrl);\n\n        if (!response.ok) {\n            throw new Error(\n                `load: Cannot load POI table at ${poiTableUrl}:` + ` ${response.statusText}`\n            );\n        }\n\n        const jsonPoiTable = (await response.json()) as PoiTableDef;\n        if (jsonPoiTable === undefined) {\n            logger.info(`load: TextureAtlas empty: ${poiTableUrl}`);\n            return true;\n        }\n\n        this.startLoading();\n\n        try {\n            logger.debug(`load: Loading POI table '${poiTableUrl}' for table '${this.name}'`);\n\n            if (jsonPoiTable.poiList !== undefined && Array.isArray(jsonPoiTable.poiList)) {\n                for (const tableEntry of jsonPoiTable.poiList) {\n                    if (PoiTableEntry.verifyJSON(tableEntry)) {\n                        const newPoiEntry = new PoiTableEntry();\n                        newPoiEntry.setup(tableEntry);\n                        const entryIdx = this.poiList.push(newPoiEntry) - 1;\n\n                        if (!this.useAltNamesForKey) {\n                            // Use actual name of entry as the key\n                            if (newPoiEntry.name === undefined) {\n                                logger.warn(\n                                    `load: Invalid entry in POI table '${poiTableUrl}' : ` +\n                                        `. No name set in entry: ${tableEntry}.`\n                                );\n                            } else {\n                                this.poiDict.set(newPoiEntry.name, entryIdx);\n                            }\n                        } else {\n                            if (\n                                newPoiEntry.altNames !== undefined &&\n                                newPoiEntry.altNames.length > 0\n                            ) {\n                                // Use the list of alternative names as keys.\n                                for (const altName of newPoiEntry.altNames) {\n                                    this.poiDict.set(altName, entryIdx);\n                                }\n                            } else {\n                                logger.warn(\n                                    `load: Invalid entry in POI table '${poiTableUrl}' : ` +\n                                        `No alternative names set in entry: ${JSON.stringify(\n                                            tableEntry\n                                        )}.`\n                                );\n                            }\n                        }\n                    } else {\n                        logger.warn(\n                            `load: Invalid entry in POI table '${poiTableUrl}' : ${JSON.stringify(\n                                tableEntry\n                            )}`\n                        );\n                    }\n                }\n            }\n            this.m_loadedOk = true;\n            this.finishedLoading();\n        } catch (ex) {\n            logger.error(`load: Failed to load POI table ` + `'${poiTableUrl}' : ${ex}`);\n            this.m_loadedOk = false;\n            this.finishedLoading();\n            return false;\n        }\n        return true;\n    }\n\n    private startLoading() {\n        this.m_isLoading = true;\n    }\n\n    private finishedLoading() {\n        this.m_isLoading = false;\n    }\n}\n\n/**\n * The `PoiTableManager` manages the list of [[PoiTables]] that can be defined in the [[Theme]]\n * file.\n */\nexport class PoiTableManager {\n    private m_isLoading = false;\n    private m_poiTables: Map<string, PoiTable> = new Map();\n\n    /**\n     * Creates an instance of PoiTableManager.\n     * @param {MapView} mapView Owning [[MapView]].\n     */\n    constructor(readonly mapView: MapView) {}\n\n    /**\n     * Load the [[PoiTable]]s that are stored in the [[MapView]]s [[Theme]]. Note that duplicate\n     * names of [[PoiTable]]s in the [[Theme]] will lead to inaccessible [[PoiTable]]s.\n     *\n     * @param {Theme} theme [[Theme]] containing all [[PoiTable]]s to load.\n     *\n     * @returns {Promise<void>} Resolved once all the [[PoiTable]]s in the [[Theme]] have been\n     *          loaded.\n     */\n    async loadPoiTables(theme: Theme): Promise<void> {\n        const finished = new Promise<void>(resolve => {\n            this.clear();\n\n            // Add the POI tables defined in the theme.\n            if (theme.poiTables !== undefined) {\n                this.startLoading();\n\n                // Gather promises to signal the success of having loaded them all\n                const loadPromises: Array<Promise<boolean>> = new Array();\n\n                theme.poiTables.forEach((poiTableRef: PoiTableRef) => {\n                    if (\n                        poiTableRef !== undefined &&\n                        poiTableRef.name !== undefined &&\n                        typeof poiTableRef.name === \"string\"\n                    ) {\n                        const poiTable = new PoiTable(\n                            poiTableRef.name,\n                            poiTableRef.useAltNamesForKey !== false\n                        );\n                        if (poiTableRef.url !== undefined && typeof poiTableRef.url === \"string\") {\n                            this.addTable(poiTable);\n                            loadPromises.push(poiTable.load(poiTableRef.url));\n                        } else {\n                            logger.error(`POI table definition has no valid url: ${poiTableRef}`);\n                        }\n                    } else {\n                        logger.error(`POI table definition has no valid name: ${poiTableRef}`);\n                    }\n                });\n\n                if (loadPromises.length > 0) {\n                    Promise.all(loadPromises).finally(() => {\n                        this.finishLoading();\n                        resolve();\n                    });\n                } else {\n                    this.finishLoading();\n                    resolve();\n                }\n            } else {\n                this.finishLoading();\n                resolve();\n            }\n        });\n\n        return finished;\n    }\n\n    /**\n     * Clear the list of [[PoiTable]]s.\n     */\n    clear() {\n        this.m_poiTables = new Map();\n    }\n\n    /**\n     * Return the map of [[PoiTable]]s.\n     */\n    get poiTables(): Map<string, PoiTable> {\n        return this.m_poiTables;\n    }\n\n    /**\n     * Manually add a [[PoiTable]]. Normally, the [[PoiTables]]s are specified in the [[Theme]].\n     * Ensure that the name is unique.\n     */\n    addTable(poiTable: PoiTable) {\n        this.m_poiTables.set(poiTable.name, poiTable);\n    }\n\n    /**\n     * Retrieve a [[PoiTable]] by name.\n     *\n     * @param {(string | undefined)} poiTableName Name of the [[PoiTable]].\n     *\n     * @returns {(PoiTable | undefined)} The found [[poiTable]] if it could be found, `undefined`\n     *          otherwise.\n     */\n    getPoiTable(poiTableName: string | undefined): PoiTable | undefined {\n        return poiTableName === undefined ? undefined : this.m_poiTables.get(poiTableName);\n    }\n\n    /**\n     * Return `true` if the [[PoiTable]]s have finished loading.\n     *\n     * @readonly\n     */\n    get finishedLoading(): boolean {\n        return !this.m_isLoading;\n    }\n\n    private startLoading() {\n        this.m_isLoading = true;\n    }\n\n    private finishLoading() {\n        this.m_isLoading = false;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { Definitions, StyleSet, Theme } from \"@here/harp-datasource-protocol\";\nimport { MapEnv, StyleSetEvaluator } from \"@here/harp-datasource-protocol/index-decoder\";\nimport {\n    GeoCoordinates,\n    MathUtils,\n    MercatorConstants,\n    polarTilingScheme,\n    TileKey,\n    TilingScheme,\n    TransverseMercatorUtils\n} from \"@here/harp-geoutils\";\n\nimport { DataSource } from \"./DataSource\";\nimport { createMaterial } from \"./DecodedTileHelpers\";\nimport { Tile } from \"./Tile\";\n\nexport interface PolarTileDataSourceOptions {\n    /**\n     * Name of [[TileDataSource]], must be unique.\n     */\n    name?: string;\n\n    /**\n     * The name of the [[StyleSet]] to evaluate for the decoding.\n     */\n    styleSetName?: string;\n\n    /**\n     * Optional minimum zoom level (storage level) for [[Tile]]s. Default is 1.\n     */\n    minZoomLevel?: number;\n\n    /**\n     * Optional maximum zoom level (storage level) for [[Tile]]s. Default is 20.\n     */\n    maxZoomLevel?: number;\n\n    /**\n     * Optional storage level offset for [[Tile]]s. Default is -1.\n     */\n    storageLevelOffset?: number;\n\n    /**\n     * Optional level offset of regular tiles from reference datasource to align tiles to.\n     * Default is -1.\n     */\n    geometryLevelOffset?: number;\n\n    /**\n     * Enable debug display for generated tiles.\n     * Default is false.\n     */\n    debugTiles?: boolean;\n}\n\n/**\n * [[DataSource]] providing geometry for poles\n */\nexport class PolarTileDataSource extends DataSource {\n    private m_tilingScheme: TilingScheme = polarTilingScheme;\n    private m_maxLatitude = MathUtils.radToDeg(MercatorConstants.MAXIMUM_LATITUDE);\n    private m_geometryLevelOffset: number;\n    private m_debugTiles: boolean;\n\n    private m_styleSetEvaluator?: StyleSetEvaluator;\n    private m_northPoleMaterial?: THREE.Material;\n    private m_southPoleMaterial?: THREE.Material;\n\n    constructor({\n        name = \"polar\",\n        styleSetName,\n        minZoomLevel,\n        maxZoomLevel,\n        storageLevelOffset = -2,\n        geometryLevelOffset = -1,\n        debugTiles = false\n    }: PolarTileDataSourceOptions) {\n        super(name, styleSetName, minZoomLevel, maxZoomLevel, storageLevelOffset);\n\n        this.m_geometryLevelOffset = geometryLevelOffset;\n        this.m_debugTiles = debugTiles;\n        this.cacheable = false;\n    }\n\n    dispose() {\n        if (this.m_northPoleMaterial) {\n            this.m_northPoleMaterial.dispose();\n            delete this.m_northPoleMaterial;\n        }\n        if (this.m_southPoleMaterial) {\n            this.m_southPoleMaterial.dispose();\n            delete this.m_southPoleMaterial;\n        }\n        if (this.m_styleSetEvaluator) {\n            delete this.m_styleSetEvaluator;\n        }\n    }\n\n    createMaterial(kind: string, styleSetEvaluator: StyleSetEvaluator): THREE.Material | undefined {\n        const env = new MapEnv({\n            $geometryType: \"polygon\",\n            $layer: \"earth\",\n            kind\n        });\n\n        const techniques = styleSetEvaluator.getMatchingTechniques(env);\n\n        return techniques.length !== 0\n            ? createMaterial({ technique: techniques[0], level: 1 })\n            : undefined;\n    }\n\n    setStyleSet(styleSet?: StyleSet, definitions?: Definitions, languages?: string[]): void {\n        this.dispose();\n\n        if (styleSet !== undefined) {\n            this.m_styleSetEvaluator = new StyleSetEvaluator(styleSet, definitions);\n\n            this.m_northPoleMaterial = this.createMaterial(\"north_pole\", this.m_styleSetEvaluator);\n            this.m_southPoleMaterial = this.createMaterial(\"south_pole\", this.m_styleSetEvaluator);\n        }\n\n        this.mapView.markTilesDirty(this);\n    }\n\n    setTheme(theme: Theme, languages?: string[]): void {\n        const styleSet =\n            (this.styleSetName !== undefined && theme.styles && theme.styles[this.styleSetName]) ||\n            [];\n\n        this.setStyleSet(styleSet, theme.definitions, languages);\n    }\n\n    shouldRender(zoomLevel: number, tileKey: TileKey): boolean {\n        if (zoomLevel !== tileKey.level || tileKey.level < 1) {\n            return false;\n        }\n\n        const { north, south } = this.m_tilingScheme.getGeoBox(tileKey);\n\n        return north > this.m_maxLatitude || south < -this.m_maxLatitude;\n    }\n\n    shouldSubdivide(zoomLevel: number, tileKey: TileKey): boolean {\n        if (zoomLevel <= tileKey.level) {\n            return false;\n        }\n\n        const { north, south } = this.m_tilingScheme.getGeoBox(tileKey);\n\n        return north > this.m_maxLatitude || south < -this.m_maxLatitude;\n    }\n\n    getTilingScheme(): TilingScheme {\n        return this.m_tilingScheme;\n    }\n\n    getTile(tileKey: TileKey): Tile {\n        const tile = new Tile(this, tileKey);\n\n        this.createTileGeometry(tile);\n\n        return tile;\n    }\n\n    get geometryLevelOffset(): number {\n        return this.m_geometryLevelOffset;\n    }\n\n    set geometryLevelOffset(geometryLevelOffset: number) {\n        this.m_geometryLevelOffset = geometryLevelOffset;\n    }\n\n    private intersectEdge(latitude: number, a: GeoCoordinates, b: GeoCoordinates): GeoCoordinates {\n        const latA = a.latitude;\n        const latB = b.latitude;\n\n        let lonA = a.longitude;\n        let lonB = b.longitude;\n\n        if (Math.abs(latA) === 90) {\n            lonA = lonB;\n        }\n        if (Math.abs(latB) === 90) {\n            lonB = lonA;\n        }\n        const deltaLat = latB - latA;\n        const deltaLon = lonB - lonA;\n        const scale = (latitude - latA) / deltaLat;\n\n        return new GeoCoordinates(latitude, lonA + deltaLon * scale, 0);\n    }\n\n    private createTileGeometry(tile: Tile): void {\n        const { north, south } = tile.geoBox;\n\n        const isNorthPole = north > 0 && south >= 0;\n        const material = isNorthPole ? this.m_northPoleMaterial : this.m_southPoleMaterial;\n        if (material === undefined) {\n            tile.forceHasGeometry(true);\n            return;\n        }\n\n        const srcProjection = this.m_tilingScheme.projection;\n        const dstProjection = this.projection;\n\n        const maxLat = this.m_maxLatitude;\n        const poleLat = isNorthPole ? maxLat : -maxLat;\n\n        const box = this.m_tilingScheme.boundingBoxGenerator.getWorldBox(tile.tileKey);\n\n        const pBL = srcProjection.unprojectPoint(new THREE.Vector3(box.min.x, box.min.y, 0));\n        const pBR = srcProjection.unprojectPoint(new THREE.Vector3(box.max.x, box.min.y, 0));\n        const pTR = srcProjection.unprojectPoint(new THREE.Vector3(box.max.x, box.max.y, 0));\n        const pTL = srcProjection.unprojectPoint(new THREE.Vector3(box.min.x, box.max.y, 0));\n\n        let points: GeoCoordinates[];\n        let needsGeometryCut = false;\n\n        // special case where tile contains half of the hemisphere\n        if (tile.tileKey.level === 1) {\n            const isLeftHalf = box.min.x === 0;\n\n            const poleX = isLeftHalf ? box.max.x : box.min.x;\n            const poleY = (box.max.y + box.min.y) / 2;\n            const pPole = srcProjection.unprojectPoint(new THREE.Vector3(poleX, poleY, 0));\n\n            // coordinates are not used, needed for right position\n            const pXX = isLeftHalf ? pBL : pBR;\n\n            points = isNorthPole\n                ? isLeftHalf\n                    ? [pPole, pTR, pXX, pBR]\n                    : [pPole, pBL, pXX, pTL]\n                : isLeftHalf\n                ? [pPole, pBR, pXX, pTR]\n                : [pPole, pTL, pXX, pBL];\n\n            needsGeometryCut = true;\n        } else {\n            // ccw for north, cw for south\n            points = isNorthPole ? [pBL, pBR, pTR, pTL] : [pBL, pTL, pTR, pBR];\n\n            const lats = points.map(p => p.latitude);\n            const lmax = Math.max(...lats);\n            const lmin = Math.min(...lats);\n\n            const isAllPointsOut = isNorthPole ? lmax < poleLat : lmin > poleLat;\n            if (isAllPointsOut) {\n                return;\n            }\n\n            const isSomePointsOut = isNorthPole ? lmin < poleLat : lmax > poleLat;\n            needsGeometryCut = isSomePointsOut;\n\n            if (needsGeometryCut) {\n                const nearest = lats.indexOf(isNorthPole ? lmax : lmin);\n                if (nearest !== 0) {\n                    for (let i = 0; i < nearest; i++) {\n                        points.push(points.shift() as GeoCoordinates);\n                    }\n                }\n            }\n        }\n\n        if (needsGeometryCut) {\n            const centerX = (box.min.x + box.max.x) / 2;\n            const centerY = (box.min.y + box.max.y) / 2;\n            const center = srcProjection.unprojectPoint(new THREE.Vector3(centerX, centerY, 0));\n\n            TransverseMercatorUtils.alignLongitude(points, center);\n\n            // points aligned as follows:\n            // a - nearest to the pole, always in\n            // b - next to nearest\n            // c - farthes from the pole, always out\n            // d - prev from nearest\n            const a = points[0];\n            const b = points[1];\n            const c = points[2];\n            const d = points[3];\n\n            const inPointB = Math.abs(b.latitude) >= maxLat;\n            const inPointD = Math.abs(d.latitude) >= maxLat;\n\n            const cutStart = inPointB\n                ? this.intersectEdge(poleLat, b, c)\n                : this.intersectEdge(poleLat, a, b);\n\n            const cutEnd = inPointD\n                ? this.intersectEdge(poleLat, d, c)\n                : this.intersectEdge(poleLat, a, d);\n\n            points.splice(inPointB ? 2 : 1, 4, cutStart);\n\n            const level = tile.tileKey.level - this.storageLevelOffset + this.m_geometryLevelOffset;\n            // tslint:disable-next-line:no-bitwise\n            const subdivisions = 1 << Math.max(0, level);\n            const step = 360 / subdivisions;\n\n            const cutIndexStart = Math.floor((cutStart.longitude + 180) / step);\n            const cutIndexEnd = Math.ceil((cutEnd.longitude + 180) / step);\n\n            for (let i = cutIndexStart + 1; i < cutIndexEnd; i++) {\n                points.push(new GeoCoordinates(poleLat, i * step - 180, 0));\n            }\n\n            points.push(cutEnd);\n            if (inPointD) {\n                points.push(d);\n            }\n        }\n\n        const g = new THREE.Geometry();\n\n        for (const point of points) {\n            const projected = dstProjection.projectPoint(point, new THREE.Vector3());\n            g.vertices.push(projected.sub(tile.center));\n        }\n\n        for (let i = 1; i < points.length - 1; i++) {\n            g.faces.push(isNorthPole ? new THREE.Face3(0, i, i + 1) : new THREE.Face3(0, i + 1, i));\n        }\n\n        const geometry = new THREE.BufferGeometry();\n        geometry.fromGeometry(g);\n        g.dispose();\n\n        const mesh = new THREE.Mesh(geometry, material);\n        mesh.userData = {\n            dataSource: this.name,\n            tileKey: tile.tileKey\n        };\n\n        if (this.m_debugTiles) {\n            const color = Math.round(Math.abs(Math.sin(11 * tile.tileKey.mortonCode())) * 0xffffff);\n            mesh.material = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.5 });\n\n            tile.objects.push(\n                new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ color, wireframe: true }))\n            );\n        }\n\n        tile.objects.push(mesh);\n    }\n}\n","!function(t,i){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=i():\"function\"==typeof define&&define.amd?define(i):(t=t||self).RBush=i()}(this,function(){\"use strict\";function t(t,r,e,a,h){!function t(n,r,e,a,h){for(;a>e;){if(a-e>600){var o=a-e+1,s=r-e+1,l=Math.log(o),f=.5*Math.exp(2*l/3),u=.5*Math.sqrt(l*f*(o-f)/o)*(s-o/2<0?-1:1),m=Math.max(e,Math.floor(r-s*f/o+u)),c=Math.min(a,Math.floor(r+(o-s)*f/o+u));t(n,r,m,c,h)}var p=n[r],d=e,x=a;for(i(n,e,r),h(n[a],p)>0&&i(n,e,a);d<x;){for(i(n,d,x),d++,x--;h(n[d],p)<0;)d++;for(;h(n[x],p)>0;)x--}0===h(n[e],p)?i(n,e,x):i(n,++x,a),x<=r&&(e=x+1),r<=x&&(a=x-1)}}(t,r,e||0,a||t.length-1,h||n)}function i(t,i,n){var r=t[i];t[i]=t[n],t[n]=r}function n(t,i){return t<i?-1:t>i?1:0}var r=function(t){void 0===t&&(t=9),this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()};function e(t,i,n){if(!n)return i.indexOf(t);for(var r=0;r<i.length;r++)if(n(t,i[r]))return r;return-1}function a(t,i){h(t,0,t.children.length,i,t)}function h(t,i,n,r,e){e||(e=p(null)),e.minX=1/0,e.minY=1/0,e.maxX=-1/0,e.maxY=-1/0;for(var a=i;a<n;a++){var h=t.children[a];o(e,t.leaf?r(h):h)}return e}function o(t,i){return t.minX=Math.min(t.minX,i.minX),t.minY=Math.min(t.minY,i.minY),t.maxX=Math.max(t.maxX,i.maxX),t.maxY=Math.max(t.maxY,i.maxY),t}function s(t,i){return t.minX-i.minX}function l(t,i){return t.minY-i.minY}function f(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function u(t){return t.maxX-t.minX+(t.maxY-t.minY)}function m(t,i){return t.minX<=i.minX&&t.minY<=i.minY&&i.maxX<=t.maxX&&i.maxY<=t.maxY}function c(t,i){return i.minX<=t.maxX&&i.minY<=t.maxY&&i.maxX>=t.minX&&i.maxY>=t.minY}function p(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function d(i,n,r,e,a){for(var h=[n,r];h.length;)if(!((r=h.pop())-(n=h.pop())<=e)){var o=n+Math.ceil((r-n)/e/2)*e;t(i,o,n,r,a),h.push(n,o,o,r)}}return r.prototype.all=function(){return this._all(this.data,[])},r.prototype.search=function(t){var i=this.data,n=[];if(!c(t,i))return n;for(var r=this.toBBox,e=[];i;){for(var a=0;a<i.children.length;a++){var h=i.children[a],o=i.leaf?r(h):h;c(t,o)&&(i.leaf?n.push(h):m(t,o)?this._all(h,n):e.push(h))}i=e.pop()}return n},r.prototype.collides=function(t){var i=this.data;if(!c(t,i))return!1;for(var n=[];i;){for(var r=0;r<i.children.length;r++){var e=i.children[r],a=i.leaf?this.toBBox(e):e;if(c(t,a)){if(i.leaf||m(t,a))return!0;n.push(e)}}i=n.pop()}return!1},r.prototype.load=function(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(var i=0;i<t.length;i++)this.insert(t[i]);return this}var n=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===n.height)this._splitRoot(this.data,n);else{if(this.data.height<n.height){var r=this.data;this.data=n,n=r}this._insert(n,this.data.height-n.height-1,!0)}else this.data=n;return this},r.prototype.insert=function(t){return t&&this._insert(t,this.data.height-1),this},r.prototype.clear=function(){return this.data=p([]),this},r.prototype.remove=function(t,i){if(!t)return this;for(var n,r,a,h=this.data,o=this.toBBox(t),s=[],l=[];h||s.length;){if(h||(h=s.pop(),r=s[s.length-1],n=l.pop(),a=!0),h.leaf){var f=e(t,h.children,i);if(-1!==f)return h.children.splice(f,1),s.push(h),this._condense(s),this}a||h.leaf||!m(h,o)?r?(n++,h=r.children[n],a=!1):h=null:(s.push(h),l.push(n),n=0,r=h,h=h.children[0])}return this},r.prototype.toBBox=function(t){return t},r.prototype.compareMinX=function(t,i){return t.minX-i.minX},r.prototype.compareMinY=function(t,i){return t.minY-i.minY},r.prototype.toJSON=function(){return this.data},r.prototype.fromJSON=function(t){return this.data=t,this},r.prototype._all=function(t,i){for(var n=[];t;)t.leaf?i.push.apply(i,t.children):n.push.apply(n,t.children),t=n.pop();return i},r.prototype._build=function(t,i,n,r){var e,h=n-i+1,o=this._maxEntries;if(h<=o)return a(e=p(t.slice(i,n+1)),this.toBBox),e;r||(r=Math.ceil(Math.log(h)/Math.log(o)),o=Math.ceil(h/Math.pow(o,r-1))),(e=p([])).leaf=!1,e.height=r;var s=Math.ceil(h/o),l=s*Math.ceil(Math.sqrt(o));d(t,i,n,l,this.compareMinX);for(var f=i;f<=n;f+=l){var u=Math.min(f+l-1,n);d(t,f,u,s,this.compareMinY);for(var m=f;m<=u;m+=s){var c=Math.min(m+s-1,u);e.children.push(this._build(t,m,c,r-1))}}return a(e,this.toBBox),e},r.prototype._chooseSubtree=function(t,i,n,r){for(;r.push(i),!i.leaf&&r.length-1!==n;){for(var e=1/0,a=1/0,h=void 0,o=0;o<i.children.length;o++){var s=i.children[o],l=f(s),u=(m=t,c=s,(Math.max(c.maxX,m.maxX)-Math.min(c.minX,m.minX))*(Math.max(c.maxY,m.maxY)-Math.min(c.minY,m.minY))-l);u<a?(a=u,e=l<e?l:e,h=s):u===a&&l<e&&(e=l,h=s)}i=h||i.children[0]}var m,c;return i},r.prototype._insert=function(t,i,n){var r=n?t:this.toBBox(t),e=[],a=this._chooseSubtree(r,this.data,i,e);for(a.children.push(t),o(a,r);i>=0&&e[i].children.length>this._maxEntries;)this._split(e,i),i--;this._adjustParentBBoxes(r,e,i)},r.prototype._split=function(t,i){var n=t[i],r=n.children.length,e=this._minEntries;this._chooseSplitAxis(n,e,r);var h=this._chooseSplitIndex(n,e,r),o=p(n.children.splice(h,n.children.length-h));o.height=n.height,o.leaf=n.leaf,a(n,this.toBBox),a(o,this.toBBox),i?t[i-1].children.push(o):this._splitRoot(n,o)},r.prototype._splitRoot=function(t,i){this.data=p([t,i]),this.data.height=t.height+1,this.data.leaf=!1,a(this.data,this.toBBox)},r.prototype._chooseSplitIndex=function(t,i,n){for(var r,e,a,o,s,l,u,m=1/0,c=1/0,p=i;p<=n-i;p++){var d=h(t,0,p,this.toBBox),x=h(t,p,n,this.toBBox),v=(e=d,a=x,o=void 0,s=void 0,l=void 0,u=void 0,o=Math.max(e.minX,a.minX),s=Math.max(e.minY,a.minY),l=Math.min(e.maxX,a.maxX),u=Math.min(e.maxY,a.maxY),Math.max(0,l-o)*Math.max(0,u-s)),M=f(d)+f(x);v<m?(m=v,r=p,c=M<c?M:c):v===m&&M<c&&(c=M,r=p)}return r||n-i},r.prototype._chooseSplitAxis=function(t,i,n){var r=t.leaf?this.compareMinX:s,e=t.leaf?this.compareMinY:l;this._allDistMargin(t,i,n,r)<this._allDistMargin(t,i,n,e)&&t.children.sort(r)},r.prototype._allDistMargin=function(t,i,n,r){t.children.sort(r);for(var e=this.toBBox,a=h(t,0,i,e),s=h(t,n-i,n,e),l=u(a)+u(s),f=i;f<n-i;f++){var m=t.children[f];o(a,t.leaf?e(m):m),l+=u(a)}for(var c=n-i-1;c>=i;c--){var p=t.children[c];o(s,t.leaf?e(p):p),l+=u(s)}return l},r.prototype._adjustParentBBoxes=function(t,i,n){for(var r=n;r>=0;r--)o(i[r],t)},r.prototype._condense=function(t){for(var i=t.length-1,n=void 0;i>=0;i--)0===t[i].children.length?i>0?(n=t[i-1].children).splice(n.indexOf(t[i]),1):this.clear():a(t[i],this.toBBox)},r});\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { CubemapSky } from \"@here/harp-datasource-protocol\";\nimport { LoggerManager } from \"@here/harp-utils\";\nimport { CubeTexture, CubeTextureLoader, Texture } from \"three\";\n\nconst logger = LoggerManager.instance.create(\"SkyCubemapTexture\");\n\n/**\n * Number of faces that form a [[SkyCubemapTexture]].\n */\nexport const SKY_CUBEMAP_FACE_COUNT = 6;\n\n/**\n * Maps the faceId to the expected position in the threejs faces array.\n */\nexport enum SkyCubemapFaceId {\n    \"positiveX\",\n    \"negativeX\",\n    \"positiveY\",\n    \"negativeY\",\n    \"positiveZ\",\n    \"negativeZ\"\n}\n\n/**\n * Class that handles loading all 6 faces of a [[CubeTexture]], to be used with [[SkyBackground]].\n */\nexport class SkyCubemapTexture {\n    private m_skybox: CubeTexture;\n\n    /**\n     * Constructs a new `SkyCubemapTexture`.\n     *\n     * @param sky Initial [[CubemapSky]] configuration.\n     */\n    constructor(sky: CubemapSky) {\n        const faces = this.createCubemapFaceArray(sky);\n        this.m_skybox =\n            faces !== undefined ? new CubeTextureLoader().load(faces) : new CubeTexture();\n    }\n\n    /**\n     * Disposes allocated resources.\n     */\n    dispose() {\n        this.m_skybox.dispose();\n    }\n\n    /**\n     * `SkyCubemapTexture`'s texture resource.\n     */\n    get texture(): Texture {\n        return this.m_skybox;\n    }\n\n    /**\n     * Updates the `SkyCubemapTexture` with new parameters.\n     *\n     * @param params New [[CubemapSky]] configuration.\n     */\n    updateTexture(sky: CubemapSky) {\n        const faces = this.createCubemapFaceArray(sky);\n        if (faces === undefined) {\n            return;\n        }\n        this.m_skybox = new CubeTextureLoader().load(faces);\n    }\n\n    private createCubemapFaceArray(sky: CubemapSky): string[] | undefined {\n        const faces: Array<string | undefined> = [\n            undefined,\n            undefined,\n            undefined,\n            undefined,\n            undefined,\n            undefined\n        ];\n        for (let i = 0; i < SKY_CUBEMAP_FACE_COUNT; ++i) {\n            const face: string | undefined = (sky as any)[SkyCubemapFaceId[i]];\n            if (face === undefined) {\n                logger.error(`Face \"${SkyCubemapFaceId[i]}\" was not defined.`);\n                return;\n            }\n            faces[i] = face;\n        }\n\n        return faces as string[];\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    Definitions,\n    isActualSelectorDefinition,\n    isJsonExprReference,\n    isValueDefinition,\n    ResolvedStyleDeclaration,\n    ResolvedStyleSet,\n    StyleDeclaration,\n    StyleSet,\n    Theme\n} from \"@here/harp-datasource-protocol/lib/Theme\";\nimport {\n    cloneDeep,\n    composeUriResolvers,\n    ContextLogger,\n    getAppBaseUrl,\n    getOptionValue,\n    IContextLogger,\n    ISimpleChannel,\n    RelativeUriResolver,\n    resolveReferenceUri,\n    UriResolver\n} from \"@here/harp-utils\";\nimport { SKY_CUBEMAP_FACE_COUNT, SkyCubemapFaceId } from \"./SkyCubemapTexture\";\n\nimport \"@here/harp-fetch\";\n\nexport const DEFAULT_MAX_THEME_INTHERITANCE_DEPTH = 4;\n\n/**\n * Options to customize [[Theme]] loading process.\n *\n * @see [[ThemeLoader.load]]\n */\nexport interface ThemeLoadOptions {\n    /**\n     * Whether to resolve `ref` expressions in `definition` and `styles` elements.\n     *\n     * @default `false`, as datasources resolve definitions in [[StyleSetEvaluator]].\n     */\n    resolveDefinitions?: boolean;\n\n    /**\n     * An `AbortSignal` object instance; allows you to communicate with a loading process\n     * (including fetch requests) request and abort it if desired via an `AbortController`.\n     *\n     * Modeled after Web APIs `fetch`s `init.signal`.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/AbortController\n     */\n    signal?: AbortSignal;\n\n    /**\n     * Maximum recursion depth when resolving base themes through [[[Theme]]s `extends` property.\n     *\n     * @default [[DEFAULT_MAX_THEME_INTHERITANCE_DEPTH]]\n     */\n    maxInheritanceDepth?: number;\n\n    /**\n     * Custom logging channel on which diagnostics and warnings will be reported.\n     *\n     * If not specified, [[ThemeLoader.load]] will log to `console`.\n     */\n    logger?: ISimpleChannel;\n\n    /**\n     * Resolve asset `URI`s referenced in `Theme` assets using this resolver.\n     */\n    uriResolver?: UriResolver;\n}\n\n/**\n * Loads and validates a theme from URL objects.\n */\nexport class ThemeLoader {\n    /**\n     * Loads a [[Theme]] from a remote resource, provided as a URL that points to a\n     * JSON-encoded theme.\n     *\n     * By default, resolves following features of theme:\n     *\n     *  -  `extends` - loads and merges all inherited themes (see [[resolveBaseTheme]])\n     *  -  `ref` - resolves all `ref` instances to their values defined in `definitions` section\n     *     of theme (see [[resolveThemeReferences]])\n     *\n     * Relative URIs of reference resources are resolved to full URL using the document's base URL\n     * (see [[resolveUrls]]).\n     *\n     * Custom URIs (of theme itself and of resources referenced by theme) may be resolved with by\n     * providing [[UriResolver]] using [[ThemeLoadOptions.uriResolver]] option.\n     *\n     * @param theme [[Theme]] instance or theme URL to the theme.\n     * @param options Optional, a [[ThemeLoadOptions]] objects containing any custom settings for\n     *    this load request.\n     */\n    static async load(theme: string | Theme, options?: ThemeLoadOptions): Promise<Theme> {\n        options = options || {};\n        if (typeof theme === \"string\") {\n            const uriResolver = options.uriResolver;\n            const themeUrl = uriResolver !== undefined ? uriResolver.resolveUri(theme) : theme;\n\n            const response = await fetch(themeUrl, { signal: options.signal });\n            if (!response.ok) {\n                throw new Error(`ThemeLoader#load: cannot load theme: ${response.statusText}`);\n            }\n            theme = (await response.json()) as Theme;\n            theme.url = resolveReferenceUri(getAppBaseUrl(), themeUrl);\n            theme = this.resolveUrls(theme, uriResolver);\n        } else if (theme.url === undefined) {\n            // assume that theme url is same as baseUrl\n            theme.url = getAppBaseUrl();\n            theme = this.resolveUrls(theme, options.uriResolver);\n        }\n\n        if (theme === null || theme === undefined) {\n            throw new Error(\"ThemeLoader#load: loaded resource is not valid JSON\");\n        }\n        theme = theme as Theme;\n\n        ThemeLoader.checkTechniqueSupport(theme);\n\n        const resolveDefinitions = getOptionValue<boolean>(options.resolveDefinitions, false);\n        theme = await ThemeLoader.resolveBaseThemes(theme, options);\n        if (resolveDefinitions) {\n            const contextLoader = new ContextLogger(\n                options.logger || console,\n                `when processing Theme ${theme.url}:`\n            );\n            ThemeLoader.resolveThemeReferences(theme, contextLoader);\n        }\n        return theme;\n    }\n\n    /**\n     * Checks if `theme` instance is completely loaded, meaning that `extends` property is resolved.\n     *\n     * @param theme\n     */\n    static isThemeLoaded(theme: Theme): boolean {\n        return theme.extends === undefined;\n    }\n\n    /**\n     * @deprecated Please use `ThemeLoader.load`\n     *\n     * Loads a [[Theme]] from a remote resource, provided as a URL that points to a JSON-encoded\n     * theme.\n     *\n     * @param themeUrl The URL to the theme.\n     *\n     */\n    static async loadAsync(themeUrl: string): Promise<Theme> {\n        return ThemeLoader.load(themeUrl);\n    }\n\n    /**\n     * Resolves all [[Theme]]'s relatives URLs to full URL using the [[Theme]]'s URL\n     * (see: https://www.w3.org/TR/WD-html40-970917/htmlweb.html#h-5.1.2).\n     *\n     * This method mutates original `theme` instance.\n     *\n     * @param theme The [[Theme]] to resolve.\n     */\n    static resolveUrls(theme: Theme, uriResolver?: UriResolver): Theme {\n        // Ensure that all resources referenced in theme by relative URIs are in fact relative to\n        // theme.\n        if (theme.url === undefined) {\n            return theme;\n        }\n\n        const childUrlResolver = composeUriResolvers(\n            new RelativeUriResolver(theme.url),\n            uriResolver\n        );\n\n        if (theme.extends) {\n            theme.extends = (Array.isArray(theme.extends) ? theme.extends : [theme.extends]).map(\n                baseTheme => {\n                    if (typeof baseTheme === \"string\") {\n                        return childUrlResolver.resolveUri(baseTheme);\n                    } else {\n                        if (baseTheme.url !== undefined) {\n                            return baseTheme;\n                        } else {\n                            baseTheme.url = theme.url;\n                            return this.resolveUrls(baseTheme, uriResolver);\n                        }\n                    }\n                }\n            );\n        }\n\n        if (theme.sky && theme.sky.type === \"cubemap\") {\n            for (let i = 0; i < SKY_CUBEMAP_FACE_COUNT; ++i) {\n                const faceUrl: string | undefined = (theme.sky as any)[SkyCubemapFaceId[i]];\n                if (faceUrl !== undefined) {\n                    (theme.sky as any)[SkyCubemapFaceId[i]] = childUrlResolver.resolveUri(faceUrl);\n                }\n            }\n        }\n        if (theme.images) {\n            for (const name of Object.keys(theme.images)) {\n                const image = theme.images[name];\n                image.url = childUrlResolver.resolveUri(image.url);\n\n                if (image.atlas !== undefined) {\n                    image.atlas = childUrlResolver.resolveUri(image.atlas);\n                }\n            }\n        }\n        if (theme.fontCatalogs) {\n            for (const font of theme.fontCatalogs) {\n                font.url = childUrlResolver.resolveUri(font.url);\n            }\n        }\n        if (theme.poiTables) {\n            for (const poiTable of theme.poiTables) {\n                poiTable.url = childUrlResolver.resolveUri(poiTable.url);\n            }\n        }\n\n        if (theme.styles) {\n            for (const styleSetName in theme.styles) {\n                if (!theme.styles.hasOwnProperty(styleSetName)) {\n                    continue;\n                }\n                const styleSet = theme.styles[styleSetName] as ResolvedStyleDeclaration[];\n                for (const style of styleSet) {\n                    if (!style.attr) {\n                        continue;\n                    }\n                    [\"map\", \"normalMap\", \"displacementMap\", \"roughnessMap\"].forEach(\n                        texturePropertyName => {\n                            const textureProperty = (style.attr! as any)[texturePropertyName];\n                            if (textureProperty && typeof textureProperty === \"string\") {\n                                (style.attr! as any)[\n                                    texturePropertyName\n                                ] = childUrlResolver.resolveUri(textureProperty);\n                            }\n                        }\n                    );\n                }\n            }\n        }\n        return theme;\n    }\n\n    static checkTechniqueSupport(theme: Theme) {\n        if (theme.styles !== undefined) {\n            for (const styleSetName in theme.styles) {\n                if (!theme.styles.hasOwnProperty(styleSetName)) {\n                    continue;\n                }\n                for (const style of theme.styles[styleSetName]) {\n                    switch ((style as any).technique) {\n                        // TODO: Re-enable this once \"dashed-line\" is deprecated.\n                        /* case \"dashed-line\":\n                            console.warn(\n                                `Using deprecated \"dashed-line\" technique.\n                                Use \"solid-line\" technique instead`\n                            ); */\n                        default:\n                            break;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Expand all `ref` expressions in [[Theme]] basing on `definitions`.\n     *\n     * This method mutates original `theme` instance.\n     */\n    static resolveThemeReferences(theme: Theme, contextLogger: IContextLogger): Theme {\n        if (theme.definitions !== undefined) {\n            contextLogger.pushAttr(\"definitions\");\n            /**\n             * First, try to resolve all internal references in definitions, so if we may save few\n             * CPU cycles if some definition is used many times in actual style sets.\n             */\n            for (const definitionName in theme.definitions) {\n                if (!theme.definitions.hasOwnProperty(definitionName)) {\n                    continue;\n                }\n\n                const def = theme.definitions[definitionName];\n                if (isActualSelectorDefinition(def)) {\n                    contextLogger.pushAttr(definitionName);\n                    const resolvedDef = ThemeLoader.resolveStyle(\n                        def,\n                        theme.definitions,\n                        contextLogger\n                    );\n                    contextLogger.pop();\n                    if (resolvedDef === undefined) {\n                        contextLogger.pushAttr(definitionName);\n                        contextLogger.warn(\"skipping invalid style in definition\");\n                        contextLogger.pop();\n                        delete theme.definitions[definitionName];\n                    } else {\n                        theme.definitions[definitionName] = resolvedDef;\n                    }\n                }\n            }\n            contextLogger.pop();\n        }\n        if (theme.styles !== undefined) {\n            for (const styleSetName in theme.styles) {\n                if (!theme.styles.hasOwnProperty(styleSetName)) {\n                    continue;\n                }\n                contextLogger.pushAttr(\"styles\");\n                contextLogger.pushAttr(styleSetName);\n\n                theme.styles[styleSetName] = ThemeLoader.resolveStyleSet(\n                    theme.styles[styleSetName],\n                    theme.definitions,\n                    contextLogger\n                );\n                contextLogger.pop();\n                contextLogger.pop();\n            }\n        }\n        return theme;\n    }\n\n    /**\n     * Expand all `ref` in [[StyleSet]] basing on `definitions`.\n     */\n    static resolveStyleSet(\n        styleSet: StyleSet,\n        definitions: Definitions | undefined,\n        contextLogger: IContextLogger\n    ): ResolvedStyleSet {\n        const result: ResolvedStyleSet = [];\n\n        for (let index = 0; index < styleSet.length; ++index) {\n            const currentStyle = styleSet[index];\n            contextLogger.pushIndex(index);\n            const resolvedStyle = ThemeLoader.resolveStyle(\n                currentStyle,\n                definitions,\n                contextLogger\n            );\n            if (resolvedStyle !== undefined) {\n                result.push(resolvedStyle);\n            } else {\n                contextLogger.warn(\"invalid style, ignored\");\n            }\n            contextLogger.pop();\n        }\n        return result;\n    }\n\n    /**\n     * Expand all `ref` in [[Style]] instance basing on `definitions`.\n     */\n    static resolveStyle(\n        style: StyleDeclaration,\n        definitions: Definitions | undefined,\n        contextLogger: IContextLogger\n    ): ResolvedStyleDeclaration | undefined {\n        if (isJsonExprReference(style)) {\n            // expand and instantiate references to style definitions.\n\n            const def = definitions && definitions[style[1]];\n\n            if (!def) {\n                contextLogger.warn(`invalid reference '${style[1]}' - not found`);\n                return undefined;\n            }\n            if (!isActualSelectorDefinition(def)) {\n                contextLogger.warn(`invalid reference '${style[1]}' - expected style definition`);\n                return undefined;\n            }\n\n            // instantiate the style\n            style = cloneDeep(def);\n        }\n        style = style as ResolvedStyleDeclaration;\n\n        if (Array.isArray(style.when)) {\n            contextLogger.pushAttr(\"when\");\n            const resolvedWhen = this.resolveExpressionReferences(\n                style.when,\n                definitions,\n                contextLogger\n            );\n            contextLogger.pop();\n            if (resolvedWhen === undefined) {\n                return undefined;\n            }\n            style.when = resolvedWhen;\n        }\n\n        if (style.attr !== undefined) {\n            const attr = style.attr as any;\n\n            contextLogger.pushAttr(\"attr\");\n            for (const prop in attr) {\n                if (!attr.hasOwnProperty(prop)) {\n                    continue;\n                }\n\n                const value = attr[prop];\n\n                if (!Array.isArray(value)) {\n                    continue; // nothing to do\n                }\n\n                contextLogger.pushAttr(prop);\n                const resolvedValue = this.resolveExpressionReferences(\n                    value,\n                    definitions,\n                    contextLogger\n                );\n                contextLogger.pop();\n\n                if (resolvedValue !== undefined) {\n                    attr[prop] = resolvedValue;\n                } else {\n                    delete attr[prop];\n                }\n            }\n            contextLogger.pop();\n        }\n        return style;\n    }\n\n    /**\n     * Resolve `[ref, ...]` in expressions.\n     *\n     * Returns `undefined` some reference was invalid (missing or wrong type).\n     */\n    static resolveExpressionReferences<T>(\n        value: T,\n        definitions: Definitions | undefined,\n        contextLogger: IContextLogger\n    ): T | undefined {\n        let failed = false;\n        function resolveInternal(node: any) {\n            if (isJsonExprReference(node)) {\n                const defName = node[1];\n                const def = definitions && definitions[defName];\n                if (def === undefined) {\n                    contextLogger.warn(`invalid reference '${defName}' - not found`);\n                    failed = true;\n                    return undefined;\n                }\n                if (!isValueDefinition(def)) {\n                    contextLogger.warn(\n                        `invalid reference '${defName}' - expected value definition`\n                    );\n                    failed = true;\n                    return undefined;\n                }\n                return def.value;\n            } else if (Array.isArray(node)) {\n                const result = [...node];\n                for (let i = 1; i < result.length; ++i) {\n                    result[i] = resolveInternal(result[i]);\n                }\n                return result;\n            } else {\n                return node;\n            }\n        }\n        const r = resolveInternal(value);\n        if (failed) {\n            return undefined;\n        }\n        return r;\n    }\n\n    /**\n     * Realize `extends` clause by merging `theme` with its base [[Theme]].\n     *\n     * @param theme [Theme] object\n     * @param options Optional, a [[ThemeLoadOptions]] objects containing any custom settings for\n     *    this load request.\n     */\n    static async resolveBaseThemes(theme: Theme, options?: ThemeLoadOptions): Promise<Theme> {\n        options = options || {};\n        if (theme.extends === undefined) {\n            return theme;\n        }\n\n        const maxInheritanceDepth = getOptionValue(\n            options.maxInheritanceDepth,\n            DEFAULT_MAX_THEME_INTHERITANCE_DEPTH\n        );\n        if (maxInheritanceDepth <= 0) {\n            throw new Error(`maxInheritanceDepth reached when attempting to load base theme`);\n        }\n\n        const baseThemes = !Array.isArray(theme.extends) ? [theme.extends] : theme.extends;\n        delete theme.extends;\n        let baseThemesMerged: Theme = {};\n        for (const baseTheme of baseThemes) {\n            const actualBaseTheme = await ThemeLoader.load(baseTheme, {\n                ...options,\n                resolveDefinitions: false,\n                maxInheritanceDepth: maxInheritanceDepth - 1\n            });\n\n            baseThemesMerged = ThemeLoader.mergeThemes(actualBaseTheme, baseThemesMerged);\n        }\n        return ThemeLoader.mergeThemes(theme, baseThemesMerged);\n    }\n\n    static mergeThemes(theme: Theme, baseTheme: Theme): Theme {\n        const definitions = { ...baseTheme.definitions, ...theme.definitions };\n        const styles = { ...baseTheme.styles, ...theme.styles };\n        return { ...baseTheme, ...theme, definitions, styles };\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { ViewRanges } from \"@here/harp-datasource-protocol/lib/ViewRanges\";\nimport {\n    GeoCoordinates,\n    Projection,\n    TileKey,\n    TileKeyUtils,\n    TilingScheme\n} from \"@here/harp-geoutils\";\nimport { LRUCache } from \"@here/harp-lrucache\";\nimport { assert, MathUtils } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\nimport { ClipPlanesEvaluator } from \"./ClipPlanesEvaluator\";\nimport { DataSource } from \"./DataSource\";\nimport { ElevationRangeSource } from \"./ElevationRangeSource\";\nimport { FrustumIntersection, TileKeyEntry } from \"./FrustumIntersection\";\nimport { TileGeometryManager } from \"./geometry/TileGeometryManager\";\nimport { Tile } from \"./Tile\";\nimport { MapViewUtils, TileOffsetUtils } from \"./Utils\";\n\n/**\n * Way the memory consumption of a tile is computed. Either in number of tiles, or in MegaBytes. If\n * it is in MB, an estimation is used.\n */\nexport enum ResourceComputationType {\n    EstimationInMb = 0,\n    NumberOfTiles\n}\n\n/**\n * Limited set of [[MapViewOptions]] used for [[VisibleTileSet]].\n */\nexport interface VisibleTileSetOptions {\n    /**\n     * The projection of the view.\n     */\n    projection: Projection;\n\n    /**\n     * User-defined camera clipping planes evaluator.\n     */\n    clipPlanesEvaluator: ClipPlanesEvaluator;\n\n    /**\n     * Limit of tiles that can be visible per datasource.\n     */\n    maxVisibleDataSourceTiles: number;\n\n    /**\n     * In addition to the simple frustum culling also do additional checks with [[MapTileCuller]].\n     */\n    extendedFrustumCulling: boolean;\n\n    /**\n     * Missing Typedoc\n     */\n    tileCacheSize: number;\n\n    /**\n     * Missing Typedoc\n     */\n    resourceComputationType: ResourceComputationType;\n\n    /**\n     * Number of levels to go up when searching for fallback tiles.\n     */\n    quadTreeSearchDistanceUp: number;\n\n    /**\n     * Number of levels to go down when searching for fallback tiles.\n     */\n    quadTreeSearchDistanceDown: number;\n}\n\nconst MB_FACTOR = 1.0 / (1024.0 * 1024.0);\n\ntype TileCacheId = string;\n\n/**\n * Wrapper for LRU cache that encapsulates tiles caching for any [[DataSource]] used.\n *\n * Provides LRU based caching mechanism where each tile is identified by its tile key\n * (morton code) and data source name.\n * Tiles are kept in the cache based on last recently used policy, cached tile may be evicted\n * only when cache reaches full saturation and tile is no longer visible.\n * @note Currently cached entries (tiles) are identified by unique tile code (morton code) and\n * data source name, thus it is required that each [[DataSource]] used should have unique\n * name, but implementation could be improved to omit this limitation.\n */\nclass DataSourceCache {\n    /**\n     * Creates unique tile key for caching based on morton code, tile offset and its data source.\n     *\n     * @param mortonCode The tile morton code.\n     * @param offset The tile offset.\n     * @param dataSource The [[DataSource]] from which tile was loaded.\n     */\n    static getKey(mortonCode: number, offset: number, dataSource: DataSource): TileCacheId {\n        return `${dataSource.name}_${mortonCode}_${offset}`;\n    }\n\n    /**\n     * Create unique tile identifier for caching, based on tile object passed in.\n     *\n     * @param tile The tile for which key is generated.\n     */\n    static getKeyForTile(tile: Tile): TileCacheId {\n        return DataSourceCache.getKey(tile.tileKey.mortonCode(), tile.offset, tile.dataSource);\n    }\n\n    private readonly m_tileCache: LRUCache<TileCacheId, Tile>;\n    private readonly m_disposedTiles: Tile[] = [];\n    private m_resourceComputationType: ResourceComputationType;\n\n    constructor(\n        cacheSize: number,\n        rct: ResourceComputationType = ResourceComputationType.EstimationInMb\n    ) {\n        this.m_resourceComputationType = rct;\n        this.m_tileCache = new LRUCache<string, Tile>(cacheSize, (tile: Tile) => {\n            if (this.m_resourceComputationType === ResourceComputationType.EstimationInMb) {\n                // Default is size in MB.\n                return tile.memoryUsage * MB_FACTOR;\n            } else {\n                return 1;\n            }\n        });\n        this.m_tileCache.evictionCallback = (_, tile) => {\n            if (tile.tileLoader !== undefined) {\n                // Cancel downloads as early as possible.\n                tile.tileLoader.cancel();\n            }\n            this.m_disposedTiles.push(tile);\n        };\n        this.m_tileCache.canEvict = (_, tile) => {\n            // Tiles can be evicted that weren't requested in the last frame.\n            return !tile.isVisible;\n        };\n    }\n\n    /**\n     * Get information how cached tiles affects cache space available.\n     *\n     * The way how cache evaluates the __resources size__ have a big influence on entire\n     * caching mechanism, if [[resourceComputationType]] is set to:\n     * [[ResourceComputationType.EstimationInMb]] then each tiles contributes to cache size\n     * differently depending on the memory consumed, on other side\n     * [[ResourceComputationType.NumberOfTiles]] says each tile occupies single slot in cache,\n     * so its real memory consumed does not matter affect caching behavior. Of course in\n     * the second scenario cache may grow significantly in terms of memory usage and thus it\n     * is out of control.\n     *\n     * @return [[ResourceComputationType]] enum that describes if resources are counted by\n     * space occupied in memory or just by number of them.\n     */\n    get resourceComputationType(): ResourceComputationType {\n        return this.m_resourceComputationType;\n    }\n\n    /**\n     * Get the cache capacity measured as number if megabytes or number of entries.\n     *\n     * The total cached tiles size determines cache saturation, if it reaches the capacity value\n     * then the resources becomes evicted (released) starting from the oldest (the latest used).\n     *\n     * @see size.\n     * @see resourceComputationType.\n     */\n    get capacity(): number {\n        return this.m_tileCache.capacity;\n    }\n\n    /**\n     * Get total cache size described as number of megabytes consumed or number of tiles stored.\n     *\n     * @see capacity.\n     * @see resourceComputationType.\n     */\n    get size(): number {\n        return this.m_tileCache.size;\n    }\n\n    /**\n     * Set cache capacity and the algorithm used for cache size calculation.\n     *\n     * @see capacity.\n     * @see resourceComputationType.\n     * @param size The new capacity declared in megabytes or number of entires.\n     * @param rct The enum value that determines how size and capacity are evaluated.\n     */\n    setCapacity(size: number, rct: ResourceComputationType) {\n        this.m_resourceComputationType = rct;\n        this.m_tileCache.setCapacityAndMeasure(size, (tile: Tile) => {\n            if (this.m_resourceComputationType === ResourceComputationType.EstimationInMb) {\n                // Default is size in MB.\n                return tile.memoryUsage * MB_FACTOR;\n            } else {\n                return 1;\n            }\n        });\n    }\n\n    /**\n     * Get tile cached or __undefined__ if tile is not yet in cache.\n     *\n     * @param mortonCode En unique tile morton code.\n     * @param offset Tile offset.\n     * @param dataSource A [[DataSource]] the tile comes from.\n     */\n    get(mortonCode: number, offset: number, dataSource: DataSource): Tile | undefined {\n        return this.m_tileCache.get(DataSourceCache.getKey(mortonCode, offset, dataSource));\n    }\n\n    /**\n     * Add new tile to the cache.\n     *\n     * @param mortonCode En unique tile code (morton code).\n     * @param offset The tile offset.\n     * @param dataSource A [[DataSource]] the tile comes from.\n     * @param tile The tile reference.\n     */\n    set(mortonCode: number, offset: number, dataSource: DataSource, tile: Tile) {\n        this.m_tileCache.set(DataSourceCache.getKey(mortonCode, offset, dataSource), tile);\n    }\n\n    /**\n     * Delete tile from cache.\n     *\n     * @note This method will not call eviction callback.\n     * @param tile The tile reference to be removed from cache.\n     */\n    delete(tile: Tile) {\n        const tileKey = DataSourceCache.getKeyForTile(tile);\n        this.deleteByKey(tileKey);\n    }\n\n    /**\n     * Delete tile using its unique identifier.\n     *\n     * @note Tile identifier its constructed using information about tile code (morton code) and its\n     * [[DataSource]].\n     * @note This is explicit removal thus eviction callback will not be processed.\n     * @see DataSourceCache.getKey.\n     * @param tileKey The unique tile identifier.\n     */\n    deleteByKey(tileKey: TileCacheId) {\n        this.m_tileCache.delete(tileKey);\n    }\n\n    /**\n     * Dispose all tiles releasing their internal data.\n     */\n    disposeTiles() {\n        this.m_disposedTiles.forEach(tile => {\n            tile.dispose();\n        });\n\n        this.m_disposedTiles.length = 0;\n    }\n\n    /**\n     * Shrink cache to its allowed capacity.\n     *\n     * This method should be called each time after operations are performed on the cache entries,\n     * in order to keep cache size consistent. It informs caching mechanism to invalidate memory\n     * consumed by its entries and check if cache is overgrown, is such case some tiles will be\n     * evicted.\n     */\n    shrinkToCapacity() {\n        this.m_tileCache.shrinkToCapacity();\n    }\n\n    /**\n     * Evict all cached tiles implicitly even without checking if still in use.\n     */\n    evictAll() {\n        this.m_tileCache.evictAll();\n    }\n\n    /**\n     * Evict selected tiles implicitly.\n     *\n     * @param selector The callback used to determine if tile should be evicted.\n     */\n    evictSelected(selector: (tile: Tile, key: TileCacheId) => boolean) {\n        this.m_tileCache.evictSelected(selector);\n    }\n\n    /**\n     * Call functor (callback) on each tile store in cache.\n     *\n     * Optionally you may specify from which [[DataSource]] tiles should be processed.\n     * This limits the tiles visited to a sub-set originating from single [[DataSource]].\n     * @param callback The function to be called for each visited tile.\n     * @param inDataSource The optional [[DataSource]] to which tiles should belong.\n     */\n    forEach(callback: (tile: Tile, key: TileCacheId) => void, inDataSource?: DataSource): void {\n        this.m_tileCache.forEach((entry: Tile, key: TileCacheId) => {\n            if (inDataSource === undefined || entry.dataSource === inDataSource) {\n                callback(entry, key);\n            }\n        });\n    }\n}\n\n/**\n * List of visible tiles for a [[DataSource]].\n */\nexport interface DataSourceTileList {\n    /**\n     * The datasource that was producing the tiles.\n     */\n    dataSource: DataSource;\n\n    /**\n     * The current [[MapView]] zoom level.\n     */\n    zoomLevel: number;\n\n    /**\n     * The storage level of the visibleTiles.\n     * Note: renderedTiles might contain tiles from different levels.\n     */\n    storageLevel: number;\n\n    /**\n     * True if all [[visibleTiles]] are loaded.\n     */\n    allVisibleTileLoaded: boolean;\n\n    /**\n     * The number of tiles which are still loading.\n     */\n    numTilesLoading: number;\n\n    /**\n     * List of tiles we want to render (i.e. the tiles computed from the zoom level and view\n     * frustum). However some might not be renderable yet (e.g. loading). See [[renderedTiles]] for\n     * the actual list of tiles that the user will see.\n     */\n    visibleTiles: Tile[];\n\n    /**\n     * Map of tiles that will be rendered, key is the the combination of tile key and offset, see\n     * [[getKeyForTileKeyAndOffset]]. This includes tiles that are not in the [[visibleTiles]]\n     * list but that are used as fallbacks b/c they are still in the cache.\n     */\n    renderedTiles: Map<number, Tile>;\n}\n\n/**\n * Manages visible [[Tile]]s for [[MapView]].\n *\n * Responsible for election of rendered tiles:\n *  - quad-tree traversal\n *  - frustum culling\n *  - sorting tiles by relevance (visible area) to prioritize load\n *  - limiting number of visible tiles\n *  - caching tiles\n *  - searching cache to replace visible but yet empty tiles with already loaded siblings in nearby\n *    zoom levels\n */\nexport class VisibleTileSet {\n    dataSourceTileList: DataSourceTileList[] = [];\n    allVisibleTilesLoaded: boolean = false;\n    options: VisibleTileSetOptions;\n\n    private readonly m_projectionMatrixOverride = new THREE.Matrix4();\n    private m_dataSourceCache: DataSourceCache;\n    private m_viewRange: ViewRanges = { near: 0.1, far: Infinity, minimum: 0.1, maximum: Infinity };\n\n    private m_resourceComputationType: ResourceComputationType =\n        ResourceComputationType.EstimationInMb;\n\n    constructor(\n        private readonly m_frustumIntersection: FrustumIntersection,\n        private readonly m_tileGeometryManager: TileGeometryManager,\n        options: VisibleTileSetOptions\n    ) {\n        this.options = options;\n        this.m_resourceComputationType =\n            options.resourceComputationType === undefined\n                ? ResourceComputationType.EstimationInMb\n                : options.resourceComputationType;\n        this.m_dataSourceCache = new DataSourceCache(\n            this.options.tileCacheSize,\n            this.m_resourceComputationType\n        );\n    }\n\n    /**\n     * Returns cache size.\n     */\n    getDataSourceCacheSize(): number {\n        return this.options.tileCacheSize;\n    }\n\n    /**\n     * Sets cache size.\n     *\n     * @param size cache size\n     * @param computationType Optional value specifying the way a [[Tile]]s cache usage is computed,\n     *      either based on size in MB (mega bytes) or in number of tiles. Defaults to\n     *      `ResourceComputationType.EstimationInMb`.\n     */\n    setDataSourceCacheSize(\n        size: number,\n        computationType: ResourceComputationType = ResourceComputationType.EstimationInMb\n    ): void {\n        this.options.tileCacheSize = size;\n        // This effectively invalidates DataSourceCache\n        this.resourceComputationType = computationType;\n    }\n\n    /**\n     * Retrieves maximum number of visible tiles.\n     */\n    getNumberOfVisibleTiles() {\n        return this.options.maxVisibleDataSourceTiles;\n    }\n\n    /**\n     * Sets maximum number of visible tiles.\n     *\n     * @param size size of visible tiles array\n     */\n    setNumberOfVisibleTiles(size: number) {\n        this.options.maxVisibleDataSourceTiles = size;\n    }\n\n    /**\n     * The way the cache usage is computed, either based on size in MB (mega bytes) or in number of\n     * tiles.\n     */\n    get resourceComputationType(): ResourceComputationType {\n        return this.m_resourceComputationType;\n    }\n\n    /**\n     * Sets the way tile cache is managing its elements.\n     *\n     * Cache may be either keeping number of elements stored or the memory consumed by them.\n     *\n     * @param computationType Type of algorith used in cache for checking full saturation,\n     * may be counting number of elements or memory consumed by them.\n     */\n    set resourceComputationType(computationType: ResourceComputationType) {\n        this.m_resourceComputationType = computationType;\n        this.m_dataSourceCache.setCapacity(this.options.tileCacheSize, computationType);\n    }\n\n    /**\n     * Evaluate frustum near/far clip planes and visibility ranges.\n     */\n    updateClipPlanes(maxElevation?: number, minElevation?: number): ViewRanges {\n        if (maxElevation !== undefined) {\n            this.options.clipPlanesEvaluator.maxElevation = maxElevation;\n        }\n        if (minElevation !== undefined) {\n            this.options.clipPlanesEvaluator.minElevation = minElevation;\n        }\n        this.m_viewRange = this.options.clipPlanesEvaluator.evaluateClipPlanes(\n            this.m_frustumIntersection.mapView\n        );\n        return this.m_viewRange;\n    }\n\n    /**\n     * Calculates a new set of visible tiles.\n     * @param storageLevel The camera storage level, see [[MapView.storageLevel]].\n     * @param zoomLevel The camera zoom level.\n     * @param dataSources The data sources for which the visible tiles will be calculated.\n     * @param elevationRangeSource Source of elevation range data if any.\n     * @returns view ranges and their status since last update (changed or not).\n     */\n    updateRenderList(\n        storageLevel: number,\n        zoomLevel: number,\n        dataSources: DataSource[],\n        elevationRangeSource?: ElevationRangeSource\n    ): { viewRanges: ViewRanges; viewRangesChanged: boolean } {\n        let allVisibleTilesLoaded: boolean = true;\n\n        const visibleTileKeysResult = this.getVisibleTileKeysForDataSources(\n            zoomLevel,\n            dataSources,\n            elevationRangeSource\n        );\n        this.dataSourceTileList = [];\n        for (const { dataSource, visibleTileKeys } of visibleTileKeysResult.tileKeys) {\n            // Sort by projected (visible) area, now the tiles that are further away are at the end\n            // of the list.\n            //\n            // Sort is unstable if distance is equal, which happens a lot when looking top-down.\n            // Unstable sorting makes label placement unstable at tile borders, leading to\n            // flickering.\n            visibleTileKeys.sort((a: TileKeyEntry, b: TileKeyEntry) => {\n                const areaDiff = b.area - a.area;\n\n                // Take care or numerical precision issues\n                const minDiff = (a.area + b.area) * 0.001;\n\n                return Math.abs(areaDiff) < minDiff\n                    ? b.tileKey.mortonCode() - a.tileKey.mortonCode()\n                    : areaDiff;\n            });\n\n            const actuallyVisibleTiles: Tile[] = [];\n            let allDataSourceTilesLoaded = true;\n            let numTilesLoading = 0;\n            // Create actual tiles only for the allowed number of visible tiles\n            const displayZoomLevel = dataSource.getDisplayZoomLevel(zoomLevel);\n            for (\n                let i = 0;\n                i < visibleTileKeys.length &&\n                actuallyVisibleTiles.length < this.options.maxVisibleDataSourceTiles;\n                i++\n            ) {\n                const tileEntry = visibleTileKeys[i];\n                if (!dataSource.shouldRender(displayZoomLevel, tileEntry.tileKey)) {\n                    continue;\n                }\n                const tile = this.getTile(dataSource, tileEntry.tileKey, tileEntry.offset);\n                if (tile === undefined) {\n                    continue;\n                }\n\n                tile.prepareTileInfo();\n\n                allDataSourceTilesLoaded = allDataSourceTilesLoaded && tile.allGeometryLoaded;\n                if (!tile.allGeometryLoaded) {\n                    numTilesLoading++;\n                } else {\n                    tile.numFramesVisible++;\n\n                    if (tile.frameNumVisible < 0) {\n                        // Store the fist frame the tile became visible.\n                        tile.frameNumVisible = dataSource.mapView.frameNumber;\n                    }\n                }\n                // Update the visible area of the tile. This is used for those tiles that are\n                // currently loaded and are waiting to be decoded to sort the jobs by area.\n                tile.visibleArea = tileEntry.area;\n                tile.minElevation = tileEntry.minElevation;\n                tile.maxElevation = tileEntry.maxElevation;\n\n                actuallyVisibleTiles.push(tile);\n            }\n\n            this.m_tileGeometryManager.updateTiles(actuallyVisibleTiles);\n\n            this.dataSourceTileList.push({\n                dataSource,\n                storageLevel,\n                zoomLevel: displayZoomLevel,\n                allVisibleTileLoaded: allDataSourceTilesLoaded,\n                numTilesLoading,\n                visibleTiles: actuallyVisibleTiles,\n                renderedTiles: new Map<number, Tile>()\n            });\n            allVisibleTilesLoaded = allVisibleTilesLoaded && allDataSourceTilesLoaded;\n        }\n\n        this.allVisibleTilesLoaded =\n            allVisibleTilesLoaded && visibleTileKeysResult.allBoundingBoxesFinal;\n\n        this.fillMissingTilesFromCache();\n\n        this.forEachCachedTile(tile => {\n            // Remove all tiles that are still being loaded, but are no longer visible. They have to\n            // be reloaded when they become visible again. Hopefully, they are still in the browser\n            // cache by then.\n            if (!tile.isVisible && tile.tileLoader !== undefined && !tile.tileLoader.isFinished) {\n                // The internal TileLoader is cancelled automatically when the Tile is disposed.\n                this.disposeTile(tile);\n            }\n        });\n\n        this.m_dataSourceCache.shrinkToCapacity();\n\n        let minElevation: number | undefined;\n        let maxElevation: number | undefined;\n        this.dataSourceTileList.forEach(renderListEntry => {\n            // Calculate min/max elevation from every data source tiles,\n            // data sources without elevationRangeSource will contribute to\n            // values with zero levels for both elevations.\n            const tiles = renderListEntry.renderedTiles;\n            tiles.forEach(tile => {\n                minElevation = MathUtils.min2(minElevation, tile.minElevation);\n                maxElevation = MathUtils.max2(\n                    maxElevation,\n                    tile.maxElevation + tile.maxGeometryHeight\n                );\n            });\n        });\n\n        if (minElevation === undefined) {\n            minElevation = 0;\n        }\n        if (maxElevation === undefined) {\n            maxElevation = 0;\n        }\n        // If clip planes evaluator depends on the tiles elevation re-calculate\n        // frustum planes and update the camera near/far plane distances.\n        let viewRangesChanged: boolean = false;\n        const oldViewRanges = this.m_viewRange;\n        const newViewRanges = this.updateClipPlanes(maxElevation, minElevation);\n        viewRangesChanged = viewRangesEqual(newViewRanges, oldViewRanges) === false;\n\n        return {\n            viewRanges: newViewRanges,\n            viewRangesChanged\n        };\n    }\n\n    /**\n     * Gets the tile corresponding to the given data source, key and offset, creating it if\n     * necessary.\n     *\n     * @param dataSource The data source the tile belongs to.\n     * @param tileKey The key identifying the tile.\n     * @param offset Tile offset.\n     * @return The tile if it was found or created, undefined otherwise.\n     */\n    getTile(dataSource: DataSource, tileKey: TileKey, offset: number = 0): Tile | undefined {\n        const cacheOnly = false;\n        return this.getTileImpl(dataSource, tileKey, offset, cacheOnly);\n    }\n\n    /**\n     * Gets the tile corresponding to the given data source, key and offset from the cache.\n     *\n     * @param dataSource The data source the tile belongs to.\n     * @param tileKey The key identifying the tile.\n     * @param offset Tile offset.\n     * @return The tile if found in cache, undefined otherwise.\n     */\n    getCachedTile(dataSource: DataSource, tileKey: TileKey, offset: number = 0): Tile | undefined {\n        assert(dataSource.cacheable);\n        const cacheOnly = true;\n        return this.getTileImpl(dataSource, tileKey, offset, cacheOnly);\n    }\n\n    /**\n     * Gets the tile corresponding to the given data source, key and offset from the rendered tiles.\n     *\n     * @param dataSource The data source the tile belongs to.\n     * @param tileKey The key identifying the tile.\n     * @param offset Tile offset.\n     * @return The tile if found among the rendered tiles, undefined otherwise.\n     */\n    getRenderedTile(\n        dataSource: DataSource,\n        tileKey: TileKey,\n        offset: number = 0\n    ): Tile | undefined {\n        const dataSourceVisibleTileList = this.dataSourceTileList.find(list => {\n            return list.dataSource === dataSource;\n        });\n\n        if (dataSourceVisibleTileList === undefined) {\n            return undefined;\n        }\n\n        return dataSourceVisibleTileList.renderedTiles.get(\n            TileOffsetUtils.getKeyForTileKeyAndOffset(tileKey, offset)\n        );\n    }\n\n    /**\n     * Gets the tile corresponding to the given data source and location from the rendered tiles.\n     *\n     * @param dataSource The data source the tile belongs to.\n     * @param geoPoint The geolocation included within the tile.\n     * @return The tile if found among the rendered tiles, undefined otherwise.\n     */\n    getRenderedTileAtLocation(\n        dataSource: DataSource,\n        geoPoint: GeoCoordinates,\n        offset: number = 0\n    ): Tile | undefined {\n        const dataSourceVisibleTileList = this.dataSourceTileList.find(list => {\n            return list.dataSource === dataSource;\n        });\n\n        if (dataSourceVisibleTileList === undefined) {\n            return undefined;\n        }\n\n        const tilingScheme = dataSource.getTilingScheme();\n        const visibleLevel = dataSourceVisibleTileList.zoomLevel;\n        const visibleTileKey = tilingScheme.getTileKey(geoPoint, visibleLevel);\n\n        if (!visibleTileKey) {\n            return undefined;\n        }\n\n        let tile = dataSourceVisibleTileList.renderedTiles.get(\n            TileOffsetUtils.getKeyForTileKeyAndOffset(visibleTileKey, offset)\n        );\n\n        if (tile !== undefined) {\n            return tile;\n        }\n\n        const { searchLevelsUp, searchLevelsDown } = this.getCacheSearchLevels(\n            dataSource,\n            visibleLevel\n        );\n\n        let parentTileKey = visibleTileKey;\n        for (let levelOffset = 1; levelOffset <= searchLevelsUp; ++levelOffset) {\n            parentTileKey = parentTileKey.parent();\n\n            tile = dataSourceVisibleTileList.renderedTiles.get(\n                TileOffsetUtils.getKeyForTileKeyAndOffset(parentTileKey, offset)\n            );\n            if (tile !== undefined) {\n                return tile;\n            }\n        }\n\n        const worldPoint = tilingScheme.projection.projectPoint(geoPoint);\n\n        for (let levelOffset = 1; levelOffset <= searchLevelsDown; ++levelOffset) {\n            const childLevel = visibleLevel + levelOffset;\n            const childTileKey = TileKeyUtils.worldCoordinatesToTileKey(\n                tilingScheme,\n                worldPoint,\n                childLevel\n            );\n            if (childTileKey) {\n                tile = dataSourceVisibleTileList.renderedTiles.get(\n                    TileOffsetUtils.getKeyForTileKeyAndOffset(childTileKey, offset)\n                );\n\n                if (tile !== undefined) {\n                    return tile;\n                }\n            }\n        }\n        return undefined;\n    }\n\n    /**\n     * Removes all internal bookkeeping entries and cache related to specified datasource.\n     *\n     * Called by [[MapView]] when [[DataSource]] has been removed from [[MapView]].\n     */\n    removeDataSource(dataSource: DataSource) {\n        this.clearTileCache(dataSource);\n        this.dataSourceTileList = this.dataSourceTileList.filter(\n            tileList => tileList.dataSource !== dataSource\n        );\n    }\n\n    /**\n     * Clear the tile cache.\n     *\n     * Remove the [[Tile]] objects created by cacheable [[DataSource]]. If a [[DataSource]] name is\n     * provided, this method restricts the eviction the [[DataSource]] with the given name.\n     *\n     * @param dataSourceName The name of the [[DataSource]].\n     */\n    clearTileCache(dataSource?: DataSource) {\n        if (dataSource !== undefined) {\n            this.m_dataSourceCache.evictSelected((tile: Tile, _) => {\n                return tile.dataSource === dataSource;\n            });\n        } else {\n            this.m_dataSourceCache.evictAll();\n        }\n    }\n\n    /**\n     * Visit each tile in visible, rendered, and cached sets.\n     *\n     *  * Visible and temporarily rendered tiles will be marked for update and retained.\n     *  * Cached but not rendered/visible will be evicted.\n     *\n     * @param dataSource If passed, only the tiles from this [[DataSource]] instance are processed.\n     *     If `undefined`, tiles from all [[DataSource]]s are processed.\n     */\n    markTilesDirty(dataSource?: DataSource) {\n        if (dataSource === undefined) {\n            this.dataSourceTileList.forEach(renderListEntry => {\n                this.markDataSourceTilesDirty(renderListEntry);\n            });\n        } else {\n            const renderListEntry = this.dataSourceTileList.find(e => e.dataSource === dataSource);\n            if (renderListEntry === undefined) {\n                return;\n            }\n            this.markDataSourceTilesDirty(renderListEntry);\n        }\n    }\n\n    /**\n     * Dispose tiles that are marked for removal by [[LRUCache]] algorithm.\n     */\n    disposePendingTiles() {\n        this.m_dataSourceCache.disposeTiles();\n    }\n\n    /**\n     * Process callback function [[fun]] with each visible tile in set.\n     *\n     * @param fun The callback function to be called.\n     */\n    forEachVisibleTile(fun: (tile: Tile) => void): void {\n        for (const listEntry of this.dataSourceTileList) {\n            listEntry.renderedTiles.forEach(fun);\n        }\n    }\n\n    /**\n     * Process callback function [[fun]] with each tile in the cache.\n     *\n     * Optional [[dataSource]] parameter limits processing to the tiles that belongs to\n     * DataSource passed in.\n     *\n     * @param fun The callback function to be called.\n     * @param dataSource The optional DataSource reference for tiles selection.\n     */\n    forEachCachedTile(fun: (tile: Tile) => void, dataSource?: DataSource): void {\n        this.m_dataSourceCache.forEach((tile, _) => fun(tile), dataSource);\n    }\n\n    /**\n     * Dispose a `Tile` from cache, 'dispose()' is also called on the tile to free its resources.\n     */\n    disposeTile(tile: Tile): void {\n        // TODO: Consider using evict here!\n        this.m_dataSourceCache.delete(tile);\n        tile.dispose();\n    }\n\n    private getCacheSearchLevels(\n        dataSource: DataSource,\n        visibleLevel: number\n    ): { searchLevelsUp: number; searchLevelsDown: number } {\n        const searchLevelsUp = Math.min(\n            this.options.quadTreeSearchDistanceUp,\n            Math.max(0, visibleLevel - dataSource.minZoomLevel)\n        );\n        const searchLevelsDown = Math.min(\n            this.options.quadTreeSearchDistanceDown,\n            Math.max(0, dataSource.maxZoomLevel - visibleLevel)\n        );\n\n        return { searchLevelsUp, searchLevelsDown };\n    }\n\n    /**\n     * Search cache to replace visible but yet empty tiles with already loaded siblings in nearby\n     * zoom levels.\n     *\n     * Useful, when zooming in/out and when \"newly elected\" tiles are not yet loaded. Prevents\n     * flickering by rendering already loaded tiles from upper/higher zoom levels.\n     */\n    private fillMissingTilesFromCache() {\n        this.dataSourceTileList.forEach(renderListEntry => {\n            const dataSource = renderListEntry.dataSource;\n            const displayZoomLevel = renderListEntry.zoomLevel;\n            const renderedTiles = renderListEntry.renderedTiles;\n\n            // Direction in quad tree to search: up -> shallower levels, down -> deeper levels.\n            enum SearchDirection {\n                NONE,\n                UP,\n                DOWN,\n                BOTH\n            }\n            let defaultSearchDirection = SearchDirection.NONE;\n\n            const { searchLevelsUp, searchLevelsDown } = this.getCacheSearchLevels(\n                dataSource,\n                displayZoomLevel\n            );\n\n            defaultSearchDirection =\n                searchLevelsDown > 0 && searchLevelsUp > 0\n                    ? SearchDirection.BOTH\n                    : searchLevelsDown > 0\n                    ? SearchDirection.DOWN\n                    : searchLevelsUp > 0\n                    ? SearchDirection.UP\n                    : SearchDirection.NONE;\n\n            const incompleteTiles: Map<number, SearchDirection> = new Map();\n\n            renderListEntry.visibleTiles.forEach(tile => {\n                const tileCode = TileOffsetUtils.getKeyForTileKeyAndOffset(\n                    tile.tileKey,\n                    tile.offset\n                );\n                tile.levelOffset = 0;\n                if (tile.hasGeometry || defaultSearchDirection === SearchDirection.NONE) {\n                    renderedTiles.set(tileCode, tile);\n                } else {\n                    // if dataSource supports cache and it was existing before this render\n                    // then enable searching for loaded tiles in cache\n                    incompleteTiles.set(tileCode, defaultSearchDirection);\n                }\n            });\n\n            if (incompleteTiles.size === 0) {\n                // short circuit, nothing to be done\n                return;\n            }\n\n            // Minor optimization for the fallback search, only check parent tiles once, otherwise\n            // the recursive algorithm checks all parent tiles multiple times, the key is the code\n            // of the tile that is checked and the value is whether a parent was found or not.\n            const checkedTiles = new Map<number, boolean>();\n            // Iterate over incomplete (not loaded tiles) and find their parents or children that\n            // are in cache that can be rendered temporarily until tile is loaded. Note, we favour\n            // falling back to parent tiles rather than children.\n            for (const [tileKeyCode, searchDirection] of incompleteTiles) {\n                if (\n                    searchDirection === SearchDirection.BOTH ||\n                    searchDirection === SearchDirection.UP\n                ) {\n                    if (\n                        this.findUp(\n                            tileKeyCode,\n                            displayZoomLevel,\n                            renderedTiles,\n                            checkedTiles,\n                            dataSource\n                        )\n                    ) {\n                        // Continue to next entry so we don't search down.\n                        continue;\n                    }\n                }\n\n                if (\n                    searchDirection === SearchDirection.BOTH ||\n                    searchDirection === SearchDirection.DOWN\n                ) {\n                    this.findDown(tileKeyCode, displayZoomLevel, renderedTiles, dataSource);\n                }\n            }\n        });\n    }\n\n    private findDown(\n        tileKeyCode: number,\n        displayZoomLevel: number,\n        renderedTiles: Map<number, Tile>,\n        dataSource: DataSource\n    ) {\n        const { offset, mortonCode } = TileOffsetUtils.extractOffsetAndMortonKeyFromKey(\n            tileKeyCode\n        );\n        const tileKey = TileKey.fromMortonCode(mortonCode);\n\n        const tilingScheme = dataSource.getTilingScheme();\n        for (const childTileKey of tilingScheme.getSubTileKeys(tileKey)) {\n            const childTileCode = TileOffsetUtils.getKeyForTileKeyAndOffset(childTileKey, offset);\n            const childTile = this.m_dataSourceCache.get(\n                childTileKey.mortonCode(),\n                offset,\n                dataSource\n            );\n\n            const nextLevelDiff = Math.abs(childTileKey.level - displayZoomLevel);\n            if (childTile !== undefined && childTile.hasGeometry) {\n                // childTile has geometry, so can be reused as fallback\n                renderedTiles.set(childTileCode, childTile);\n                childTile.levelOffset = nextLevelDiff;\n                continue;\n            }\n\n            // Recurse down until the max distance is reached.\n            if (nextLevelDiff < this.options.quadTreeSearchDistanceDown) {\n                this.findDown(childTileCode, displayZoomLevel, renderedTiles, dataSource);\n            }\n        }\n    }\n\n    /**\n     * Returns true if a tile was found in the cache which is a parent\n     * @param tileKeyCode Morton code of the current tile that should be searched for.\n     * @param displayZoomLevel The current zoom level of tiles that are to be displayed.\n     * @param renderedTiles The list of tiles that are shown to the user.\n     * @param checkedTiles Used to map a given code to a boolean which tells us if an ancestor is\n     * displayed or not.\n     * @param dataSource The provider of tiles.\n     * @returns Whether a parent tile exists.\n     */\n    private findUp(\n        tileKeyCode: number,\n        displayZoomLevel: number,\n        renderedTiles: Map<number, Tile>,\n        checkedTiles: Map<number, boolean>,\n        dataSource: DataSource\n    ): boolean {\n        const parentCode = TileOffsetUtils.getParentKeyFromKey(tileKeyCode);\n        // Check if another sibling has already added the parent.\n        if (renderedTiles.get(parentCode) !== undefined) {\n            return true;\n        }\n        const exists = checkedTiles.get(parentCode)!;\n        if (exists !== undefined) {\n            return exists;\n        }\n\n        const { offset, mortonCode } = TileOffsetUtils.extractOffsetAndMortonKeyFromKey(parentCode);\n        const parentTile = this.m_dataSourceCache.get(mortonCode, offset, dataSource);\n        const parentTileKey = parentTile ? parentTile.tileKey : TileKey.fromMortonCode(mortonCode);\n        const nextLevelDiff = Math.abs(displayZoomLevel - parentTileKey.level);\n        if (parentTile !== undefined && parentTile.hasGeometry) {\n            checkedTiles.set(parentCode, true);\n            // parentTile has geometry, so can be reused as fallback\n            renderedTiles.set(parentCode, parentTile);\n\n            // We want to have parent tiles as -ve, hence the minus.\n            parentTile.levelOffset = -nextLevelDiff;\n\n            return true;\n        } else {\n            checkedTiles.set(parentCode, false);\n        }\n\n        // Recurse up until the max distance is reached or we go to the parent of all parents.\n        if (nextLevelDiff < this.options.quadTreeSearchDistanceUp && parentTileKey.level !== 0) {\n            const foundUp = this.findUp(\n                parentCode,\n                displayZoomLevel,\n                renderedTiles,\n                checkedTiles,\n                dataSource\n            );\n            // If there was a tile upstream found, then add it to the list, so we can\n            // early skip checkedTiles.\n            checkedTiles.set(parentCode, foundUp);\n            if (foundUp) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private getTileImpl(\n        dataSource: DataSource,\n        tileKey: TileKey,\n        offset: number,\n        cacheOnly: boolean\n    ): Tile | undefined {\n        function updateTile(tileToUpdate?: Tile) {\n            if (tileToUpdate === undefined) {\n                return;\n            }\n            // Keep the tile from being removed from the cache.\n            tileToUpdate.frameNumLastRequested = dataSource.mapView.frameNumber;\n        }\n\n        if (!dataSource.cacheable && !cacheOnly) {\n            const resultTile = dataSource.getTile(tileKey);\n            updateTile(resultTile);\n            return resultTile;\n        }\n\n        const tileCache = this.m_dataSourceCache;\n        let tile = tileCache.get(tileKey.mortonCode(), offset, dataSource);\n\n        if (tile !== undefined && tile.offset === offset) {\n            updateTile(tile);\n            return tile;\n        }\n\n        if (cacheOnly) {\n            return undefined;\n        }\n\n        tile = dataSource.getTile(tileKey);\n        // TODO: Update all tile information including area, min/max elevation from TileKeyEntry\n        if (tile !== undefined) {\n            tile.offset = offset;\n            updateTile(tile);\n            tileCache.set(tileKey.mortonCode(), offset, dataSource, tile);\n            this.m_tileGeometryManager.initTile(tile);\n        }\n        return tile;\n    }\n\n    private markDataSourceTilesDirty(renderListEntry: DataSourceTileList) {\n        const dataSourceCache = this.m_dataSourceCache;\n        const retainedTiles: Set<TileCacheId> = new Set();\n\n        function markTileDirty(tile: Tile, tileGeometryManager: TileGeometryManager) {\n            const tileKey = DataSourceCache.getKeyForTile(tile);\n            if (!retainedTiles.has(tileKey)) {\n                retainedTiles.add(tileKey);\n                if (tile.tileGeometryLoader !== undefined) {\n                    tile.tileGeometryLoader.reset();\n                }\n\n                // Prevent label rendering issues when the style set is changing. Prevent Text\n                // element rendering that depends on cleaned font catalog data.\n                tile.clearTextElements();\n\n                tile.load();\n            }\n        }\n\n        renderListEntry.visibleTiles.forEach(tile => {\n            markTileDirty(tile, this.m_tileGeometryManager);\n        });\n        renderListEntry.renderedTiles.forEach(tile => {\n            markTileDirty(tile, this.m_tileGeometryManager);\n        });\n\n        dataSourceCache.forEach((tile, key) => {\n            if (!retainedTiles.has(key)) {\n                dataSourceCache.deleteByKey(key);\n                tile.dispose();\n            }\n        }, renderListEntry.dataSource);\n    }\n\n    // Computes the visible tile keys for each supplied data source.\n    private getVisibleTileKeysForDataSources(\n        zoomLevel: number,\n        dataSources: DataSource[],\n        elevationRangeSource: ElevationRangeSource | undefined\n    ): {\n        tileKeys: Array<{ dataSource: DataSource; visibleTileKeys: TileKeyEntry[] }>;\n        allBoundingBoxesFinal: boolean;\n    } {\n        const tileKeys = Array<{ dataSource: DataSource; visibleTileKeys: TileKeyEntry[] }>();\n        let allBoundingBoxesFinal: boolean = true;\n\n        if (dataSources.length === 0) {\n            return { tileKeys, allBoundingBoxesFinal };\n        }\n\n        const dataSourceBuckets = new Map<TilingScheme, DataSource[]>();\n        dataSources.forEach(dataSource => {\n            const tilingScheme = dataSource.getTilingScheme();\n            const bucket = dataSourceBuckets.get(tilingScheme);\n            if (bucket === undefined) {\n                dataSourceBuckets.set(tilingScheme, [dataSource]);\n            } else {\n                bucket.push(dataSource);\n            }\n        });\n\n        // If elevation is to be taken into account create extended frustum:\n        // (near ~0, far: maxVisibilityRange) that allows to consider tiles that\n        // are far below ground plane and high enough to intersect the frustum.\n        if (elevationRangeSource !== undefined) {\n            const fp = MapViewUtils.getCameraFrustumPlanes(this.m_frustumIntersection.camera);\n            fp.near = this.m_viewRange.minimum;\n            fp.far = this.m_viewRange.maximum;\n            this.m_projectionMatrixOverride.makePerspective(\n                fp.left,\n                fp.right,\n                fp.bottom,\n                fp.top,\n                fp.near,\n                fp.far\n            );\n            this.m_frustumIntersection.updateFrustum(this.m_projectionMatrixOverride);\n        } else {\n            this.m_frustumIntersection.updateFrustum();\n        }\n\n        // For each bucket of data sources with same tiling scheme, calculate frustum intersection\n        // once using the maximum display level.\n        for (const [tilingScheme, bucket] of dataSourceBuckets) {\n            const zoomLevels = bucket.map(dataSource => dataSource.getDisplayZoomLevel(zoomLevel));\n            const maxDisplayLevel = Math.max(...zoomLevels);\n            const result = this.m_frustumIntersection.compute(\n                tilingScheme,\n                maxDisplayLevel,\n                elevationRangeSource,\n                zoomLevels,\n                bucket\n            );\n\n            allBoundingBoxesFinal = allBoundingBoxesFinal && result.calculationFinal;\n\n            for (const dataSource of bucket) {\n                const visibleTileKeys: TileKeyEntry[] = [];\n\n                // For each data source check what tiles from the intersection should be rendered\n                // at this zoom level.\n                const displayZoomLevel = dataSource.getDisplayZoomLevel(zoomLevel);\n                for (const tileEntry of result.tileKeyEntries.values()) {\n                    if (dataSource.shouldRender(displayZoomLevel, tileEntry.tileKey)) {\n                        visibleTileKeys.push(tileEntry);\n                    }\n                }\n                tileKeys.push({ dataSource, visibleTileKeys });\n            }\n        }\n\n        return { tileKeys, allBoundingBoxesFinal };\n    }\n}\n\nfunction viewRangesEqual(a: ViewRanges, b: ViewRanges) {\n    return (\n        a.far === b.far && a.maximum === b.maximum && a.minimum === b.minimum && a.near === b.near\n    );\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ITiler } from \"@here/harp-datasource-protocol\";\nimport { ConcurrentWorkerSet } from \"./ConcurrentWorkerSet\";\nimport { WorkerBasedTiler } from \"./WorkerBasedTiler\";\n\n/**\n * Default concurrent tiler helper.\n *\n * A convenient singleton that maintains a separate [[ConcurrentWorkerSet]] for each bundle\n * requested. Provides easy access to [[WorkerBasedTiler]]s for data sources.\n */\nexport class ConcurrentTilerFacade {\n    /**\n     * The URL containing a script to fall back (default) to when looking for worker sets\n     * and tilers.\n     */\n    static defaultScriptUrl: string = \"./decoder.bundle.js\";\n\n    /**\n     * The default number of workers.\n     */\n    static defaultWorkerCount: number = 1;\n\n    /**\n     * Returns a [[WorkerBasedTiler]] instance.\n     *\n     * @param tilerServiceType The name of the tiler service type.\n     * @param scriptUrl The optional URL with the workers' script.\n     * @param workerCount The number of web workers to use.\n     */\n    static getTiler(tilerServiceType: string, scriptUrl?: string, workerCount?: number): ITiler {\n        const workerSet = this.getWorkerSet(scriptUrl, workerCount);\n\n        return new WorkerBasedTiler(workerSet, tilerServiceType);\n    }\n\n    /**\n     * Returns a [[ConcurrentWorkerSet]] instance based on the script URL specified.\n     *\n     * @param scriptUrl The optional URL with the workers' script. If not specified,\n     * the function uses [[defaultScriptUrl]] instead.\n     * @param workerCount The number of web workers to use.\n     */\n    static getWorkerSet(scriptUrl?: string, workerCount?: number): ConcurrentWorkerSet {\n        if (scriptUrl === undefined) {\n            scriptUrl = this.defaultScriptUrl;\n        }\n\n        let workerSet = this.workerSets[scriptUrl];\n        if (workerSet === undefined) {\n            workerSet = new ConcurrentWorkerSet({\n                scriptUrl,\n                workerCount: workerCount === undefined ? this.defaultWorkerCount : workerCount\n            });\n            this.workerSets[scriptUrl] = workerSet;\n        }\n        return workerSet;\n    }\n\n    /**\n     * Destroys a [[ConcurrentWorkerSet]] instance.\n     *\n     * @param scriptUrl The worker script URL that was used to create the [[ConcurrentWorkerSet]].\n     */\n    static destroyWorkerSet(scriptUrl: string) {\n        const workerSet = this.workerSets[scriptUrl];\n        if (workerSet !== undefined) {\n            workerSet.destroy();\n            delete this.workerSets[scriptUrl];\n        }\n    }\n\n    /**\n     * Destroys all managed [[ConcurrentWorkerSet]]s.\n     */\n    static destroy() {\n        Object.keys(this.workerSets).forEach(name => {\n            this.workerSets[name].destroy();\n        });\n        this.workerSets = {};\n    }\n\n    /**\n     * The [[ConcurrentWorkerSet]] instances which are stored by the script URL.\n     */\n    private static workerSets: {\n        [bundleUrl: string]: ConcurrentWorkerSet;\n    } = {};\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    GeoJson,\n    ITiler,\n    WorkerServiceProtocol,\n    WorkerTilerProtocol\n} from \"@here/harp-datasource-protocol\";\nimport { TileKey } from \"@here/harp-geoutils\";\nimport { ConcurrentWorkerSet } from \"./ConcurrentWorkerSet\";\n\n/**\n * Identifier of next tiler worker-service. Used to ensure uniqueness of service ids of tilers\n * dedicated to different datasources.\n */\nlet nextUniqueServiceId = 0;\n\n/**\n * Tiler based on [[ConcurrentWorkerSet]].\n *\n * Tiles payloads using workers running in separate contexts (also known as `WebWorkers`):\n * - connection establishment,\n * - sends tile requests,\n * - configuration.\n */\nexport class WorkerBasedTiler implements ITiler {\n    private serviceId: string;\n    private m_serviceCreated: boolean = false;\n\n    /**\n     * Creates a new `WorkerBasedTiler`.\n     *\n     * @param workerSet [[ConcurrentWorkerSet]] this tiler will live in.\n     * @param tilerServiceType Service type identifier.\n     */\n    constructor(\n        private readonly workerSet: ConcurrentWorkerSet,\n        private readonly tilerServiceType: string\n    ) {\n        this.workerSet.addReference();\n        this.serviceId = `${this.tilerServiceType}-${nextUniqueServiceId++}`;\n    }\n\n    /**\n     * Dispose of dedicated tiler services in workers and remove reference to underlying\n     * [[ConcurrentWorkerSet]].\n     */\n    dispose() {\n        if (this.m_serviceCreated) {\n            this.workerSet\n                .broadcastRequest(WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {\n                    type: WorkerServiceProtocol.Requests.DestroyService,\n                    targetServiceId: this.serviceId\n                })\n                .catch(() => {\n                    /* Ignoring these errors as underlying workers possibly do not exist anymore. */\n                });\n        }\n\n        this.workerSet.removeReference();\n    }\n\n    /**\n     * Connects to [[WorkerServiceManager]]s in underlying [[ConcurrentWorkerSet]] and creates\n     * dedicated [[TilerService]]s in all workers to serve tiling requests.\n     */\n    async connect(): Promise<void> {\n        await this.workerSet.connect(WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID);\n        if (!this.m_serviceCreated) {\n            await this.workerSet.broadcastRequest(\n                WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID,\n                {\n                    type: WorkerServiceProtocol.Requests.CreateService,\n                    targetServiceType: this.tilerServiceType,\n                    targetServiceId: this.serviceId\n                }\n            );\n\n            this.m_serviceCreated = true;\n        }\n    }\n\n    /**\n     * Register index in the tiler. Indexes registered in the tiler can be later used to retrieved\n     * tiled payloads using `getTile`.\n     *\n     * @param indexId Index identifier.\n     * @param input Url to the index payload, or direct GeoJSON.\n     */\n    registerIndex(indexId: string, input: URL | GeoJson): Promise<void> {\n        const message: WorkerTilerProtocol.RegisterIndexRequest = {\n            type: WorkerTilerProtocol.Requests.RegisterIndex,\n            id: indexId,\n            input: input instanceof URL ? input.href : (input as GeoJson)\n        };\n        return this.workerSet.invokeRequest(this.serviceId, message);\n    }\n\n    /**\n     * Update index in the tiler. Indexes registered in the tiler can be later used to retrieved\n     * tiled payloads using `getTile`.\n     *\n     * @param indexId Index identifier.\n     * @param input Url to the index payload, or direct GeoJSON.\n     */\n    updateIndex(indexId: string, input: URL | GeoJson): Promise<void> {\n        const message: WorkerTilerProtocol.UpdateIndexRequest = {\n            type: WorkerTilerProtocol.Requests.UpdateIndex,\n            id: indexId,\n            input: input instanceof URL ? input.href : (input as GeoJson)\n        };\n        return this.workerSet.invokeRequest(this.serviceId, message);\n    }\n\n    /**\n     * Retrieves a tile for a previously registered index.\n     *\n     * @param indexId Index identifier.\n     * @param tileKey The [[TileKey]] that identifies the tile.\n     */\n    getTile(indexId: string, tileKey: TileKey): Promise<{}> {\n        const tileKeyCode = tileKey.mortonCode();\n        const message: WorkerTilerProtocol.TileRequest = {\n            type: WorkerTilerProtocol.Requests.TileRequest,\n            index: indexId,\n            tileKey: tileKeyCode\n        };\n        return this.workerSet.invokeRequest(this.serviceId, message);\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeoBox } from \"@here/harp-geoutils\";\nimport { getOptionValue, LoggerManager } from \"@here/harp-utils\";\nimport { CopyrightInfo } from \"./CopyrightInfo\";\nimport { CopyrightProvider } from \"./CopyrightProvider\";\n\ndeclare const require: any;\n\n// tslint:disable-next-line:no-var-requires\nconst RBush = require(\"rbush\");\n\n/**\n * Schema of [Map Tile API copyright\n * endpoint](https://developer.here.com/documentation/map-tile/topics/resource-copyright.html) JSON\n * response.\n */\nexport interface AreaCopyrightInfo {\n    /**\n     * Minimum zoom level for the specified copyright label.\n     */\n    minLevel?: number;\n\n    /**\n     * Maximum zoom level for the specified copyright label.\n     */\n    maxLevel?: number;\n\n    /**\n     * Copyright text to display after the copyright symbol on the map.\n     */\n    label: string;\n\n    /**\n     * Verbose copyright text of the label to display by mouse over label or info menu entry.\n     */\n    alt?: string;\n\n    /**\n     * The bounding boxes define areas where specific copyrights are valid. A bounding box is\n     * defined by bottom (latitude), left (longitude) and top (latitude), right (longitude).\n     *\n     * The default copyright has no boxes element and covers all other areas.\n     */\n    boxes?: Array<[number, number, number, number]>;\n}\n\n/**\n * Schema of [Map Tile API copyright\n * endpoint](https://developer.here.com/documentation/map-tile/topics/resource-copyright.html) JSON\n * response.\n */\nexport interface CopyrightCoverageResponse {\n    [scheme: string]: AreaCopyrightInfo[];\n}\n\n/**\n * Base class to provide copyrights based on copyright coverage information, defined by geographical\n * bounding boxes and relevant zoom level ranges.\n */\nexport abstract class CopyrightCoverageProvider implements CopyrightProvider {\n    /** Logger instance. */\n    protected readonly logger = LoggerManager.instance.create(\"CopyrightCoverageProvider\");\n\n    private m_cachedTreePromise: Promise<any> | undefined;\n\n    /** Asynchronously retrieves copyright coverage data. */\n    abstract async getCopyrightCoverageData(): Promise<AreaCopyrightInfo[]>;\n\n    /** @inheritdoc */\n    getTree(): Promise<any> {\n        if (this.m_cachedTreePromise !== undefined) {\n            return this.m_cachedTreePromise;\n        }\n\n        this.m_cachedTreePromise = this.getCopyrightCoverageData()\n            .then(coverageInfo => this.initRBush(coverageInfo))\n            .catch(error => {\n                this.logger.error(error);\n                return new RBush();\n            });\n\n        return this.m_cachedTreePromise;\n    }\n\n    /** @inheritdoc */\n    async getCopyrights(geoBox: GeoBox, level: number): Promise<CopyrightInfo[]> {\n        const tree = await this.getTree();\n\n        const result: CopyrightInfo[] = [];\n\n        const matchingEntries: AreaCopyrightInfo[] = tree.search({\n            minX: geoBox.west,\n            minY: geoBox.south,\n            maxX: geoBox.east,\n            maxY: geoBox.north\n        });\n\n        for (const entry of matchingEntries) {\n            const minLevel = getOptionValue(entry.minLevel, 0);\n            const maxLevel = getOptionValue(entry.maxLevel, Infinity);\n\n            if (level >= minLevel && level <= maxLevel) {\n                if (result.find(item => item.id === entry.label) === undefined) {\n                    result.push({ id: entry.label });\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Initializes RBush.\n     *\n     * @param entries Entries for tree.\n     * @returns RBush instance.\n     */\n    initRBush(entries: AreaCopyrightInfo[]): any {\n        const tree = new RBush();\n\n        if (!entries) {\n            this.logger.warn(\"No copyright coverage data provided\");\n            return tree;\n        }\n\n        for (const entry of entries) {\n            const { minLevel, maxLevel, label, alt } = entry;\n\n            if (!entry.boxes) {\n                tree.insert({\n                    minX: -180,\n                    minY: -90,\n                    maxX: 180,\n                    maxY: 180,\n                    minLevel,\n                    maxLevel,\n                    label,\n                    alt\n                });\n            } else {\n                for (const box of entry.boxes) {\n                    const [minY, minX, maxY, maxX] = box;\n                    tree.insert({\n                        minX,\n                        minY,\n                        maxX,\n                        maxY,\n                        minLevel,\n                        maxLevel,\n                        label,\n                        alt\n                    });\n                }\n            }\n        }\n\n        return tree;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport * from \"./src/TransferManager\";\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { GeometryType } from \"@here/harp-datasource-protocol\";\nimport { reconstructLineWidth } from \"@here/harp-lines\";\nimport { assert, LoggerManager } from \"@here/harp-utils\";\n\nconst logger = LoggerManager.instance.create(\"TileGeometry\");\n\n/**\n * Interface to access lines. Allows read access for some important attributes.\n */\nexport interface ILineAccessor {\n    /**\n     * Hint for the original type of geometry.\n     */\n    geometryType: GeometryType;\n\n    /**\n     * Get the color from materials.\n     */\n    color: THREE.Color | undefined | Array<THREE.Color | undefined>;\n\n    /**\n     * Get the width. May have to be reconstructed from triangulated line mesh.\n     */\n    width: number | undefined;\n\n    /**\n     * Render order.\n     */\n    renderOrder: number;\n\n    /**\n     * Helper for function `isLineAccessor`.\n     *\n     * @returns `true` if it is a line accessor.\n     */\n    isLineAccessor(): boolean;\n\n    /**\n     * Clear the object from the mesh.\n     */\n    clear(): void;\n\n    /**\n     * Get vertices from the object.\n     */\n    getVertices(): Float32Array | undefined;\n}\n\n/**\n * Helper function to check if an accessor is of type `ILineAccessor`.\n *\n * @param arg `true` if `arg` is `ILineAccessor`.\n */\nexport function isLineAccessor(arg: any): arg is ILineAccessor {\n    /**\n     * Get vertices from the object.\n     *\n     * @param mode Specifies which part of the vertices should be returned.\n     */\n\n    return typeof arg.isLineAccessor === \"function\" && arg.isLineAccessor() === true;\n}\n\n/**\n * Accessor for unspecified 3D objects, like landmarks.\n */\nexport interface IObject3dAccessor {\n    /**\n     * Hint for the original type of geometry.\n     */\n    geometryType: GeometryType;\n\n    /**\n     * Get the color from materials.\n     */\n    color: THREE.Color | undefined | Array<THREE.Color | undefined>;\n\n    /**\n     * Render order.\n     */\n    renderOrder: number;\n\n    /**\n     * Helper for function `isObject3dAccessor`.\n     *\n     * @returns `true` if it is a line accessor.\n     */\n    isObject3dAccessor(): boolean;\n\n    /**\n     * Clear the object from the mesh.\n     */\n    clear(): void;\n\n    getVertices(): Float32Array | undefined;\n}\n\n/**\n * Helper function to check if an accessor is of type `IObject3dAccessor`.\n *\n * @param arg `true` if `arg` is `IObject3dAccessor`.\n */\nexport function isObject3dAccessor(arg: any): arg is IObject3dAccessor {\n    return typeof arg.isObject3dAccessor === \"function\" && arg.isObject3dAccessor() === true;\n}\n\n/**\n * Basic interface for geometry accessors.\n */\nexport interface IGeometryAccessor {\n    /**\n     * Get the number of primitives (vertices of triangles).\n     *\n     * @returns Number of primitives.\n     */\n    getCount(): number;\n\n    /**\n     * Set range of primitives in this object related to one or more buffers.\n     *\n     * @param start Start index in buffers.\n     * @param end End index in buffers (+1).\n     */\n    setRange(start: number, end: number): void;\n}\n\n/**\n * Geometry accessor for both indexed and nonindexed `BufferedGeometry`.\n */\nexport abstract class BufferedGeometryAccessorBase implements IGeometryAccessor {\n    protected start: number = -1;\n    protected end: number = -1;\n    protected startCapSize: number = 0;\n    protected endCapSize: number = 0;\n    protected position: THREE.BufferAttribute;\n    protected itemSize: number;\n\n    constructor(\n        readonly object: THREE.Mesh,\n        readonly geometryType: GeometryType,\n        protected readonly bufferGeometry: THREE.BufferGeometry\n    ) {\n        assert(!!object);\n\n        if (bufferGeometry.type !== \"BufferGeometry\") {\n            logger.error(\n                \"IndexedBufferedGeometryAccessor#constructor: BufferGeometry has wrong \" + \"type\"\n            );\n        }\n        assert(\n            bufferGeometry.type === \"BufferGeometry\",\n            \"IndexedBufferedGeometryAccessor#constructor: BufferGeometry has wrong type\"\n        );\n\n        // we know its a BufferAttribute because it is a BufferGeometry\n        this.position = this.bufferGeometry.getAttribute(\"position\") as THREE.BufferAttribute;\n        this.itemSize = this.position.itemSize;\n\n        if (!this.position) {\n            logger.warn(\n                \"BufferedGeometryAccessor#constructor: BufferGeometry has no position \" +\n                    \"attribute\"\n            );\n        }\n\n        if (this.position.array.constructor !== Float32Array) {\n            logger.warn(\n                \"BufferedGeometryAccessor#constructor: BufferGeometry.position: \" +\n                    \"unsupported ArrayBuffer\"\n            );\n        }\n    }\n\n    /**\n     * Get the number of accessible geometries in this buffer.\n     *\n     * @returns Number of primitives in this geometry.\n     */\n    getCount(): number {\n        return this.position.count;\n    }\n\n    /**\n     * Get `renderOrder` of object.\n     *\n     * @returns `renderOrder` of the object.\n     */\n    get renderOrder(): number {\n        return this.object.renderOrder;\n    }\n\n    setRange(start: number, end: number, startCapSize: number = 0, endCapSize: number = 0) {\n        assert(start >= 0);\n        assert(end >= 0);\n        assert(start <= end);\n        this.start = start;\n        this.end = end;\n        this.startCapSize = startCapSize;\n        this.endCapSize = endCapSize;\n    }\n\n    /**\n     * Get one or more colors from materials.\n     */\n    get color(): THREE.Color | undefined | Array<THREE.Color | undefined> {\n        /**\n         * TODO: Get color(s) from vertex colors\n         */\n        const getColor = (material: THREE.Material) => {\n            const meshMaterial = material as THREE.MeshBasicMaterial;\n            if (\n                meshMaterial.type === \"MeshBasicMaterial\" ||\n                meshMaterial.type === \"MeshStandardMaterial\"\n            ) {\n                return meshMaterial.color;\n            } else if (meshMaterial.type === \"RawShaderMaterial\") {\n                const rawShaderMaterial = material as THREE.RawShaderMaterial;\n\n                if (rawShaderMaterial.name === \"SolidLineMaterial\") {\n                    return rawShaderMaterial.uniforms.diffuse.value as THREE.Color;\n                }\n\n                logger.warn(\n                    \"BufferedGeometryAccessor#color: unknown shader material name\",\n                    rawShaderMaterial.name\n                );\n            } else {\n                logger.warn(\n                    \"BufferedGeometryAccessor#color: unknown material type\",\n                    meshMaterial.type\n                );\n            }\n\n            return undefined;\n        };\n\n        if (Array.isArray(this.object.material)) {\n            const results = new Array<THREE.Color | undefined>();\n            const materials = this.object.material as THREE.Material[];\n\n            for (const material of materials) {\n                results.push(getColor(material));\n            }\n\n            return results;\n        } else {\n            return getColor(this.object.material);\n        }\n    }\n}\n\n/**\n * Abstract base class of an accessor for nonindexed geometry.\n */\nexport abstract class BufferedGeometryAccessor extends BufferedGeometryAccessorBase {\n    /**\n     * Create an object of type `BufferedGeometryAccessor`\n     *\n     * @param object - mesh object\n     * @param geometryType - type of geometry to be used\n     * @param bufferGeometry - which buffer geometry to use\n     * @param stride - geometry stride length\n     */\n    constructor(\n        readonly object: THREE.Mesh,\n        readonly geometryType: GeometryType,\n        protected readonly bufferGeometry: THREE.BufferGeometry,\n        protected stride: number\n    ) {\n        super(object, geometryType, bufferGeometry);\n    }\n\n    clear(): void {\n        assert(this.checkSetUp(), \"BufferedGeometryAccessor not setup\");\n\n        const positionsArray = this.position.array as number[];\n\n        const start = this.start * this.itemSize;\n        const end = this.end * this.itemSize;\n\n        for (let i = start; i < end; i++) {\n            positionsArray[i] = 0;\n        }\n\n        this.position.needsUpdate = true;\n    }\n\n    getVertices(): Float32Array | undefined {\n        assert(this.checkSetUp(), \"BufferedGeometryAccessor not setup\");\n\n        const start = this.start;\n        const end = this.end;\n\n        return (this.position.array as Float32Array).subarray(\n            start * this.itemSize,\n            end * this.itemSize\n        );\n    }\n\n    protected checkSetUp(): boolean {\n        return (\n            this.position !== undefined &&\n            this.start !== undefined &&\n            this.end !== undefined &&\n            this.start >= 0 &&\n            this.end <= this.position.count &&\n            this.start <= this.end\n        );\n    }\n}\n\n/**\n * Accessor for nonindexed line geometry.\n */\nexport class BufferedGeometryLineAccessor extends BufferedGeometryAccessor\n    implements ILineAccessor {\n    constructor(\n        readonly object: THREE.Mesh,\n        readonly geometryType: GeometryType,\n        readonly bufferGeometry: THREE.BufferGeometry\n    ) {\n        super(object, geometryType, bufferGeometry, 3);\n    }\n\n    isLineAccessor(): boolean {\n        return true;\n    }\n\n    get width(): number | undefined {\n        //TODO: There is no implementation of such a line, yet...\n        assert(this.checkSetUp(), \"RoBufferedGeometryLineAccessor not setup\");\n        return undefined;\n    }\n}\n\n/**\n * Accessor for nonindexed unspecified (`Object3D`) geometry.\n */\nexport class BufferedGeometryObject3dAccessor extends BufferedGeometryAccessor\n    implements IObject3dAccessor {\n    constructor(\n        readonly object: THREE.Mesh,\n        readonly geometryType: GeometryType,\n        readonly bufferGeometry: THREE.BufferGeometry\n    ) {\n        super(object, geometryType, bufferGeometry, 1);\n    }\n\n    isObject3dAccessor(): boolean {\n        return true;\n    }\n\n    getVertices(): Float32Array | undefined {\n        return super.getVertices();\n    }\n}\n\n/**\n * Abstract base class of indexed geometry.\n */\nexport abstract class IndexedBufferedGeometryAccessor extends BufferedGeometryAccessorBase {\n    indices: number[];\n\n    /**\n     * Creates an abstract class `IndexedBufferedGeometryAccessor`.\n     *\n     * @param object - mesh to be used\n     * @param geometryType - type of geometry\n     * @param bufferGeometry - geometry used\n     * @param start\n     * @param end\n     */\n    constructor(\n        readonly object: THREE.Mesh,\n        readonly geometryType: GeometryType,\n        protected readonly bufferGeometry: THREE.BufferGeometry,\n        // tslint:disable-next-line:no-unused-variable\n        start?: number,\n        // tslint:disable-next-line:no-unused-variable\n        end?: number\n    ) {\n        super(object, geometryType, bufferGeometry);\n\n        this.indices =\n            this.bufferGeometry.index !== null\n                ? (this.bufferGeometry.index.array as number[])\n                : ((undefined as any) as number[]);\n\n        if (!this.indices) {\n            logger.warn(\n                \"IndexedBufferedGeometryAccessor#constructor: BufferGeometry has no \" + \"index\"\n            );\n            assert(!!this.indices);\n        } else {\n            if (!(this.indices instanceof Uint32Array)) {\n                logger.warn(\n                    \"IndexedBufferedGeometryAccessor#constructor: BufferGeometry index \" +\n                        \"has wrong type\"\n                );\n                assert(this.indices instanceof Uint32Array);\n            }\n        }\n    }\n\n    /**\n     * Returns number of primitives, which is not known in this base class, so we return the number\n     * of indices.\n     *\n     * @returns The number of indices in the geometry.\n     */\n    getCount(): number {\n        return this.indices.length;\n    }\n\n    protected checkSetUp(): boolean {\n        return (\n            !!this.indices &&\n            this.start !== undefined &&\n            this.end !== undefined &&\n            this.start >= 0 &&\n            this.end <= this.indices.length &&\n            this.start <= this.end\n        );\n    }\n}\n\n/**\n * Accessor for lines in an indexed geometry.\n */\nexport class IndexedBufferedGeometryLineAccessor extends IndexedBufferedGeometryAccessor\n    implements ILineAccessor {\n    constructor(\n        readonly object: THREE.Mesh,\n        readonly geometryType: GeometryType,\n        readonly bufferGeometry: THREE.BufferGeometry\n    ) {\n        super(object, geometryType, bufferGeometry, 3);\n    }\n\n    isLineAccessor(): boolean {\n        return true;\n    }\n\n    /**\n     * Reconstructs line width from triangulated geometry.\n     *\n     * @returns Line width.\n     */\n    get width(): number | undefined {\n        assert(this.checkSetUp(), \"RoIndexedBufferedGeometryLineAccessor not setup\");\n\n        if (this.geometryType === GeometryType.ExtrudedLine) {\n            const start = this.start + this.startCapSize;\n            const positionArray = this.position.array as Float32Array;\n            return reconstructLineWidth(positionArray, start);\n        }\n\n        return undefined;\n    }\n\n    clear(): void {\n        assert(this.checkSetUp(), \"RoIndexedBufferedGeometryLineAccessor not setup\");\n\n        const start = this.start;\n        const end = this.end;\n\n        for (let i = start; i < end; i++) {\n            this.indices[i] = 0;\n        }\n\n        if (this.bufferGeometry.index !== null) {\n            this.bufferGeometry.index.needsUpdate = true;\n        }\n    }\n\n    getVertices(): Float32Array | undefined {\n        assert(this.checkSetUp(), \"RoIndexedBufferedGeometryLineAccessor not setup\");\n\n        const itemSize = this.itemSize;\n\n        const start = this.start;\n        const end = this.end;\n\n        const result = new Float32Array((end - start) * itemSize);\n        const positionArray = this.position.array;\n\n        if (itemSize === 2) {\n            for (let i = start, j = 0; i < end; i++, j += itemSize) {\n                const index = this.indices[i];\n                result[j + 0] = positionArray[index * itemSize + 0];\n                result[j + 1] = positionArray[index * itemSize + 1];\n            }\n        }\n        if (itemSize === 3) {\n            for (let i = start, j = 0; i < end; i++, j += itemSize) {\n                const index = this.indices[i];\n                result[j + 0] = positionArray[index * itemSize + 0];\n                result[j + 1] = positionArray[index * itemSize + 1];\n                result[j + 2] = positionArray[index * itemSize + 2];\n            }\n        } else {\n            for (let i = start, j = 0; i < end; i++, j++) {\n                const index = this.indices[i];\n                for (let k = 0; k < itemSize; k++) {\n                    result[j * itemSize + k] = positionArray[index * itemSize + k];\n                }\n            }\n        }\n\n        return result;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nconst UNIT_Z = new THREE.Vector3(0, 0, 1);\nconst POINTS = [0, 1, 2, 1, 3, 2];\nconst BEVEL_POINTS = [0, 1, 3, 3, 1, 2, 0, 3, 4, 5, 4, 3];\n\nconst SECTORS_IN_CIRCLE = 8;\nconst STEP = Math.PI / SECTORS_IN_CIRCLE;\n\n/**\n * Adds a half-circle geometry to original line\n *\n * @param x The line end X (used as circle center X)\n * @param y The line end Y (used as circle center Y)\n * @param lineAngle The cap incline angle\n * @param radius The cap (circle) radius\n * @param vertices The input vertex buffer (cap vertices are added there)\n * @param indices The input index buffer (cap indices are is added there)\n */\nfunction addCircle(\n    x: number,\n    y: number,\n    lineAngle: number,\n    radius: number,\n    vertices: number[],\n    indices: number[]\n) {\n    const baseVertex = vertices.length / 3;\n\n    // Add cap center to vertices directly (it doesn't need rotation)\n    vertices.push(x, y, 0);\n\n    for (let i = 0; i < SECTORS_IN_CIRCLE + 1; ++i) {\n        const angle = STEP * i + Math.PI / 2 + lineAngle; // Start angle is -90deg\n        vertices.push(x + radius * Math.cos(angle), y + radius * Math.sin(angle), 0);\n\n        indices.push(\n            baseVertex,\n            baseVertex + i + 1,\n            baseVertex + ((i + 1) % (SECTORS_IN_CIRCLE + 1)) + 1\n        );\n    }\n}\n\n/**\n * Returns the number of points in circle used for caps.\n *\n * @param lineWidth Width of line.\n */\n// tslint:disable-next-line:no-unused-variable\nexport function numCirclePoints(lineWidth: number): number {\n    return SECTORS_IN_CIRCLE + 1;\n}\n\n/**\n * Create a triangle mesh from the given polyline.\n *\n * @param points Sequence of (x,y,z) coordinates.\n * @param width The width of the extruded line.\n * @param vertices The output vertex buffer.\n * @param indices The output index buffer.\n * @param startWithCircle `true` if the line should start will a circle.\n * @param endWithCircle `true` if the line should end with a circle.\n */\nexport function triangulateLine(\n    points: ArrayLike<number>,\n    width: number,\n    vertices: number[],\n    indices: number[],\n    startWithCircle = true,\n    endWithCircle = startWithCircle\n) {\n    if (points.length < 3) {\n        return;\n    }\n\n    // This vector is used for computing cap angle\n    const angleVec = new THREE.Vector2();\n\n    if (startWithCircle) {\n        // Define lineAngle as (direction - origin) vector angle to X axis\n        const lineAngle =\n            points.length !== 3\n                ? angleVec.set(points[3] - points[0], points[4] - points[1]).angle()\n                : 0;\n\n        addCircle(points[0], points[1], lineAngle, width, vertices, indices);\n    }\n\n    const baseVertex = vertices.length / 3;\n\n    // bt = Bitangent (i.e. extrusion vector)\n    const prevBt = new THREE.Vector3();\n    const p = new THREE.Vector3(); // current point\n    const n = new THREE.Vector3(); // next point\n    const bt = new THREE.Vector3();\n    const averageBt = new THREE.Vector3();\n    const p0 = new THREE.Vector3();\n    const p1 = new THREE.Vector3();\n    const p2 = new THREE.Vector3();\n    const p3 = new THREE.Vector3();\n\n    const N = points.length / 3;\n\n    let vertexOffset = 0;\n    for (let i = 0; i < N; ++i) {\n        let useBevel = false;\n        p.set(points[i * 3], points[i * 3 + 1], points[i * 3 + 2]);\n\n        if (i + 1 < N) {\n            n.set(points[(i + 1) * 3], points[(i + 1) * 3 + 1], points[(i + 1) * 3 + 2]);\n\n            bt.copy(n)\n                .sub(p)\n                .normalize()\n                .cross(UNIT_Z);\n\n            averageBt.copy(bt);\n\n            if (i > 0) {\n                averageBt.add(prevBt).multiplyScalar(1.0 - 0.5 * bt.dot(prevBt));\n\n                useBevel = prevBt.angleTo(bt) > Math.PI / 2;\n\n                if (useBevel) {\n                    const inclineWidth = width / Math.cos(bt.angleTo(prevBt) / 2);\n\n                    p0.copy(bt)\n                        .add(prevBt)\n                        .normalize()\n                        .multiplyScalar(-inclineWidth)\n                        .add(p);\n\n                    p1.copy(prevBt)\n                        .multiplyScalar(width)\n                        .add(p);\n\n                    // p2 is used for \"miter\" connections\n                    p2.copy(bt)\n                        .add(prevBt)\n                        .normalize()\n                        .multiplyScalar(inclineWidth)\n                        .add(p);\n\n                    p3.copy(bt)\n                        .multiplyScalar(width)\n                        .add(p);\n                }\n            }\n\n            if (useBevel) {\n                vertices.push(\n                    p0.x,\n                    p0.y,\n                    p0.z,\n                    p1.x,\n                    p1.y,\n                    p1.z,\n                    p2.x,\n                    p2.y,\n                    p2.z,\n                    p3.x,\n                    p3.y,\n                    p3.z\n                );\n            } else {\n                p0.copy(averageBt)\n                    .multiplyScalar(-width)\n                    .add(p);\n\n                p1.copy(averageBt)\n                    .multiplyScalar(width)\n                    .add(p);\n\n                vertices.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z);\n            }\n\n            prevBt.copy(bt);\n        } else {\n            p0.copy(prevBt)\n                .multiplyScalar(-width)\n                .add(p);\n\n            p1.copy(prevBt)\n                .multiplyScalar(width)\n                .add(p);\n\n            vertices.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z);\n        }\n\n        if (i !== N - 1) {\n            (useBevel ? BEVEL_POINTS : POINTS).forEach(o =>\n                indices.push(baseVertex + vertexOffset + o)\n            );\n            vertexOffset += useBevel ? 4 : 2;\n        }\n    }\n\n    if (endWithCircle) {\n        const lineAngle =\n            points.length !== 2\n                ? angleVec\n                      .set(\n                          points[(N - 3) * 3] - points[(N - 2) * 3],\n                          points[(N - 3) * 3 + 1] - points[(N - 2) * 3 + 1]\n                      )\n                      .angle()\n                : Math.PI;\n\n        addCircle(\n            points[(N - 2) * 3],\n            points[(N - 2) * 3 + 1],\n            lineAngle,\n            width,\n            vertices,\n            indices\n        );\n    }\n}\n\n/**\n * Reconstruct the original points of a line from the vertices of the triangulated line.\n *\n * @param inBuffer Buffer with vertices.\n * @param startOffset Start index, will differ from `0` if the line has caps.\n * @returns Buffer containing the original points of the triangulated line.\n */\nexport function reconstructLine(inBuffer: Float32Array, startOffset: number): Float32Array {\n    const outBuffer = new Float32Array(inBuffer.length / 2);\n\n    for (let i = startOffset * 3, i2 = i * 2; i < outBuffer.length; i += 3, i2 += 6) {\n        outBuffer[i] = inBuffer[i2] + (inBuffer[i2 + 3] - inBuffer[i2]) * 0.5;\n        outBuffer[i + 1] = inBuffer[i2 + 1] + (inBuffer[i2 + 3 + 1] - inBuffer[i2 + 1]) * 0.5;\n        outBuffer[i + 2] = inBuffer[i2 + 2] + (inBuffer[i2 + 3 + 2] - inBuffer[i2 + 2]) * 0.5;\n    }\n    return outBuffer;\n}\n\n/**\n * Extract the line width from a triangulated line.\n *\n * @param inBuffer Array of vertex elements of a triangulated line.\n * @param startIndex Start index, will differ from `0` if the line has caps.\n */\nexport function reconstructLineWidth(inBuffer: Float32Array, startIndex: number): number {\n    const xd = inBuffer[startIndex * 2 + 3] - inBuffer[startIndex * 2];\n    const yd = inBuffer[startIndex * 2 + 3 + 1] - inBuffer[startIndex * 2 + 1];\n    const zd = inBuffer[startIndex * 2 + 3 + 2] - inBuffer[startIndex * 2 + 2];\n\n    return Math.sqrt(xd * xd + yd * yd + zd * zd) * 0.5;\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { HighPrecisionLineMaterial } from \"@here/harp-materials\";\n\nimport * as THREE from \"three\";\nimport { HighPrecisionUtils } from \"./HighPrecisionUtils\";\n\n/**\n * Declare interface for `HighPrecisionObject` which describes additional functionality to render\n * high-precision vertices.\n */\nexport interface HighPrecisionObject extends THREE.Object3D {\n    /**\n     * Allow direct access to [[BufferGeometry]] without cast.\n     */\n    bufferGeometry: THREE.BufferGeometry;\n\n    /**\n     * Allow direct access to [[ShaderMaterial]] without cast.\n     */\n    shaderMaterial: THREE.ShaderMaterial;\n\n    /**\n     * Inversed World Matrix.\n     */\n    matrixWorldInverse: THREE.Matrix4;\n\n    /**\n     * Sets up attributes for position (one attribute for major 32 bits position \"halve\", and one\n     * attribute for lower 32 bits).\n     */\n    setPositions(positions: number[] | THREE.Vector3[]): void;\n\n    /**\n     * Prepare the objects \"`onBeforeRender()`\" callback to generate proper high-precision camera\n     * position.\n     */\n    setupForRendering(): void;\n}\n\n/**\n * Class used to render high-precision wireframe lines.\n */\nexport class HighPrecisionWireFrameLine extends THREE.Line implements HighPrecisionObject {\n    matrixWorldInverse: THREE.Matrix4;\n\n    /**\n     * Creates a `HighPrecisionWireFrameLine` object.\n     *\n     * @param geometry [[BufferGeometry]] used to render this object.\n     * @param material [[HighPrecisionLineMaterial]] used to render this object.\n     *     instances.\n     * @param positions Array of 2D/3D positions.\n     * @param color Color of the rendered line.\n     * @param opacity Opacity of the rendered line.\n     */\n    constructor(\n        geometry?: THREE.BufferGeometry,\n        material?: HighPrecisionLineMaterial,\n        positions?: number[] | THREE.Vector3[],\n        color?: THREE.Color,\n        opacity?: number\n    ) {\n        super(geometry === undefined ? new THREE.BufferGeometry() : geometry, material);\n\n        if (material === undefined) {\n            material = new HighPrecisionLineMaterial({\n                color: color ? color : HighPrecisionLineMaterial.DEFAULT_COLOR,\n                opacity: opacity !== undefined ? opacity : HighPrecisionLineMaterial.DEFAULT_OPACITY\n            });\n        }\n\n        this.matrixWorldInverse = new THREE.Matrix4();\n\n        if (positions) {\n            this.setPositions(positions);\n        }\n    }\n\n    get bufferGeometry(): THREE.BufferGeometry {\n        return this.geometry as THREE.BufferGeometry;\n    }\n\n    get shaderMaterial(): THREE.ShaderMaterial {\n        return this.material as THREE.ShaderMaterial;\n    }\n\n    setPositions(positions: number[] | THREE.Vector3[]): void {\n        HighPrecisionUtils.setPositions(this, positions);\n    }\n\n    setupForRendering(): void {\n        this.onBeforeRender = (\n            _renderer: THREE.WebGLRenderer,\n            _scene: THREE.Scene,\n            camera: THREE.Camera,\n            _geometry: THREE.Geometry | THREE.BufferGeometry,\n            _material: THREE.Material,\n            _group: THREE.Group\n        ) => {\n            HighPrecisionUtils.updateHpUniforms(this, camera, this.shaderMaterial);\n        };\n    }\n\n    updateMatrixWorld(force: boolean) {\n        const doUpdateMatrixWorldInverse = this.matrixWorldNeedsUpdate || force;\n\n        super.updateMatrixWorld(force);\n\n        if (doUpdateMatrixWorldInverse) {\n            this.matrixWorldInverse.getInverse(this.matrixWorld);\n        }\n    }\n}\n\n/**\n * Class used to render high-precision lines.\n */\nexport class HighPrecisionLine extends THREE.Mesh implements HighPrecisionObject {\n    matrixWorldInverse: THREE.Matrix4;\n\n    /**\n     * Creates a `HighPrecisionLine` object.\n     *\n     * @param geometry [[BufferGeometry]] used to render this object.\n     * @param material [[HighPrecisionLineMaterial]] used to render this object.\n     *     instances.\n     * @param positions Array of 2D/3D positions.\n     * @param color Color of the rendered line.\n     * @param opacity Opacity of the rendered line.\n     */\n    constructor(\n        geometry?: THREE.BufferGeometry,\n        material?: HighPrecisionLineMaterial,\n        positions?: number[] | THREE.Vector3[],\n        color?: THREE.Color,\n        opacity?: number\n    ) {\n        super(geometry === undefined ? new THREE.BufferGeometry() : geometry, material);\n\n        if (material === undefined) {\n            material = new HighPrecisionLineMaterial({\n                color: color ? color : HighPrecisionLineMaterial.DEFAULT_COLOR,\n                opacity: opacity !== undefined ? opacity : HighPrecisionLineMaterial.DEFAULT_OPACITY\n            });\n        }\n\n        this.matrixWorldInverse = new THREE.Matrix4();\n\n        if (positions) {\n            this.setPositions(positions);\n        }\n    }\n\n    get bufferGeometry(): THREE.BufferGeometry {\n        return this.geometry as THREE.BufferGeometry;\n    }\n\n    get shaderMaterial(): THREE.ShaderMaterial {\n        return this.material as THREE.ShaderMaterial;\n    }\n\n    setPositions(positions: number[] | THREE.Vector3[]): void {\n        HighPrecisionUtils.setPositions(this, positions);\n    }\n\n    setupForRendering(): void {\n        this.onBeforeRender = (\n            _renderer: THREE.WebGLRenderer,\n            _scene: THREE.Scene,\n            camera: THREE.Camera,\n            _geometry: THREE.Geometry | THREE.BufferGeometry,\n            _material: THREE.Material,\n            _group: THREE.Group\n        ) => {\n            HighPrecisionUtils.updateHpUniforms(this, camera, this.shaderMaterial);\n        };\n    }\n\n    updateMatrixWorld(force: boolean) {\n        const doUpdateMatrixWorldInverse = this.matrixWorldNeedsUpdate || force;\n\n        super.updateMatrixWorld(force);\n\n        if (doUpdateMatrixWorldInverse) {\n            this.matrixWorldInverse.getInverse(this.matrixWorld);\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport \"@here/harp-fetch\";\n\nimport {\n    DecodedTile,\n    ITileDecoder,\n    RequestController,\n    TileInfo\n} from \"@here/harp-datasource-protocol\";\nimport { TileKey } from \"@here/harp-geoutils\";\nimport { DataSource, TileLoaderState } from \"@here/harp-mapview\";\nimport { LoggerManager } from \"@here/harp-utils\";\n\nimport { DataProvider } from \"./DataProvider\";\n\nconst logger = LoggerManager.instance.create(\"TileLoader\");\n\n/**\n * The [[TileLoader]] manages the different states of loading and decoding for a [[Tile]]. Used by\n * the [[TileDataSource]].\n *\n * A TileLoader supports loading for multiple tiles, this is required for the wrap around, where\n * it is possible to see the same tile multiple times.\n */\nexport class TileLoader {\n    /**\n     * Current state of `TileLoader`.\n     */\n    state: TileLoaderState = TileLoaderState.Initialized;\n\n    /**\n     * Error object if loading or decoding failed.\n     */\n    error?: Error;\n\n    /**\n     * The binary data in form of [[ArrayBufferLike]], or any object.\n     */\n    payload?: ArrayBufferLike | {};\n\n    /**\n     * The result of decoding the `payload`: The [[DecodedTile]].\n     */\n    decodedTile?: DecodedTile;\n\n    /**\n     * The abort controller notifying the [[DataProvider]] to cancel loading.\n     */\n    protected loadAbortController = new AbortController();\n\n    /**\n     * The  notifying the [[ITileDecoder]] to cancel decoding.\n     */\n    protected requestController?: RequestController;\n\n    /**\n     * The promise which is resolved when loading and decoding have finished.\n     */\n    protected donePromise?: Promise<TileLoaderState>;\n\n    /**\n     * The internal function that is called when loading and decoding have finished successfully.\n     */\n    protected resolveDonePromise?: (state: TileLoaderState) => void;\n\n    /**\n     * The internal function that is called when loading and decoding failed.\n     */\n    protected rejectedDonePromise?: (state: TileLoaderState) => void;\n\n    /**\n     * This is a form of reference counting for the result. We keep a track of this because when\n     * cancelling, it is important to know if we can actually cancel, or if there is another Tile\n     * that needs the result.\n     */\n    private countRequests: number = 0;\n\n    /**\n     * Set up loading of a single [[Tile]].\n     *\n     * @param dataSource The [[DataSource]] the tile belongs to.\n     * @param tileKey The quadtree address of a [[Tile]].\n     * @param dataProvider The [[DataProvider]] that retrieves the binary tile data.\n     * @param tileDecoder The [[ITileDecoder]] that decodes the binary tile to a [[DecodeTile]].\n     * @param priority The priority given to the loading job. Highest number will be served first.\n     */\n    constructor(\n        protected dataSource: DataSource,\n        protected tileKey: TileKey,\n        protected dataProvider: DataProvider,\n        protected tileDecoder: ITileDecoder,\n        public priority: number\n    ) {}\n\n    /**\n     * Start loading and/or proceed through the various states of loading of this tile.\n     *\n     * @returns A promise which resolves the [[TileLoaderState]].\n     */\n    loadAndDecode(): Promise<TileLoaderState> {\n        switch (this.state) {\n            case TileLoaderState.Loading:\n            case TileLoaderState.Loaded:\n            case TileLoaderState.Decoding:\n                // tile is already loading\n                this.countRequests++;\n                return this.donePromise!;\n\n            case TileLoaderState.Ready:\n            case TileLoaderState.Failed:\n            case TileLoaderState.Initialized:\n            case TileLoaderState.Canceled:\n                // restart loading\n                this.countRequests++;\n                this.startLoading();\n                return this.donePromise!;\n        }\n    }\n\n    /**\n     * Return the current state in form of a promise. Caller can then wait for the promise to be\n     * resolved.\n     *\n     * @returns A promise which resolves the current [[TileLoaderState]].\n     */\n    waitSettled(): Promise<TileLoaderState> {\n        if (!this.donePromise) {\n            return Promise.resolve(this.state);\n        }\n        return this.donePromise;\n    }\n\n    /**\n     * Cancel loading of the [[Tile]] if there is only a single request remaining. Cancellation\n     * token is notified, an internal state is cleaned up.\n     *\n     * Otherwise this just reduces the count of requests by one.\n     */\n    cancel() {\n        if (--this.countRequests !== 0) {\n            return;\n        }\n        switch (this.state) {\n            case TileLoaderState.Loading:\n                this.loadAbortController.abort();\n                this.loadAbortController = new AbortController();\n                break;\n\n            case TileLoaderState.Decoding:\n                if (this.requestController) {\n                    this.requestController.abort();\n                    this.requestController = undefined;\n                }\n                break;\n        }\n\n        this.onDone(TileLoaderState.Canceled);\n    }\n\n    /**\n     * Return `true` if [[Tile]] is still loading, `false` otherwise.\n     */\n    get isFinished(): boolean {\n        return (\n            this.state === TileLoaderState.Ready ||\n            this.state === TileLoaderState.Canceled ||\n            this.state === TileLoaderState.Failed\n        );\n    }\n\n    /**\n     * Update the priority of this [[Tile]]'s priority. Is effective to sort the decoding requests\n     * in the request queue (used during heavy load).\n     */\n    updatePriority(priority: number): void {\n        this.priority = priority;\n        if (this.requestController !== undefined) {\n            this.requestController.priority = priority;\n        }\n    }\n\n    /**\n     * Start loading. Only call if loading did not start yet.\n     */\n    protected startLoading() {\n        const myLoadCancellationToken = this.loadAbortController.signal;\n        this.dataProvider\n            .getTile(this.tileKey, myLoadCancellationToken)\n            .then(payload => {\n                if (myLoadCancellationToken.aborted) {\n                    // safety belt if getTile doesn't really support cancellation tokens\n                    const err = new Error(\"Aborted\");\n                    err.name = \"AbortError\";\n                    throw err;\n                }\n                this.onLoaded(payload);\n            })\n            .catch(error => {\n                // Handle abort messages from fetch and also our own.\n                if (error.name === \"AbortError\" || error.message === \"AbortError: Aborted\") {\n                    return;\n                }\n                this.onError(error);\n            });\n\n        if (this.donePromise === undefined) {\n            this.donePromise = new Promise<TileLoaderState>((resolve, reject) => {\n                this.resolveDonePromise = resolve;\n                this.rejectedDonePromise = reject;\n            });\n        }\n        this.state = TileLoaderState.Loading;\n    }\n\n    /**\n     * Called when binary data has been loaded. The loading state is now progressing to decoding.\n     *\n     * @param payload Binary data in form of [[ArrayBufferLike]], or any object.\n     */\n    protected onLoaded(payload: ArrayBufferLike | {}) {\n        this.state = TileLoaderState.Loaded;\n        this.payload = payload;\n\n        if ((payload as ArrayBufferLike).byteLength !== undefined) {\n            if ((payload as ArrayBufferLike).byteLength === 0) {\n                this.onDone(TileLoaderState.Ready);\n                return;\n            }\n        }\n        // Object is empty\n        if ((payload as {}) === {}) {\n            this.onDone(TileLoaderState.Ready);\n            return;\n        }\n\n        // TBD: we might suspend decode if tile is not visible ... ?\n        this.startDecodeTile();\n    }\n\n    /**\n     * Start decoding the payload.\n     */\n    protected startDecodeTile() {\n        const payload = this.payload;\n        if (payload === undefined) {\n            logger.error(\"TileLoader#startDecodeTile: Cannot decode without payload\");\n            return;\n        }\n\n        this.state = TileLoaderState.Decoding;\n        this.payload = undefined;\n\n        // Save our cancellation point, so we can be reliably cancelled by any subsequent decode\n        // attempts\n        const requestController = new RequestController(this.priority);\n        this.requestController = requestController;\n\n        const dataSource = this.dataSource;\n        this.tileDecoder\n            .decodeTile(payload, this.tileKey, dataSource.projection, requestController)\n            .then(decodedTile => {\n                if (requestController.signal.aborted) {\n                    // our flow is cancelled, silently return\n                    return;\n                }\n\n                this.onDecoded(decodedTile);\n            })\n            .catch(error => {\n                // Handle abort messages from fetch and also our own.\n                if (error.name === \"AbortError\" || error.message === \"AbortError: Aborted\") {\n                    // our flow is cancelled, silently return\n                    return;\n                }\n                this.onError(error);\n            });\n    }\n\n    /**\n     * Called when the decoding is finished, and the [[DecodedTile]] has been created.\n     *\n     * @param decodedTile The [[DecodedTile]].\n     */\n    protected onDecoded(decodedTile: DecodedTile) {\n        this.decodedTile = decodedTile;\n        this.onDone(TileLoaderState.Ready);\n    }\n\n    /**\n     * Cancel the decoding process.\n     */\n    protected cancelDecoding() {\n        if (this.requestController !== undefined) {\n            // we should cancel any decodes already in progress!\n            this.requestController.abort();\n            this.requestController = undefined;\n        }\n    }\n\n    /**\n     * Called when loading and decoding has finished successfully. Resolves loading promise if the\n     * state is Ready, otherwise it rejects the promise with the supplied state.\n     *\n     * @param doneState The latest state of loading.\n     */\n    protected onDone(doneState: TileLoaderState) {\n        if (this.resolveDonePromise && doneState === TileLoaderState.Ready) {\n            this.resolveDonePromise(doneState);\n        } else if (this.rejectedDonePromise) {\n            this.rejectedDonePromise(doneState);\n        }\n        this.resolveDonePromise = undefined;\n        this.rejectedDonePromise = undefined;\n        this.donePromise = undefined;\n        this.state = doneState;\n    }\n\n    /**\n     * Called when loading or decoding has finished with an error.\n     *\n     * @param error Error object describing the failing.\n     */\n    protected onError(error: Error) {\n        if (this.state === TileLoaderState.Canceled) {\n            // If we're canceled, we should simply ignore any state transitions and errors from\n            // underlying load/decode ops.\n            return;\n        }\n        const dataSource = this.dataSource;\n        logger.error(\n            `[${dataSource.name}]: failed to load tile ${this.tileKey.mortonCode()}`,\n            error\n        );\n\n        this.error = error;\n\n        this.onDone(TileLoaderState.Failed);\n    }\n}\n\n/**\n * Subclass of [[TileLoader]] which is used by [[TileDataSource]] to load the [[TileInfo]] meta\n * data, not the tile data itself.\n */\nexport class TileInfoLoader extends TileLoader {\n    tileInfo?: TileInfo;\n\n    protected startDecodeTile() {\n        const payload = this.payload;\n        if (payload === undefined) {\n            logger.error(\"TileInfoLoader#startDecodeTile: Cannot decode without payload\");\n            return;\n        }\n\n        this.state = TileLoaderState.Decoding;\n        this.payload = undefined;\n\n        // Save our cancellation point, so we can be reliably cancelled by any subsequent decode\n        // attempts\n        const requestController = new RequestController(this.priority);\n        this.requestController = requestController;\n\n        const dataSource = this.dataSource;\n        this.tileDecoder\n            .getTileInfo(payload, this.tileKey, dataSource.projection, requestController)\n            .then(tileInfo => {\n                if (requestController.signal.aborted) {\n                    // our flow is cancelled, silently return\n                    return;\n                }\n                this.tileInfo = tileInfo;\n\n                this.onDone(TileLoaderState.Ready);\n            })\n            .catch(error => {\n                // Handle abort messages from fetch and also our own.\n                if (error.name === \"AbortError\" || error.message === \"AbortError: Aborted\") {\n                    // our flow is cancelled, silently return\n                    return;\n                }\n                this.onError(error);\n            });\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport \"@here/harp-fetch\";\nimport { TileKey, TilingScheme } from \"@here/harp-geoutils\";\nimport { DataProvider } from \"@here/harp-mapview-decoder\";\nimport { TransferManager } from \"@here/harp-transfer-manager\";\nimport { LoggerManager } from \"@here/harp-utils\";\n\nconst logger = LoggerManager.instance.create(\"OmvRestClient\");\n\n// tslint:disable:max-line-length\nexport enum APIFormat {\n    /**\n     * Use the REST API format of HERE Vector Tiles Server component version 1.\n     *\n     * Usage:\n     *\n     *     <OmvRestClientParams.baseUrl>/<zoom>/<X>/<Y>/omv\n     *\n     * If [[OmvRestClientParams.authenticationToken]] is provided, it will be added as HTTP header:\n     *\n     *     Authorization: Bearer $authenticationToken\n     *\n     * Format definition:\n     * `//http|s://<base-url>/{API version}/{layers}/{projection}/{z}/{x}/{y}/{format}`\n     *\n     * Default authentication method used: [[AuthenticationTypeBearer]].\n     */\n    HereV1,\n\n    /**\n     * Use the REST API format of Mapbox Vector Tile API v4.\n     *\n     * Usage:\n     * `<OmvRestClientParams.baseUrl>/<zoom>/<X>/<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`\n     *\n     * Format definition:\n     * `http|s://<base-url>/v4/{map_id}/{z}/{x}/{y}{@2x}.{format}?[style]&access_token={access_token}`\n     *\n     * Sample URL:\n     * `http://a.tiles.mapbox.com/v4/mapbox.mapbox-streets-v7/14/4823/6160.mvt?access_token=your-mapbox-access-token`\n     *\n     * Default authentication method used: [[AuthenticationTypeAccessToken]].\n     */\n    MapboxV4,\n\n    /**\n     * Use the REST API format of XYZ Vector Tile API in MVT format.\n     *\n     * Usage:\n     * `<OmvRestClientParams.baseUrl>/tiles/omsbase/256/<zoom>/<X>/<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`\n     *\n     * Format definition:\n     * `http|s://<base-url>/tiles/{layers}/{z}/{x}/{y}/{format}?access_token={access_token}`\n     *\n     * Sample URL:\n     * `https://xyz.api.here.com/tiles/osmbase/256/all/16/19293/24641.mvt?access_token=your-xyz-access-token`\n     *\n     * Default authentication method used: [[AuthenticationTypeAccessToken]].\n     */\n    XYZMVT,\n\n    /**\n     * Use the REST API format of XYZ Vector Tile API in JSON format.\n     *\n     * Usage:\n     * `<OmvRestClientParams.baseUrl>/tiles/omsbase/256/<zoom>/<X>/<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`\n     *\n     * Format definition:\n     * `http|s://<base-url>/tiles/{layers}/{z}/{x}/{y}/{format}?access_token={access_token}`\n     *\n     * Sample URL:\n     * `https://xyz.api.here.com/tiles/osmbase/256/all/16/19293/24641.json?access_token=your-xyz-api-key`\n     *\n     * Default authentication method used: [[AuthenticationTypeAccessToken]].\n     */\n    XYZJson,\n\n    /**\n     * Use the REST API format of XYZ Vector Tile API in OMV format.\n     *\n     * Usage:\n     * `<OmvRestClientParams.baseUrl>/tiles/herebase.02/<zoom>/<X>/<Y>/omv?access_token=<OmvRestClientParams.authenticationCode>`\n     *\n     * Format definition:\n     * `http|s://<base-url>/tiles/herebase.02/{z}/{x}/{y}/{format}?access_token={access_token}`\n     *\n     * Sample URL:\n     * `https://xyz.api.here.com/tiles/herebase.02/14/2649/6338/omv?access_token=your-xyz-access-token`\n     *\n     * Default authentication method used: [[AuthenticationTypeAccessToken]].\n     */\n    XYZOMV,\n\n    /**\n     * Use the REST API format of Tomtoms Vector Tile API v1.\n     *\n     * Usage:\n     * `<OmvRestClientParams.baseUrl>/<zoom>/<X>/<Y>.pbf?key=<OmvRestClientParams.authenticationCode>`\n     *\n     * Format definition:\n     * `<http|https>://<baseURL>/map/<versionNumber>/tile/<layer>/<style>/<zoom>/<X>/<Y>.<format>?key=<apiKey>[&view=<view>][&language=<language>]`\n     *\n     * Sample URL:\n     * `http://api.tomtom.com/map/1/tile/basic/main/0/0/0.pbf?key=<apiKey>`\n     *\n     * Default authentication method used: [[AuthenticationTypeTomTomV1]].\n     */\n    TomtomV1,\n\n    /**\n     * Use the REST API format of XYZ Space Vector Tile API in OMV format.\n     *\n     * Usage:\n     * `<OmvRestClientParams.baseUrl>/hub/spaces/<space-id>/tile/web/<zoom>_<X>_<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`\n     *\n     * Format definition:\n     * `http|s://<base-url>/hub/spaces/{spaceId}/tile/web/{z}_{x}_{y}.mvt?access_token={access_token}`\n     *\n     * Sample URL:\n     * `https://xyz.api.here.com/hub/spaces/your-space-id/tile/web/{z}_{x}_{y}.mvt?access_token=your-access-token`\n     *\n     * Default authentication method used: [[AuthenticationTypeAccessToken]].\n     */\n    XYZSpace\n}\n// tslint:enable:max-line-length\n\n/**\n * Authentication token/code provider used by [[OmvRestClient]] before each call to currently valid\n * authentication code/token.\n */\nexport type AuthenticationCodeProvider = () => Promise<string>;\n\nexport enum AuthenticationMethod {\n    QueryString,\n    AuthorizationHeader\n}\n\nexport interface AuthenticationMethodInfo {\n    method: AuthenticationMethod;\n    name?: string;\n}\n\n/**\n * Authentication method, where token will be provided as HTTP Header:\n *\n *    Authorization: Bearer $authenticationToken\n */\nexport const AuthenticationTypeBearer: AuthenticationMethodInfo = {\n    method: AuthenticationMethod.AuthorizationHeader,\n    name: \"Bearer\"\n};\n\n/**\n * TomTomV1 API compatible authorization method, where token will be provided as HTTP Header:\n *\n *    Authorization: Bearer $authenticationToken\n */\nexport const AuthenticationTypeTomTomV1: AuthenticationMethodInfo = {\n    method: AuthenticationMethod.QueryString,\n    name: \"key\"\n};\n\nexport const AuthenticationTypeAccessToken: AuthenticationMethodInfo = {\n    method: AuthenticationMethod.QueryString,\n    name: \"access_token\"\n};\n\nexport interface OmvRestClientParameters {\n    /**\n     * `URL` pattern used to fetch tile files.\n     *\n     * `URL` with special keywords replaced to retrieve specific tile:\n     *  - `{z}` - zoom level of tile, @see [[TileKey.level]]\n     *  - `{x}` - horizontal coordinate of tile (column number), @see [[TileKey.column]]\n     *  - `{y}` - vertical coordinate of Tile (row number), @see [[TileKey.row]]\n     *\n     * Examples of `url` patterns:\n     * ```\n     *   https://my-base-url.com/vector-tiles/{z}/{x}/{y}.mvt\n     *   https://xyz.api.here.com/tiles/herebase.02/{z}/{x}/{y}/omv\n     *   https://xyz.api.here.com/tiles/osmbase/512/all/{z}/{x}/{y}.mvt\n     * ```\n     *\n     * Note: To add authentication headers and/or query params, use [[authMethod]], [[urlParams]]\n     * properties or embed token directly in `url`.\n     *\n     * Complete examples:\n     * ```\n     * // XYZ OSM with authentication using query param\n     * {\n     *     url: \"https://xyz.api.here.com/tiles/osmbase/512/all/{z}/{x}/{y}.mvt\",\n     *     urlParams: {\n     *           access_token: accessToken\n     *     },\n     * }\n     * // HERE Vector Tile with authentication using bearer token retrieved by callback\n     * {\n     *     url: \"https://vector.hereapi.com/v2/vectortiles/base/mc/{z}/{x}/{y}/omv\",\n     *     authenticationMethod: AuthenticationTypeBearer,\n     *     authenticationCode: () => getBearerToken()\n     * }\n     * ```\n     */\n    url?: string;\n\n    /**\n     * The base URL of the REST Tile Service.\n     * @see [[APIFormat]] for the definition of `baseUrl`.\n     */\n    baseUrl?: string;\n\n    /**\n     * Authentication code used for the different APIs.\n     *\n     * When [[AuthenticationCodeProvider]] is is used as value, the provider is called before each\n     * to get currently valid authentication code/token.\n     *\n     * @see [[APIFormat]] for the query parameter this is used with.\n     */\n    authenticationCode?: string | AuthenticationCodeProvider;\n\n    /**\n     * Specifies [[AuthMethod]] to be used when requesting tiles.\n     *\n     * Defaults for each [[APIFormat]] are documented with each format type.\n     */\n    authenticationMethod?: AuthenticationMethodInfo;\n\n    /**\n     * The REST API format to use for the tile path generation, will default to the HERE Vector Tile\n     * API.\n     */\n    apiFormat?: APIFormat;\n\n    /**\n     * Tiling scheme is used in some of the APIs, not implemented yet.\n     */\n    tilingScheme?: TilingScheme;\n\n    /**\n     * Transfer Manager to use; creates an own instance if none passed.\n     */\n    downloadManager?: TransferManager;\n\n    /**\n     * Function to retrieve the Bearer Token\n     *\n     * @deprecated Please use [[authenticationCode]].\n     */\n    getBearerToken?: () => Promise<string>;\n\n    /**\n     * Array of query parameters to be appended at the end of the url.\n     * It is empty by default.\n     */\n    urlParams?: { [key: string]: string };\n}\n\n/**\n * REST client supporting getting protobuf OMV Tile from REST-based servers.\n */\nexport class OmvRestClient implements DataProvider {\n    private readonly downloadManager: TransferManager;\n    private readonly urlParams: { [key: string]: string };\n\n    constructor(readonly params: OmvRestClientParameters) {\n        this.downloadManager =\n            params.downloadManager === undefined\n                ? TransferManager.instance()\n                : params.downloadManager;\n        this.urlParams = params.urlParams === undefined ? {} : params.urlParams;\n    }\n\n    /** Overriding abstract method, in this case doing nothing. */\n    async connect(): Promise<void> {\n        // not needed\n    }\n\n    /** Overriding abstract method, in this case always returning `true`. */\n    ready(): boolean {\n        return true;\n    }\n\n    /**\n     * Asynchronously fetches a tile from this restful server.\n     *\n     * **Note:** If the tile doesn't exist, a successful response with a `404` status code is\n     * returned.\n     *\n     * @example\n     * ```typescript\n     * const response = layer.getTile(tileKey);\n     * if (!response.ok) {\n     *     // a network error happened\n     *     console.error(\"Unable to download tile\", response.statusText);\n     *     return;\n     * }\n     * if (response.status === 404) {\n     *     // 404 -, no data exists at the given tile. Do nothing.\n     *     return;\n     * }\n     *\n     * // the response is ok and contains data, access it e.g. as arrayBuffer:\n     * const payload = await response.arrayBuffer();\n     * ```\n     *\n     * @param tileKey The tile key of the tile.\n     * @param tileRequestInit Optional request options to be passed to fetch when downloading a\n     * tile.\n     * @returns A `Promise` of the HTTP response that contains the payload of the requested tile.\n     */\n    async getTile(\n        tileKey: TileKey,\n        abortSignal?: AbortSignal | undefined\n    ): Promise<ArrayBufferLike | {}> {\n        const init: RequestInit = { signal: abortSignal };\n\n        let tileUrl = this.dataUrl(tileKey);\n\n        const authenticationCode = await this.getActualAuthenticationCode();\n\n        tileUrl = this.applyAuthCode(tileUrl, init, authenticationCode);\n        tileUrl = this.addQueryParams(tileUrl, this.urlParams);\n\n        if (this.params.apiFormat === APIFormat.XYZJson) {\n            return this.downloadManager.downloadJson(tileUrl, init);\n        }\n\n        return this.downloadManager.downloadArrayBuffer(tileUrl, init);\n    }\n\n    /**\n     * Get actual authentication code/token for this request according to configuration.\n     */\n    private async getActualAuthenticationCode() {\n        if (typeof this.params.authenticationCode === \"string\") {\n            return this.params.authenticationCode;\n        } else if (this.params.authenticationCode !== undefined) {\n            return this.params.authenticationCode();\n        } else if (this.params.getBearerToken !== undefined) {\n            return this.params.getBearerToken();\n        } else {\n            return undefined;\n        }\n    }\n\n    /**\n     * Get default authnentication method basing on apiFormat and other params.\n     */\n    private getDefaultAuthMethod() {\n        if (this.params.getBearerToken !== undefined) {\n            return AuthenticationTypeBearer;\n        }\n\n        switch (this.params.apiFormat) {\n            case APIFormat.HereV1:\n                return AuthenticationTypeBearer;\n            case APIFormat.MapboxV4:\n            case APIFormat.XYZOMV:\n            case APIFormat.XYZMVT:\n            case APIFormat.XYZSpace:\n            case APIFormat.XYZJson:\n                return AuthenticationTypeAccessToken;\n            case APIFormat.TomtomV1:\n                return AuthenticationTypeTomTomV1;\n            default:\n                logger.warn(\n                    `#getDefaultAuthMethod: Not supported API format: ${this.params.apiFormat}`\n                );\n                return undefined;\n        }\n    }\n\n    /**\n     * Apply athentication code/token using configured (or default) authentication method.\n     *\n     * @param url\n     * @param init request extra data\n     * @param authenticationCode authentication/token to be applied\n     * @return new url to be used\n     */\n    private applyAuthCode(url: string, init: RequestInit, authenticationCode: string | undefined) {\n        if (authenticationCode === undefined) {\n            return url;\n        }\n        const authMethod = this.params.authenticationMethod || this.getDefaultAuthMethod();\n        if (authMethod === undefined) {\n            return url;\n        }\n\n        if (authMethod.method === AuthenticationMethod.AuthorizationHeader) {\n            if (init.headers === undefined) {\n                init.headers = new Headers();\n            }\n            const authType = authMethod.name || \"Bearer\";\n            (init.headers as Headers).append(\"Authorization\", `${authType} ${authenticationCode}`);\n        } else if (authMethod.method === AuthenticationMethod.QueryString) {\n            const attrName: string = authMethod.name || \"access_token\";\n            const authParams: { [key: string]: string } = {};\n            authParams[attrName] = authenticationCode;\n            url = this.addQueryParams(url, authParams);\n        }\n        return url;\n    }\n\n    /**\n     * Get actual tile URL depending on configured API format.\n     */\n    private dataUrl(tileKey: TileKey): string {\n        if (this.params.url !== undefined) {\n            return this.params.url\n                .replace(\"{x}\", String(tileKey.column))\n                .replace(\"{y}\", String(tileKey.row))\n                .replace(\"{z}\", String(tileKey.level));\n        }\n        let path = [`/${tileKey.level}`, tileKey.column, tileKey.row].join(\n            this.params.apiFormat === APIFormat.XYZSpace ? \"_\" : \"/\"\n        );\n        switch (this.params.apiFormat) {\n            case APIFormat.HereV1:\n            case APIFormat.XYZOMV:\n                path += \"/omv\";\n                break;\n            case APIFormat.MapboxV4:\n                path += \".mvt\";\n                break;\n            case APIFormat.XYZMVT:\n                path += \".mvt\";\n                break;\n            case APIFormat.XYZJson:\n                path += \".json\";\n                break;\n            case APIFormat.XYZSpace:\n                path += \".mvt\";\n                break;\n            case APIFormat.TomtomV1:\n                path += \".pbf\";\n                break;\n            default:\n                logger.warn(`Not supported API format: ${this.params.apiFormat}`);\n                break;\n        }\n\n        return this.params.baseUrl + path;\n    }\n\n    private addQueryParams(url: string, queryParams: { [key: string]: string }): string {\n        let queryString = \"\";\n        let concatinator = url.indexOf(\"?\") !== -1 ? \"&\" : \"?\";\n        Object.getOwnPropertyNames(queryParams).forEach(property => {\n            const prop = property as keyof typeof queryParams;\n            queryString += concatinator + prop + \"=\" + queryParams[prop];\n            if (concatinator === \"?\") {\n                concatinator = \"&\";\n            }\n        });\n        return url + queryString;\n    }\n}\n","// tslint:disable-next-line:no-implicit-dependencies\nconsole.log(\"#index, hello\");\nimport \"./css/index.css\";\n\nconst s3Base = \"https://www.harp.gl/docs/\";\n\n//Update initial links to s3 base\ndocument.querySelector<HTMLAnchorElement>(\".examples-link\")!.href = s3Base + \"master/examples/\";\ndocument.querySelector<HTMLAnchorElement>(\".docs-link\")!.href = s3Base + \"master/doc/\";\ndocument.querySelector<HTMLAnchorElement>(\"#docs-nav\")!.href = s3Base + \"master/doc/\";\ndocument.querySelector<HTMLAnchorElement>(\"#examples-nav\")!.href = s3Base + \"master/examples/\";\ndocument.querySelector<HTMLAnchorElement>(\"#docs-nav-mobile\")!.href = s3Base + \"master/doc/\";\n\n//Update year\n(document.getElementById(\"year\") as HTMLDivElement).innerText = `${new Date().getFullYear()}`;\n\nconst releases = [\n    {\n        date: \"latest\",\n        hash: \"master\",\n        version: \"latest-dev\"\n    }\n];\nconst dropdown = document.querySelector(\"select[name=versions]\") as HTMLSelectElement;\n\nfetch(\"./releases.json\")\n    .then(res => res.json())\n    .then(res => {\n        releases.push(...res);\n        releases.forEach(release => {\n            const option = document.createElement(\"option\");\n            option.innerText = release.version;\n            dropdown.appendChild(option);\n        });\n\n        dropdown.onchange = () => {\n            const selected = dropdown.querySelector<HTMLOptionElement>(\"option:checked\")!;\n            const release = releases.find(x => x.version === selected.innerText);\n            if (!release) {\n                return;\n            }\n            const hash = release.hash;\n            const version = release.version;\n\n            //Update examples button and link\n            document.querySelector<HTMLAnchorElement>(\".examples-link\")!.href =\n                s3Base + hash + \"/examples/\";\n            document.querySelector<HTMLAnchorElement>(\".examples-link\")!.innerText =\n                \"Examples\" + (hash !== \"master\" ? ` (${version})` : \"\");\n\n            //Update docs button and link\n            document.querySelector<HTMLAnchorElement>(\".docs-link\")!.href = s3Base + hash + \"/doc/\";\n            document.querySelector<HTMLAnchorElement>(\".docs-link\")!.innerText =\n                \"Documentation\" + (hash !== \"master\" ? ` (${version})` : \"\");\n        };\n    })\n    .catch(() => {\n        //In case network request to build information fails, add master link\n        const option = document.createElement(\"option\");\n        option.innerText = \"master\";\n        dropdown.appendChild(option);\n    });\n\nasync function createMapInt(canvas: HTMLCanvasElement) {\n    if (typeof canvas.transferControlToOffscreen === \"function\") {\n        return import(\"./WorkerMapViewFacade\").then(({ createMapViewInWorker }) => {\n            return createMapViewInWorker(canvas);\n        });\n    } else {\n        return import(\"./map\").then(({ createMap }) => {\n            return createMap({ canvas });\n        });\n    }\n}\n\nasync function main() {\n    const theCanvas = document.getElementById(\"map\") as HTMLCanvasElement;\n    const map = await createMapInt(theCanvas);\n\n    // tslint:disable-next-line:no-console\n    map.addEventListener(\"theme-loaded\", () => console.log(\"#ThemeLoaded\"));\n\n    map.resize(window.innerWidth, 500);\n    window.addEventListener(\"resize\", () => map.resize(window.innerWidth, 500));\n\n    const options = { tilt: 34.3, distance: 1400 };\n    const Boston = { latitude: 42.361145, longitude: -71.057083 };\n    let azimuth = 135;\n    map.lookAt(Boston, options.distance, options.tilt, azimuth);\n\n    map.addEventListener(\"frame-complete\", () => {\n        // tslint:disable-next-line:no-console\n        console.log(\"#FirstFrameComplete, starting animation\");\n        theCanvas.style.opacity = \"1\";\n\n        map.addEventListener(\"render\", () =>\n            map.lookAt(Boston, options.distance, options.tilt, (azimuth += 0.1))\n        );\n        setTimeout(() => {\n            map.beginAnimation();\n        }, 0.5);\n    });\n}\n\nmain();\n","import { GeoCoordinatesLike } from \"@here/harp-geoutils\";\nimport { getAppBaseUrl } from \"@here/harp-utils\";\nimport { EventEmitter } from \"events\";\n\nexport async function createMapViewInWorker(canvas: HTMLCanvasElement) {\n    const offscreen = canvas.transferControlToOffscreen();\n    const worker = new Worker(\"mapview-worker.bundle.js\");\n\n    worker.addEventListener(\"error\", (event: ErrorEvent) => {\n        console.log(\"MapViewWorkerFacade#error!\", event);\n    });\n\n    worker.postMessage(\n        {\n            type: \"mapview-worker-init\",\n            canvas: offscreen,\n            baseUrl: getAppBaseUrl(),\n            clientHeight: canvas.clientHeight,\n            clientWidth: canvas.clientWidth,\n            pixelRatio: window.devicePixelRatio\n        },\n        [(offscreen as unknown) as Transferable]\n    );\n\n    const eventHandler = new EventEmitter();\n    worker.addEventListener(\"message\", (event: MessageEvent) => {\n        const message = event.data;\n        if (message.type === \"event\") {\n            eventHandler.emit(message.eventName, message.data);\n        }\n    });\n\n    return {\n        resize(width: number, height: number) {\n            worker.postMessage({ type: \"resize\", width, height });\n        },\n        addEventListener(name: string, listener: () => void) {\n            if (eventHandler.listenerCount(name) === 0) {\n                worker.postMessage({ type: \"addEventListener\", name });\n            }\n\n            eventHandler.on(name, listener);\n        },\n        // removeEventListener() {},\n        lookAt(geoPos: GeoCoordinatesLike, distance: number, tiltDeg: number, headingDeg?: number) {\n            worker.postMessage({\n                type: \"lookAt\",\n                lat: geoPos.latitude,\n                long: geoPos.longitude,\n                distance,\n                tiltDeg,\n                headingDeg\n            });\n        },\n        beginAnimation() {\n            worker.postMessage({ type: \"beginAnimation\" });\n        }\n    };\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * A `PriorityListElement` has a priority to assist in sorting. The idea is that the items in a\n * grouped priority list will not modify their priority during processing to such an amount, that\n * they will change into another group. Smaller lists are smaller to sort, and in case of resource\n * limitation (maximum number of rendered objects reached), not all items have to be sorted at all.\n */\nexport interface PriorityListElement {\n    /**\n     * The integer value of this priority is used to group objects of \"same\" priority.\n     */\n    priority: number;\n}\n\n/**\n * The `PriorityListGroup` contains a list of [[PriorityListElement]]s that all have the same\n * (integer) priority.\n */\nexport class PriorityListGroup<T extends PriorityListElement> {\n    constructor(readonly priority: number, public elements: T[] = new Array()) {}\n\n    /**\n     * Create and return a deep copy of the `PriorityListGroup<T>`.\n     *\n     * @returns A clone of the `PriorityListGroup<T>`.\n     */\n    clone(): PriorityListGroup<T> {\n        return new PriorityListGroup<T>(this.priority, this.elements.slice());\n    }\n}\n\n/**\n * The `PriorityListGroupMap` is a map to map the (integer) priority to a [[PriorityListGroup]].\n */\nexport type PriorityListGroupMap<T extends PriorityListElement> = Map<number, PriorityListGroup<T>>;\n\n/**\n * The `GroupedPriorityList` contains a [[PriorityListGroupMap]] to manage a larger number of items\n * in priority groups.\n */\nexport class GroupedPriorityList<T extends PriorityListElement> {\n    readonly groups: PriorityListGroupMap<T> = new Map();\n    private m_sortedGroups: Array<PriorityListGroup<T>> | undefined;\n    /**\n     * Add an element to the `GroupedPriorityList`. Selects group based on the elements priority.\n     *\n     * @param element Element to be added.\n     */\n    add(element: T): void {\n        this.getGroup(element.priority).elements.push(element);\n    }\n\n    /**\n     * Remove an element from the `GroupedPriorityList`.\n     *\n     * Note: It is required that the priority is the same as it was when the element has been added.\n     * Otherwise, the removal will fail.\n     *\n     * @param element Element to be removed.\n     * @returns `True` if the element was removed, `false` otherwise.\n     */\n    remove(element: T): boolean {\n        const group = this.getGroup(element.priority);\n        if (group !== undefined) {\n            const foundIndex = group.elements.indexOf(element);\n            if (foundIndex >= 0) {\n                group.elements.splice(foundIndex, 1);\n                if (group.elements.length === 0) {\n                    const normalizedPriority = Math.floor(element.priority);\n                    this.groups.delete(normalizedPriority);\n                    if (this.m_sortedGroups) {\n                        this.m_sortedGroups = [];\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Remove all internal [[PriorityListGroup]]s.\n     */\n    clear(): void {\n        this.groups.clear();\n        if (this.m_sortedGroups) {\n            this.m_sortedGroups = [];\n        }\n    }\n\n    /**\n     * Merge another [[GroupedPriorityList]] into this one.\n     *\n     * @param other Other group to merge.\n     */\n    merge(other: GroupedPriorityList<T>): GroupedPriorityList<T> {\n        for (const otherGroup of other.groups) {\n            const group = this.findGroup(otherGroup[1].priority);\n            if (group === undefined) {\n                this.groups.set(Math.floor(otherGroup[1].priority), otherGroup[1].clone());\n                if (this.m_sortedGroups) {\n                    this.m_sortedGroups = [];\n                }\n                continue;\n            }\n            group.elements = group.elements.concat(otherGroup[1].elements);\n        }\n        return this;\n    }\n\n    /**\n     * Return a sorted list of [[PriorityListGroup]]s.\n     */\n    get sortedGroups(): Array<PriorityListGroup<T>> {\n        if (this.m_sortedGroups && this.m_sortedGroups.length > 0) {\n            return this.m_sortedGroups;\n        }\n\n        if (!this.m_sortedGroups) {\n            this.m_sortedGroups = [];\n        }\n        for (const priorityList of this.groups) {\n            this.m_sortedGroups.push(priorityList[1]);\n        }\n\n        this.m_sortedGroups.sort((a: PriorityListGroup<T>, b: PriorityListGroup<T>) => {\n            return b.priority - a.priority;\n        });\n        return this.m_sortedGroups;\n    }\n\n    /**\n     * Apply function to all elements in this `GroupedPriorityList`.\n     *\n     * @param {(element: T) => void} fun Function to apply.\n     */\n    forEach(fun: (element: T) => void): void {\n        for (const group of this.groups) {\n            group[1].elements.forEach(fun);\n        }\n    }\n\n    /**\n     * Count the number of elements in this `GroupedPriorityList`.\n     */\n    count(): number {\n        let n = 0;\n        for (const group of this.groups) {\n            n += group[1].elements.length;\n        }\n        return n;\n    }\n\n    /**\n     * Get group of elements that have the same (integer) priority.\n     *\n     * @param priority The priority to retrieve all elements from.\n     */\n    private findGroup(priority: number): PriorityListGroup<T> | undefined {\n        const normalizedPriority = Math.floor(priority);\n        const group = this.groups.get(normalizedPriority);\n        return group;\n    }\n\n    /**\n     * Get group of elements that have the same (integer) priority.\n     *\n     * @param priority The priority to retrieve all elements from.\n     */\n    private getGroup(priority: number): PriorityListGroup<T> {\n        let group = this.findGroup(priority);\n\n        if (group === undefined) {\n            const normalizedPriority = Math.floor(priority);\n            group = new PriorityListGroup<T>(normalizedPriority);\n            this.groups.set(normalizedPriority, group);\n            if (this.m_sortedGroups) {\n                this.m_sortedGroups = [];\n            }\n        }\n\n        return group;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport * from \"./ConsoleChannel\";\nexport * from \"./IChannel\";\nexport * from \"./ILogger\";\nexport * from \"./Logger\";\nexport * from \"./LoggerManager\";\nexport * from \"./MultiChannel\";\nexport * from \"./WorkerChannel\";\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ILoggerManager } from \"./ILoggerManager\";\nimport { LoggerManagerImpl } from \"./LoggerManagerImpl\";\n\n/**\n * The LoggerManager class implements a singleton object that handles logging.\n *\n * Example:\n *\n * ```typescript\n *\n * const logger = LoggerManager.instance.create(\"MyFontLoaderClass\");\n * if (missingFonts.length > 0) {\n *     logger.error(\"These fonts can not be loaded: \", missingFonts);\n * } else {\n *     logger.log(\"All fonts have been loaded.\");\n * }\n * ```\n */\nexport class LoggerManager {\n    private static m_instance: ILoggerManager;\n\n    static get instance(): ILoggerManager {\n        return this.m_instance || (this.m_instance = new LoggerManagerImpl());\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ConsoleChannel } from \"./ConsoleChannel\";\nimport { IChannel } from \"./IChannel\";\nimport { ILogger, LoggerOptions, LogLevel } from \"./ILogger\";\nimport { ILoggerManager } from \"./ILoggerManager\";\nimport { Logger } from \"./Logger\";\nimport { WorkerChannel } from \"./WorkerChannel\";\n\n/**\n * LoggerManagerImpl is the class for the singleton instance of the logger manager.\n * It handles channels and loggers.\n */\n\nexport class LoggerManagerImpl implements ILoggerManager {\n    channel: IChannel;\n    private readonly m_loggers: ILogger[] = [];\n    private m_levelSetForAll?: LogLevel;\n\n    constructor() {\n        this.channel = new ConsoleChannel();\n        // typeof self === \"undefined\" || typeof self.document !== \"undefined\"\n        //    ? new ConsoleChannel()\n        //    : new WorkerChannel();\n    }\n\n    getLoggerNames(): string[] {\n        return this.m_loggers.map(logger => logger.name);\n    }\n\n    getLogger(name: string): ILogger | undefined {\n        return this.m_loggers.find(logger => logger.name === name);\n    }\n\n    create(loggerName: string, options: LoggerOptions = {}): ILogger {\n        if (\n            this.m_levelSetForAll !== undefined &&\n            (options.level === undefined || options.level < this.m_levelSetForAll)\n        ) {\n            options.level = this.m_levelSetForAll;\n        }\n        const logger = new Logger(loggerName, this.channel, options);\n        this.m_loggers.push(logger);\n        return logger;\n    }\n\n    dispose(logger: ILogger) {\n        const found = this.m_loggers.indexOf(logger);\n        if (found < 0) {\n            throw new Error(`Cannot unregister \"${logger}\" : no such logger registered.`);\n        }\n        this.m_loggers.splice(found, 1);\n    }\n\n    updateAll(options: LoggerOptions) {\n        for (const logger of this.m_loggers) {\n            logger.update(options);\n        }\n    }\n\n    update(loggerName: string, config: LoggerOptions) {\n        for (const logger of this.m_loggers) {\n            if (logger.name === loggerName) {\n                logger.update(config);\n            }\n        }\n    }\n\n    enableAll(enabled: boolean) {\n        for (const logger of this.m_loggers) {\n            logger.enabled = enabled;\n        }\n    }\n\n    enable(loggerName: string, value: boolean) {\n        this.update(loggerName, { enabled: value });\n    }\n\n    setLogLevelForAll(level: LogLevel) {\n        this.m_levelSetForAll = level;\n        for (const logger of this.m_loggers) {\n            logger.level = level;\n        }\n    }\n\n    setLogLevel(loggerName: string, level: LogLevel) {\n        this.update(loggerName, { level });\n    }\n\n    setChannel(channel: IChannel) {\n        this.channel = channel;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { IChannel } from \"./IChannel\";\n\n/**\n * Class allowing mixing several channels.\n */\nexport class MultiChannel implements IChannel {\n    private readonly channels: IChannel[] = [];\n    constructor(...channels: IChannel[]) {\n        this.channels = channels;\n    }\n\n    error(message?: any, ...optionalParams: any[]) {\n        for (const channel of this.channels) {\n            channel.error(message, ...optionalParams);\n        }\n    }\n\n    debug(message?: any, ...optionalParams: any[]) {\n        for (const channel of this.channels) {\n            channel.debug(message, ...optionalParams);\n        }\n    }\n\n    info(message?: any, ...optionalParams: any[]) {\n        for (const channel of this.channels) {\n            channel.info(message, ...optionalParams);\n        }\n    }\n\n    log(message?: any, ...optionalParams: any[]) {\n        for (const channel of this.channels) {\n            channel.log(message, ...optionalParams);\n        }\n    }\n\n    trace(message?: any, ...optionalParams: any[]) {\n        for (const channel of this.channels) {\n            channel.trace(message, ...optionalParams);\n        }\n    }\n\n    warn(message?: any, ...optionalParams: any[]) {\n        for (const channel of this.channels) {\n            channel.warn(message, ...optionalParams);\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { IChannel } from \"./IChannel\";\nimport { LogLevel } from \"./ILogger\";\n\ndeclare let self: Worker;\n\nexport const WORKERCHANNEL_MSG_TYPE = \"worker-channel-message\";\n\n/**\n * The interface for the messages of the WorkerChannel.\n */\nexport interface IWorkerChannelMessage {\n    message: any[];\n    type: \"worker-channel-message\";\n    level: LogLevel;\n}\n\n/**\n * The class for the worker channel.\n */\nexport class WorkerChannel implements IChannel {\n    error(message?: any, ...optionalParams: any[]) {\n        const workerMessage: IWorkerChannelMessage = {\n            message: [message, ...optionalParams],\n            type: WORKERCHANNEL_MSG_TYPE,\n            level: LogLevel.Error\n        };\n        self.postMessage(workerMessage);\n    }\n\n    debug(message?: any, ...optionalParams: any[]) {\n        const workerMessage: IWorkerChannelMessage = {\n            message: [message, ...optionalParams],\n            type: WORKERCHANNEL_MSG_TYPE,\n            level: LogLevel.Debug\n        };\n        self.postMessage(workerMessage);\n    }\n\n    info(message?: any, ...optionalParams: any[]) {\n        const workerMessage: IWorkerChannelMessage = {\n            message: [message, ...optionalParams],\n            type: WORKERCHANNEL_MSG_TYPE,\n            level: LogLevel.Info\n        };\n        self.postMessage(workerMessage);\n    }\n\n    log(message?: any, ...optionalParams: any[]) {\n        const workerMessage: IWorkerChannelMessage = {\n            message: [message, ...optionalParams],\n            type: WORKERCHANNEL_MSG_TYPE,\n            level: LogLevel.Log\n        };\n        self.postMessage(workerMessage);\n    }\n\n    trace(message?: any, ...optionalParams: any[]) {\n        const workerMessage: IWorkerChannelMessage = {\n            message: [message, ...optionalParams],\n            type: WORKERCHANNEL_MSG_TYPE,\n            level: LogLevel.Trace\n        };\n        self.postMessage(workerMessage);\n    }\n\n    warn(message?: any, ...optionalParams: any[]) {\n        const workerMessage: IWorkerChannelMessage = {\n            message: [message, ...optionalParams],\n            type: WORKERCHANNEL_MSG_TYPE,\n            level: LogLevel.Warn\n        };\n        self.postMessage(workerMessage);\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport namespace Math2D {\n    /**\n     * Alternative 2D box object with less memory impact (four numbers instead of two min/max\n     * objects with two numbers each). Should be faster.\n     */\n    export class Box {\n        /**\n         * Alternative 2D box object with less memory impact (four numbers instead of two min/max\n         * objects with two numbers each). Should be faster.\n         *\n         * @param x New X value.\n         * @param y New y value.\n         * @param w New w value.\n         * @param h New h value.\n         */\n        constructor(public x = 0, public y = 0, public w = 0, public h = 0) {}\n\n        /**\n         * Set new values to all properties of the box.\n         *\n         * @param x New X value.\n         * @param y New y value.\n         * @param w New w value.\n         * @param h New h value.\n         */\n        set(x: number, y: number, w: number, h: number) {\n            this.x = x;\n            this.y = y;\n            this.w = w;\n            this.h = h;\n        }\n\n        /**\n         * Test box for inclusion of point.\n         *\n         * @param x X coordinate of point.\n         * @param y Y coordinate of point.\n         */\n        contains(x: number, y: number): boolean {\n            return this.x <= x && this.x + this.w >= x && this.y <= y && this.y + this.h >= y;\n        }\n\n        /**\n         * Test two boxes for intersection.\n         *\n         * @param other Box 2 to test for intersection.\n         */\n        intersects(other: Box): boolean {\n            return (\n                this.x <= other.x + other.w &&\n                this.x + this.w >= other.x &&\n                this.y <= other.y + other.h &&\n                this.y + this.h >= other.y\n            );\n        }\n    }\n\n    /**\n     * Box to store UV coordinates.\n     */\n    export interface UvBox {\n        s0: number;\n        t0: number;\n        s1: number;\n        t1: number;\n    }\n\n    /**\n     * Compute squared distance between two 2D points `a` and `b`.\n     *\n     * @param ax Point a.x\n     * @param ay Point a.y\n     * @param bx Point b.x\n     * @param by Point b.y\n     * @returns Squared distance between the two points\n     */\n    export function distSquared(ax: number, ay: number, bx: number, by: number): number {\n        return (ax - bx) * (ax - bx) + (ay - by) * (ay - by);\n    }\n\n    /**\n     * Computes the squared length of a line.\n     *\n     * @param line An array of that forms a line via [x,y,z,x,y,z,...] tuples.\n     */\n    export function computeSquaredLineLength(line: number[]): number {\n        let squaredLineLength: number = 0;\n\n        const length = line.length - 4;\n        for (let i = 0; i < length; i += 3) {\n            const xDiff = line[i + 3] - line[i];\n            const yDiff = line[i + 4] - line[i + 1];\n            squaredLineLength += xDiff * xDiff + yDiff * yDiff;\n        }\n        return squaredLineLength;\n    }\n\n    /**\n     * Compute squared distance between a 2D point and a 2D line segment.\n     *\n     * @param px Test point X\n     * @param py Test point y\n     * @param l0x Line segment start X\n     * @param l0y Line segment start Y\n     * @param l1x Line segment end X\n     * @param l1y Line segment end Y\n     * @returns Squared distance between point and line segment\n     */\n    export function distToSegmentSquared(\n        px: number,\n        py: number,\n        l0x: number,\n        l0y: number,\n        l1x: number,\n        l1y: number\n    ): number {\n        const lineLengthSuared = distSquared(l0x, l0y, l1x, l1y);\n        if (lineLengthSuared === 0) {\n            return distSquared(px, py, l0x, l0y);\n        }\n        let t = ((px - l0x) * (l1x - l0x) + (py - l0y) * (l1y - l0y)) / lineLengthSuared;\n        t = Math.max(0, Math.min(1, t));\n        return distSquared(px, py, l0x + t * (l1x - l0x), l0y + t * (l1y - l0y));\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport namespace MathUtils {\n    /**\n     * Ensures that input value fits in a given range.\n     *\n     * @param value The value to be clamped.\n     * @param min Minimum value.\n     * @param max Maximum value.\n     *\n     * @returns Clamped value.\n     */\n    export function clamp(value: number, min: number, max: number): number {\n        return value < min ? min : value > max ? max : value;\n    }\n\n    /**\n     * Returns a linear interpolation between the values of edge0 and edge1 based on the factor.\n     *\n     * Given two known points the linear interpolant between these points may be presented as\n     * straight line. This means that for given factor change the resulting change of return\n     * value is always const.\n     * @see https://en.wikipedia.org/wiki/Linear_interpolation\n     *\n     * @param edge0\n     * @param edge1\n     * @param factor Interpolation factor that ranges between: 0 <= x <= 1.\n     */\n    export function lerp(edge0: number, edge1: number, factor: number): number {\n        return edge0 * (1 - factor) + edge1 * factor;\n    }\n\n    /**\n     * Returns a smooth interpolation between the values edge0 and edge1 based on the interpolation\n     * factor x. `0 <= x <= 1`.\n     * @see https://en.wikipedia.org/wiki/Smoothstep\n     *\n     * @param edge0\n     * @param edge1\n     * @param x\n     */\n    export function smoothStep(edge0: number, edge1: number, x: number) {\n        // Scale, bias and saturate x to 0..1 range\n        x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n        // Evaluate polynomial\n        return x * x * (3 - 2 * x);\n    }\n\n    /**\n     * Returns a smooth interpolation between the values edge0 and edge1 based on the interpolation\n     * factor x. `0 <= x <= 1`.\n     *\n     * Improved version by Ken Perlin, which has zero 1st- and 2nd-order derivatives at `x = 0` and\n     * `x = 1`:\n     *\n     * @see https://en.wikipedia.org/wiki/Smoothstep\n     *\n     * @param edge0\n     * @param edge1\n     * @param x\n     */\n    export function smootherStep(edge0: number, edge1: number, x: number) {\n        // Scale, and clamp x to 0..1 range\n        x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n        // Evaluate polynomial\n        return x * x * x * (x * (x * 6 - 15) + 10);\n    }\n\n    /**\n     * Maps a number from one range to another.\n     *\n     * @param val The incoming value to be converted.\n     * @param inMin Lower bound of the value's current range.\n     * @param inMax Upper bound of the value's current range.\n     * @param outMin Lower bound of the value's target range.\n     * @param outMax Upper bound of the value's target range.\n     */\n    export function map(val: number, inMin: number, inMax: number, outMin: number, outMax: number) {\n        return ((val - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;\n    }\n\n    /**\n     * Returns the smaller of the two given numbers. Both numbers may be undefined, in which case\n     * the result is undefined. If only one of the numbers is undefined, the other number is\n     * returned.\n     *\n     * @param a First number.\n     * @param b Second number.\n     */\n    export function min2(a: number | undefined, b: number | undefined): number | undefined {\n        let result: number | undefined;\n\n        if (a !== undefined) {\n            result = a;\n        }\n        if (b !== undefined) {\n            result = result === undefined ? b : Math.min(result, b);\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns the larger of the two given numbers. Both numbers may be undefined, in which case\n     * the result is undefined. If only one of the numbers is undefined, the other number is\n     * returned.\n     *\n     * @param a First number.\n     * @param b Second number.\n     */\n    export function max2(a: number | undefined, b: number | undefined): number | undefined {\n        let result: number | undefined;\n\n        if (a !== undefined) {\n            result = a;\n        }\n        if (b !== undefined) {\n            result = result === undefined ? b : Math.max(result, b);\n        }\n\n        return result;\n    }\n\n    /**\n     * Checks if the value of a given number is inside an upper or lower bound. The bounds may be\n     * undefined, in which case their value is ignored.\n     *\n     * @param value Value to check.\n     * @param lowerBound The lower bound to check the value against.\n     * @param upperBound The upper bound to check the value against.\n     *\n     * @returns `true` if value is inside the bounds or if the bounds are `undefined`, `false`\n     *          otherwise.\n     */\n    export function isClamped(\n        value: number,\n        lowerBound: number | undefined,\n        upperBound: number | undefined\n    ): boolean {\n        if (lowerBound !== undefined && value < lowerBound) {\n            return false;\n        }\n        if (upperBound !== undefined && value > upperBound) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Smoothly interpolates between two values using cubic formula\n     *\n     * @param startValue\n     * @param endValue\n     * @param time\n     * @returns Result of the interpolation within the range of `[startValue, endValue]`\n     */\n    export function easeInOutCubic(startValue: number, endValue: number, time: number): number {\n        const timeValue =\n            time < 0.5 ? 4 * time * time * time : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1;\n        return startValue + (endValue - startValue) * timeValue;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Copy methods and properties from one prototype into another.\n *\n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n *\n * @param derivedCtor Class to mix methods and properties into.\n * @param baseCtors Class to take all methods and properties from.\n */\nexport function applyMixins(derivedCtor: any, baseCtors: any[]) {\n    baseCtors.forEach(baseCtor => {\n        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n            derivedCtor.prototype[name] = baseCtor.prototype[name];\n        });\n    });\n}\n\n/**\n * Copy methods from one prototype into another.\n *\n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n *\n * @param derivedCtor Class to mix methods into.\n * @param baseCtors Class to take all methods from.\n */\nexport function applyMixinsWithoutProperties(derivedCtor: any, baseCtors: any[]) {\n    baseCtors.forEach(baseCtor => {\n        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n            const descriptor = Object.getOwnPropertyDescriptor(baseCtor.prototype, name);\n            if (descriptor !== undefined && descriptor.get === undefined) {\n                derivedCtor.prototype[name] = baseCtor.prototype[name];\n            }\n        });\n    });\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\ndeclare const process: any;\n\n// cache value, because access to process.env.NODE_ENV is SLOW!\nconst isProduction = process.env.NODE_ENV === \"production\";\n\n//TODO: Make assertHandler configurable\n\n/**\n * Implementation of assert as a development help\n *\n * Note - this is deliberately a global function so that minimizers remove the\n * entire call when building for production.\n *\n * @hidden\n * @param condition Condition to match, if false, throws an Error(message)\n * @param message Optional message, defaults to \"ASSERTION failed\"\n */\nexport function assert(condition: boolean, message?: string): void {\n    if (!isProduction) {\n        if (!condition) {\n            throw new Error(message !== undefined ? message : \"ASSERTION failed\");\n        }\n    }\n}\n\nexport function assertExists<T>(element: T | undefined, message?: string): T {\n    if (!isProduction) {\n        if (element === undefined || element === null) {\n            throw new Error(\n                message !== undefined ? message : \"ASSERTION failed: Element is undefined or null\"\n            );\n        }\n    }\n    return element!;\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Refinement of `console` interface only for important information i.e `info`, `warn` and `errors`.\n */\nexport interface ISimpleChannel {\n    info(message?: any, ...optionalParams: any[]): void;\n    warn(message?: any, ...optionalParams: any[]): void;\n    error(message?: any, ...optionalParams: any[]): void;\n}\n\n/**\n * Extension of [[ISimpleChannel]] to support contextual logging by adding stack of prefixes.\n */\nexport interface IContextLogger extends ISimpleChannel {\n    /**\n     * Push \"attribute-like\" context.\n     */\n    pushAttr(name: string): void;\n\n    /**\n     * Push \"index-like\" context.\n     *\n     * Following log messages will be prefixed with `[index]`.\n     */\n    pushIndex(index: string | number): void;\n\n    /**\n     * Remove current context from top of stack.\n     */\n    pop(): void;\n}\n\n/**\n * Context-aware logger that decorates log message with stack-based prefix, emits `headerMessage`\n * before first actual log message.\n */\nexport class ContextLogger implements IContextLogger {\n    private readonly context: string[] = [];\n    private m_headerLogged = false;\n\n    /**\n     * Construct a context-aware logger that logs to `m_logger`.\n     */\n    constructor(readonly m_logger: ISimpleChannel, readonly headerMessage: string) {}\n\n    /**\n     * Push \"attribute-like\" context.\n     *\n     * Following log messages will be prefixed with `name` or `.name` depending on current context.\n     */\n    pushAttr(name: string) {\n        this.context.push(`${this.context.length > 0 ? \".\" : \"\"}${name}`);\n    }\n\n    /**\n     * Push \"index-like\" context.\n     *\n     * Following log messages will be prefixed with `[index]`.\n     */\n    pushIndex(index: string | number) {\n        this.context.push(`[${index}]`);\n    }\n\n    pop() {\n        this.context.pop();\n    }\n\n    // They, are public member functions it's just tslint who doesn't understand this.\n\n    // tslint:disable:member-ordering\n    warn = this.createLogMethod(\"warn\");\n    info = this.createLogMethod(\"info\");\n    error = this.createLogMethod(\"error\");\n    // tslint:enable:member-ordering\n\n    private createLogMethod(severity: \"warn\" | \"info\" | \"error\") {\n        return (message: string, ...rest: any[]) => {\n            if (!this.m_headerLogged) {\n                this.m_logger.info(this.headerMessage);\n                this.m_headerLogged = true;\n            }\n            this.m_logger[severity](`${this.context.join(\"\")}: ${message}`, ...rest);\n        };\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/* tslint:disable:max-line-length */\n/**\n * See:\n * https://developers.google.com/web/updates/2012/08/When-milliseconds-are-not-enough-performance-now\n */\n/* tslint:ensable:max-line-length */\n\nexport class PerformanceTimer {\n    /**\n     * Returns timestamp in milliseconds since page load.\n     *\n     * If the [[DOMHighResTimeStamp]] is supported, the resolution is up to 5 microseconds,\n     * otherwise it is in milliseconds. Timespans are computed by taking the difference between two\n     * samples.\n     *\n     * Example:\n     * ```typescript\n     * const now = PerformanceTimer.now();\n     * // call some expensive function for which you want to check the duration.\n     * const end = PerformanceTimer.now();\n     * const elapsedTime = end - now;\n     * ```\n     */\n    static now(): number {\n        return PerformanceTimer.nowFunc();\n    }\n\n    // tslint:disable-next-line:no-unused-variable\n    private static readonly instance = new PerformanceTimer();\n\n    private static readonly nowFunc: () => number = PerformanceTimer.getNowFunc();\n\n    private static getNowFunc() {\n        if (typeof performance !== \"undefined\" && typeof performance.now !== \"undefined\") {\n            return () => performance.now();\n        }\n\n        // fall back to Date.getTime()\n        return () => {\n            return new Date().getTime();\n        };\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Deep clone of object.\n *\n * Like `JSON.parse(JSON.stringify(obj))`, but supports basic javascript types (string, number,\n * object), `Date` and `RegExp`s and cycles.\n *\n * Throws error if enounters object with `prototype` assuming that in general class instances\n * cannot be reliably cloned by generic algorithm.\n */\nexport function cloneDeep<T>(obj: T): T {\n    const cache: Map<object, object> = new Map();\n    function cloneInternal(src: any): any {\n        if (src === null) {\n            return null;\n        } else if (typeof src === \"object\") {\n            const cached = cache.get(src);\n            if (cached !== undefined) {\n                return cached;\n            }\n\n            if (Array.isArray(src)) {\n                const result: any[] = [];\n                cache.set(src, result);\n                result.length = src.length;\n                for (let i = 0; i < result.length; ++i) {\n                    result[i] = cloneInternal(src[i]);\n                }\n                return result;\n            } else if (src instanceof Date) {\n                const result = new Date(src.getTime());\n                cache.set(src, result);\n                return result;\n            } else if (src instanceof RegExp) {\n                const result = new RegExp(src.source, src.flags);\n                cache.set(src, result);\n                return result;\n            } else if (src.constructor !== Object) {\n                throw new Error(\"cloneDeep doesn't support objects with custom prototypes\");\n            } else {\n                const result: typeof src = {};\n                cache.set(src, result);\n                for (const key in src) {\n                    if (src.hasOwnProperty(key)) {\n                        result[key] = cloneInternal(src[key]);\n                    }\n                }\n                return result;\n            }\n        } else {\n            // string, number, boolean, undefined and functions are returned as is\n            return src;\n        }\n    }\n\n    const r = cloneInternal(obj);\n    cache.clear();\n    return r;\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Get first defined value.\n *\n * Specialized \"replacement\" for `a || b || c` used frequently to get value from various sources\n * (defaults, configs  constants).\n * In contrast to `||`, this function provides proper typing for usual use cases (constant as last\n * argument) and correct treatment of `null` and `undefined`.\n *\n * If last parameter is \"defined\" then return type is `T`, otherwise return type is `T | undefined`.\n *\n * Usage example:\n *\n *     interface Config {\n *         x?: number;\n *     }\n *     const someConfig: Config = {};\n *     const val: number | undefined = undefined;\n *     const DEFAULT = 5;\n *     const x = getOptionValue(val, someConfig.x, DEFAULT);\n *         // typeof x === 'number' because DEFAULT is defined\n *     const y = getOptionValue(val, someConfig.x);\n *         // typeof y === 'number | undefined' because someConfig.x is possibly undefined\n */\n// specialized overloads with last param defined params overload\nexport function getOptionValue<T>(a: T): T;\nexport function getOptionValue<T>(a: T | undefined, b: T): T;\nexport function getOptionValue<T>(a: T | undefined, b: T | undefined, c: T): T;\nexport function getOptionValue<T>(a: T | undefined, b: T | undefined, c: T | undefined, d: T): T;\nexport function getOptionValue<T>(...values: Array<T | undefined>): T | undefined;\n\nexport function getOptionValue<T>(...values: Array<T | undefined>): T | undefined {\n    for (const candidate of values) {\n        if (candidate !== undefined && candidate !== null) {\n            return candidate;\n        }\n    }\n    return undefined;\n}\n\n/**\n * Merge options into existing parameters object.\n *\n * Convenience helper with _similar_ semantics as:\n *\n *     const finalParams1 = { ...defaults, ... options };\n *     const finalParams2 = Object.assign({}, defaults, options);\n *\n * This function doesn't copy _extra_ properties of `options` that doesn't exist in `defaults`.\n * `defaults` is used as _parameters_ template.\n *\n * This doc uses following notion of `option` and `parameter` terms:\n * * `parameter` is a variable, or 'almost constant' of procedure/function/algorith/object\n *    * `parameter` usually have sensible and usually used default\n *    * `parameter` is always defined (no `undefined`, `null` or `?` in type)\n *    * `parameter` can be overriden by specyfying `option` with same name\n * * `option` means value that may be passed optionally, overrides `parameter` value with same name\n *\n * Usage:\n *\n *     interface FooParams {\n *         useTextures: boolean;\n *         opacity: number;\n *     }\n *\n *     const FOO_DEFAULTS: FooParams = {\n *         useTextures: true,\n *         opacity: 0.8\n *     };\n *\n *     type FooOptions = Partial<FooParams>;\n *\n *     function doSomething(options: FooOptions) {\n *         const params = mergeWithOptions(FOO_DEFAULTS, options);\n *             // typeof params === FooParams\n *             // params.opacity = 0.5\n *             // params.useTextures = true\n *             // params.someOtherOptionFromOtherApi is not defined\n *     }\n *     const opt = {opacity: 0.5, someOtherOptionFromOtherApi: 'aaa'};\n *     doSomething(opt);\n *\n * Rationale:\n *   * both `Object.assign` and spread operator copy extra options\n *   * `Object.assign` & `spread operator` may copy `undefined` and `null`s if they really exist\n *     in options object\n *\n * @param parameters parmeters template object holding all expected parameters\n * @param options options object\n * @returns new object with `parameters` overriden by values from `options`\n */\nexport function mergeWithOptions<T extends object>(parameters: T, options?: Partial<T>): T {\n    // NOTE: `as object` needed due to TypeScript bug:\n    //       https://github.com/Microsoft/TypeScript/issues/14409\n    // tslint:disable-next-line:no-object-literal-type-assertion\n    const result = { ...(parameters as object) } as T;\n    if (options === undefined || options === null) {\n        return result;\n    }\n    for (const prop in parameters) {\n        if (parameters.hasOwnProperty(prop)) {\n            const optionValue = options[prop];\n            if (optionValue !== undefined && optionValue !== null) {\n                result[prop] = optionValue as any;\n            }\n        }\n    }\n    return result;\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { resolveReferenceUri } from \"./UrlUtils\";\n\n/**\n * Custom, app-specific URI resolver interface.\n */\nexport interface UriResolver {\n    /**\n     * Attempt to resolve `URI` to `URL`.\n     *\n     * If given resolver doesn't know about this specific kind of `URI`, it should return string as\n     * received.\n     *\n     * @param input `URI`\n     * @returns actual `URL` if this handler knows how locate given `uri` or original `uri`\n     */\n    resolveUri(uri: string): string;\n}\n\nexport interface PrefixUriResolverDefinition {\n    [prefix: string]: string;\n}\n\n/**\n * Basic, import-map like [[UriResolver]].\n *\n * Resolves `uris` basing on exact or prefix match of `key` from `definitions`.\n *\n * In definitions, `key` is matched against input uri with following strategy:\n *  - `key` without trailing `/` -> `key` and input `uri` must be identical\n *  - `key` with trailing `/`, -> `key` is treated as \"package prefix\", so `uri` must start with\n *    `key`\n *\n * Example:\n * ```\n * {\n *     \"local://poiMasterList\": \"/assets/poiMasterList.json\"\n *        // will match only 'local://poiMasterList' and resolve `/assets/poiMasterList.json`\n *     \"local://icons/\": \"/assets/icons/\"\n *        // will match only 'local://icons/ANYPATH' (and similar) and resolve to\n *        // `/assets/icons/ANYPATH\n * }\n * ```\n * Inspired by [`WICG` import maps proposal](https://github.com/WICG/import-maps#the-import-map).\n */\nexport class PrefixMapUriResolver implements UriResolver {\n    constructor(readonly definitions: PrefixUriResolverDefinition) {}\n\n    resolveUri(uri: string) {\n        return Object.keys(this.definitions).reduce((r, key) => {\n            if (key.endsWith(\"/\") && r.startsWith(key)) {\n                const newPrefix = this.definitions[key];\n                return newPrefix + r.substr(key.length);\n            } else if (r === key) {\n                return this.definitions[key];\n            }\n            return r;\n        }, uri);\n    }\n}\n\n/**\n * [UriResolver] that resolve relative `uri`s against to parent resource `uri`.\n */\nexport class RelativeUriResolver implements UriResolver {\n    constructor(readonly parentUri: string) {}\n\n    resolveUri(uri: string) {\n        return resolveReferenceUri(this.parentUri, uri);\n    }\n}\n\n/**\n * Compose URI resolvers.\n *\n * Creates new [[UriResolver]] that applies resolvers in orders or arguments.\n *\n * Example:\n *\n *     const themeUrl = ...; // url of parent object\n *     const childUrlResolver = composeUrlResolvers(\n *           new RelativeUriResolver(themeUrl),\n *           defaultUrlResolver\n *     );\n */\nexport function composeUriResolvers(...resolvers: Array<UriResolver | undefined>): UriResolver {\n    return {\n        resolveUri(originalUrl: string) {\n            return resolvers.reduce((url, resolver) => {\n                if (resolver !== undefined) {\n                    return resolver.resolveUri(url);\n                } else {\n                    return url;\n                }\n            }, originalUrl);\n        }\n    };\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { baseUrl } from \"./UrlUtils\";\n\n/**\n * Get base URL for from where relative URLs will be loaded.\n *\n * * In browser, it resolves to `baseUrl(location.href)` i.e document's base URL\n * (see: https://www.w3.org/TR/WD-html40-970917/htmlweb.html#h-5.1.2).\n *\n * * In node, it resolves to `file://${process.cwd()}`.\n */\nexport function getAppBaseUrl() {\n    if (typeof window === \"undefined\") {\n        if (appBaseUrl !== undefined) {\n            return appBaseUrl;\n        } else {\n            throw new Error(\n                \"getAppBaseUrl: no appBaseUrl defined in worker context, use setAppBaseUrl\"\n            );\n        }\n    }\n    return baseUrl(window.location.href);\n}\n\nlet appBaseUrl: string | undefined;\nexport function setAppBaseUrl(v: string) {\n    appBaseUrl = v;\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Chains two functions for further assigning as one wrapped callback function\n */\nexport function chainCallbacks<T extends (this: unknown, ...args: any[]) => any>(\n    f1: T | null | undefined,\n    f2: T\n): T {\n    return function(this: any, ...args: any[]): ReturnType<T> {\n        if (f1) {\n            f1.apply(this, args);\n        }\n        return f2.apply(this, args);\n    } as T;\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = $getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  var args = [];\n  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    ReflectApply(this.listener, this.target, args);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n","import { MapView, MapViewEventNames, MapViewOptions } from \"@here/harp-mapview\";\nimport { APIFormat, OmvDataSource } from \"@here/harp-omv-datasource\";\n\nimport { accessToken } from \"../@here/harp-examples/config\";\n\nexport function createMap(options: MapViewOptions) {\n    const map = new MapView({\n        ...options,\n        decoderUrl: \"decoder.bundle.js\",\n        theme: \"resources/theme.json\",\n        preserveDrawingBuffer: true,\n        maxVisibleDataSourceTiles: 40,\n        tileCacheSize: 100\n    });\n\n    const omvDataSource = new OmvDataSource({\n        baseUrl: \"https://xyz.api.here.com/tiles/herebase.02\",\n        apiFormat: APIFormat.XYZOMV,\n        styleSetName: \"tilezen\",\n        authenticationCode: accessToken\n    });\n    map.addDataSource(omvDataSource);\n    return map;\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\nimport { enforceBlending } from \"./Utils\";\n\nconst vertexShader: string = `\nuniform float size;\n\nvoid main() {\n    vec3 transformed = vec3(position);\n    vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0);\n\n    gl_Position = projectionMatrix * mvPosition;\n    gl_PointSize = size;\n}\n`;\n\nconst fragmentShader: string = `\nuniform vec3 diffuse;\n\nvoid main() {\n    float alpha = 1.0;\n\n    float radius = 0.5;\n    vec2 coords = gl_PointCoord.xy - vec2(0.5);\n    float len = length(coords);\n    float falloff = fwidth(len);\n    float threshold = 1.0 - smoothstep(radius - falloff, radius, len);\n    alpha *= threshold;\n\n    gl_FragColor = vec4(diffuse, alpha);\n}`;\n\n/**\n * Parameters used when constructing a new [[HighPrecisionPointMaterial]].\n */\nexport interface CirclePointsMaterialParameters extends THREE.ShaderMaterialParameters {\n    /**\n     * Point size.\n     */\n    size?: number;\n}\n\nconst DEFAULT_CIRCLE_SIZE = 1;\n\n/**\n * Material designed to render circle points. Note that it is always transparent since the circle\n * shape is created with an alpha channel to benefit an antialising that a mere `discard` could\n * not bring.\n */\nexport class CirclePointsMaterial extends THREE.ShaderMaterial {\n    isCirclePointsMaterial: true;\n    uniforms: { [uniform: string]: THREE.IUniform };\n    vertexShader: string;\n    fragmentShader: string;\n\n    private m_size: number;\n    private m_color: THREE.Color;\n\n    /**\n     * Constructs a new `CirclePointsMaterial`.\n     *\n     * @param parameters The constructor's parameters.\n     */\n    constructor(parameters: CirclePointsMaterialParameters = {}) {\n        parameters.depthTest = false;\n\n        super(parameters);\n        enforceBlending(this);\n\n        this.isCirclePointsMaterial = true;\n        this.type = \"CirclePointsMaterial\";\n        this.vertexShader = vertexShader;\n        this.fragmentShader = fragmentShader;\n\n        this.m_size = parameters.size || DEFAULT_CIRCLE_SIZE;\n        this.m_color = new THREE.Color();\n\n        this.uniforms = {\n            diffuse: new THREE.Uniform(this.m_color),\n            size: new THREE.Uniform(this.m_size)\n        };\n\n        this.extensions.derivatives = true;\n    }\n\n    /**\n     * Gets the circle screen size.\n     */\n    get size(): number {\n        return this.m_size;\n    }\n\n    /**\n     * Sets the circle screen size.\n     */\n    set size(size: number) {\n        this.m_size = size;\n        this.uniforms.size.value = size;\n    }\n\n    /**\n     * Gets the diffuse.\n     */\n    get color(): string {\n        return \"#\" + this.m_color.getHexString();\n    }\n\n    /**\n     * Sets the diffuse.\n     */\n    set color(color: string) {\n        this.m_color.set(color);\n        this.uniforms.diffuse.value.set(this.m_color);\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport {\n    DisplacementFeature,\n    DisplacementFeatureParameters,\n    ExtrusionFeature,\n    FadingFeature,\n    FadingFeatureParameters\n} from \"./MapMeshMaterials\";\nimport { enforceBlending } from \"./Utils\";\n\nconst vertexSource: string = `\n#define EDGE_DEPTH_OFFSET 0.0001\n\nattribute vec3 position;\nattribute vec4 color;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 edgeColor;\nuniform float edgeColorMix;\n\n#ifdef USE_DISPLACEMENTMAP\nattribute vec3 normal;\nattribute vec2 uv;\nuniform sampler2D displacementMap;\n#endif\n\nvarying vec3 vColor;\n\n#ifdef USE_EXTRUSION\n#include <extrusion_pars_vertex>\n#endif\n\n#ifdef USE_FADING\n#include <fading_pars_vertex>\n#endif\n\nvoid main() {\n\n    #ifdef USE_COLOR\n    vColor = mix(edgeColor.rgb, color.rgb, edgeColorMix);\n    #else\n    vColor = edgeColor.rgb;\n    #endif\n\n    vec3 transformed = vec3( position );\n\n    #ifdef USE_EXTRUSION\n    #include <extrusion_vertex>\n    #endif\n\n    #ifdef USE_DISPLACEMENTMAP\n    transformed += normalize( normal ) * texture2D( displacementMap, uv ).x;\n    #endif\n\n    vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\n    gl_Position = projectionMatrix * mvPosition;\n    // After projection gl_Position contains clip space coordinates of each vertex\n    // before perspective division (1 / w), thus only vertexes with -w < z < w should\n    // be displayed and offset. We offset only those edges which z coordinate in NDC\n    // space is between: -inf < z < 1\n    float depthOffset = step(-1.0, -gl_Position.z / gl_Position.w) * EDGE_DEPTH_OFFSET;\n    gl_Position.z -= depthOffset;\n\n    #ifdef USE_FADING\n    #include <fading_vertex>\n    #endif\n}`;\n\nconst fragmentSource: string = `\nprecision highp float;\nprecision highp int;\n\nvarying vec3 vColor;\n\n#ifdef USE_EXTRUSION\n#include <extrusion_pars_fragment>\n#endif\n\n#ifdef USE_FADING\n#include <fading_pars_fragment>\n#endif\n\nvoid main() {\n    float alphaValue = 1.0;\n    gl_FragColor = vec4(vColor, alphaValue);\n\n    #ifdef USE_EXTRUSION\n    #include <extrusion_fragment>\n    #endif\n\n    #ifdef USE_FADING\n    #include <fading_fragment>\n    #endif\n}`;\n\n/**\n * Parameters used when constructing a new [[EdgeMaterial]].\n */\nexport interface EdgeMaterialParameters\n    extends FadingFeatureParameters,\n        DisplacementFeatureParameters {\n    /**\n     * Edge color.\n     */\n    color?: number | string;\n    /**\n     * Color mix value. Mixes between vertexColors and edgeColor.\n     */\n    colorMix?: number;\n}\n\n/**\n * Material designed to render the edges of extruded buildings using GL_LINES. It supports solid\n * colors, vertex colors, color mixing and distance fading.\n */\nexport class EdgeMaterial extends THREE.RawShaderMaterial\n    implements FadingFeature, ExtrusionFeature, DisplacementFeature {\n    static DEFAULT_COLOR: number = 0x000000;\n    static DEFAULT_COLOR_MIX: number = 0.0;\n\n    /**\n     * Constructs a new `EdgeMaterial`.\n     *\n     * @param params `EdgeMaterial` parameters.\n     */\n    constructor(params?: EdgeMaterialParameters) {\n        const defines: { [key: string]: any } = {};\n        const hasDisplacementMap = params !== undefined && params.displacementMap !== undefined;\n\n        if (hasDisplacementMap) {\n            defines.USE_DISPLACEMENTMAP = \"\";\n        }\n\n        const shaderParams = {\n            name: \"EdgeMaterial\",\n            vertexShader: vertexSource,\n            fragmentShader: fragmentSource,\n            uniforms: {\n                edgeColor: new THREE.Uniform(new THREE.Color(EdgeMaterial.DEFAULT_COLOR)),\n                edgeColorMix: new THREE.Uniform(EdgeMaterial.DEFAULT_COLOR_MIX),\n                fadeNear: new THREE.Uniform(FadingFeature.DEFAULT_FADE_NEAR),\n                fadeFar: new THREE.Uniform(FadingFeature.DEFAULT_FADE_FAR),\n                extrusionRatio: new THREE.Uniform(ExtrusionFeature.DEFAULT_RATIO_MIN),\n                displacementMap: new THREE.Uniform(\n                    hasDisplacementMap ? params!.displacementMap : new THREE.Texture()\n                )\n            },\n            depthWrite: false,\n            defines\n        };\n        super(shaderParams);\n        enforceBlending(this);\n\n        FadingFeature.patchGlobalShaderChunks();\n        ExtrusionFeature.patchGlobalShaderChunks();\n\n        // Apply initial parameter values.\n        if (params !== undefined) {\n            if (params.color !== undefined) {\n                this.color.set(params.color as any);\n            }\n            if (params.colorMix !== undefined) {\n                this.colorMix = params.colorMix;\n            }\n            if (params.fadeNear !== undefined) {\n                this.fadeNear = params.fadeNear;\n            }\n            if (params.fadeFar !== undefined) {\n                this.fadeFar = params.fadeFar;\n            }\n\n            if (params.displacementMap !== undefined) {\n                this.displacementMap = params.displacementMap;\n            }\n        }\n    }\n\n    /**\n     * Edge color.\n     */\n    get color(): THREE.Color {\n        return this.uniforms.edgeColor.value as THREE.Color;\n    }\n    set color(value: THREE.Color) {\n        this.uniforms.edgeColor.value = value;\n    }\n\n    /**\n     * Color mix value. Mixes between vertexColors and edgeColor.\n     */\n    get colorMix(): number {\n        return this.uniforms.edgeColorMix.value as number;\n    }\n    set colorMix(value: number) {\n        if (this.uniforms.edgeColorMix.value === value) {\n            return;\n        }\n        this.uniforms.edgeColorMix.value = value;\n        const doMixColor = value > 0.0;\n        if (doMixColor) {\n            // NOTE: We can not check Material.needsUpdate current value cause there is\n            // no getter for this property, setting it to true increments Material version\n            // which in turn forces invalidation.\n            this.needsUpdate = this.defines.USE_COLOR === undefined;\n            this.defines.USE_COLOR = \"\";\n        } else {\n            this.needsUpdate = this.defines.USE_COLOR !== undefined;\n            delete this.defines.USE_COLOR;\n        }\n    }\n\n    get fadeNear(): number {\n        return this.uniforms.fadeNear.value as number;\n    }\n    set fadeNear(value: number) {\n        this.uniforms.fadeNear.value = value;\n    }\n\n    get fadeFar(): number {\n        return this.uniforms.fadeFar.value as number;\n    }\n    set fadeFar(value: number) {\n        if (this.uniforms.fadeFar.value === value) {\n            return;\n        }\n        this.uniforms.fadeFar.value = value;\n        const doFade = value > 0.0;\n        if (doFade) {\n            this.needsUpdate = this.defines.USE_FADING === undefined;\n            this.defines.USE_FADING = \"\";\n        } else {\n            this.needsUpdate = this.defines.USE_FADING !== undefined;\n            delete this.defines.USE_FADING;\n        }\n    }\n\n    get extrusionRatio(): number {\n        return this.uniforms.extrusionRatio.value as number;\n    }\n    set extrusionRatio(value: number) {\n        if (this.uniforms.extrusionRatio.value === value) {\n            return;\n        }\n        this.uniforms.extrusionRatio.value = value;\n        const doExtrusion = value >= ExtrusionFeature.DEFAULT_RATIO_MIN;\n        if (doExtrusion) {\n            this.needsUpdate = this.defines.USE_EXTRUSION === undefined;\n            this.defines.USE_EXTRUSION = \"\";\n        } else {\n            this.needsUpdate = this.defines.USE_EXTRUSION !== undefined;\n            delete this.defines.USE_EXTRUSION;\n        }\n    }\n\n    get displacementMap(): THREE.Texture | undefined {\n        return this.uniforms.displacementMap.value;\n    }\n\n    set displacementMap(map: THREE.Texture | undefined) {\n        if (this.uniforms.displacementMap.value === map) {\n            return;\n        }\n        this.uniforms.displacementMap.value = map;\n        if (map !== undefined) {\n            this.uniforms.displacementMap.value.needsUpdate = true;\n            this.needsUpdate = this.defines.USE_DISPLACEMENTMAP === undefined;\n            this.defines.USE_DISPLACEMENTMAP = \"\";\n        } else {\n            this.needsUpdate = this.defines.USE_DISPLACEMENTMAP !== undefined;\n            delete this.defines.USE_DISPLACEMENTMAP;\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport default {\n    extrusion_pars_vertex: `\n// Extrusion axis (xyz: vector, w: factor).\nattribute vec4 extrusionAxis;\nuniform float extrusionRatio;\nvarying vec4 vExtrusionAxis;\n`,\n    extrusion_vertex: `\ntransformed = transformed + extrusionAxis.xyz * (extrusionRatio - 1.0);\nvExtrusionAxis = vec4(normalMatrix * extrusionAxis.xyz, extrusionAxis.w);\n`,\n    // Modified version of THREE <normal_fragment_begin> shader chunk which, for flat shaded\n    // geometries, computes the normal either with the extrusion axis or fragment derivatives based\n    // on the extrusion factor (1.0 = ceiling, 0.0 = footprint).\n    extrusion_normal_fragment_begin: `\n#ifdef FLAT_SHADED\n    // Flattened this divergent path to prevent undefined behaviour in the following derivatives\n    // functions. For more info:\n    // http://www.aclockworkberry.com/shader-derivative-functions/#Derivatives_and_branches\n\n    // Workaround for Adreno/Nexus5 not able able to do dFdx( vViewPosition ) ...\n    vec3 fdx = vec3(dFdx(vViewPosition.x), dFdx(vViewPosition.y), dFdx(vViewPosition.z));\n    vec3 fdy = vec3(dFdy(vViewPosition.x), dFdy(vViewPosition.y), dFdy(vViewPosition.z));\n    vec3 normal = cross( fdx, fdy );\n    if (vExtrusionAxis.w > 0.999999) {\n        normal = vExtrusionAxis.xyz;\n    }\n    normal = normalize(normal);\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * (float(gl_FrontFacing) * 2.0 - 1.0);\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * (float(gl_FrontFacing) * 2.0 - 1.0);\n\t\t\tbitangent = bitangent * (float(gl_FrontFacing) * 2.0 - 1.0);\n\t\t#endif\n\t#endif\n#endif\n// non perturbed normal for clearcoat among others\nvec3 geometryNormal = normal;\n`,\n    extrusion_pars_fragment: `\nuniform float extrusionRatio;\nvarying vec4 vExtrusionAxis;\n`,\n    extrusion_fragment: `\ngl_FragColor.a *= smoothstep( 0.0, 0.25, extrusionRatio );\n`\n};\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * The shader chunks have their lines \"#ifdef USE_FADING\" commented out, because currently the\n * mesh materials use individually created shader strings based on the materials settings.\n * @see [[FadingMeshBasicMaterial]]\n **/\n\nexport default {\n    fading_pars_vertex: `\nvarying float fadingDepth;\n`,\n\n    fading_vertex: `\nfadingDepth = -mvPosition.z;\n`,\n\n    fading_pars_fragment: `\nvarying float fadingDepth;\nuniform float fadeNear;\nuniform float fadeFar;\n`,\n\n    fading_fragment: `\n\n// lerp with \"hard\" edges\n//float fadingFactor = 1.0 - clamp((fadingDepth - fadeNear) / (fadeFar - fadeNear), 0.0, 1.0);\n\n// smooth transitions\nfloat fadingFactor = smoothstep( fadeNear, fadeFar, fadingDepth );\n\ngl_FragColor.a *= 1.0 - fadingFactor;\n\n// debugging color:\n// gl_FragColor = vec4(1., fadingFactor, fadingFactor, 1.0);\n`\n};\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\nimport linesShaderChunk from \"./ShaderChunks/LinesChunks\";\n\nconst vertexSource: string = `\n#ifdef USE_COLOR\nattribute vec4 color;\nvarying vec3 vColor;\n#endif\n\n// uniforms to implement double-precision\nuniform mat4 u_mvp;             // combined modelView and projection matrix\nuniform vec3 u_eyepos;          // eye position major\nuniform vec3 u_eyepos_lowpart;  // eye position minor ((double) eyepos - (float) eyepos)\n\n// vertex attributes\nattribute vec3 position;        // high part\nattribute vec3 positionLow;     // low part\n\n#include <high_precision_vert_func>\n\nvoid main() {\n    #ifdef USE_COLOR\n    vColor = color.rgb;\n    #endif\n\n    vec3 pos = subtractDblEyePos(position);\n    gl_Position = u_mvp * vec4(pos, 1.0);\n}`;\n\nconst fragmentSource: string = `\nprecision highp float;\nprecision highp int;\n\nuniform vec3 diffuse;\nuniform float opacity;\n\n#ifdef USE_COLOR\nvarying vec3 color;\n#endif\n\nvoid main() {\n    #ifdef USE_COLOR\n    gl_FragColor = vec4( diffuse * vColor, opacity );\n    #else\n    gl_FragColor = vec4( diffuse, opacity );\n    #endif\n}`;\n\n/**\n * Parameters used when constructing a new [[SolidLineMaterial]].\n */\nexport interface HighPrecisionLineMaterialParameters {\n    /**\n     * Line color.\n     */\n    color?: number | string | THREE.Color;\n    /**\n     * Line opacity.\n     */\n    opacity?: number;\n}\n\n/**\n * Material designed to render high precision lines (ideal for position-sensible data).\n */\nexport class HighPrecisionLineMaterial extends THREE.RawShaderMaterial {\n    static DEFAULT_COLOR: number = 0x000050;\n    static DEFAULT_OPACITY: number = 1.0;\n\n    isHighPrecisionLineMaterial: boolean;\n\n    /**\n     * Constructs a new `HighPrecisionLineMaterial`.\n     *\n     * @param params `HighPrecisionLineMaterial` parameters.\n     */\n    constructor(params?: HighPrecisionLineMaterialParameters) {\n        Object.assign(THREE.ShaderChunk, linesShaderChunk);\n\n        const shaderParams = {\n            name: \"HighPrecisionLineMaterial\",\n            vertexShader: vertexSource,\n            fragmentShader: fragmentSource,\n            uniforms: {\n                diffuse: new THREE.Uniform(\n                    new THREE.Color(HighPrecisionLineMaterial.DEFAULT_COLOR)\n                ),\n                opacity: new THREE.Uniform(HighPrecisionLineMaterial.DEFAULT_OPACITY),\n                u_mvp: new THREE.Uniform(new THREE.Matrix4()),\n                u_eyepos: new THREE.Uniform(new THREE.Vector3()),\n                u_eyepos_lowpart: new THREE.Uniform(new THREE.Vector3())\n            }\n        };\n        Object.assign(shaderParams, params);\n        super(shaderParams);\n\n        this.type = \"HighPrecisionLineMaterial\";\n        this.isHighPrecisionLineMaterial = true;\n\n        // Apply initial parameter values.\n        if (params !== undefined) {\n            if (params.color !== undefined) {\n                this.color.set(params.color as any);\n            }\n            if (params.opacity !== undefined) {\n                this.opacity = params.opacity;\n            }\n        }\n\n        this.updateTransparencyFeature();\n    }\n\n    /**\n     * Line color.\n     */\n    get color(): THREE.Color {\n        return this.uniforms.diffuse.value as THREE.Color;\n    }\n    set color(value: THREE.Color) {\n        this.uniforms.diffuse.value = value;\n    }\n\n    private updateTransparencyFeature() {\n        this.transparent = this.opacity < 1.0 ? true : false;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\nimport linesShaderChunk from \"./ShaderChunks/LinesChunks\";\n\nconst vertexSource: string = `\n#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif\n\nuniform float size;\n\n// uniforms to implement double-precision\nuniform mat4 u_mvp;             // combined modelView and projection matrix\nuniform vec3 u_eyepos;          // eye position major\nuniform vec3 u_eyepos_lowpart;  // eye position minor ((double) eyepos - (float) eyepos)\n\n// vertex attributes\nattribute vec3 positionLow;     // low part\n\n#include <high_precision_vert_func>\n\nvoid main() {\n    #ifdef USE_COLOR\n    vColor = color.rgb;\n    #endif\n\n    vec3 pos = subtractDblEyePos(position);\n    gl_Position = u_mvp * vec4(pos, 1.0);\n\n    // ignore sizeAttenuation for now!\n    gl_PointSize = size;\n}`;\n\n/**\n * Parameters used when constructing a new [[HighPrecisionPointMaterial]].\n */\nexport interface HighPrecisionPointMaterialParameters extends THREE.PointsMaterialParameters {\n    /**\n     * Point color.\n     */\n    color?: number | string | THREE.Color;\n    /**\n     * Point opacity.\n     */\n    opacity?: number;\n    /**\n     * Point scale.\n     */\n    scale?: number;\n    /**\n     * UV transformation matrix.\n     */\n    uvTransform?: THREE.Matrix3;\n}\n\n/**\n * Material designed to render high precision points (ideal for position-sensible data).\n */\nexport class HighPrecisionPointMaterial extends THREE.PointsMaterial {\n    static DEFAULT_COLOR: number = 0x000050;\n    static DEFAULT_OPACITY: number = 1.0;\n    static DEFAULT_SIZE: number = 1.0;\n    static DEFAULT_SCALE: number = 1.0;\n\n    isHighPrecisionPointMaterial: boolean;\n    uniforms: { [uniform: string]: THREE.IUniform };\n    vertexShader?: string;\n    fragmentShader?: string;\n\n    /**\n     * Constructs a new `HighPrecisionPointMaterial`.\n     *\n     * @param params `HighPrecisionPointMaterial` parameters.\n     */\n    constructor(params?: HighPrecisionPointMaterialParameters) {\n        Object.assign(THREE.ShaderChunk, linesShaderChunk);\n\n        const shaderParams = params;\n        super(shaderParams);\n\n        this.type = \"HighPrecisionPointMaterial\";\n        this.vertexShader = vertexSource;\n        this.fragmentShader = THREE.ShaderChunk.points_frag;\n        this.fog = false;\n\n        this.uniforms = {\n            diffuse: new THREE.Uniform(new THREE.Color(HighPrecisionPointMaterial.DEFAULT_COLOR)),\n            opacity: new THREE.Uniform(HighPrecisionPointMaterial.DEFAULT_OPACITY),\n            size: new THREE.Uniform(HighPrecisionPointMaterial.DEFAULT_SIZE),\n            scale: new THREE.Uniform(HighPrecisionPointMaterial.DEFAULT_SCALE),\n            map: new THREE.Uniform(new THREE.Texture()),\n            uvTransform: new THREE.Uniform(new THREE.Matrix3()),\n            u_mvp: new THREE.Uniform(new THREE.Matrix4()),\n            u_eyepos: new THREE.Uniform(new THREE.Vector3()),\n            u_eyepos_lowpart: new THREE.Uniform(new THREE.Vector3())\n        };\n\n        this.isHighPrecisionPointMaterial = true;\n\n        // Apply initial parameter values.\n        if (params !== undefined) {\n            if (params.color !== undefined) {\n                this.color.set(params.color as any);\n            }\n            if (params.opacity !== undefined) {\n                this.opacity = params.opacity;\n            }\n            if (params.size !== undefined) {\n                this.size = params.size;\n            }\n            if (params.scale !== undefined) {\n                this.scale = params.scale;\n            }\n            if (params.uvTransform !== undefined) {\n                this.uvTransform = params.uvTransform;\n            }\n            if (params.map !== undefined) {\n                this.map = params.map;\n            }\n        }\n    }\n\n    /**\n     *  Point scale.\n     */\n    get scale(): number {\n        return this.uniforms.scale.value;\n    }\n\n    set scale(value: number) {\n        this.uniforms.scale.value = value;\n    }\n\n    /**\n     * UV transformation matrix.\n     */\n    get uvTransform(): THREE.Matrix3 {\n        return this.uniforms.uvTransform.value;\n    }\n    set uvTransform(value: THREE.Matrix3) {\n        this.uniforms.uvTransform.value = value;\n    }\n}\n\nexport function isHighPrecisionPointMaterial(\n    material: object | undefined\n): material is HighPrecisionPointMaterial {\n    return (\n        material !== undefined &&\n        (material as HighPrecisionPointMaterial).isHighPrecisionPointMaterial === true\n    );\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nconst vertexSource: string = `\nattribute vec4 position;\nattribute vec4 color;\nattribute vec2 uv;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nvarying vec4 vColor;\nvarying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    vColor = color;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xyz, 1.0);\n}`;\n\nconst fragmentSource: string = `\nprecision highp float;\nprecision highp int;\n\nuniform sampler2D map;\n\nvarying vec4 vColor;\nvarying vec2 vUv;\n\nvoid main() {\n\n    vec4 color = texture2D(map, vUv.xy);\n    color *= vColor.a;\n    if (color.a < 0.05) {\n        discard;\n    }\n    gl_FragColor = color;\n}`;\n\n/**\n * Parameters used when constructing a new [[IconMaterial]].\n */\nexport interface IconMaterialParameters {\n    /**\n     * Texture map.\n     */\n    map: THREE.Texture;\n}\n\n/**\n * 2D material for icons, similar to [[TextMaterial]]. Uses component in texture coordinates to\n * apply opacity.\n */\nexport class IconMaterial extends THREE.RawShaderMaterial {\n    /**\n     * Constructs a new `IconMaterial`.\n     *\n     * @param params `IconMaterial` parameters.\n     */\n    constructor(params: IconMaterialParameters) {\n        const shaderParams: THREE.ShaderMaterialParameters = {\n            name: \"IconMaterial\",\n            vertexShader: vertexSource,\n            fragmentShader: fragmentSource,\n            uniforms: {\n                map: new THREE.Uniform(params.map)\n            },\n            depthTest: true,\n            depthWrite: true,\n            transparent: true,\n\n            vertexColors: THREE.VertexColors,\n            premultipliedAlpha: true,\n            blending: THREE.NormalBlending\n        };\n        super(shaderParams);\n    }\n\n    /**\n     * Icon texture map/atlas.\n     */\n    get map(): THREE.Texture {\n        return this.uniforms.map.value;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\n/**\n * The shader used in the [[UnrealBloomPass]] for the bloom/glow effect.\n */\nexport const LuminosityHighPassShader: THREE.Shader = {\n    uniforms: {\n        tDiffuse: { value: null },\n        luminosityThreshold: { value: 1.0 },\n        smoothWidth: { value: 1.0 },\n        defaultColor: { value: new THREE.Color(0x000000) },\n        defaultOpacity: { value: 0.0 }\n    },\n    vertexShader: `\n    varying vec2 vUv;\n    void main() {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }`,\n    fragmentShader: `\n    uniform sampler2D tDiffuse;\n    uniform vec3 defaultColor;\n    uniform float defaultOpacity;\n    uniform float luminosityThreshold;\n    uniform float smoothWidth;\n    varying vec2 vUv;\n    void main() {\n        vec4 texel = texture2D( tDiffuse, vUv );\n        vec3 luma = vec3( 0.299, 0.587, 0.114 );\n        float v = dot( texel.xyz, luma );\n        vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\n        float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\n        gl_FragColor = mix( outputColor, texel, alpha );\n    }`\n};\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport * as THREE from \"three\";\n\nimport { CopyShader } from \"./CopyMaterial\";\n\n/**\n * The material to use for the quad of the [[MSAARenderPass]] in the composing.\n */\nexport class MSAAMaterial extends THREE.ShaderMaterial {\n    /**\n     * The constructor of `MSAAMaterial`.\n     *\n     * @param uniforms The [[CopyShader]]'s uniforms.\n     */\n    constructor(uniforms: { [uniformName: string]: THREE.IUniform }) {\n        super({\n            uniforms,\n            vertexShader: CopyShader.vertexShader,\n            fragmentShader: CopyShader.fragmentShader,\n            premultipliedAlpha: true,\n            transparent: true,\n            blending: THREE.AdditiveBlending,\n            depthTest: false,\n            depthWrite: false\n        });\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport * as THREE from \"three\";\n\n/**\n * `SepiaShader`.\n */\nexport const SepiaShader: THREE.Shader = {\n    uniforms: {\n        tDiffuse: { value: null },\n        amount: { value: 1.0 }\n    },\n    vertexShader: `\n        varying vec2 vUv;\n        void main() {\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }`,\n    fragmentShader: `\n        uniform float amount;\n        uniform sampler2D tDiffuse;\n        varying vec2 vUv;\n        void main() {\n            vec4 color = texture2D( tDiffuse, vUv );\n            vec3 c = color.rgb;\n            color.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );\n            color.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );\n            color.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );\n            gl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );\n        }`\n};\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { LineCaps } from \"@here/harp-datasource-protocol\";\nimport * as THREE from \"three\";\nimport {\n    DisplacementFeature,\n    DisplacementFeatureParameters,\n    FadingFeature,\n    FadingFeatureParameters\n} from \"./MapMeshMaterials\";\nimport linesShaderChunk from \"./ShaderChunks/LinesChunks\";\nimport { enforceBlending } from \"./Utils\";\n\nexport const LineCapsDefinitions: { [key in LineCaps]: string } = {\n    Square: \"CAPS_SQUARE\",\n    Round: \"CAPS_ROUND\",\n    None: \"CAPS_NONE\",\n    TriangleIn: \"CAPS_TRIANGLE_IN\",\n    TriangleOut: \"CAPS_TRIANGLE_OUT\"\n};\n\n/**\n * The vLength contains the actual line length, it's needed for the creation of line caps by\n * detecting line ends. `vLength == vExtrusionCoord.x + lineWidth * 2`\n */\n/**\n * The vExtrusionStrength relies on the edges of the lines. Represents how far the current point was\n * extruded on the edges because of the current angle. Needed for preventing line caps artifacts on\n * sharp line edges. For example, on sharp edges, some vertices can be extruded much further than\n * the full line length.\n */\n\nconst vertexSource: string = `\n#define SEGMENT_OFFSET 0.1\n\nattribute vec3 extrusionCoord;\nattribute vec3 position;\nattribute vec4 bitangent;\nattribute vec3 tangent;\nattribute vec2 uv;\nattribute vec3 normal;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float lineWidth;\nuniform float outlineWidth;\nuniform vec2 drawRange;\n\n#ifdef USE_DISPLACEMENTMAP\nuniform sampler2D displacementMap;\n#endif\n\nvarying vec3 vPosition;\nvarying vec3 vRange;\nvarying vec4 vCoords;\n#if USE_COLOR\nattribute vec3 color;\nvarying vec3 vColor;\n#endif\n\n#ifdef USE_FADING\n#include <fading_pars_vertex>\n#endif\n\n#include <fog_pars_vertex>\n\n#include <extrude_line_vert_func>\n\nvoid main() {\n    // Calculate the segment.\n    vec2 segment = abs(extrusionCoord.xy) - SEGMENT_OFFSET;\n    float segmentPos = sign(extrusionCoord.x) / 2.0 + 0.5;\n\n    // Calculate the vertex position inside the line (segment) and extrusion direction and factor.\n    float linePos = mix(segment.x, segment.y, segmentPos);\n    vec2 extrusionDir = sign(extrusionCoord.xy);\n    float extrusionFactor = extrusionDir.y * tan(bitangent.w / 2.0);\n\n    // Calculate the extruded vertex position (and scale the extrusion direction).\n    vec3 pos = extrudeLine(\n        position, linePos, lineWidth + outlineWidth, bitangent, tangent, extrusionDir);\n\n    // Store the normalized extrusion coordinates in vCoords (with their ranges in vRange).\n    vRange = vec3(extrusionCoord.z, lineWidth, extrusionFactor);\n    vCoords = vec4(extrusionDir / vRange.xy, segment / vRange.x);\n\n    // Adjust the segment to fit the drawRange.\n    float capDist = (lineWidth + outlineWidth) / extrusionCoord.z;\n    if ((vCoords.w + capDist) < drawRange.x || (vCoords.z - capDist) > drawRange.y) {\n        vCoords.zw += 1.0;\n    }\n    if (vCoords.z < drawRange.x) {\n        vCoords.zw += vec2(drawRange.x - vCoords.z, 0.0);\n    }\n    if (vCoords.w > drawRange.y) {\n        vCoords.zw -= vec2(0.0, vCoords.w - drawRange.y);\n    }\n\n    // Transform position.\n    #ifdef USE_DISPLACEMENTMAP\n    pos += normalize( normal ) * texture2D( displacementMap, uv ).x;\n    #endif\n    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);\n    gl_Position = projectionMatrix * mvPosition;\n\n    // Pass extruded position to fragment shader.\n    vPosition = pos;\n\n    #if USE_COLOR\n    // Pass vertex color to fragment shader.\n    vColor = color;\n    #endif\n\n    #ifdef USE_FADING\n    #include <fading_vertex>\n    #endif\n\n    #include <fog_vertex>\n}`;\n\nconst fragmentSource: string = `\nprecision highp float;\nprecision highp int;\n\nuniform vec3 diffuse;\nuniform vec3 outlineColor;\nuniform float opacity;\nuniform float lineWidth;\nuniform float outlineWidth;\nuniform vec2 tileSize;\nuniform vec2 drawRange;\n\n#if DASHED_LINE\nuniform float dashSize;\nuniform float gapSize;\nuniform vec3 dashColor;\n#endif\n\nvarying vec3 vPosition;\nvarying vec3 vRange;\nvarying vec4 vCoords;\n#if USE_COLOR\nvarying vec3 vColor;\n#endif\n\n#include <round_edges_and_add_caps>\n#include <tile_clip_func>\n\n#ifdef USE_FADING\n#include <fading_pars_fragment>\n#endif\n\n#include <fog_pars_fragment>\n\nvoid main() {\n    float alpha = opacity;\n    vec3 outputDiffuse = diffuse;\n\n    #if TILE_CLIP\n    tileClip(vPosition.xy, tileSize);\n    #endif\n\n    // Calculate distance to center (0.0: lineCenter, 1.0: lineEdge).\n    float distToCenter = roundEdgesAndAddCaps(vCoords, vRange);\n    // Calculate distance to edge (-1.0: lineCenter, 0.0: lineEdge).\n    float distToEdge = distToCenter - (lineWidth + outlineWidth) / lineWidth;\n\n    // Decrease the line opacity by the distToEdge, making the transition steeper when the slope\n    // of distToChange increases (i.e. the line is further away).\n    float width = fwidth(distToEdge);\n    alpha *= (1.0 - smoothstep(-width, width, distToEdge));\n\n    #if DASHED_LINE\n    // Compute the distance to the dash origin (0.0: dashOrigin, 1.0: dashEnd, (d+g)/d: gapEnd).\n    float d = dashSize / vRange.x;\n    float g = gapSize / vRange.x;\n    float distToDashOrigin = mod(vCoords.x, d + g) / d;\n\n    // Compute distance to dash edge (0.5: dashCenter, 0.0: dashEdge) and compute the\n    // dashBlendFactor similarly on how we did it for the line opacity.\n    float distToDashEdge = 0.5 - distance(distToDashOrigin, (d + g) / d * 0.5);\n    float dashWidth = fwidth(distToDashEdge);\n    float dashBlendFactor = 1.0 - smoothstep(-dashWidth, dashWidth, distToDashEdge);\n\n    #if USE_DASH_COLOR\n    outputDiffuse = mix(diffuse, dashColor, dashBlendFactor);\n    #endif\n    #endif\n\n    #ifdef USE_OUTLINE\n    // Calculate distance to outline (0.0: lineEdge, outlineWidth/lineWidth: outlineEdge) and\n    // compute the outlineBlendFactor (used to mix line and outline colors).\n    float distToOutline = distToCenter - 1.0;\n    float outlineWidth = fwidth(distToOutline);\n    float outlineBlendFactor = smoothstep(-outlineWidth, outlineWidth, distToOutline);\n\n    // Mix the colors using the different computed factors.\n    #if DASHED_LINE && USE_DASH_COLOR == 0\n    float colorBlendFactor = smoothstep(-1.0, 1.0, dashBlendFactor - outlineBlendFactor);\n    outputDiffuse = mix(\n      mix(\n        mix(outlineColor, diffuse, colorBlendFactor),\n        outputDiffuse,\n        dashBlendFactor\n      ),\n      outlineColor,\n      outlineBlendFactor\n    );\n    #else\n    outputDiffuse = mix(outputDiffuse, outlineColor, outlineBlendFactor);\n    #endif\n    #endif\n\n    // Multiply the alpha by the dashBlendFactor.\n    #if DASHED_LINE && defined(USE_OUTLINE) && USE_DASH_COLOR == 0\n    alpha *= clamp(dashBlendFactor + outlineBlendFactor, 0.0, 1.0);\n    #elif DASHED_LINE && USE_DASH_COLOR == 0\n    alpha *= 1.0 - dashBlendFactor;\n    #endif\n\n    #if USE_COLOR\n    gl_FragColor = vec4( outputDiffuse * vColor, alpha );\n    #else\n    gl_FragColor = vec4( outputDiffuse, alpha );\n    #endif\n\n    #include <fog_fragment>\n\n    #ifdef USE_FADING\n    #include <fading_fragment>\n    #endif\n}`;\n\n/**\n * Parameters used when constructing a new [[SolidLineMaterial]].\n */\nexport interface SolidLineMaterialParameters\n    extends FadingFeatureParameters,\n        DisplacementFeatureParameters {\n    /**\n     * Line color.\n     */\n    color?: number | string;\n\n    /**\n     * Line outline color.\n     */\n    outlineColor?: number | string;\n\n    /**\n     * Enables/Disable depth test.\n     */\n    depthTest?: boolean;\n\n    /**\n     * Enables/Disable depth write.\n     */\n    depthWrite?: boolean;\n\n    /**\n     * `SolidLineMaterial` extends the ThreeJS `RawShaderMaterial` that does not update fog at\n     * runtime, so instead of recompiling everything we pass it in the constructor.\n     */\n    fog?: boolean;\n\n    /**\n     * Line width.\n     */\n    lineWidth?: number;\n\n    /**\n     * Outline width.\n     */\n    outlineWidth?: number;\n\n    /**\n     * Line opacity.\n     */\n    opacity?: number;\n\n    /**\n     * Describes line caps type (`\"None\"`, `\"Round\"`, `\"Square\"`, `\"TriangleOut\"`, `\"TriangleIn\"`).\n     * Default is `\"Round\"`.\n     */\n    caps?: LineCaps;\n\n    /**\n     * Describes the starting drawing position for the line (in the range [0...1]).\n     * Default is `0.0`.\n     */\n    drawRangeStart?: number;\n\n    /**\n     * Describes the ending drawing position for the line (in the range [0...1]).\n     * Default is `1.0`.\n     */\n    drawRangeEnd?: number;\n\n    /**\n     * Line dashes color.\n     */\n    dashColor?: number | string;\n\n    /**\n     * Size of the dashed segments.\n     */\n    dashSize?: number;\n\n    /**\n     * Size of the gaps between dashed segments.\n     */\n    gapSize?: number;\n}\n\n/**\n * Material designed to render solid variable-width lines.\n */\nexport class SolidLineMaterial extends THREE.RawShaderMaterial\n    implements DisplacementFeature, FadingFeature {\n    static DEFAULT_COLOR: number = 0xff0000;\n    static DEFAULT_WIDTH: number = 1.0;\n    static DEFAULT_OUTLINE_WIDTH: number = 0.0;\n    static DEFAULT_OPACITY: number = 1.0;\n    static DEFAULT_DRAW_RANGE_START: number = 0.0;\n    static DEFAULT_DRAW_RANGE_END: number = 1.0;\n    static DEFAULT_DASH_SIZE: number = 1.0;\n    static DEFAULT_GAP_SIZE: number = 1.0;\n\n    /**\n     * Constructs a new `SolidLineMaterial`.\n     *\n     * @param params `SolidLineMaterial` parameters.\n     */\n    constructor(params?: SolidLineMaterialParameters) {\n        Object.assign(THREE.ShaderChunk, linesShaderChunk);\n\n        FadingFeature.patchGlobalShaderChunks();\n\n        const defines: { [key: string]: any } = {\n            DASHED_LINE: 0,\n            TILE_CLIP: 0,\n            USE_COLOR: 0,\n            USE_DASH_COLOR: 0,\n            CAPS_SQUARE: 0,\n            CAPS_ROUND: 1,\n            CAPS_NONE: 0,\n            CAPS_TRIANGLE_IN: 0,\n            CAPS_TRIANGLE_OUT: 0\n        };\n\n        const hasFog = params !== undefined && params.fog === true;\n\n        if (hasFog) {\n            defines.USE_FOG = \"\";\n        }\n\n        const hasDisplacementMap = params !== undefined && params.displacementMap !== undefined;\n\n        if (hasDisplacementMap) {\n            defines.USE_DISPLACEMENTMAP = \"\";\n        }\n\n        if (params !== undefined && params.outlineWidth !== undefined && params.outlineWidth > 0) {\n            defines.USE_OUTLINE = \"\";\n        }\n\n        const shaderParams: THREE.ShaderMaterialParameters = {\n            name: \"SolidLineMaterial\",\n            vertexShader: vertexSource,\n            fragmentShader: fragmentSource,\n            uniforms: THREE.UniformsUtils.merge([\n                {\n                    diffuse: new THREE.Uniform(new THREE.Color(SolidLineMaterial.DEFAULT_COLOR)),\n                    dashColor: new THREE.Uniform(new THREE.Color(SolidLineMaterial.DEFAULT_COLOR)),\n                    outlineColor: new THREE.Uniform(\n                        new THREE.Color(SolidLineMaterial.DEFAULT_COLOR)\n                    ),\n                    lineWidth: new THREE.Uniform(SolidLineMaterial.DEFAULT_WIDTH),\n                    outlineWidth: new THREE.Uniform(SolidLineMaterial.DEFAULT_OUTLINE_WIDTH),\n                    opacity: new THREE.Uniform(SolidLineMaterial.DEFAULT_OPACITY),\n                    tileSize: new THREE.Uniform(new THREE.Vector2()),\n                    fadeNear: new THREE.Uniform(FadingFeature.DEFAULT_FADE_NEAR),\n                    fadeFar: new THREE.Uniform(FadingFeature.DEFAULT_FADE_FAR),\n                    displacementMap: new THREE.Uniform(\n                        hasDisplacementMap ? params!.displacementMap : new THREE.Texture()\n                    ),\n                    drawRange: new THREE.Uniform(\n                        new THREE.Vector2(\n                            SolidLineMaterial.DEFAULT_DRAW_RANGE_START,\n                            SolidLineMaterial.DEFAULT_DRAW_RANGE_END\n                        )\n                    ),\n                    dashSize: new THREE.Uniform(SolidLineMaterial.DEFAULT_DASH_SIZE),\n                    gapSize: new THREE.Uniform(SolidLineMaterial.DEFAULT_GAP_SIZE)\n                },\n                // We need the fog uniforms available when we use `updateFog` as the internal\n                // recompilation cannot add or remove uniforms.\n                THREE.UniformsLib.fog\n            ]),\n            defines,\n            fog: true\n        };\n\n        super(shaderParams);\n        enforceBlending(this);\n        this.extensions.derivatives = true;\n\n        // Apply initial parameter values.\n        if (params !== undefined) {\n            if (params.color !== undefined) {\n                this.color.set(params.color as any);\n            }\n            if (params.outlineColor !== undefined) {\n                this.outlineColor.set(params.outlineColor as any);\n            }\n            if (params.lineWidth !== undefined) {\n                this.lineWidth = params.lineWidth;\n            }\n            if (params.outlineWidth !== undefined) {\n                this.outlineWidth = params.outlineWidth;\n            }\n            if (params.opacity !== undefined) {\n                this.opacity = params.opacity;\n            }\n            if (params.depthTest !== undefined) {\n                this.depthTest = params.depthTest;\n            }\n            if (params.depthWrite !== undefined) {\n                this.depthWrite = params.depthWrite;\n            }\n            if (params.fadeNear !== undefined) {\n                this.fadeNear = params.fadeNear;\n            }\n            if (params.fadeFar !== undefined) {\n                this.fadeFar = params.fadeFar;\n            }\n            if (params.displacementMap !== undefined) {\n                this.displacementMap = params.displacementMap;\n            }\n            if (params.caps !== undefined) {\n                this.caps = params.caps;\n            }\n            if (params.drawRangeStart !== undefined) {\n                this.drawRangeStart = params.drawRangeStart;\n            }\n            if (params.drawRangeEnd !== undefined) {\n                this.drawRangeEnd = params.drawRangeEnd;\n            }\n            if (params.dashColor !== undefined) {\n                this.dashColor.set(params.dashColor as any);\n                this.defines.USE_DASH_COLOR = 1.0;\n            }\n            if (params.dashSize !== undefined) {\n                this.dashSize = params.dashSize;\n            }\n            if (params.gapSize !== undefined) {\n                this.gapSize = params.gapSize;\n            }\n            this.fog = hasFog;\n        }\n    }\n\n    /**\n     * The method to call to recompile a material to get a new fog define.\n     *\n     * @param enableFog Whether we want to enable the fog.\n     */\n    updateFog(enableFog: boolean) {\n        if (!enableFog) {\n            this.needsUpdate = this.defines.USE_FOG !== undefined;\n            delete this.defines.USE_FOG;\n        } else {\n            this.needsUpdate = this.defines.USE_FOG === undefined;\n            this.defines.USE_FOG = \"\";\n        }\n    }\n\n    /**\n     * The method to call to recompile a material to an outline effect\n     *\n     * @param enableOutline Whether we want to use outline.\n     */\n    updateOutline(enableOutline: boolean) {\n        if (!enableOutline) {\n            delete this.defines.USE_OUTLINE;\n        } else {\n            this.defines.USE_OUTLINE = \"\";\n        }\n    }\n\n    /**\n     * Line opacity.\n     */\n    get opacity(): number {\n        return this.uniforms.opacity.value;\n    }\n    set opacity(value: number) {\n        if (this.uniforms !== undefined) {\n            this.uniforms.opacity.value = value;\n        }\n    }\n\n    /**\n     * Line color.\n     */\n    get color(): THREE.Color {\n        return this.uniforms.diffuse.value as THREE.Color;\n    }\n    set color(value: THREE.Color) {\n        this.uniforms.diffuse.value = value;\n    }\n\n    /**\n     * Outline color.\n     */\n    get outlineColor(): THREE.Color {\n        return this.uniforms.outlineColor.value as THREE.Color;\n    }\n    set outlineColor(value: THREE.Color) {\n        this.uniforms.outlineColor.value = value;\n    }\n\n    /**\n     * Dash color.\n     */\n    get dashColor(): THREE.Color {\n        return this.uniforms.dashColor.value as THREE.Color;\n    }\n    set dashColor(value: THREE.Color) {\n        this.uniforms.dashColor.value = value;\n        this.defines.USE_DASH_COLOR = 1.0;\n    }\n\n    /**\n     * Line width.\n     */\n    get lineWidth(): number {\n        return this.uniforms.lineWidth.value as number;\n    }\n    set lineWidth(value: number) {\n        this.uniforms.lineWidth.value = value;\n    }\n\n    /**\n     * Outline width.\n     */\n    get outlineWidth(): number {\n        return this.uniforms.outlineWidth.value as number;\n    }\n    set outlineWidth(value: number) {\n        this.uniforms.outlineWidth.value = value;\n        this.updateOutline(value > 0);\n    }\n\n    /**\n     * Size of the dashed segments.\n     */\n    get dashSize(): number {\n        return this.uniforms.dashSize.value as number;\n    }\n    set dashSize(value: number) {\n        this.uniforms.dashSize.value = value;\n    }\n\n    /**\n     * Size of the gaps between dashed segments.\n     */\n    get gapSize(): number {\n        return this.uniforms.gapSize.value as number;\n    }\n    set gapSize(value: number) {\n        this.uniforms.gapSize.value = value;\n        this.defines.DASHED_LINE = this.gapSize > 0.0 ? 1 : 0;\n    }\n\n    /**\n     * Caps mode.\n     */\n    get caps(): LineCaps {\n        let result: LineCaps = \"Round\";\n        if (this.defines.CAPS_SQUARE === 1) {\n            result = \"Square\";\n        } else if (this.defines.CAPS_NONE === 1) {\n            result = \"None\";\n        } else if (this.defines.CAPS_ROUND === 1) {\n            result = \"Round\";\n        } else if (this.defines.CAPS_TRIANGLE_IN === 1) {\n            result = \"TriangleIn\";\n        } else if (this.defines.CAPS_TRIANGLE_OUT === 1) {\n            result = \"TriangleOut\";\n        }\n        return result;\n    }\n    set caps(value: LineCaps) {\n        this.defines.CAPS_SQUARE = 0;\n        this.defines.CAPS_ROUND = 0;\n        this.defines.CAPS_NONE = 0;\n        this.defines.CAPS_TRIANGLE_IN = 0;\n        this.defines.CAPS_TRIANGLE_OUT = 0;\n        this.defines[LineCapsDefinitions[value]] = 1;\n    }\n\n    get fadeNear(): number {\n        return this.uniforms.fadeNear.value as number;\n    }\n    set fadeNear(value: number) {\n        this.uniforms.fadeNear.value = value;\n    }\n\n    get fadeFar(): number {\n        return this.uniforms.fadeFar.value as number;\n    }\n    set fadeFar(value: number) {\n        const fadeFar = this.uniforms.fadeFar.value;\n        this.uniforms.fadeFar.value = value;\n        const doFade = fadeFar !== undefined && fadeFar > 0.0;\n        if (doFade) {\n            this.defines.USE_FADING = \"\";\n        } else {\n            delete this.defines.USE_FADING;\n        }\n    }\n\n    get displacementMap(): THREE.Texture | undefined {\n        return this.uniforms.displacementMap.value;\n    }\n    set displacementMap(map: THREE.Texture | undefined) {\n        this.uniforms.displacementMap.value = map;\n        if (map !== undefined) {\n            this.uniforms.displacementMap.value.needsUpdate = true;\n            this.defines.USE_DISPLACEMENTMAP = \"\";\n        } else {\n            delete this.defines.USE_DISPLACEMENTMAP;\n        }\n        this.needsUpdate = true;\n    }\n\n    get drawRangeStart(): number {\n        return this.uniforms.drawRange.value.x as number;\n    }\n    set drawRangeStart(value: number) {\n        this.uniforms.drawRange.value.x = value;\n    }\n\n    get drawRangeEnd(): number {\n        return this.uniforms.drawRange.value.y as number;\n    }\n    set drawRangeEnd(value: number) {\n        this.uniforms.drawRange.value.y = value;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport * as THREE from \"three\";\n\n/**\n * `VignetteShader`.\n */\nexport const VignetteShader: THREE.Shader = {\n    uniforms: {\n        tDiffuse: { value: null },\n        offset: { value: 1.0 },\n        darkness: { value: 1.0 }\n    },\n    vertexShader: `\n        varying vec2 vUv;\n        void main() {\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }`,\n    fragmentShader: `\n        uniform float offset;\n        uniform float darkness;\n        uniform sampler2D tDiffuse;\n        varying vec2 vUv;\n        void main() {\n            vec4 texel = texture2D( tDiffuse, vUv );\n            vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );\n            gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );\n        }`\n};\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    BooleanLiteralExpr,\n    CallExpr,\n    CaseExpr,\n    ContainsExpr,\n    Env,\n    Expr,\n    ExprScope,\n    ExprVisitor,\n    HasAttributeExpr,\n    LiteralExpr,\n    MatchExpr,\n    NullLiteralExpr,\n    NumberLiteralExpr,\n    ObjectLiteralExpr,\n    StringLiteralExpr,\n    Value,\n    VarExpr\n} from \"./Expr\";\n\nimport { ArrayOperators } from \"./operators/ArrayOperators\";\nimport { CastOperators } from \"./operators/CastOperators\";\nimport { ColorOperators } from \"./operators/ColorOperators\";\nimport { ComparisonOperators } from \"./operators/ComparisonOperators\";\nimport { FeatureOperators } from \"./operators/FeatureOperators\";\nimport { FlowOperators } from \"./operators/FlowOperators\";\nimport { InterpolationOperators } from \"./operators/InterpolationOperators\";\nimport { MapOperators } from \"./operators/MapOperators\";\nimport { MathOperators } from \"./operators/MathOperators\";\nimport { MiscOperators } from \"./operators/MiscOperators\";\nimport { ObjectOperators } from \"./operators/ObjectOperators\";\nimport { StringOperators } from \"./operators/StringOperators\";\nimport { TypeOperators } from \"./operators/TypeOperators\";\n\nexport interface OperatorDescriptor {\n    /**\n     * Returns `true` if this operator requires a dynamic execution context (e.g. [\"zoom\"]).\n     */\n    isDynamicOperator?: (call: CallExpr) => boolean;\n\n    /**\n     * Evaluates the given expression.\n     */\n    call: (context: ExprEvaluatorContext, call: CallExpr) => Value;\n}\n\nexport interface OperatorDescriptorMap {\n    [name: string]: OperatorDescriptor;\n}\n\nconst operatorDescriptors = new Map<string, OperatorDescriptor>();\n\n/*\n * @hidden\n */\nexport class ExprEvaluatorContext {\n    private m_partialEvaluation = false;\n\n    constructor(\n        readonly evaluator: ExprEvaluator,\n        readonly env: Env,\n        readonly scope: ExprScope,\n        readonly cache?: Map<Expr, Value>\n    ) {}\n\n    /**\n     * `true` if the this context is used to partially evaluate expressions.\n     */\n    get partialEvaluation() {\n        return this.m_partialEvaluation;\n    }\n\n    /**\n     * Evaluate the given expression.\n     *\n     * @param expr The [[Expr]] to evaluate.\n     */\n    evaluate(expr: Expr | undefined) {\n        if (expr !== undefined) {\n            return expr.accept(this.evaluator, this);\n        }\n        throw new Error(\"Failed to evaluate expression\");\n    }\n\n    /**\n     * Partially evaluate the given expression.\n     *\n     * @param expr The [[Expr]] to evaluate.\n     */\n    partiallyEvaluate(expr: Expr | undefined): Expr {\n        if (expr === undefined) {\n            throw new Error(\"Failed to evaluate expression\");\n        }\n\n        const previousEvaluationMode = this.m_partialEvaluation;\n\n        this.m_partialEvaluation = true;\n\n        try {\n            const value = expr.accept(this.evaluator, this);\n\n            this.m_partialEvaluation = previousEvaluationMode;\n\n            if (value instanceof Expr) {\n                return value;\n            }\n\n            return LiteralExpr.fromValue(value);\n        } catch (error) {\n            // rethrow the exception\n            throw error;\n        } finally {\n            // reset the evaluation mode.\n            this.m_partialEvaluation = previousEvaluationMode;\n        }\n    }\n}\n\n/**\n * [[ExprEvaluator]] is used to evaluate [[Expr]] in a given environment.\n *\n * @hidden\n */\nexport class ExprEvaluator implements ExprVisitor<Value, ExprEvaluatorContext> {\n    static defineOperator(op: string, builtin: OperatorDescriptor) {\n        operatorDescriptors.set(op, builtin);\n    }\n\n    static defineOperators(builtins: OperatorDescriptorMap) {\n        Object.getOwnPropertyNames(builtins).forEach(p => {\n            this.defineOperator(p, builtins[p]);\n        });\n    }\n\n    /**\n     * Returns the [[OperatorDescriptor]] for the given operator name.\n     * @hidden\n     */\n    static getOperator(op: string): OperatorDescriptor | undefined {\n        return operatorDescriptors.get(op);\n    }\n\n    visitVarExpr(expr: VarExpr, context: ExprEvaluatorContext): Value {\n        const value = context.env.lookup(expr.name);\n        return value !== undefined ? value : null;\n    }\n\n    visitNullLiteralExpr(expr: NullLiteralExpr, context: ExprEvaluatorContext): Value {\n        return null;\n    }\n\n    visitBooleanLiteralExpr(expr: BooleanLiteralExpr, context: ExprEvaluatorContext): Value {\n        return expr.value;\n    }\n\n    visitNumberLiteralExpr(expr: NumberLiteralExpr, context: ExprEvaluatorContext): Value {\n        return expr.value;\n    }\n\n    visitStringLiteralExpr(expr: StringLiteralExpr, context: ExprEvaluatorContext): Value {\n        return expr.value;\n    }\n\n    visitObjectLiteralExpr(expr: ObjectLiteralExpr, context: ExprEvaluatorContext): Value {\n        return expr.value;\n    }\n\n    visitHasAttributeExpr(expr: HasAttributeExpr, context: ExprEvaluatorContext): Value {\n        return context.env.lookup(expr.name) !== undefined;\n    }\n\n    visitContainsExpr(expr: ContainsExpr, context: ExprEvaluatorContext): Value {\n        const value = expr.value.accept(this, context);\n\n        const result = expr.elements.includes(value as any);\n\n        if (context.cache !== undefined) {\n            context.cache.set(expr, result);\n        }\n\n        return result;\n    }\n\n    visitMatchExpr(match: MatchExpr, context: ExprEvaluatorContext): Value {\n        const r = context.evaluate(match.value);\n        for (const [label, body] of match.branches) {\n            if (Array.isArray(label) && (label as any[]).includes(r)) {\n                return context.evaluate(body);\n            } else if (label === r) {\n                return context.evaluate(body);\n            }\n        }\n        return context.evaluate(match.fallback);\n    }\n\n    visitCaseExpr(match: CaseExpr, context: ExprEvaluatorContext): Value {\n        for (const [condition, body] of match.branches) {\n            if (context.evaluate(condition)) {\n                return context.evaluate(body);\n            }\n        }\n        return context.evaluate(match.fallback);\n    }\n\n    visitCallExpr(expr: CallExpr, context: ExprEvaluatorContext): Value {\n        if (context.cache !== undefined) {\n            const v = context.cache.get(expr);\n            if (v !== undefined) {\n                return v;\n            }\n        }\n\n        const descriptor = expr.descriptor || operatorDescriptors.get(expr.op);\n\n        if (descriptor) {\n            expr.descriptor = descriptor;\n\n            const result = descriptor.call(context, expr);\n\n            if (context.cache) {\n                context.cache.set(expr, result);\n            }\n\n            return result;\n        }\n\n        throw new Error(`undefined operator '${expr.op}`);\n    }\n}\n\nExprEvaluator.defineOperators(CastOperators);\nExprEvaluator.defineOperators(ComparisonOperators);\nExprEvaluator.defineOperators(MathOperators);\nExprEvaluator.defineOperators(StringOperators);\nExprEvaluator.defineOperators(ColorOperators);\nExprEvaluator.defineOperators(TypeOperators);\nExprEvaluator.defineOperators(MiscOperators);\nExprEvaluator.defineOperators(FlowOperators);\nExprEvaluator.defineOperators(ArrayOperators);\nExprEvaluator.defineOperators(InterpolationOperators);\nExprEvaluator.defineOperators(ObjectOperators);\nExprEvaluator.defineOperators(FeatureOperators);\nExprEvaluator.defineOperators(MapOperators);\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { CallExpr } from \"../Expr\";\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\n\nconst operators = {\n    at: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const args = call.args;\n            const index = context.evaluate(args[0]);\n            if (typeof index !== \"number\") {\n                throw new Error(`expected the index of the element to retrieve`);\n            }\n            const value = context.evaluate(args[1]);\n            if (!Array.isArray(value)) {\n                throw new Error(`expected an array`);\n            }\n            return index >= 0 && index < value.length ? value[index] : null;\n        }\n    }\n};\n\nexport const ArrayOperators: OperatorDescriptorMap = operators;\nexport type ArrayOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { CallExpr } from \"../Expr\";\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\n\nconst operators = {\n    \"to-boolean\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return Boolean(context.evaluate(call.args[0]));\n        }\n    },\n\n    \"to-string\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return String(context.evaluate(call.args[0]));\n        }\n    },\n\n    \"to-number\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            for (const arg of call.args) {\n                const value = Number(context.evaluate(arg));\n                if (!isNaN(value)) {\n                    return value;\n                }\n            }\n            throw new Error(\"cannot convert the value to a number\");\n        }\n    }\n};\n\nexport const CastOperators: OperatorDescriptorMap = operators;\nexport type CastOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { ColorUtils } from \"../ColorUtils\";\nimport { CallExpr } from \"../Expr\";\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\n\nconst operators = {\n    rgba: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const r = context.evaluate(call.args[0]);\n            const g = context.evaluate(call.args[1]);\n            const b = context.evaluate(call.args[2]);\n            const a = context.evaluate(call.args[3]);\n            if (\n                typeof r === \"number\" &&\n                typeof g === \"number\" &&\n                typeof b === \"number\" &&\n                typeof a === \"number\" &&\n                r >= 0 &&\n                g >= 0 &&\n                b >= 0 &&\n                a >= 0 &&\n                a <= 1\n            ) {\n                return rgbaToHex(r, g, b, a);\n            }\n            throw new Error(`unknown color 'rgba(${r},${g},${b},${a})'`);\n        }\n    },\n    rgb: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const r = context.evaluate(call.args[0]);\n            const g = context.evaluate(call.args[1]);\n            const b = context.evaluate(call.args[2]);\n            if (\n                typeof r === \"number\" &&\n                typeof g === \"number\" &&\n                typeof b === \"number\" &&\n                r >= 0 &&\n                g >= 0 &&\n                b >= 0\n            ) {\n                return rgbToHex(r, g, b);\n            }\n            throw new Error(`unknown color 'rgb(${r},${g},${b})'`);\n        }\n    },\n    // Hsl operator contains angle modulated to <0, 360> range, percent of\n    // saturation and lightness in <0, 100> range, i.e. hsl(360, 100, 100)\n    hsl: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const h = context.evaluate(call.args[0]);\n            const s = context.evaluate(call.args[1]);\n            const l = context.evaluate(call.args[2]);\n            if (\n                typeof h === \"number\" &&\n                typeof s === \"number\" &&\n                typeof l === \"number\" &&\n                h >= 0 &&\n                s >= 0 &&\n                l >= 0\n            ) {\n                return hslToHex(h, s, l);\n            }\n            throw new Error(`unknown color 'hsl(${h},${s}%,${l}%)'`);\n        }\n    }\n};\n\nfunction rgbaToHex(r: number, g: number, b: number, a: number): number {\n    // We decode rgba color channels using custom hex format with transparency.\n    return ColorUtils.getHexFromRgba(\n        THREE.Math.clamp(r, 0, 255) / 255,\n        THREE.Math.clamp(g, 0, 255) / 255,\n        THREE.Math.clamp(b, 0, 255) / 255,\n        THREE.Math.clamp(a, 0, 1)\n    );\n}\n\nfunction rgbToHex(r: number, g: number, b: number): number {\n    return ColorUtils.getHexFromRgb(\n        THREE.Math.clamp(r, 0, 255) / 255,\n        THREE.Math.clamp(g, 0, 255) / 255,\n        THREE.Math.clamp(b, 0, 255) / 255\n    );\n}\n\nfunction hslToHex(h: number, s: number, l: number): number {\n    return ColorUtils.getHexFromHsl(\n        THREE.Math.euclideanModulo(h, 360) / 360,\n        THREE.Math.clamp(s, 0, 100) / 100,\n        THREE.Math.clamp(l, 0, 100) / 100\n    );\n}\n\nexport const ColorOperators: OperatorDescriptorMap = operators;\nexport type ColorOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { CallExpr } from \"../Expr\";\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\n\nfunction compare(context: ExprEvaluatorContext, call: CallExpr, strict: boolean = false) {\n    const left = context.evaluate(call.args[0]) as any;\n    const right = context.evaluate(call.args[1]) as any;\n\n    if (\n        !(\n            (typeof left === \"number\" && typeof right === \"number\") ||\n            (typeof left === \"string\" && typeof right === \"string\")\n        )\n    ) {\n        if (strict) {\n            throw new Error(`invalid operands '${left}' and '${right}' for operator '${call.op}'`);\n        }\n    }\n\n    switch (call.op) {\n        case \"<\":\n            return left < right;\n        case \">\":\n            return left > right;\n        case \"<=\":\n            return left <= right;\n        case \">=\":\n            return left >= right;\n        default:\n            throw new Error(`invalid comparison operator '${call.op}'`);\n    }\n}\n\nconst operators = {\n    \"!\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return !context.evaluate(call.args[0]);\n        }\n    },\n\n    \"==\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const left = context.evaluate(call.args[0]);\n            const right = context.evaluate(call.args[1]);\n            return left === right;\n        }\n    },\n\n    \"!=\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const left = context.evaluate(call.args[0]);\n            const right = context.evaluate(call.args[1]);\n            return left !== right;\n        }\n    },\n\n    \"<\": { call: (context: ExprEvaluatorContext, call: CallExpr) => compare(context, call) },\n    \">\": { call: (context: ExprEvaluatorContext, call: CallExpr) => compare(context, call) },\n    \"<=\": { call: (context: ExprEvaluatorContext, call: CallExpr) => compare(context, call) },\n    \">=\": { call: (context: ExprEvaluatorContext, call: CallExpr) => compare(context, call) }\n};\n\nexport const ComparisonOperators: OperatorDescriptorMap = operators;\nexport type ComparisonOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { CallExpr } from \"../Expr\";\n\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\n\nconst operators = {\n    \"geometry-type\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const geometryType = context.env.lookup(\"$geometryType\");\n            switch (geometryType) {\n                case \"point\":\n                    return \"Point\";\n                case \"line\":\n                    return \"LineString\";\n                case \"polygon\":\n                    return \"Polygon\";\n                default:\n                    return null;\n            }\n        }\n    }\n};\n\nexport const FeatureOperators: OperatorDescriptorMap = operators;\nexport type FeatureOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { CallExpr, Expr } from \"../Expr\";\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\n\nfunction conditionalCast(context: ExprEvaluatorContext, type: string, args: Expr[]) {\n    switch (type) {\n        case \"boolean\":\n        case \"number\":\n        case \"string\":\n            for (const childExpr of args) {\n                const value = context.evaluate(childExpr);\n                if (typeof value === type) {\n                    return value;\n                }\n            }\n            throw new Error(`expected a '${type}'`);\n        default:\n            throw new Error(`invalid type '${type}'`);\n    } // switch\n}\n\nconst operators = {\n    all: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            for (const childExpr of call.args) {\n                if (!context.evaluate(childExpr)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    },\n\n    any: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            for (const childExpr of call.args) {\n                if (context.evaluate(childExpr)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    },\n\n    none: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            for (const childExpr of call.args) {\n                if (context.evaluate(childExpr)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    },\n\n    boolean: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return conditionalCast(context, \"boolean\", call.args);\n        }\n    },\n\n    number: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return conditionalCast(context, \"number\", call.args);\n        }\n    },\n\n    string: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return conditionalCast(context, \"string\", call.args);\n        }\n    }\n};\n\nexport const FlowOperators: OperatorDescriptorMap = operators;\nexport type FlowOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { CallExpr, ExprScope, LiteralExpr, NumberLiteralExpr, Value } from \"../Expr\";\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\nimport { createInterpolatedProperty, getPropertyValue } from \"../InterpolatedProperty\";\nimport { InterpolatedProperty, InterpolatedPropertyDefinition } from \"../InterpolatedPropertyDefs\";\n\ntype InterpolateCallExpr = CallExpr & {\n    _mode?: InterpolatedPropertyDefinition<any>[\"interpolation\"];\n    _exponent?: number;\n    _stops?: number[];\n    _interpolatedProperty?: InterpolatedProperty;\n};\n\n/**\n * Evaluates the given piecewise function.\n */\nfunction step(context: ExprEvaluatorContext, call: CallExpr) {\n    const { args } = call;\n\n    const value = context.evaluate(args[0]) as number;\n\n    if (value === null) {\n        // returns the default value of step.\n        return context.evaluate(args[1]);\n    }\n\n    if (typeof value !== \"number\") {\n        throw new Error(`the input of a 'step' operator must have type 'number'`);\n    }\n\n    let first = 1;\n    let last = args.length / 2 - 1;\n\n    while (first < last) {\n        // tslint:disable-next-line: no-bitwise\n        const mid = (first + last) >>> 1;\n        const stop = (args[mid * 2] as NumberLiteralExpr).value;\n\n        if (value < stop) {\n            last = mid - 1;\n        } else if (value > stop) {\n            first = mid + 1;\n        } else {\n            last = mid;\n        }\n    }\n\n    const result = args[first * 2];\n\n    if (!(result instanceof NumberLiteralExpr)) {\n        throw new Error(\"expected a numeric literal\");\n    }\n\n    const index = result.value <= value ? first : first - 1;\n\n    return context.evaluate(args[index * 2 + 1]);\n}\n\n/**\n * Prepare and validate the \"interpolate\" call.\n *\n * @param call An [[Expr]] representing an \"interpolate\" call.\n * @hidden\n */\nfunction prepareInterpolateCallExpr(call: InterpolateCallExpr) {\n    if (call._interpolatedProperty || call._mode !== undefined) {\n        return;\n    }\n\n    const interpolatorType = call.args[0];\n\n    if (!(interpolatorType instanceof CallExpr)) {\n        throw new Error(\"expected an interpolation type\");\n    }\n\n    let mode: InterpolatedPropertyDefinition<any>[\"interpolation\"];\n    let exponent: number | undefined;\n\n    if (interpolatorType.op === \"linear\") {\n        mode = \"Linear\";\n    } else if (interpolatorType.op === \"discrete\") {\n        mode = \"Discrete\";\n    } else if (interpolatorType.op === \"cubic\") {\n        mode = \"Cubic\";\n    } else if (interpolatorType.op === \"exponential\") {\n        mode = \"Exponential\";\n        const base = interpolatorType.args[0];\n        if (!(base instanceof NumberLiteralExpr)) {\n            throw new Error(\"expected the base of the exponential interpolation\");\n        }\n        exponent = base.value;\n    } else {\n        throw new Error(\"unrecognized interpolation type\");\n    }\n\n    const input = call.args[1];\n\n    if (!(input instanceof CallExpr)) {\n        throw new Error(\"expected the input of the interpolation\");\n    }\n\n    if (input.op !== \"zoom\") {\n        throw new Error(\"only 'zoom' is supported\");\n    }\n\n    if (call.args.length === 2 || call.args.length % 2) {\n        throw new Error(\"invalid number of samples\");\n    }\n\n    const stops: number[] = [];\n    const values: Value[] = [];\n\n    let isConstantInterpolation = true;\n\n    for (let i = 2; i < call.args.length; i += 2) {\n        const stop = call.args[i];\n\n        if (!(stop instanceof NumberLiteralExpr)) {\n            throw new Error(\"expected a numeric literal\");\n        }\n\n        stops.push(stop.value);\n\n        if (isConstantInterpolation) {\n            const value = call.args[i + 1];\n\n            if (value instanceof LiteralExpr) {\n                values.push(value.value);\n            } else {\n                isConstantInterpolation = false;\n            }\n        }\n    }\n\n    if (isConstantInterpolation) {\n        const result = createInterpolatedProperty({\n            interpolation: mode,\n            exponent,\n            zoomLevels: stops,\n            values\n        });\n\n        if (!result) {\n            throw new Error(\"failed to create interpolation\");\n        }\n\n        call._interpolatedProperty = result;\n    } else {\n        call._mode = mode;\n        call._exponent = exponent;\n        call._stops = stops;\n    }\n}\n\ntype StepCallExpr = CallExpr & {\n    /**\n     * `true` if the input of `step` call is `[\"zoom\"], otherwise false.\n     */\n    _inputIsZoom?: boolean;\n\n    /**\n     * The stops when the a constant [[InterpolatedProperty]] cannot be\n     * created for this `[\"step\"]` call.\n     */\n    _stops?: number[];\n\n    /**\n     * The [[InterpolatedProperty]] representing this `step` call,\n     * otherwise `undefined` if an interpolated property cannot\n     * be created at parsing time (e.g. one if the value of the step is not a literal).\n     */\n    _interpolatedProperty?: InterpolatedProperty;\n};\n\n/**\n * Classify the given `step` call.\n *\n * This function checks the input of the `step` and ensures that the stops\n * are literals.\n *\n * @param call A call to `[\"step\", ...]`.\n * @hidden\n */\nfunction classifyStepCallExpr(call: StepCallExpr) {\n    if (call._inputIsZoom !== undefined) {\n        // nothing to do, the `call` was already classified.\n        return;\n    }\n\n    if (call.args[0] === undefined) {\n        throw new Error(\"expected the input of the 'step' operator\");\n    }\n\n    if (call.args.length < 3 || call.args.length % 2) {\n        throw new Error(\"not enough arguments\");\n    }\n\n    const input = call.args[0];\n\n    // tslint:disable-next-line: prefer-conditional-expression\n    if (input instanceof CallExpr && input.op === \"zoom\") {\n        call._inputIsZoom = true;\n    } else {\n        call._inputIsZoom = false;\n    }\n\n    // check that the stops are literals.\n    for (let i = 2; i < call.args.length; i += 2) {\n        const stop = call.args[i];\n        if (!(stop instanceof NumberLiteralExpr)) {\n            throw new Error(\"expected a numeric literal\");\n        }\n    }\n}\n\n/**\n * Prepares the given call for the dynamic exception.\n * This method collects the stops and\n *\n * @param call A call to `[\"step\", ...]`.\n * @hidden\n */\nfunction prepareStepCallExpr(call: StepCallExpr) {\n    if (call._stops || call._interpolatedProperty) {\n        // nothing to do, the `call` was already prepared for execution.\n        return;\n    }\n\n    // collect the stops of the step call.\n    const stops: number[] = [Number.MIN_SAFE_INTEGER];\n\n    for (let i = 2; i < call.args.length; i += 2) {\n        const stop = call.args[i] as NumberLiteralExpr;\n        stops.push(stop.value);\n    }\n\n    // collect the values of the step call.\n    const values: Value[] = [];\n    let hasConstantValues = true;\n\n    for (let i = 1; hasConstantValues && i < call.args.length; i += 2) {\n        const literal = call.args[i];\n        if (literal instanceof LiteralExpr) {\n            values.push(literal.value);\n        } else {\n            hasConstantValues = false;\n        }\n    }\n\n    if (hasConstantValues) {\n        // all the values of this zoom-based `step` are constant,\n        // create an interpolated property and store it together\n        // with the call.\n        const interpolatedProperty = createInterpolatedProperty({\n            interpolation: \"Discrete\",\n            zoomLevels: stops,\n            values\n        });\n\n        if (interpolatedProperty === undefined) {\n            throw new Error(\"failed to create interpolator\");\n        }\n\n        call._interpolatedProperty = interpolatedProperty;\n    } else {\n        // the values the `[\"step\"]` call are not constants,\n        // cache the `zoomLevels` to avoid recreating input `Array`\n        // when instantiating a new [[InterpolatedProperty]].\n        call._stops = stops;\n    }\n}\n\nconst operators = {\n    interpolate: {\n        isDynamicOperator: (call: CallExpr): boolean => {\n            return call.args[1] && call.args[1].isDynamic();\n        },\n        call: (context: ExprEvaluatorContext, call: InterpolateCallExpr): Value => {\n            prepareInterpolateCallExpr(call);\n\n            if (context.scope !== ExprScope.Dynamic) {\n                return call;\n            }\n\n            let interpolatedProperty = call._interpolatedProperty;\n\n            if (!interpolatedProperty) {\n                const values: Value[] = [];\n\n                for (let i = 2; i < call.args.length; i += 2) {\n                    const value = context.evaluate(call.args[i + 1]);\n                    values.push(value);\n                }\n\n                interpolatedProperty = createInterpolatedProperty({\n                    interpolation: call._mode!,\n                    exponent: call._exponent,\n                    zoomLevels: call._stops!,\n                    values\n                });\n\n                if (interpolatedProperty === undefined) {\n                    throw new Error(\"failed to create interpolator\");\n                }\n            }\n\n            return getPropertyValue(interpolatedProperty, context.env);\n        }\n    },\n    step: {\n        isDynamicOperator: (call: CallExpr): boolean => {\n            return call.args[0] && call.args[0].isDynamic();\n        },\n        call: (context: ExprEvaluatorContext, call: StepCallExpr): Value => {\n            classifyStepCallExpr(call);\n\n            if (context.scope === ExprScope.Value) {\n                return call;\n            }\n\n            if (context.scope === ExprScope.Condition || call._inputIsZoom === false) {\n                return step(context, call);\n            }\n\n            prepareStepCallExpr(call);\n\n            let interpolatedProperty = call._interpolatedProperty;\n\n            if (!interpolatedProperty) {\n                // the values of the interpolation are not literals,\n                // evaluate the sub expressions and combine them\n                // with the constant stops computed when preparing this call.\n                const values: Value[] = [];\n                for (let i = 1; i < call.args.length; i += 2) {\n                    const value = context.evaluate(call.args[i]);\n                    values.push(value);\n                }\n\n                interpolatedProperty = createInterpolatedProperty({\n                    interpolation: \"Discrete\",\n                    zoomLevels: call._stops!,\n                    values\n                });\n\n                if (interpolatedProperty === undefined) {\n                    throw new Error(\"failed to create interpolator\");\n                }\n            }\n\n            return getPropertyValue(interpolatedProperty, context.env);\n        }\n    }\n};\n\nexport const InterpolationOperators: OperatorDescriptorMap = operators;\nexport type InterpolationOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Interpolant } from \"three\";\n\nexport class ExponentialInterpolant extends Interpolant {\n    /**\n     * Exponent value. Defaults to `2.0`.\n     */\n    exponent: number = 2.0;\n\n    // Note: We need to disable linting here as tslint thinks this function is never used, though it\n    // indeed is called by ``Interpolant.evaluate(level)``.\n    // tslint:disable-next-line\n    private interpolate_(i1: number, t0: number, t: number, t1: number) {\n        const result = this.resultBuffer;\n        // TODO: Remove when Interpolant types are fixed.\n        const values = (this as any).sampleValues;\n        const stride = this.valueSize;\n        const offset1 = i1 * stride;\n        const offset0 = offset1 - stride;\n        const weight1 = Math.pow((t - t0) / (t1 - t0), this.exponent);\n        const weight0 = 1 - weight1;\n\n        for (let i = 0; i !== stride; ++i) {\n            result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;\n        }\n\n        return result;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ExprScope, Value } from \"../Expr\";\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\n\nconst operators = {\n    ppi: {\n        call: (context: ExprEvaluatorContext) => {\n            const ppi = context.env.lookup(\"$ppi\");\n            if (typeof ppi === \"number\") {\n                return ppi;\n            }\n            return 72;\n        }\n    },\n    zoom: {\n        isDynamicOperator: (): boolean => {\n            return true;\n        },\n        call: (context: ExprEvaluatorContext): Value => {\n            if (context.scope === ExprScope.Condition) {\n                const zoom = context.env.lookup(\"$zoom\")!;\n                if (zoom !== undefined) {\n                    return zoom;\n                }\n                throw new Error(\"failed to get the zoom level.\");\n            }\n            // direct usages of 'zoom' outside technique filter conditions\n            // and interpolations are not allowed.\n            throw new Error(\"invalid usage of the 'zoom' operator.\");\n        }\n    }\n};\n\nexport const MapOperators: OperatorDescriptorMap = operators;\nexport type MapOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { CallExpr } from \"../Expr\";\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\n\nimport * as THREE from \"three\";\n\nconst operators = {\n    \"^\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const a = context.evaluate(call.args[0]);\n            const b = context.evaluate(call.args[1]);\n            if (typeof a !== \"number\" || typeof b !== \"number\") {\n                // tslint:disable-next-line: max-line-length\n                throw new Error(\n                    `invalid operands '${typeof a}' and '${typeof b}' for operator '^'`\n                );\n            }\n            return Math.pow(a, b);\n        }\n    },\n\n    \"-\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const a = context.evaluate(call.args[0]);\n            const b = context.evaluate(call.args[1]);\n            if (typeof a !== \"number\" || typeof b !== \"number\") {\n                throw new Error(\n                    `invalid operands '${typeof a}' and '${typeof b}' for operator '-'`\n                );\n            }\n            return a - b;\n        }\n    },\n\n    \"/\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const a = context.evaluate(call.args[0]);\n            const b = context.evaluate(call.args[1]);\n            if (typeof a !== \"number\" || typeof b !== \"number\") {\n                // tslint:disable-next-line: max-line-length\n                throw new Error(\n                    `invalid operands '${typeof a}' and '${typeof b}' for operator '/'`\n                );\n            }\n            return a / b;\n        }\n    },\n\n    \"%\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const a = context.evaluate(call.args[0]);\n            const b = context.evaluate(call.args[1]);\n            if (typeof a !== \"number\" || typeof b !== \"number\") {\n                // tslint:disable-next-line: max-line-length\n                throw new Error(\n                    `invalid operands '${typeof a}' and '${typeof b}' for operator '%'`\n                );\n            }\n            return a % b;\n        }\n    },\n\n    \"+\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return call.args.reduce((a, b) => Number(a) + Number(context.evaluate(b)), 0);\n        }\n    },\n\n    \"*\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return call.args.reduce((a, b) => Number(a) * Number(context.evaluate(b)), 1);\n        }\n    },\n\n    abs: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'abs'`);\n            }\n            return Math.abs(value);\n        }\n    },\n\n    acos: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'acos'`);\n            }\n            return Math.acos(value);\n        }\n    },\n\n    asin: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'asin'`);\n            }\n            return Math.asin(value);\n        }\n    },\n\n    atan: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'atan'`);\n            }\n            return Math.atan(value);\n        }\n    },\n\n    ceil: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'ceil'`);\n            }\n            return Math.ceil(value);\n        }\n    },\n\n    cos: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'cos'`);\n            }\n            return Math.cos(value);\n        }\n    },\n\n    e: {\n        call: () => {\n            return Math.E;\n        }\n    },\n\n    floor: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'floor'`);\n            }\n            return Math.floor(value);\n        }\n    },\n\n    ln: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'ln'`);\n            }\n            return Math.log(value);\n        }\n    },\n\n    ln2: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'ln2'`);\n            }\n            return Math.log2(value);\n        }\n    },\n\n    log10: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'log10'`);\n            }\n            return Math.log10(value);\n        }\n    },\n\n    max: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return Math.max(...call.args.map(v => Number(context.evaluate(v))));\n        }\n    },\n\n    min: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return Math.min(...call.args.map(v => Number(context.evaluate(v))));\n        }\n    },\n\n    /**\n     * Clamp numeric value to given range, inclusive.\n     *\n     * Synopsis:\n     * ```\n     * [\"clamp\", v: number, min: number, max: number]`\n     * ```\n     */\n    clamp: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const v = context.evaluate(call.args[0]);\n            const min = context.evaluate(call.args[1]);\n            const max = context.evaluate(call.args[2]);\n\n            if (typeof v !== \"number\" || typeof min !== \"number\" || typeof max !== \"number\") {\n                throw new Error(`invalid operands '${v}', ${min}, ${max} for operator 'clamp'`);\n            }\n            return THREE.Math.clamp(v, min, max);\n        }\n    },\n\n    pi: {\n        call: () => {\n            return Math.PI;\n        }\n    },\n\n    round: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'round'`);\n            }\n            return Math.round(value);\n        }\n    },\n\n    sin: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'sin'`);\n            }\n            return Math.sin(value);\n        }\n    },\n\n    sqrt: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'sqrt'`);\n            }\n            return Math.sqrt(value);\n        }\n    },\n\n    tan: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'tan'`);\n            }\n            return Math.tan(value);\n        }\n    }\n};\n\nexport const MathOperators: OperatorDescriptorMap = operators;\nexport type MathOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { CallExpr } from \"../Expr\";\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\n\nconst operators = {\n    length: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (Array.isArray(value) || typeof value === \"string\") {\n                return value.length;\n            }\n            throw new Error(`invalid operand '${value}' for operator 'length'`);\n        }\n    },\n    coalesce: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            for (const childExpr of call.args) {\n                const value = context.evaluate(childExpr);\n                if (value !== null) {\n                    return value;\n                }\n            }\n            return null;\n        }\n    }\n};\n\nexport const MiscOperators: OperatorDescriptorMap = operators;\nexport type MiscOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { CallExpr, Expr } from \"../Expr\";\n\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nenum LookupMode {\n    get,\n    has\n}\n\nfunction lookupMember(context: ExprEvaluatorContext, args: Expr[], lookupMode: LookupMode) {\n    const memberName = context.evaluate(args[0]);\n\n    if (typeof memberName !== \"string\") {\n        throw new Error(`expected the name of an attribute`);\n    }\n\n    const object = context.evaluate(args[1]) as any;\n\n    if (object && typeof object === \"object\" && hasOwnProperty.call(object, memberName)) {\n        return lookupMode === LookupMode.get ? object[memberName] : true;\n    }\n\n    return lookupMode === LookupMode.get ? null : false;\n}\n\nconst operators = {\n    get: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) =>\n            lookupMember(context, call.args, LookupMode.get)\n    },\n\n    has: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) =>\n            lookupMember(context, call.args, LookupMode.has)\n    }\n};\n\nexport const ObjectOperators: OperatorDescriptorMap = operators;\nexport type ObjectOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { CallExpr } from \"../Expr\";\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\n\nconst operators = {\n    concat: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return \"\".concat(...call.args.map(a => String(context.evaluate(a))));\n        }\n    },\n\n    downcase: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return String(context.evaluate(call.args[0])).toLocaleLowerCase();\n        }\n    },\n\n    upcase: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return String(context.evaluate(call.args[0])).toLocaleUpperCase();\n        }\n    },\n\n    \"~=\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const left = context.evaluate(call.args[0]);\n            const right = context.evaluate(call.args[1]);\n            if (typeof left === \"string\" && typeof right === \"string\") {\n                return left.indexOf(right) !== -1;\n            }\n            return false;\n        }\n    },\n\n    \"^=\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const left = context.evaluate(call.args[0]);\n            const right = context.evaluate(call.args[1]);\n            if (typeof left === \"string\" && typeof right === \"string\") {\n                return left.startsWith(right);\n            }\n            return false;\n        }\n    },\n\n    \"$=\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const left = context.evaluate(call.args[0]);\n            const right = context.evaluate(call.args[1]);\n            if (typeof left === \"string\" && typeof right === \"string\") {\n                return left.endsWith(right);\n            }\n            return false;\n        }\n    }\n};\n\nexport const StringOperators: OperatorDescriptorMap = operators;\nexport type StringOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { CallExpr } from \"../Expr\";\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\n\nconst operators = {\n    typeof: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return typeof context.evaluate(call.args[0]);\n        }\n    }\n};\n\nexport const TypeOperators: OperatorDescriptorMap = operators;\nexport type TypeOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    BooleanLiteralExpr,\n    CallExpr,\n    CaseExpr,\n    ContainsExpr,\n    Env,\n    Expr,\n    ExprVisitor,\n    HasAttributeExpr,\n    LiteralExpr,\n    MatchExpr,\n    MatchLabel,\n    NullLiteralExpr,\n    NumberLiteralExpr,\n    ObjectLiteralExpr,\n    StringLiteralExpr,\n    VarExpr\n} from \"./Expr\";\n\nexport interface InstantiationContext {\n    /**\n     * The [[Env]] used to lookup for names.\n     */\n    env: Env;\n\n    /**\n     * The names to preserve during the instantiation.\n     */\n    preserve?: Set<string>;\n}\n\n/**\n * @hidden\n */\nexport class ExprInstantiator implements ExprVisitor<Expr, InstantiationContext> {\n    visitNullLiteralExpr(expr: NullLiteralExpr, _context: InstantiationContext): Expr {\n        return expr;\n    }\n\n    visitBooleanLiteralExpr(expr: BooleanLiteralExpr, _context: InstantiationContext): Expr {\n        return expr;\n    }\n\n    visitNumberLiteralExpr(expr: NumberLiteralExpr, _context: InstantiationContext): Expr {\n        return expr;\n    }\n\n    visitStringLiteralExpr(expr: StringLiteralExpr, _context: InstantiationContext): Expr {\n        return expr;\n    }\n\n    visitObjectLiteralExpr(expr: ObjectLiteralExpr, _context: InstantiationContext): Expr {\n        return expr;\n    }\n\n    visitVarExpr(expr: VarExpr, context: InstantiationContext): Expr {\n        if (context.preserve && context.preserve.has(expr.name)) {\n            return expr;\n        }\n        const value = context.env.lookup(expr.name);\n        return LiteralExpr.fromValue(value !== undefined ? value : null);\n    }\n\n    visitHasAttributeExpr(expr: HasAttributeExpr, context: InstantiationContext): Expr {\n        if (context.preserve && context.preserve.has(expr.name)) {\n            return expr;\n        }\n        const value = context.env.lookup(expr.name) !== undefined;\n        return LiteralExpr.fromValue(value);\n    }\n\n    visitContainsExpr(expr: ContainsExpr, context: InstantiationContext): Expr {\n        const value = expr.value.accept(this, context);\n\n        if (value instanceof LiteralExpr) {\n            const result = expr.elements.includes(value.value as any);\n            return LiteralExpr.fromValue(result);\n        }\n\n        return value === expr.value ? expr : new ContainsExpr(value, expr.elements);\n    }\n\n    visitCallExpr(expr: CallExpr, context: InstantiationContext): Expr {\n        const args = expr.args.map(arg => arg.accept(this, context));\n        if (args.some((a, i) => a !== expr.args[i])) {\n            return new CallExpr(expr.op, args);\n        }\n        return expr;\n    }\n\n    visitMatchExpr(match: MatchExpr, context: InstantiationContext): Expr {\n        const value = match.value.accept(this, context);\n\n        if (value instanceof LiteralExpr) {\n            const r = value.value;\n            for (const [label, body] of match.branches) {\n                if (Array.isArray(label) && (label as any[]).includes(r)) {\n                    return body.accept(this, context);\n                } else if (label === r) {\n                    return body.accept(this, context);\n                }\n            }\n            return match.fallback.accept(this, context);\n        }\n\n        let changed = match.value !== value;\n\n        const branches: Array<[MatchLabel, Expr]> = match.branches.map(([label, branch]) => {\n            const newBranch = branch.accept(this, context);\n            if (newBranch !== branch) {\n                changed = true;\n            }\n            return [label, newBranch];\n        });\n\n        const fallback = match.fallback.accept(this, context);\n\n        if (fallback !== match.fallback) {\n            changed = true;\n        }\n\n        return changed ? new MatchExpr(value, branches, fallback) : match;\n    }\n\n    visitCaseExpr(expr: CaseExpr, context: InstantiationContext): Expr {\n        const branches: Array<[Expr, Expr]> = [];\n\n        let changed = false;\n\n        for (const [condition, branch] of expr.branches) {\n            const newCondition = condition.accept(this, context);\n\n            if (newCondition instanceof LiteralExpr) {\n                if (newCondition.value) {\n                    return branch.accept(this, context);\n                }\n            } else {\n                if (newCondition !== condition) {\n                    changed = true;\n                }\n                branches.push([newCondition, branch]);\n            }\n        }\n\n        if (branches.length === 0) {\n            // all the conditions of this CaseExpr evaluated\n            // to false, so the resulting of instantiating this CaseExpr\n            // is the same as instantiating its fallback expression.\n            return expr.fallback.accept(this, context);\n        }\n\n        if (branches.length !== expr.branches.length) {\n            // the number of branches changed, this means that\n            // some of the branches had constant expressions that\n            // evaluate to false. In this case the resulting\n            // `CaseExpr` has less branches.\n            changed = true;\n        }\n\n        // Instantiate the body of all the branches of this CaseExpr\n        // that have dynamic conditions.\n        branches.forEach(branch => {\n            const instantiatedBranch = branch[1].accept(this, context);\n\n            if (instantiatedBranch !== branch[1]) {\n                changed = true;\n            }\n\n            branch[1] = instantiatedBranch;\n        });\n\n        const fallback = expr.fallback.accept(this, context);\n\n        if (fallback !== expr.fallback) {\n            changed = true;\n        }\n\n        if (!changed) {\n            // nothing changed, return the old expression.\n            return expr;\n        }\n\n        return new CaseExpr(branches, fallback);\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    CallExpr,\n    ContainsExpr,\n    EqualityOp,\n    Expr,\n    HasAttributeExpr,\n    NumberLiteralExpr,\n    RelationalOp,\n    StringLiteralExpr,\n    VarExpr\n} from \"./Expr\";\n\n/**\n * Character value\n */\nenum Character {\n    Tab = 9,\n    Lf = 10,\n    Cr = 13,\n    Space = 32,\n    LParen = 40,\n    RParen = 41,\n    Comma = 44,\n    Dot = 46,\n    LBracket = 91,\n    Backslash = 92,\n    RBracket = 93,\n    _0 = 48,\n    _9 = 57,\n    _ = 95,\n    A = 64,\n    Z = 90,\n    a = 97,\n    z = 122,\n    DoubleQuote = 34,\n    SingleQuote = 39,\n    Exclaim = 33,\n    Equal = 61,\n    Caret = 94,\n    Tilde = 126,\n    Dollar = 36,\n    Less = 60,\n    Greater = 62,\n    Bar = 124,\n    Amp = 38\n}\n\n/**\n * Check if a codepoint is a whitespace character.\n */\nfunction isSpace(codepoint: number): boolean {\n    switch (codepoint) {\n        case Character.Tab:\n        case Character.Lf:\n        case Character.Cr:\n        case Character.Space:\n            return true;\n        default:\n            return false;\n    } // switch\n}\n\n/**\n * Check if codepoint is a digit character.\n */\nfunction isNumber(codepoint: number): boolean {\n    return codepoint >= Character._0 && codepoint <= Character._9;\n}\n\n/**\n * Check if codepoint is a letter character.\n */\nfunction isLetter(codepoint: number): boolean {\n    return (\n        (codepoint >= Character.a && codepoint <= Character.z) ||\n        (codepoint >= Character.A && codepoint <= Character.Z)\n    );\n}\n\n/**\n * Check if codepoint is either a digit or a letter character.\n */\nfunction isLetterOrNumber(codepoint: number): boolean {\n    return isLetter(codepoint) || isNumber(codepoint);\n}\n\n/**\n * Check if codepoint is an identification character: underscore, dollar sign, dot or bracket.\n */\nfunction isIdentChar(codepoint: number): boolean {\n    return (\n        isLetterOrNumber(codepoint) ||\n        codepoint === Character._ ||\n        codepoint === Character.Dollar ||\n        codepoint === Character.Dot ||\n        codepoint === Character.LBracket ||\n        codepoint === Character.RBracket\n    );\n}\n\n/**\n * Tokens used in theme grammar.\n */\nenum Token {\n    Eof = 0,\n    Error,\n    Identifier,\n    Number,\n    String,\n    Comma,\n    LParen,\n    RParen,\n    LBracket,\n    RBracket,\n    Exclaim,\n    TildeEqual,\n    CaretEqual,\n    DollarEqual,\n    EqualEqual,\n    ExclaimEqual,\n    Less,\n    Greater,\n    LessEqual,\n    GreaterEqual,\n    BarBar,\n    AmpAmp\n}\n\n/**\n * Maps a token to its string name.\n */\nfunction tokenSpell(token: Token): string {\n    switch (token) {\n        case Token.Eof:\n            return \"eof\";\n        case Token.Error:\n            return \"error\";\n        case Token.Identifier:\n            return \"identifier\";\n        case Token.Number:\n            return \"number\";\n        case Token.String:\n            return \"string\";\n        case Token.Comma:\n            return \",\";\n        case Token.LParen:\n            return \"(\";\n        case Token.RParen:\n            return \")\";\n        case Token.LBracket:\n            return \"[\";\n        case Token.RBracket:\n            return \"]\";\n        case Token.Exclaim:\n            return \"!\";\n        case Token.TildeEqual:\n            return \"~=\";\n        case Token.CaretEqual:\n            return \"^=\";\n        case Token.DollarEqual:\n            return \"$=\";\n        case Token.EqualEqual:\n            return \"==\";\n        case Token.ExclaimEqual:\n            return \"!=\";\n        case Token.Less:\n            return \"<\";\n        case Token.Greater:\n            return \">\";\n        case Token.LessEqual:\n            return \"<=\";\n        case Token.GreaterEqual:\n            return \">=\";\n        case Token.BarBar:\n            return \"||\";\n        case Token.AmpAmp:\n            return \"&&\";\n        default:\n            throw new Error(`invalid token ${token}`);\n    }\n}\n\n/**\n * Lexer class implementation.\n */\nclass Lexer {\n    private m_token: Token = Token.Error;\n    private m_index = 0;\n    private m_char: number = Character.Lf;\n    private m_text?: string;\n\n    constructor(readonly code: string) {}\n\n    /**\n     * Single lexer token.\n     */\n    token(): Token {\n        return this.m_token;\n    }\n\n    /**\n     * Parsed text.\n     */\n    text(): string {\n        return this.m_text || \"\";\n    }\n\n    /**\n     * Go to the next token.\n     */\n    next(): Token {\n        this.m_token = this.yylex();\n        if (this.m_token === Token.Error) {\n            throw new Error(`unexpected character ${this.m_char}`);\n        }\n        return this.m_token;\n    }\n\n    private yyinp(): void {\n        this.m_char = this.code.codePointAt(this.m_index++) || 0;\n    }\n\n    private yylex(): Token {\n        this.m_text = undefined;\n        while (isSpace(this.m_char)) {\n            this.yyinp();\n        }\n        if (this.m_char === 0) {\n            return Token.Eof;\n        }\n        const ch = this.m_char;\n        this.yyinp();\n        switch (ch) {\n            case Character.LParen:\n                return Token.LParen;\n            case Character.RParen:\n                return Token.RParen;\n            case Character.LBracket:\n                return Token.LBracket;\n            case Character.RBracket:\n                return Token.RBracket;\n            case Character.Comma:\n                return Token.Comma;\n            case Character.SingleQuote:\n            case Character.DoubleQuote: {\n                const start = this.m_index - 1;\n                while (this.m_char && this.m_char !== ch) {\n                    // ### TODO handle escape sequences\n                    this.yyinp();\n                }\n                if (this.m_char !== ch) {\n                    throw new Error(\"Unfinished string literal\");\n                }\n                this.yyinp();\n                this.m_text = this.code.substring(start, this.m_index - 2);\n                return Token.String;\n            }\n            case Character.Exclaim:\n                if (this.m_char === Character.Equal) {\n                    this.yyinp();\n                    return Token.ExclaimEqual;\n                }\n                return Token.Exclaim;\n            case Character.Caret:\n                if (this.m_char === Character.Equal) {\n                    this.yyinp();\n                    return Token.CaretEqual;\n                }\n                return Token.Error;\n            case Character.Tilde:\n                if (this.m_char === Character.Equal) {\n                    this.yyinp();\n                    return Token.TildeEqual;\n                }\n                return Token.Error;\n            case Character.Equal:\n                if (this.m_char === Character.Equal) {\n                    this.yyinp();\n                    return Token.EqualEqual;\n                }\n                return Token.Error;\n            case Character.Less:\n                if (this.m_char === Character.Equal) {\n                    this.yyinp();\n                    return Token.LessEqual;\n                }\n                return Token.Less;\n            case Character.Greater:\n                if (this.m_char === Character.Equal) {\n                    this.yyinp();\n                    return Token.GreaterEqual;\n                }\n                return Token.Greater;\n            case Character.Bar:\n                if (this.m_char === Character.Bar) {\n                    this.yyinp();\n                    return Token.BarBar;\n                }\n                return Token.Error;\n            case Character.Amp:\n                if (this.m_char === Character.Amp) {\n                    this.yyinp();\n                    return Token.AmpAmp;\n                }\n                return Token.Error;\n            default: {\n                const start = this.m_index - 2;\n                if (\n                    isLetter(ch) ||\n                    ch === Character._ ||\n                    (ch === Character.Dollar && isIdentChar(this.m_char))\n                ) {\n                    while (isIdentChar(this.m_char)) {\n                        this.yyinp();\n                    }\n                    this.m_text = this.code.substring(start, this.m_index - 1);\n                    return Token.Identifier;\n                } else if (isNumber(ch)) {\n                    while (isNumber(this.m_char)) {\n                        this.yyinp();\n                    }\n                    if (this.m_char === Character.Dot) {\n                        this.yyinp();\n                        while (isNumber(this.m_char)) {\n                            this.yyinp();\n                        }\n                    }\n                    this.m_text = this.code.substring(start, this.m_index - 1);\n                    return Token.Number;\n                } else if (ch === Character.Dollar) {\n                    if (this.m_char === Character.Equal) {\n                        this.yyinp();\n                        return Token.DollarEqual;\n                    }\n                    return Token.Error;\n                }\n            }\n        }\n        return Token.Error;\n    }\n}\n\nfunction getEqualityOp(token: Token): EqualityOp | undefined {\n    switch (token) {\n        case Token.TildeEqual:\n            return \"~=\";\n        case Token.CaretEqual:\n            return \"^=\";\n        case Token.DollarEqual:\n            return \"$=\";\n        case Token.EqualEqual:\n            return \"==\";\n        case Token.ExclaimEqual:\n            return \"!=\";\n        default:\n            return undefined;\n    } // switch\n}\n\nfunction getRelationalOp(token: Token): RelationalOp | undefined {\n    switch (token) {\n        case Token.Less:\n            return \"<\";\n        case Token.Greater:\n            return \">\";\n        case Token.LessEqual:\n            return \"<=\";\n        case Token.GreaterEqual:\n            return \">=\";\n        default:\n            return undefined;\n    } // switch\n}\n\nexport class ExprParser {\n    private readonly lex: Lexer;\n\n    constructor(code: string) {\n        this.lex = new Lexer(code);\n        this.lex.next();\n    }\n\n    parse(): Expr | never {\n        return this.parseLogicalOr();\n    }\n\n    private yyexpect(token: Token): void | never {\n        if (this.lex.token() !== token) {\n            throw new Error(\n                `Syntax error: Expected token '${tokenSpell(token)}' but ` +\n                    `found '${tokenSpell(this.lex.token())}'`\n            );\n        }\n        this.lex.next();\n    }\n\n    private parsePrimary(): Expr | never {\n        switch (this.lex.token()) {\n            case Token.Identifier: {\n                const text = this.lex.text();\n                switch (text) {\n                    case \"has\":\n                        this.lex.next(); // skip has keyword\n                        this.yyexpect(Token.LParen);\n                        const hasAttribute = this.lex.text();\n                        this.yyexpect(Token.Identifier);\n                        this.yyexpect(Token.RParen);\n                        return new HasAttributeExpr(hasAttribute);\n                    case \"length\":\n                        this.lex.next(); // skip length keyword\n                        this.yyexpect(Token.LParen);\n                        const value = this.parseLogicalOr();\n                        this.yyexpect(Token.RParen);\n                        return new CallExpr(\"length\", [value]);\n                    default:\n                        const expr = new VarExpr(text);\n                        this.lex.next();\n                        return expr;\n                }\n            }\n\n            case Token.LParen: {\n                this.lex.next();\n                const expr = this.parseLogicalOr();\n                this.yyexpect(Token.RParen);\n                return expr;\n            }\n\n            default:\n                return this.parseLiteral();\n        } // switch\n    }\n\n    private parseLiteral(): NumberLiteralExpr | StringLiteralExpr | never {\n        switch (this.lex.token()) {\n            case Token.Number: {\n                const expr = new NumberLiteralExpr(parseFloat(this.lex.text()));\n                this.lex.next();\n                return expr;\n            }\n            case Token.String: {\n                const expr = new StringLiteralExpr(this.lex.text());\n                this.lex.next();\n                return expr;\n            }\n            default:\n                throw new Error(\"Syntax error\");\n        } // switch\n    }\n\n    private parseUnary(): Expr | never {\n        if (this.lex.token() === Token.Exclaim) {\n            this.lex.next();\n            return new CallExpr(\"!\", [this.parseUnary()]);\n        }\n        return this.parsePrimary();\n    }\n\n    private parseRelational(): Expr | never {\n        let expr = this.parseUnary();\n        while (true) {\n            if (this.lex.token() === Token.Identifier && this.lex.text() === \"in\") {\n                this.lex.next();\n                this.yyexpect(Token.LBracket);\n                const elements = [this.parseLiteral()];\n                while (this.lex.token() === Token.Comma) {\n                    this.lex.next();\n                    elements.push(this.parseLiteral());\n                }\n                this.yyexpect(Token.RBracket);\n                expr = new ContainsExpr(\n                    expr,\n                    elements.map(literal => literal.value)\n                );\n            } else {\n                const op = getRelationalOp(this.lex.token());\n                if (op === undefined) {\n                    break;\n                }\n                this.lex.next();\n                const right = this.parseUnary();\n                expr = new CallExpr(op, [expr, right]);\n            }\n        }\n        return expr;\n    }\n\n    private parseEquality(): Expr | never {\n        let expr = this.parseRelational();\n        while (true) {\n            const op = getEqualityOp(this.lex.token());\n            if (op === undefined) {\n                break;\n            }\n            this.lex.next();\n            const right = this.parseRelational();\n            expr = new CallExpr(op, [expr, right]);\n        }\n        return expr;\n    }\n\n    private parseLogicalAnd(): Expr | never {\n        const expr = this.parseEquality();\n\n        if (this.lex.token() !== Token.AmpAmp) {\n            return expr;\n        }\n\n        const expressions: Expr[] = [expr];\n\n        do {\n            this.lex.next();\n            expressions.push(this.parseEquality());\n        } while (this.lex.token() === Token.AmpAmp);\n\n        return new CallExpr(\"all\", expressions);\n    }\n\n    private parseLogicalOr(): Expr | never {\n        const expr = this.parseLogicalAnd();\n\n        if (this.lex.token() !== Token.BarBar) {\n            return expr;\n        }\n\n        const expressions: Expr[] = [expr];\n\n        do {\n            this.lex.next();\n            expressions.push(this.parseLogicalAnd());\n        } while (this.lex.token() === Token.BarBar);\n\n        return new CallExpr(\"any\", expressions);\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Common communication protocol for [[WorkerService]].\n */\nexport namespace WorkerServiceProtocol {\n    /**\n     * Service id of worker manager ([[WorkerServiceManager]]) used to create/destroy service\n     * instances in workers.\n     */\n    export const WORKER_SERVICE_MANAGER_SERVICE_ID = \"worker-service-manager\";\n\n    /**\n     * Define possible names of messages exchanged with services within `WebWorker`.\n     */\n    export enum ServiceMessageName {\n        Initialized = \"initialized\",\n        Request = \"request\",\n        Response = \"response\"\n    }\n\n    /**\n     * Interface for `ServiceMessage` which describes metadata for a service messages.\n     */\n    export interface ServiceMessage {\n        service: string;\n        type: ServiceMessageName;\n    }\n\n    /**\n     * This message is sent by the worker to the main thread. No data is sent. Receiving this\n     * message confirms that the worker has started successfully.\n     */\n    export interface InitializedMessage extends ServiceMessage {\n        type: ServiceMessageName.Initialized;\n    }\n\n    /**\n     * Type guard to check if an object is a signal message from worker.\n     */\n    export function isInitializedMessage(message: any): message is InitializedMessage {\n        return (\n            message &&\n            typeof message.service === \"string\" &&\n            typeof message.type === \"string\" &&\n            message.type === ServiceMessageName.Initialized\n        );\n    }\n\n    /**\n     * Define possible names of requests called on services within `WebWorker`.\n     */\n    export enum Requests {\n        CreateService = \"create-service\",\n        DestroyService = \"destroy-service\"\n    }\n\n    /**\n     * This is an internal general interface used in communication with workers.\n     * Check [[ConcurrentWorkerSet]]'s invokeRequest function for exemplary usage.\n     */\n    export interface ServiceRequest {\n        type: string;\n    }\n\n    /**\n     * This message is sent by the main thread to [[WorkerServiceManager]] to dynamically create a\n     * new service.\n     *\n     * May throw `UnknownServiceError` if service of given type is not registered in\n     * [[WorkerServiceManager]], see [[isUnknownServiceError]].\n     */\n    export interface CreateServiceRequest extends ServiceRequest {\n        type: Requests.CreateService;\n\n        /**\n         * Type of service to be created.\n         *\n         * @see [[WorkerServiceManager.register]]\n         */\n        targetServiceType: string;\n\n        /**\n         * The newly created service instance will be available under this id.\n         */\n        targetServiceId: string;\n    }\n\n    /**\n     * Test if `error` thrown by [[CreateServiceRequest]] was caused by unknown type of service.\n     */\n    export function isUnknownServiceError(error: Error): boolean {\n        return /unknown targetServiceType requested: /.test(error.message);\n    }\n\n    /**\n     * This message is sent by the main thread to [[WorkerServiceManager]] to dynamically destroy a\n     * service.\n     */\n    export interface DestroyServiceRequest extends ServiceRequest {\n        type: Requests.DestroyService;\n\n        /**\n         * Id of service to be destroyed.\n         */\n        targetServiceId: string;\n    }\n\n    /**\n     * Possible service management messages (`CreateService` or `DestroyService`) sent to WebWorker.\n     */\n    export type WorkerServiceManagerRequest = CreateServiceRequest | DestroyServiceRequest;\n\n    /**\n     * This message is a part of the Request-Response scheme implemented to be used in communication\n     * between workers and the decoder.\n     */\n    export interface RequestMessage extends ServiceMessage {\n        type: ServiceMessageName.Request;\n        messageId: number;\n        request: any;\n    }\n\n    /**\n     * Type guard to check if an object is a request message sent to a worker.\n     */\n    export function isRequestMessage(message: any): message is RequestMessage {\n        return (\n            message &&\n            typeof message.service === \"string\" &&\n            typeof message.type === \"string\" &&\n            message.type === ServiceMessageName.Request\n        );\n    }\n\n    /**\n     * This message is a part of the Request-Response scheme implemented to be used in communication\n     * between workers and the decoder.\n     */\n    export interface ResponseMessage extends ServiceMessage {\n        type: ServiceMessageName.Response;\n        messageId: number;\n        errorMessage?: string;\n        errorStack?: string;\n        response?: object;\n    }\n\n    /**\n     * Type guard to check if an object is a request message sent to a worker.\n     */\n    export function isResponseMessage(message: any): message is ResponseMessage {\n        return (\n            message &&\n            typeof message.service === \"string\" &&\n            typeof message.type === \"string\" &&\n            message.type === ServiceMessageName.Response\n        );\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeoJson } from \"../lib/GeoJsonDataType\";\nimport { WorkerServiceProtocol } from \"./WorkerServiceProtocol\";\n\n/**\n * Communication protocol with [[ITiler]].\n */\nexport namespace WorkerTilerProtocol {\n    /**\n     * Define possible names of requests called on tiler services within `WebWorker`.\n     */\n    export enum Requests {\n        RegisterIndex = \"register-index\",\n        UpdateIndex = \"update-index\",\n        TileRequest = \"tile-request\"\n    }\n\n    /**\n     * This object is sent to the tiler to register a new tile index in the worker.\n     */\n    export interface RegisterIndexRequest extends WorkerServiceProtocol.ServiceRequest {\n        type: Requests.RegisterIndex;\n        id: string;\n        input: string | GeoJson;\n    }\n\n    /**\n     * Type guard to check if an object is an index registration request sent to a worker.\n     */\n    export function isRegisterIndexRequest(message: any): message is RegisterIndexRequest {\n        return (\n            message && typeof message.type === \"string\" && message.type === Requests.RegisterIndex\n        );\n    }\n\n    /**\n     * This object is sent to the tiler to register a new tile index in the worker.\n     */\n    export interface UpdateIndexRequest extends WorkerServiceProtocol.ServiceRequest {\n        type: Requests.UpdateIndex;\n        id: string;\n        input: string | GeoJson;\n    }\n\n    /**\n     * Type guard to check if an object is an update request for the index registration.\n     */\n    export function isUpdateIndexRequest(message: any): message is UpdateIndexRequest {\n        return message && typeof message.type === \"string\" && message.type === Requests.UpdateIndex;\n    }\n\n    /**\n     * This object is sent to the tiler asking to retrieve a specific tile. The expected response\n     * type is an object containing a tiled payload.\n     */\n    export interface TileRequest extends WorkerServiceProtocol.ServiceRequest {\n        type: Requests.TileRequest;\n        index: string;\n        tileKey: number;\n    }\n\n    /**\n     * Type guard to check if an object is a tile request sent to a worker.\n     */\n    export function isTileRequest(message: any): message is TileRequest {\n        return message && typeof message.type === \"string\" && message.type === Requests.TileRequest;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Definitions, StyleSet } from \"./Theme\";\nimport { WorkerServiceProtocol } from \"./WorkerServiceProtocol\";\n\n/**\n * Interface for `OptionsMap` which describes a general structure of key-value pairs.\n */\nexport interface OptionsMap {\n    [name: string]: any;\n}\n\n/**\n * Allows to cancel and prioritize requests inside the requestQueue. Useful to optimize the order of\n * decoding tiles during animations and camera movements.\n *\n * `RequestController` is not extending [[AbortController]], because this is not supported in ES5.\n */\nexport class RequestController implements AbortController {\n    /**\n     * Creates an instance of `RequestController`.\n     *\n     * @param {number} priority\n     * @param {AbortController} abortController Optional [[AbortController]] used internally, since\n     *      [[AbortController]]s should not be subclassed.\n     */\n    constructor(\n        public priority: number = 0,\n        public abortController: AbortController = new AbortController()\n    ) {}\n\n    get signal(): AbortSignal {\n        return this.abortController.signal;\n    }\n\n    /**\n     * Invoking this method will set this object's AbortSignal's aborted flag and\n     * signal to any observers that the associated activity is to be aborted.\n     */\n    abort(): void {\n        this.abortController.abort();\n    }\n}\n\n/**\n * Communication protocol with [[ITileDecoder]].\n */\nexport namespace WorkerDecoderProtocol {\n    /**\n     * Define possible names of messages exchanged with decoder services within `WebWorker`.\n     */\n    export enum DecoderMessageName {\n        Configuration = \"configuration\"\n    }\n\n    /**\n     * Interface for `DecodedTileMessage` which describes metadata for a decoded tile.\n     */\n    export interface DecoderMessage {\n        service: string;\n        type: DecoderMessageName;\n    }\n\n    /**\n     * Interface for a ConfigurationMessage that is sent from the datasource to the decoder. The\n     * message used to configure the [[ITileDecoder]].\n     */\n    export interface ConfigurationMessage extends DecoderMessage {\n        type: DecoderMessageName.Configuration;\n        styleSet?: StyleSet;\n        definitions?: Definitions;\n        options?: OptionsMap;\n        languages?: string[];\n    }\n\n    /**\n     * Type guard to check if an object is an instance of `ConfigurationMessage`.\n     */\n    export function isConfigurationMessage(message: any): message is ConfigurationMessage {\n        return (\n            message &&\n            typeof message.service === \"string\" &&\n            typeof message.type === \"string\" &&\n            message.type === DecoderMessageName.Configuration\n        );\n    }\n\n    /**\n     * Define possible names of requests called on decoder services within `WebWorker`.\n     */\n    export enum Requests {\n        DecodeTileRequest = \"decode-tile-request\",\n        TileInfoRequest = \"tile-info-request\"\n    }\n\n    /**\n     * This object is sent to the decoder asking to decode a specific tile. The expected response\n     * type is a [[DecodedTile]].\n     */\n    export interface DecodeTileRequest extends WorkerServiceProtocol.ServiceRequest {\n        type: Requests.DecodeTileRequest;\n        tileKey: number;\n        data: ArrayBufferLike;\n        projection: string;\n    }\n\n    /**\n     * Type guard to check if an object is a decoded tile object sent to a worker.\n     */\n    export function isDecodeTileRequest(message: any): message is DecodeTileRequest {\n        return (\n            message &&\n            typeof message.type === \"string\" &&\n            message.type === Requests.DecodeTileRequest\n        );\n    }\n\n    /**\n     * This object is sent to the decoder asking for a tile info of a specific tile. The expected\n     * response type is a [[DecodedTile]].\n     */\n    export interface TileInfoRequest extends WorkerServiceProtocol.ServiceRequest {\n        type: Requests.TileInfoRequest;\n        tileKey: number;\n        data: ArrayBufferLike;\n        projection: string;\n    }\n\n    /**\n     * Type guard to check if an object is an info tile object sent to a worker.\n     */\n    export function isTileInfoRequest(message: any): message is TileInfoRequest {\n        return (\n            message && typeof message.type === \"string\" && message.type === Requests.TileInfoRequest\n        );\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeoBox } from \"../coordinates/GeoBox\";\nimport { GeoCoordinates } from \"../coordinates/GeoCoordinates\";\nimport { GeoCoordinatesLike } from \"../coordinates/GeoCoordinatesLike\";\nimport { Box3Like, isBox3Like } from \"../math/Box3Like\";\nimport { MathUtils } from \"../math/MathUtils\";\nimport { isOrientedBox3Like, OrientedBox3Like } from \"../math/OrientedBox3Like\";\nimport { Vector3Like } from \"../math/Vector3Like\";\nimport { Projection, ProjectionType } from \"./Projection\";\n\nimport * as THREE from \"three\";\n\nclass IdentityProjection extends Projection {\n    readonly type: ProjectionType = ProjectionType.Planar;\n\n    getScaleFactor(_worldPoint: Vector3Like): number {\n        return 1;\n    }\n\n    worldExtent<WorldBoundingBox extends Box3Like>(\n        minAltitude: number,\n        maxAltitude: number,\n        result?: WorldBoundingBox\n    ): WorldBoundingBox {\n        if (!result) {\n            result = MathUtils.newEmptyBox3() as WorldBoundingBox;\n        }\n        result.min.x = -Math.PI;\n        result.min.y = -Math.PI * 0.5;\n        result.min.z = minAltitude;\n        result.max.x = Math.PI;\n        result.max.y = Math.PI * 0.5;\n        result.max.z = maxAltitude;\n        return result;\n    }\n\n    projectPoint<WorldCoordinates extends Vector3Like>(\n        geoPoint: GeoCoordinatesLike,\n        result?: WorldCoordinates\n    ): WorldCoordinates {\n        if (!result) {\n            // tslint:disable-next-line:no-object-literal-type-assertion\n            result = { x: 0, y: 0, z: 0 } as WorldCoordinates;\n        }\n        result.x = THREE.Math.degToRad(geoPoint.longitude);\n        result.y = THREE.Math.degToRad(geoPoint.latitude);\n        result.z = geoPoint.altitude || 0;\n        return result;\n    }\n\n    unprojectPoint(worldPoint: Vector3Like): GeoCoordinates {\n        const geoPoint = GeoCoordinates.fromRadians(worldPoint.y, worldPoint.x, worldPoint.z);\n        return geoPoint;\n    }\n\n    unprojectAltitude(worldPoint: Vector3Like): number {\n        return worldPoint.z;\n    }\n\n    projectBox<WorldBoundingBox extends Box3Like | OrientedBox3Like>(\n        geoBox: GeoBox,\n        result?: WorldBoundingBox\n    ): WorldBoundingBox {\n        if (!result) {\n            result = MathUtils.newEmptyBox3() as WorldBoundingBox;\n        }\n        const min = this.projectPoint(\n            new GeoCoordinates(geoBox.south, geoBox.west, geoBox.minAltitude)\n        );\n        const max = this.projectPoint(\n            new GeoCoordinates(geoBox.north, geoBox.east, geoBox.maxAltitude)\n        );\n        if (isBox3Like(result)) {\n            result.min.x = min.x;\n            result.min.y = min.y;\n            result.min.z = min.z;\n            result.max.x = max.x;\n            result.max.y = max.y;\n            result.max.z = max.z;\n        } else if (isOrientedBox3Like(result)) {\n            MathUtils.newVector3(1, 0, 0, result.xAxis);\n            MathUtils.newVector3(0, 1, 0, result.yAxis);\n            MathUtils.newVector3(0, 0, 1, result.zAxis);\n            result.position.x = (min.x + max.x) * 0.5;\n            result.position.y = (min.y + max.y) * 0.5;\n            result.position.z = (min.z + max.z) * 0.5;\n            result.extents.x = (max.x - min.x) * 0.5;\n            result.extents.y = (max.y - min.y) * 0.5;\n            result.extents.z = Math.max(Number.EPSILON, (max.z - min.z) * 0.5);\n        }\n        return result;\n    }\n\n    unprojectBox(worldBox: Box3Like): GeoBox {\n        const minGeo = this.unprojectPoint(worldBox.min);\n        const maxGeo = this.unprojectPoint(worldBox.max);\n        return GeoBox.fromCoordinates(minGeo, maxGeo);\n    }\n\n    groundDistance(worldPoint: Vector3Like): number {\n        return worldPoint.z;\n    }\n\n    scalePointToSurface(worldPoint: Vector3Like): Vector3Like {\n        worldPoint.z = 0;\n        return worldPoint;\n    }\n\n    surfaceNormal(_worldPoint: Vector3Like, normal?: Vector3Like) {\n        if (normal === undefined) {\n            normal = { x: 0, y: 0, z: 1 };\n        } else {\n            normal.x = 0;\n            normal.y = 0;\n            normal.z = 1;\n        }\n        return normal;\n    }\n}\n\n/**\n * Identity [[Projection]] used to convert geo coordinates to unit coordinates and vice versa.\n */\nexport const identityProjection: Projection = new IdentityProjection(1);\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeoBox } from \"../coordinates/GeoBox\";\nimport { GeoCoordinates } from \"../coordinates/GeoCoordinates\";\nimport { GeoCoordinatesLike } from \"../coordinates/GeoCoordinatesLike\";\nimport { Box3Like, isBox3Like } from \"../math/Box3Like\";\nimport { MathUtils } from \"../math/MathUtils\";\nimport { isOrientedBox3Like, OrientedBox3Like } from \"../math/OrientedBox3Like\";\nimport { TransformLike } from \"../math/TransformLike\";\nimport { Vector3Like } from \"../math/Vector3Like\";\nimport { EarthConstants } from \"./EarthConstants\";\nimport { mercatorProjection, webMercatorProjection } from \"./MercatorProjection\";\nimport { Projection, ProjectionType } from \"./Projection\";\n\nimport * as THREE from \"three\";\n\n/**\n * Transforms the given vector using the provided basis.\n */\nfunction apply(\n    xAxis: Vector3Like,\n    yAxis: Vector3Like,\n    zAxis: Vector3Like,\n    v: Vector3Like\n): Vector3Like {\n    const x = xAxis.x * v.x + yAxis.x * v.y + zAxis.x * v.z;\n    const y = xAxis.y * v.x + yAxis.y * v.y + zAxis.y * v.z;\n    const z = xAxis.z * v.x + yAxis.z * v.y + zAxis.z * v.z;\n    v.x = x;\n    v.y = y;\n    v.z = z;\n    return v;\n}\n\n/**\n * Returns the quadrants for the given longitude. The quadrant is defined as:\n *  - quadrant(+Math.PI * -1.0) = 0\n *  - quadrant(+Math.PI * -0.5) = 1\n *  - quadrant(+Math.PI *  0.0) = 2\n *  - quadrant(+Math.PI *  0.5) = 3\n *  - quadrant(+Math.PI *  1.0) = 4\n *\n * @param longitude The longitude in radians.\n */\nfunction getLongitudeQuadrant(longitude: number) {\n    const oneOverPI = 1 / Math.PI;\n    const quadrantIndex = Math.floor(2 * (longitude * oneOverPI + 1));\n    return THREE.Math.clamp(quadrantIndex, 0, 4);\n}\n\nfunction lengthOfVector3(worldPoint: Vector3Like): number {\n    const d = Math.sqrt(\n        worldPoint.x * worldPoint.x + worldPoint.y * worldPoint.y + worldPoint.z * worldPoint.z\n    );\n    return d;\n}\n\n/**\n * Creates a Box3 enclosing the geobox.\n *\n * @param geoBox Ghe given geobox\n * @param worldBox The resulting axis aligned bounding box.\n */\nfunction makeBox3<Bounds extends Box3Like>(\n    geoBox: GeoBox,\n    worldBox: Bounds,\n    unitScale: number\n): Bounds {\n    const halfEquatorialRadius = (unitScale + (geoBox.maxAltitude || 0)) * 0.5;\n\n    const minLongitude = THREE.Math.degToRad(geoBox.west);\n    const maxLongitude = THREE.Math.degToRad(geoBox.east);\n\n    const minLongitudeQuadrant = getLongitudeQuadrant(minLongitude);\n    const maxLongitudeQuadrant = getLongitudeQuadrant(maxLongitude);\n\n    let xMin = Math.cos(minLongitude);\n    let xMax = xMin;\n    let yMin = Math.sin(minLongitude);\n    let yMax = yMin;\n\n    for (\n        let quadrantIndex = minLongitudeQuadrant + 1;\n        quadrantIndex <= maxLongitudeQuadrant;\n        quadrantIndex++\n    ) {\n        // tslint:disable-next-line: no-bitwise\n        const x = ((quadrantIndex + 1) & 1) * ((quadrantIndex & 2) - 1);\n        xMin = Math.min(x, xMin);\n        xMax = Math.max(x, xMax);\n\n        // tslint:disable-next-line: no-bitwise\n        const y = (quadrantIndex & 1) * ((quadrantIndex & 2) - 1);\n        yMin = Math.min(y, yMin);\n        yMax = Math.max(y, yMax);\n    }\n\n    const cosMaxLongitude = Math.cos(maxLongitude);\n    xMin = Math.min(cosMaxLongitude, xMin);\n    xMax = Math.max(cosMaxLongitude, xMax);\n\n    const sinMaxLongitude = Math.sin(maxLongitude);\n    yMin = Math.min(sinMaxLongitude, yMin);\n    yMax = Math.max(sinMaxLongitude, yMax);\n\n    const xCenter = (xMax + xMin) * halfEquatorialRadius;\n    const xExtent = (xMax - xMin) * halfEquatorialRadius;\n\n    const yCenter = (yMax + yMin) * halfEquatorialRadius;\n    const yExtent = (yMax - yMin) * halfEquatorialRadius;\n\n    // Calculate Z boundaries.\n    const minLatitude = THREE.Math.degToRad(geoBox.south);\n    const maxLatutide = THREE.Math.degToRad(geoBox.north);\n\n    const zMax = Math.sin(maxLatutide);\n    const zMin = Math.sin(minLatitude);\n\n    const zCenter = (zMax + zMin) * halfEquatorialRadius;\n    const zExtent = (zMax - zMin) * halfEquatorialRadius;\n\n    worldBox.min.x = xCenter - xExtent;\n    worldBox.min.y = yCenter - yExtent;\n    worldBox.min.z = zCenter - zExtent;\n    worldBox.max.x = xCenter + xExtent;\n    worldBox.max.y = yCenter + yExtent;\n    worldBox.max.z = zCenter + zExtent;\n\n    return worldBox;\n}\n\n/**\n * Computes the spherical projection of the given geo coordinates.\n *\n * @param geoPoint The geo coordinates.\n * @param worldpoint The resulting world coordinates.\n */\nfunction project<WorldCoordinates extends Vector3Like>(\n    geoPoint: GeoCoordinatesLike,\n    worldpoint: WorldCoordinates,\n    unitScale: number\n): typeof worldpoint {\n    const radius = unitScale + (geoPoint.altitude || 0);\n    const latitude = THREE.Math.degToRad(geoPoint.latitude);\n    const longitude = THREE.Math.degToRad(geoPoint.longitude);\n    const cosLatitude = Math.cos(latitude);\n    worldpoint.x = radius * cosLatitude * Math.cos(longitude);\n    worldpoint.y = radius * cosLatitude * Math.sin(longitude);\n    worldpoint.z = radius * Math.sin(latitude);\n    return worldpoint;\n}\n\nclass SphereProjection extends Projection {\n    readonly type: ProjectionType = ProjectionType.Spherical;\n\n    worldExtent<Bounds extends Box3Like>(\n        _minElevation: number,\n        maxElevation: number,\n        result: Bounds = MathUtils.newEmptyBox3() as Bounds\n    ): Bounds {\n        const radius = this.unitScale + maxElevation;\n        result.min.x = -radius;\n        result.min.y = -radius;\n        result.min.z = -radius;\n        result.max.x = radius;\n        result.max.y = radius;\n        result.max.z = radius;\n        return result;\n    }\n\n    projectPoint<WorldCoordinates extends Vector3Like>(\n        geoPoint: GeoCoordinatesLike,\n        result: WorldCoordinates = MathUtils.newVector3(0, 0, 0) as WorldCoordinates\n    ): WorldCoordinates {\n        return project(geoPoint, result, this.unitScale);\n    }\n\n    unprojectPoint(point: Vector3Like): GeoCoordinates {\n        const parallelRadiusSq = point.x * point.x + point.y * point.y;\n        const parallelRadius = Math.sqrt(parallelRadiusSq);\n        const v = point.z / parallelRadius;\n\n        if (isNaN(v)) {\n            return GeoCoordinates.fromRadians(0, 0, -this.unitScale);\n        }\n\n        const radius = Math.sqrt(parallelRadiusSq + point.z * point.z);\n\n        return GeoCoordinates.fromRadians(\n            Math.atan(v),\n            Math.atan2(point.y, point.x),\n            radius - this.unitScale\n        );\n    }\n\n    unprojectAltitude(point: Vector3Like): number {\n        const parallelRadiusSq = point.x * point.x + point.y * point.y + point.z * point.z;\n        return Math.sqrt(parallelRadiusSq) - EarthConstants.EQUATORIAL_RADIUS;\n    }\n\n    projectBox<Bounds extends Box3Like | OrientedBox3Like>(\n        geoBox: GeoBox,\n        result: Bounds = MathUtils.newEmptyBox3() as Bounds\n    ): Bounds {\n        if (isBox3Like(result)) {\n            return makeBox3(geoBox, result, this.unitScale);\n        } else if (isOrientedBox3Like(result)) {\n            if (geoBox.longitudeSpan >= 90) {\n                const bounds = makeBox3(geoBox, MathUtils.newEmptyBox3(), this.unitScale);\n                MathUtils.newVector3(1, 0, 0, result.xAxis);\n                MathUtils.newVector3(0, 1, 0, result.yAxis);\n                MathUtils.newVector3(0, 0, 1, result.zAxis);\n                result.position.x = (bounds.max.x + bounds.min.x) * 0.5;\n                result.position.y = (bounds.max.y + bounds.min.y) * 0.5;\n                result.position.z = (bounds.max.z + bounds.min.z) * 0.5;\n                result.extents.x = (bounds.max.x - bounds.min.x) * 0.5;\n                result.extents.y = (bounds.max.y - bounds.min.y) * 0.5;\n                result.extents.z = (bounds.max.z - bounds.min.z) * 0.5;\n                return result;\n            }\n\n            const { south, west, north, east, center: mid } = geoBox;\n            const midX = mid.longitude;\n            const midY = mid.latitude;\n            const cosSouth = Math.cos(THREE.Math.degToRad(south));\n            const sinSouth = Math.sin(THREE.Math.degToRad(south));\n            const cosWest = Math.cos(THREE.Math.degToRad(west));\n            const sinWest = Math.sin(THREE.Math.degToRad(west));\n            const cosNorth = Math.cos(THREE.Math.degToRad(north));\n            const sinNorth = Math.sin(THREE.Math.degToRad(north));\n            const cosEast = Math.cos(THREE.Math.degToRad(east));\n            const sinEast = Math.sin(THREE.Math.degToRad(east));\n            const cosMidX = Math.cos(THREE.Math.degToRad(midX));\n            const sinMidX = Math.sin(THREE.Math.degToRad(midX));\n            const cosMidY = Math.cos(THREE.Math.degToRad(midY));\n            const sinMidY = Math.sin(THREE.Math.degToRad(midY));\n\n            // Build the orientation of the OBB using the normal vector and its partial derivates.\n\n            // the sperical coordinates of the mid point of the geobox.\n            MathUtils.newVector3(cosMidX * cosMidY, sinMidX * cosMidY, sinMidY, result.zAxis);\n\n            // the partial derivates of the normal vector.\n            MathUtils.newVector3(-sinMidX, cosMidX, 0, result.xAxis);\n            MathUtils.newVector3(-cosMidX * sinMidY, -sinMidX * sinMidY, cosMidY, result.yAxis);\n\n            let width: number;\n            let minY: number;\n            let maxY: number;\n\n            if (south >= 0) {\n                // abs(dot(southWest - southEast, xAxis))\n                width = Math.abs(\n                    cosSouth * (cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest))\n                );\n\n                // dot(south, yAxis)\n                minY = cosMidY * sinSouth - sinMidY * cosSouth;\n\n                // dot(northEast, zAxis)\n                maxY =\n                    cosMidY * sinNorth -\n                    sinMidY * cosNorth * (cosMidX * cosEast + sinMidX * sinEast);\n            } else {\n                if (north <= 0) {\n                    // abs(dot(northWest - northEast, xAxis))\n                    width = Math.abs(\n                        cosNorth * (cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest))\n                    );\n\n                    // dot(north, yAxis)\n                    maxY = cosMidY * sinNorth - sinMidY * cosNorth;\n                } else {\n                    // abs(dot(west - east, xAxis))\n                    width = Math.abs(cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest));\n\n                    // dot(northEast, yAxis)\n                    maxY =\n                        cosMidY * sinNorth -\n                        sinMidY * cosNorth * (sinMidX * sinEast + cosMidX * cosEast);\n                }\n\n                // dot(southEast, yAxis)\n                minY =\n                    cosMidY * sinSouth -\n                    sinMidY * cosSouth * (cosMidX * cosEast + sinMidX * sinEast);\n            }\n\n            const rMax = (this.unitScale + (geoBox.maxAltitude || 0)) * 0.5;\n            const rMin = (this.unitScale + (geoBox.minAltitude || 0)) * 0.5;\n\n            // min(dot(southEast, zAxis), dot(northEast, zAxis))\n\n            const d = cosMidY * (cosMidX * cosEast + sinMidX * sinEast);\n\n            const minZ = Math.min(\n                cosNorth * d + sinNorth * sinMidY,\n                cosSouth * d + sinSouth * sinMidY\n            );\n\n            MathUtils.newVector3(\n                width * rMax,\n                (maxY - minY) * rMax,\n                rMax - minZ * rMin,\n                result.extents\n            );\n\n            MathUtils.newVector3(0, (minY + maxY) * rMax, rMax + rMax, result.position);\n\n            apply(result.xAxis, result.yAxis, result.zAxis, result.position);\n\n            result.position.x = result.position.x - result.zAxis.x * result.extents.z;\n            result.position.y = result.position.y - result.zAxis.y * result.extents.z;\n            result.position.z = result.position.z - result.zAxis.z * result.extents.z;\n\n            return result;\n        }\n\n        throw new Error(\"Invalid bounding box\");\n    }\n\n    unprojectBox(_worldBox: Box3Like): GeoBox {\n        throw new Error(\"Method not implemented.\");\n    }\n\n    getScaleFactor(_worldPoint: Vector3Like): number {\n        return 1;\n    }\n\n    groundDistance(worldPoint: Vector3Like): number {\n        return lengthOfVector3(worldPoint) - this.unitScale;\n    }\n\n    scalePointToSurface(worldPoint: Vector3Like): Vector3Like {\n        const scale = this.unitScale / (lengthOfVector3(worldPoint) || 1);\n        worldPoint.x *= scale;\n        worldPoint.y *= scale;\n        worldPoint.z *= scale;\n        return worldPoint;\n    }\n\n    surfaceNormal(worldPoint: Vector3Like, normal?: Vector3Like) {\n        if (normal === undefined) {\n            normal = { x: 0, y: 0, z: 0 };\n        }\n        const scale = 1 / (lengthOfVector3(worldPoint) || 1);\n        normal.x = worldPoint.x * scale;\n        normal.y = worldPoint.y * scale;\n        normal.z = worldPoint.z * scale;\n        return normal;\n    }\n\n    reprojectPoint(\n        sourceProjection: Projection,\n        worldPos: Vector3Like,\n        result?: Vector3Like\n    ): Vector3Like {\n        if (sourceProjection === mercatorProjection || sourceProjection === webMercatorProjection) {\n            const { x, y, z } = worldPos;\n            const r = this.unitScale;\n            const mx = x / r - Math.PI;\n            const my = y / r - Math.PI;\n            const w = Math.exp(my);\n            const d = w * w;\n            const gx = (2 * w) / (d + 1);\n            const gy = (d - 1) / (d + 1);\n            const scale = r + z;\n\n            if (result === undefined) {\n                // tslint:disable-next-line: no-object-literal-type-assertion\n                result = {} as Vector3Like;\n            }\n\n            result.x = Math.cos(mx) * gx * scale;\n            result.y = Math.sin(mx) * gx * scale;\n            result.z = gy * scale;\n\n            if (sourceProjection === webMercatorProjection) {\n                result.z = -result.z;\n            }\n\n            return result;\n        }\n\n        return super.reprojectPoint(sourceProjection, worldPos, result!);\n    }\n\n    localTangentSpace(geoPoint: GeoCoordinatesLike, result: TransformLike): TransformLike {\n        const latitude = THREE.Math.degToRad(geoPoint.latitude);\n        const longitude = THREE.Math.degToRad(geoPoint.longitude);\n\n        const cosLongitude = Math.cos(longitude);\n        const sinLongitude = Math.sin(longitude);\n        const cosLatitude = Math.cos(latitude);\n        const sinLatitude = Math.sin(latitude);\n\n        MathUtils.newVector3(\n            cosLongitude * cosLatitude,\n            sinLongitude * cosLatitude,\n            sinLatitude,\n            result.zAxis\n        );\n\n        MathUtils.newVector3(-sinLongitude, cosLongitude, 0, result.xAxis);\n\n        MathUtils.newVector3(\n            -cosLongitude * sinLatitude,\n            -sinLongitude * sinLatitude,\n            cosLatitude,\n            result.yAxis\n        );\n\n        this.projectPoint(geoPoint, result.position);\n\n        return result;\n    }\n}\n\nexport const sphereProjection: Projection = new SphereProjection(EarthConstants.EQUATORIAL_RADIUS);\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeoBox } from \"../coordinates/GeoBox\";\nimport { TileKey } from \"./TileKey\";\nimport { TilingScheme } from \"./TilingScheme\";\n\n/**\n * A class used to represent a quadtree.\n */\nexport class QuadTree {\n    /**\n     * Constructs a new `QuadTree` for the given [[TilingScheme]].\n     *\n     * Example:\n     * ```typescript\n     * const quadTree = new QuadTree(hereTilingScheme);\n     * const geoBox = quadTree.getGeoBox(tileKey);\n     * console.log(geoBox.center);\n     * ```\n     *\n     * @param tilingScheme The TilingScheme used by this `QuadTree`.\n     */\n    constructor(readonly tilingScheme: TilingScheme) {}\n\n    /**\n     * Visits this `QuadTree` and invoke the given accept method with the current [[TileKey]] and\n     * its bounding box in geo coordinates.\n     *\n     * Example:\n     * ```typescript\n     * const geoPos = new GeoCoordinates(latitude, longitude);\n     * const quadTree = new QuadTree(hereTilingScheme);\n     * quadTree.visit((tileKey, geoBox) => {\n     *     if (geoBox.contains(geoPos)) {\n     *         console.log(\"tile\", tileKey, \"contains\", geoPos);\n     *         return tileKey.level < 14; // stop visiting the quadtree if the level is >= 14.\n     *     }\n     *     return false; // stop visiting the quadtree,\n     *                   // the tile's geoBox doesn't contain the given coordinates.\n     * });\n     * ```\n     *\n     * @param accept A function that takes a [[TileKey]] and its bounding box in geo coordinates and\n     * returns `true` if the visit of the `QuadTree` should continue; otherwise `false`.\n     */\n    visit(accept: (tileKey: TileKey, geoBox: GeoBox) => boolean) {\n        this.visitTileKey(TileKey.fromRowColumnLevel(0, 0, 0), accept);\n    }\n\n    /**\n     * Visits the subtree starting from the given tile.\n     *\n     * @param tileKey The root of the subtree that should be visited.\n     * @param accept A function that takes a [[TileKey]] and its bounding box in geo coordinates and\n     * returns `true` if the visit of the `QuadTree` should continue; otherwise `false`.\n     */\n    visitTileKey(tileKey: TileKey, accept: (tileKey: TileKey, geoBox: GeoBox) => boolean) {\n        const geoBox = this.tilingScheme.getGeoBox(tileKey);\n\n        if (!accept(tileKey, geoBox)) {\n            return;\n        }\n\n        for (const subTileKey of this.tilingScheme.getSubTileKeys(tileKey)) {\n            this.visitTileKey(subTileKey, accept);\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { normalizedEquirectangularProjection } from \"../projection/EquirectangularProjection\";\nimport { halfQuadTreeSubdivisionScheme } from \"./HalfQuadTreeSubdivisionScheme\";\nimport { TilingScheme } from \"./TilingScheme\";\n\n/**\n * [[TilingScheme]] used by most of the data published by HERE.\n *\n * The `hereTilingScheme` features a half quadtree subdivision scheme and an equirectangular\n * projection.\n */\nexport const hereTilingScheme = new TilingScheme(\n    halfQuadTreeSubdivisionScheme,\n    normalizedEquirectangularProjection\n);\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { webMercatorProjection } from \"../projection/MercatorProjection\";\nimport { quadTreeSubdivisionScheme } from \"./QuadTreeSubdivisionScheme\";\nimport { TilingScheme } from \"./TilingScheme\";\n\n/**\n * A [[TilingScheme]] featuring quadtree subdivision scheme and web Mercator projection.\n */\nexport const webMercatorTilingScheme = new TilingScheme(\n    quadTreeSubdivisionScheme,\n    webMercatorProjection\n);\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { mercatorProjection } from \"../projection/MercatorProjection\";\nimport { quadTreeSubdivisionScheme } from \"./QuadTreeSubdivisionScheme\";\nimport { TilingScheme } from \"./TilingScheme\";\n\n/**\n * The [[TilingScheme]] used by the HERE web tiles.\n *\n * The `mercatorTilingScheme` features a quadtree subdivision scheme and a Mercator projection.\n */\nexport const mercatorTilingScheme = new TilingScheme(quadTreeSubdivisionScheme, mercatorProjection);\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { transverseMercatorProjection } from \"../projection/TransverseMercatorProjection\";\nimport { quadTreeSubdivisionScheme } from \"./QuadTreeSubdivisionScheme\";\nimport { TilingScheme } from \"./TilingScheme\";\n\n/**\n * A [[TilingScheme]] featuring quadtree subdivision scheme and\n * transverse Mercator projection.\n */\nexport const polarTilingScheme = new TilingScheme(\n    quadTreeSubdivisionScheme,\n    transverseMercatorProjection\n);\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Interface representing a Vector3.\n */\nexport interface Vector3Like {\n    /**\n     * The X position.\n     */\n    x: number;\n\n    /**\n     * The Y position.\n     */\n    y: number;\n\n    /**\n     * The Z position.\n     */\n    z: number;\n}\n\nexport function isVector3Like(v: any): v is Vector3Like {\n    return v && typeof v.x === \"number\" && typeof v.y === \"number\" && typeof v.z === \"number\";\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Vector3Like } from \"./Vector3Like\";\n\n/**\n * The interface [[TransformLike]] is used to represent transforms with\n * only translation and rotation.\n */\nexport interface TransformLike {\n    /**\n     * The position of this transform.\n     */\n    readonly position: Vector3Like;\n\n    /**\n     * The x-axis of this transform.\n     */\n    readonly xAxis: Vector3Like;\n\n    /**\n     * The y-axis of this transform.\n     */\n    readonly yAxis: Vector3Like;\n\n    /**\n     * The z-axis of this transform.\n     */\n    readonly zAxis: Vector3Like;\n}\n\n/**\n * Returns true if the given object implements the interface [[TransformLike]].\n *\n * @param object The object.\n */\nexport function isTransformLike(object: {}): object is TransformLike {\n    const transform = object as Partial<TransformLike>;\n    return (\n        transform.position !== undefined &&\n        transform.xAxis !== undefined &&\n        transform.yAxis !== undefined &&\n        transform.zAxis !== undefined\n    );\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Frustum, Matrix4, Plane, Vector3 } from \"three\";\nimport { OrientedBox3Like } from \"./OrientedBox3Like\";\n\nexport class OrientedBox3 implements OrientedBox3Like {\n    /**\n     * The position of the center of this `OrientedBox3`.\n     */\n    readonly position = new Vector3();\n\n    /**\n     * The x-axis of this `OrientedBox3`.\n     */\n    readonly xAxis = new Vector3(1, 0, 0);\n\n    /**\n     * The y-axis of this `OrientedBox3`.\n     */\n    readonly yAxis = new Vector3(0, 1, 0);\n\n    /**\n     * The z-axis of this `OrientedBox3`.\n     */\n    readonly zAxis = new Vector3(0, 0, 1);\n\n    /**\n     * The extents of this `OrientedBox3`.\n     */\n    readonly extents = new Vector3();\n\n    /**\n     * Creates a new `OrientedBox3`.\n     */\n    constructor();\n\n    /**\n     * Creates a new `OrientedBox3` with the given position, orientation and extents.\n     *\n     * @param position The position of the center of the `OrientedBox3`.\n     * @param rotationMatrix The rotation of the `OrientedBox3`.\n     * @param extents The extents of the `OrientedBox3`.\n     */\n    constructor(position: Vector3, rotationMatrix: Matrix4, extents: Vector3);\n\n    /**\n     * Creates a new `OrientedBox3`.\n     *\n     * @hideconstructor\n     */\n    constructor(position?: Vector3, rotationMatrix?: Matrix4, extents?: Vector3) {\n        if (position !== undefined) {\n            this.position.copy(position);\n        }\n\n        if (rotationMatrix !== undefined) {\n            rotationMatrix.extractBasis(this.xAxis, this.yAxis, this.zAxis);\n        }\n\n        if (extents !== undefined) {\n            this.extents.copy(extents);\n        }\n    }\n\n    /**\n     * Create a copy of this [[OrientedBoundingBox]].\n     */\n    clone(): OrientedBox3 {\n        const newBox = new OrientedBox3();\n        newBox.copy(this);\n        return newBox;\n    }\n\n    /**\n     * Copies the values of `other` to this [[OrientedBox3]].\n     * @param other The other [[OrientedBox3]] to copy.\n     */\n    copy(other: OrientedBox3) {\n        this.position.copy(other.position);\n        this.xAxis.copy(other.xAxis);\n        this.yAxis.copy(other.yAxis);\n        this.zAxis.copy(other.zAxis);\n        this.extents.copy(other.extents);\n    }\n\n    /**\n     * Gets the center position of this [[OrientedBox3]].\n     *\n     * @param center The returned center position.\n     */\n    getCenter(center = new Vector3()): Vector3 {\n        return center.copy(this.position);\n    }\n\n    /**\n     * Gets the size of this [[OrientedBox3]].\n     *\n     * @param size The returned size.\n     */\n    getSize(size = new Vector3()): Vector3 {\n        return size.copy(this.extents).multiplyScalar(2);\n    }\n\n    /**\n     * Gets the orientation matrix of this `OrientedBox3`.\n     * @param matrix The output orientation matrix.\n     */\n    getRotationMatrix(matrix: Matrix4 = new Matrix4()): Matrix4 {\n        return matrix.makeBasis(this.xAxis, this.yAxis, this.zAxis);\n    }\n\n    /**\n     * Checks intersection with the given `THREE.Frustum` or array of `THREE.Plane`s.\n     *\n     * @param frustumOrPlanes Frustum or array of planes.\n     */\n    intersects(frustumOrPlanes: Plane[] | Frustum): boolean {\n        const planes: Plane[] = Array.isArray(frustumOrPlanes)\n            ? frustumOrPlanes\n            : frustumOrPlanes.planes;\n\n        for (const plane of planes) {\n            const r =\n                Math.abs(plane.normal.dot(this.xAxis) * this.extents.x) +\n                Math.abs(plane.normal.dot(this.yAxis) * this.extents.y) +\n                Math.abs(plane.normal.dot(this.zAxis) * this.extents.z);\n\n            const d = plane.distanceToPoint(this.position);\n\n            if (d + r < 0) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns true if this [[OrientedBox3]] contains the given point.\n     *\n     * @param point A valid point.\n     */\n    contains(point: Vector3): boolean {\n        const dx = point.x - this.position.x;\n        const dy = point.y - this.position.y;\n        const dz = point.z - this.position.z;\n        const x = Math.abs(dx * this.xAxis.x + dy * this.xAxis.y + dz * this.xAxis.z);\n        const y = Math.abs(dx * this.yAxis.x + dy * this.yAxis.y + dz * this.yAxis.z);\n        const z = Math.abs(dx * this.zAxis.x + dy * this.zAxis.y + dz * this.zAxis.z);\n        if (x > this.extents.x || y > this.extents.y || z > this.extents.z) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns the distance from this [[OrientedBox3]] and the given `point`.\n     *\n     * @param point A point.\n     */\n    distanceToPoint(point: Vector3): number {\n        return Math.sqrt(this.distanceToPointSquared(point));\n    }\n\n    /**\n     * Returns the squared distance from this [[OrientedBox3]] and the given `point`.\n     *\n     * @param point A point.\n     */\n    distanceToPointSquared(point: Vector3): number {\n        const d = new Vector3();\n        d.subVectors(point, this.position);\n\n        const lengths = [d.dot(this.xAxis), d.dot(this.yAxis), d.dot(this.zAxis)];\n\n        let result = 0;\n\n        for (let i = 0; i < 3; ++i) {\n            const length = lengths[i];\n            const extent = this.extents.getComponent(i);\n            if (length < -extent) {\n                const dd = extent + length;\n                result += dd * dd;\n            } else if (length > extent) {\n                const dd = length - extent;\n                result += dd * dd;\n            }\n        }\n\n        return result;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { TileKey } from \"@here/harp-geoutils\";\nimport { assert } from \"@here/harp-utils\";\n\nimport { Env, MapEnv, Value } from \"./Expr\";\nimport { makeDecodedTechnique } from \"./StyleSetEvaluator\";\nimport { AttrEvaluationContext, evaluateTechniqueAttr } from \"./TechniqueAttr\";\nimport {\n    IndexedTechnique,\n    isLineMarkerTechnique,\n    isPoiTechnique,\n    isTextTechnique,\n    Technique\n} from \"./Techniques\";\n\n/**\n * Defines a map tile metadata.\n */\nexport interface TileInfo {\n    readonly tileKey: TileKey;\n    readonly setupTime: number;\n    readonly transferList?: ArrayBuffer[];\n    readonly numBytes: number;\n}\n\n/**\n * Represents a feature group type for tile info.\n */\nexport enum FeatureGroupType {\n    Point,\n    Line,\n    Polygon\n}\n\n/**\n * Minimum estimated size of a JS object.\n */\nconst MINIMUM_OBJECT_SIZE_ESTIMATION = 100;\n\n/**\n * Structure of arrays containing data for all features of this group. No methods, since the object\n * is being passed as part of ExtendedTileInfo across \"process boundaries\" to the web worker.\n *\n * Supporting methods in namespace [[ExtendedTileInfo]].\n */\nexport class FeatureGroup {\n    /** featureIds */\n    featureIds: Array<number | undefined> = new Array<number | undefined>();\n\n    /** Indices into [[ExtendedTileInfo]].techniqueCatalog */\n    techniqueIndex: number[];\n\n    /** Indices into [[ExtendedTileInfo]].textCatalog. */\n    textIndex: number[];\n\n    /** Indices into positions. */\n    positionIndex: number[];\n\n    /** XY coordinates of this group. */\n    positions: number[];\n\n    /** number of features */\n    numFeatures: number = 0;\n\n    /** number of positions of elements (2 per point) */\n    numPositions: number = 0;\n\n    /**\n     * Optional indices into [[ExtendedTileInfo]].layerCatalog. Only available if\n     * [[OmvFeatureGroup]] has been constructed with `storeExtendedTags` set to `true`.\n     */\n    layerIndex?: number[];\n\n    /**\n     * Optional indices into [[ExtendedTileInfo]].classCatalog. Only available if\n     * [[OmvFeatureGroup]] has been constructed with `storeExtendedTags` set to `true`.\n     */\n    classIndex?: number[];\n\n    /**\n     * Optional indices into [[ExtendedTileInfo]].typeCatalog. Only available if [[OmvFeatureGroup]]\n     * has been constructed with `storeExtendedTags` set to `true`.\n     */\n    typeIndex?: number[];\n\n    /**\n     * Construct featureGroup.\n     *\n     * @param storeExtendedTags Pass `true` to create fields for more OMV tags (`layer`, `class`\n     * and `type`).\n     */\n    constructor(storeExtendedTags: boolean, startSize: number = 5000) {\n        this.featureIds = new Array<number>(startSize);\n        this.featureIds.length = startSize;\n        this.techniqueIndex = new Array<number>(startSize);\n        this.techniqueIndex.length = startSize;\n        this.textIndex = new Array<number>(startSize);\n        this.textIndex.length = startSize;\n        this.positionIndex = new Array<number>(startSize);\n        this.positionIndex.length = startSize;\n        this.positions = new Array<number>(10 * startSize);\n        this.positions.length = 10 * startSize;\n\n        if (storeExtendedTags) {\n            this.layerIndex = new Array<number>(startSize);\n            this.layerIndex.length = startSize;\n            this.classIndex = new Array<number>(startSize);\n            this.classIndex.length = startSize;\n            this.typeIndex = new Array<number>(startSize);\n            this.typeIndex.length = startSize;\n        }\n    }\n\n    /**\n     * Compute size in bytes.\n     */\n    getNumBytes(): number {\n        return (\n            (this.featureIds.length +\n                this.techniqueIndex.length +\n                this.textIndex.length +\n                this.positionIndex.length +\n                this.positions.length +\n                (this.layerIndex !== undefined ? this.layerIndex.length : 0) +\n                (this.classIndex !== undefined ? this.classIndex.length : 0) +\n                (this.typeIndex !== undefined ? this.typeIndex.length : 0)) *\n            8\n        );\n    }\n}\n\n/**\n * Structure of arrays containing data for roads. No methods, since the object is being passed as\n * part of [[ExtendedTileInfo]] across \"process boundaries\" to the web worker.\n */\nexport class LineFeatureGroup extends FeatureGroup {\n    /**\n     * An array of road segment ids. Is the same length as `featureIds` but certain elements can be\n     * `undefined` (if this line feature is not a road).\n     */\n    segmentIds?: number[];\n\n    /**\n     * An array of road start offsets. Certain elements may be `undefined` (if this line feature is\n     * not a road).\n     */\n    segmentStartOffsets?: number[];\n\n    /**\n     * An array of road end offsets. Certain elements may be `undefined` (if this line feature is\n     * not a road).\n     */\n    segmentEndOffsets?: number[];\n\n    /**\n     * An array of object defined by the user. Certain elements may be `undefined` (if this line\n     * feature is not a road, or if the object for that feature is undefined).\n     */\n    userData: Array<{} | undefined> = [];\n\n    getNumBytes(): number {\n        return (\n            super.getNumBytes() +\n            ((this.segmentIds !== undefined ? this.segmentIds.length : 0) +\n                (this.segmentStartOffsets !== undefined ? this.segmentStartOffsets.length : 0) +\n                (this.segmentEndOffsets !== undefined ? this.segmentEndOffsets.length : 0)) *\n                8\n        );\n    }\n}\n\n/**\n * Structure of arrays containing data for polygons. No methods, since the object is being passed as\n * part of ExtendedTileInfo across \"process boundaries\" to the web worker.\n *\n * Supporting methods in namespace [[ExtendedTileInfo]].\n *\n * Due to the complexity of the access, there are supporting classes to store and access data in\n * the feature groups. See [[ExtendedTileInfoWriter]] and [[ExtendedTileInfoPolygonAccessor]].\n */\nexport class PolygonFeatureGroup extends FeatureGroup {\n    /**\n     * Indices into innerRingStartIndex. One entry for every polygon feature.\n     *\n     * Number of rings is computed by either:\n     *\n     * a) Computing from the next innerRingStart, or\n     *\n     * b) Computing from the size of the array.\n     */\n    outerRingStartIndex: number[];\n\n    /**\n     * One entry for every polygon feature. Contains `true` if a polygon ring is an _outside_ ring,\n     * `false` otherwise.\n     */\n    innerRingIsOuterContour: number[];\n\n    /**\n     * Indices into [[OmvFeatureGroup]]`.positions`. One index for every ring.\n     *\n     * Number of inner rings is computed by either:\n     *\n     * a) Computing from the next innerRingStart, or\n     *\n     * b) Computing from the size of the array.\n     */\n    innerRingStartIndex: number[];\n\n    /**\n     * Number of rings stored in all polygons in tis group. Used to keep size of the\n     * arrays.\n     */\n    groupNumRings: number = 0;\n\n    constructor(storeExtendedTags: boolean, startSize: number = 5000) {\n        super(storeExtendedTags, startSize);\n\n        this.outerRingStartIndex = new Array<number>(startSize);\n        this.outerRingStartIndex.length = startSize;\n        this.innerRingIsOuterContour = new Array<number>(startSize);\n        this.innerRingIsOuterContour.length = startSize;\n        this.innerRingStartIndex = new Array<number>(startSize);\n        this.innerRingStartIndex.length = startSize;\n    }\n\n    getNumBytes(): number {\n        return (\n            super.getNumBytes() +\n            ((this.outerRingStartIndex !== undefined ? this.outerRingStartIndex.length : 0) +\n                (this.innerRingIsOuterContour !== undefined\n                    ? this.innerRingIsOuterContour.length\n                    : 0) +\n                (this.innerRingStartIndex !== undefined ? this.innerRingStartIndex.length : 0)) *\n                8\n        );\n    }\n}\n\n/**\n * Class to hold infos from [[OmvTile]]s. Optimized for fast serialization when being passed from\n * webworker to main thread. No methods, since the object is being passed across \"process\n * boundaries\" to the web worker.\n *\n * Supporting methods in namespace [[ExtendedTileInfo]].\n *\n * Due to the complexity of the access, there are supporting classes to store and access data in\n * the feature groups. See [[ExtendedTileInfoWriter]] and [[ExtendedTileInfoPolygonAccessor]].\n */\nexport class ExtendedTileInfo implements TileInfo {\n    /**\n     * Catalog of strings. Addressed by every features stringIndex.\n     */\n    readonly textCatalog: string[] = new Array<string>();\n    /**\n     * Catalog of techniques. Addressed by every features featureIndex.\n     */\n    readonly techniqueCatalog: IndexedTechnique[] = new Array<IndexedTechnique>();\n\n    /**\n     * Feature group containing all infos about `POINT` features.\n     */\n    readonly pointGroup: FeatureGroup;\n\n    /**\n     * Feature group containing all infos about `LINESTRING` features.\n     */\n    readonly lineGroup: LineFeatureGroup;\n\n    /**\n     * Feature group containing all infos about `POLYGON` features.\n     */\n    readonly polygonGroup: PolygonFeatureGroup;\n\n    /**\n     * Optional catalogs for extended feature infos. Only available if the [[ExtendedTileInfo]] has\n     * been constructed with `storeExtendedTags` == `true`.\n     */\n    readonly layerCatalog?: string[];\n\n    /**\n     * Optional catalogs for extended feature infos. Only available if the [[ExtendedTileInfo]] has\n     * been constructed with `storeExtendedTags` == `true`.\n     */\n    readonly classCatalog?: string[];\n\n    /**\n     * Optional catalogs for extended feature infos. Only available if the [[ExtendedTileInfo]] has\n     * been constructed with `storeExtendedTags` == `true`.\n     */\n    readonly typeCatalog?: string[];\n\n    /**\n     * Used for performance diagnostics.\n     */\n    setupTime: number = 0;\n\n    /**\n     * Size in bytes.\n     */\n    numBytes: number = 0;\n\n    constructor(readonly tileKey: TileKey, storeExtendedTags: boolean) {\n        this.pointGroup = new FeatureGroup(storeExtendedTags);\n        this.lineGroup = new LineFeatureGroup(storeExtendedTags);\n        this.polygonGroup = new PolygonFeatureGroup(storeExtendedTags);\n\n        if (storeExtendedTags) {\n            this.layerCatalog = new Array<string>();\n            this.classCatalog = new Array<string>();\n            this.typeCatalog = new Array<string>();\n        }\n    }\n\n    /**\n     * Compute the memory footprint caused by objects owned by the `ExtendedTileInfo`.\n     */\n    getNumBytes(): number {\n        let numBytes = MINIMUM_OBJECT_SIZE_ESTIMATION;\n        for (const str of this.textCatalog) {\n            numBytes += 2 * str.length;\n        }\n\n        numBytes += this.techniqueCatalog.length * MINIMUM_OBJECT_SIZE_ESTIMATION;\n\n        numBytes += this.pointGroup.getNumBytes();\n        numBytes += this.lineGroup.getNumBytes();\n        numBytes += this.polygonGroup.getNumBytes();\n\n        if (this.layerCatalog !== undefined) {\n            for (const str of this.layerCatalog) {\n                numBytes += 2 * str.length;\n            }\n            for (const str of this.classCatalog!) {\n                numBytes += 2 * str.length;\n            }\n            for (const str of this.typeCatalog!) {\n                numBytes += 2 * str.length;\n            }\n        }\n\n        return numBytes;\n    }\n}\n\nexport namespace ExtendedTileInfo {\n    function finishFeatureGroup(featureGroup: FeatureGroup) {\n        featureGroup.featureIds.length = featureGroup.numFeatures;\n        featureGroup.techniqueIndex.length = featureGroup.numFeatures;\n        featureGroup.textIndex.length = featureGroup.numFeatures;\n        featureGroup.positionIndex.length = featureGroup.numFeatures;\n        featureGroup.positions.length = featureGroup.numPositions;\n\n        if (featureGroup.layerIndex !== undefined) {\n            featureGroup.layerIndex.length = featureGroup.numFeatures;\n        }\n        if (featureGroup.classIndex !== undefined) {\n            featureGroup.classIndex.length = featureGroup.numFeatures;\n        }\n        if (featureGroup.typeIndex !== undefined) {\n            featureGroup.typeIndex.length = featureGroup.numFeatures;\n        }\n    }\n\n    function finishPolygonFeatureGroup(polygonGroup: PolygonFeatureGroup) {\n        finishFeatureGroup(polygonGroup);\n        polygonGroup.outerRingStartIndex.length = polygonGroup.numFeatures;\n        polygonGroup.innerRingIsOuterContour.length = polygonGroup.groupNumRings;\n        polygonGroup.innerRingStartIndex.length = polygonGroup.groupNumRings;\n    }\n\n    function finishLineFeatureGroup(lineGroup: LineFeatureGroup) {\n        finishFeatureGroup(lineGroup);\n        if (lineGroup.segmentIds !== undefined) {\n            lineGroup.segmentIds.length = lineGroup.numFeatures;\n            lineGroup.segmentStartOffsets!.length = lineGroup.numFeatures;\n            lineGroup.segmentEndOffsets!.length = lineGroup.numFeatures;\n        }\n    }\n\n    /**\n     * Finalize the tile's features groups.\n     */\n    export function finish(tileInfo: ExtendedTileInfo) {\n        finishFeatureGroup(tileInfo.pointGroup);\n        finishLineFeatureGroup(tileInfo.lineGroup);\n        finishPolygonFeatureGroup(tileInfo.polygonGroup);\n        tileInfo.numBytes = tileInfo.getNumBytes();\n    }\n\n    /**\n     * Returns the number of features in this feature group.\n     */\n    export function featureGroupSize(featureGroup: FeatureGroup): number {\n        return featureGroup.numFeatures;\n    }\n\n    /**\n     * Check if the feature group is finalized.\n     */\n    export function featureGroupFinished(featureGroup: FeatureGroup): boolean {\n        return featureGroup.numPositions === featureGroup.positions.length;\n    }\n\n    /**\n     * Check if the tileInfo is finalized.\n     */\n    export function tileInfoFinished(tileInfo: ExtendedTileInfo): boolean {\n        return (\n            featureGroupFinished(tileInfo.pointGroup) &&\n            featureGroupFinished(tileInfo.lineGroup) &&\n            featureGroupFinished(tileInfo.polygonGroup)\n        );\n    }\n\n    /**\n     * Determine the name of (OMV) feature. It implements the special handling required\n     * to determine the text content of a feature from its tags, which are passed in as the `env`.\n     *\n     * @param env Environment containing the tags from the (OMV) feature.\n     * @param useAbbreviation `true` to use the abbreviation if available.\n     * @param useIsoCode `true` to use the tag \"iso_code\".\n     * @param languages List of languages to use, for example: Specify \"en\" to use the tag \"name_en\"\n     *                  as the text of the string. Order reflects priority.\n     */\n    export function getFeatureName(\n        env: Env,\n        useAbbreviation?: boolean,\n        useIsoCode?: boolean,\n        languages?: string[]\n    ): string | undefined {\n        let name;\n        if (useAbbreviation) {\n            const abbreviation = env.lookup(`name:short`);\n            if (typeof abbreviation === \"string\" && abbreviation.length > 0) {\n                return abbreviation;\n            }\n        }\n        if (useIsoCode) {\n            const isoCode = env.lookup(`iso_code`);\n            if (typeof isoCode === \"string\" && isoCode.length > 0) {\n                return isoCode;\n            }\n        }\n        if (languages !== undefined) {\n            for (const lang of languages) {\n                name = env.lookup(`name:${lang}`) || env.lookup(`name_${lang}`);\n                if (typeof name === \"string\" && name.length > 0) {\n                    return name;\n                }\n            }\n        }\n        name = env.lookup(\"name\");\n        if (typeof name === \"string\") {\n            return name;\n        }\n        return undefined;\n    }\n\n    /**\n     * Determine the text string of the map feature. It implements the special handling required\n     * to determine the text content of a feature from its tags, which are passed in as the `env`.\n     *\n     * @param feature Feature, including properties from the (OMV) feature.\n     * @param technique technique defining how text should be created from feature\n     * @param languages List of languages to use, for example: Specify \"en\" to use the tag \"name_en\"\n     *                  as the text of the string. Order reflects priority.\n     */\n    export function getFeatureText(\n        context: Env | AttrEvaluationContext,\n        technique: Technique,\n        languages?: string[]\n    ): string | undefined {\n        let useAbbreviation: boolean | undefined;\n        let useIsoCode: boolean | undefined;\n        const env = context instanceof Env ? context : context.env;\n        if (\n            isTextTechnique(technique) ||\n            isPoiTechnique(technique) ||\n            isLineMarkerTechnique(technique)\n        ) {\n            if (technique.text !== undefined) {\n                return evaluateTechniqueAttr(context, technique.text);\n            }\n            if (technique.label !== undefined) {\n                const name = env.lookup(technique.label);\n                return typeof name === \"string\" ? name : undefined;\n            }\n            useAbbreviation = technique.useAbbreviation;\n            useIsoCode = technique.useIsoCode;\n        }\n\n        return getFeatureName(env, useAbbreviation, useIsoCode, languages);\n    }\n}\n\n/**\n * Support class for [[ExtendedTileInfo]]. Assist in filling it with data.\n */\nexport class ExtendedTileInfoWriter {\n    /** Map to identify which techniques already have been added to the [[ExtendedTileInfo]]. */\n    private readonly techniqueIndexMap = new Map<number, number>();\n    /** Map to identify which strings already have been added to the [[ExtendedTileInfo]]. */\n    private readonly stringMap = new Map<string, number>();\n    /** Map to identify which `layer` names already have been added to the [[ExtendedTileInfo]]. */\n    private readonly layerMap = new Map<string, number>();\n    /** Map to identify which `class` names already have been added to the [[ExtendedTileInfo]]. */\n    private readonly classMap = new Map<string, number>();\n    /** Map to identify which `type` names already have been added to the [[ExtendedTileInfo]]. */\n    private readonly typeMap = new Map<string, number>();\n\n    /**\n     * Create an [[ExtendedTileInfoWriter]] for an [[ExtendedTileInfo]]. Assist in filling the\n     * [[ExtendedTileInfo]] with data.\n     *\n     * @param tileInfo [[ExtendedTileInfo]] to write data to.\n     * @param storeExtendedTags Pass `true` if feature data like `layer`, `class`or `type` should\n     *          be stored for every feature.\n     */\n    constructor(readonly tileInfo: ExtendedTileInfo, readonly storeExtendedTags: boolean) {}\n\n    /**\n     * Adds a [[Technique]] to the catalog of techniques. Individual techniques have a `_index` file\n     * which has been created in the [[StyleSetEvaluator]]. This index is required to identify a\n     * technique. The `Map` is used to map techniques to already added techniques, or store the\n     * technique as new, and add it to the map.\n     *\n     * @param technique The [[Technique]] to add.\n     */\n    addTechnique(technique: IndexedTechnique): number {\n        let infoTileTechniqueIndex = this.techniqueIndexMap.get(technique._index);\n        if (infoTileTechniqueIndex !== undefined) {\n            return infoTileTechniqueIndex;\n        }\n\n        const decodedTechnique = makeDecodedTechnique(technique);\n\n        infoTileTechniqueIndex = this.tileInfo.techniqueCatalog.length;\n        this.techniqueIndexMap.set(decodedTechnique._index, infoTileTechniqueIndex);\n        this.tileInfo.techniqueCatalog.push(decodedTechnique);\n\n        return infoTileTechniqueIndex;\n    }\n\n    /**\n     * Add a feature.\n     *\n     * @param featureGroup The feature group to add to.\n     * @param technique The technique to add.\n     * @param env The `env` which is a mix of original OMV feature tags and fields added by the\n     *      [[StyleSetEvaluator]]\n     * @param featureId The featureId, a number unique for many features (but not all).\n     * @param infoTileTechniqueIndex The previously computed index of the technique. Must have been\n     *      computed by `addTechnique(technique)`.\n     * @param isPolygonGroup `true`for polygons.\n     */\n    addFeature(\n        featureGroup: FeatureGroup,\n        env: MapEnv,\n        featureId: number | undefined,\n        featureText: string | undefined,\n        infoTileTechniqueIndex: number,\n        featureGroupType: FeatureGroupType\n    ) {\n        // compute name/label of feature\n        let stringIndex = -1;\n        if (featureText !== undefined && featureText.length > 0) {\n            stringIndex = this.addText(featureText);\n        }\n\n        // add indices into the arrays.\n        featureGroup.featureIds[featureGroup.numFeatures] = featureId;\n        featureGroup.techniqueIndex[featureGroup.numFeatures] = infoTileTechniqueIndex;\n        featureGroup.textIndex[featureGroup.numFeatures] = stringIndex;\n        featureGroup.positionIndex[featureGroup.numFeatures] = featureGroup.numPositions;\n\n        switch (featureGroupType) {\n            case FeatureGroupType.Polygon:\n                // polygons need the extra fields for polygon rings\n                const polygonGroup = featureGroup as PolygonFeatureGroup;\n                assert(polygonGroup.outerRingStartIndex !== undefined);\n                assert(polygonGroup.innerRingStartIndex !== undefined);\n                assert(polygonGroup.innerRingIsOuterContour !== undefined);\n                polygonGroup.outerRingStartIndex[featureGroup.numFeatures] =\n                    polygonGroup.groupNumRings;\n                break;\n            case FeatureGroupType.Line:\n                (featureGroup as LineFeatureGroup).userData[featureGroup.numFeatures] = env.entries;\n                break;\n        }\n\n        // store the extra feature fields\n        if (this.storeExtendedTags) {\n            featureGroup.layerIndex![featureGroup.numFeatures] = this.addLayer(\n                env.lookup(\"$layer\")\n            );\n            featureGroup.classIndex![featureGroup.numFeatures] = this.addClass(env.lookup(\"class\"));\n            featureGroup.typeIndex![featureGroup.numFeatures] = this.addType(env.lookup(\"type\"));\n        }\n\n        featureGroup.numFeatures++;\n    }\n\n    /**\n     * Add the X/Y coordinate of the point. Only for point feature groups.\n     *\n     * @param featureGroup The feature group to add it to.\n     * @param x X Position of point.\n     * @param y Y Position of point.\n     */\n    addFeaturePoint(featureGroup: FeatureGroup, x: number, y: number) {\n        featureGroup.positions[featureGroup.numPositions++] = x;\n        featureGroup.positions[featureGroup.numPositions++] = y;\n    }\n\n    /**\n     * Add the line points as X/Y coordinates to the line feature.\n     *\n     * If a line feature has more than one line (rare for HERE data), it should define multiple\n     * line features for it.\n     *\n     * @param featureGroup The feature group to add to. Must be line feature group.\n     * @param points The X/Y coordinates of the points.\n     */\n    addFeaturePoints(featureGroup: FeatureGroup, points: number[]) {\n        const n = featureGroup.numPositions;\n        const l = points.length;\n        const p = featureGroup.positions;\n        for (let i = 0; i < l; i++) {\n            p[n + i] = points[i];\n        }\n        featureGroup.numPositions += points.length;\n    }\n\n    /**\n     * Add the information about road segments to the line feature. Performs lazy initialization of\n     * `segmentIds`, `segmentStartOffsets`, and `segmentEndOffsets` members of a\n     * [[LineFeatureGroup]] instance.\n     *\n     * @param featureGroup The line feature group to add information to.\n     * @param segmentId Segment id of a feature.\n     * @param startOffset Start offset of a feature.\n     * @param endOffset End offset of a feature.\n     */\n    addRoadSegments(\n        featureGroup: LineFeatureGroup,\n        segmentId: number,\n        startOffset: number,\n        endOffset: number\n    ) {\n        if (featureGroup.segmentIds === undefined) {\n            featureGroup.segmentIds = new Array<number>();\n            featureGroup.segmentStartOffsets = new Array<number>();\n            featureGroup.segmentEndOffsets = new Array<number>();\n        }\n\n        featureGroup.segmentIds[featureGroup.numFeatures - 1] = segmentId;\n        featureGroup.segmentStartOffsets![featureGroup.numFeatures - 1] = startOffset;\n        featureGroup.segmentEndOffsets![featureGroup.numFeatures - 1] = endOffset;\n    }\n\n    /**\n     * Add a single ring to the polygon. Can be called multiple times to add multiple rings to the\n     * polygon.\n     *\n     * @param featureGroup Polygon feature group to add polygon ring to.\n     * @param contour The X/Y coordinates of the ring.\n     * @param isOuterRing Pass `true`if it is a outer ring, otherwise `false`.\n     */\n    addRingPoints(featureGroup: PolygonFeatureGroup, contour: number[], isOuterRing: boolean) {\n        featureGroup.innerRingStartIndex[featureGroup.groupNumRings] = featureGroup.numPositions;\n        featureGroup.innerRingIsOuterContour[featureGroup.groupNumRings] = isOuterRing ? 1 : 0;\n        featureGroup.groupNumRings++;\n\n        const n = featureGroup.numPositions;\n        const l = contour.length;\n        const p = featureGroup.positions;\n        for (let i = 0; i < l; i++) {\n            p[n + i] = contour[i];\n        }\n        featureGroup.numPositions += contour.length;\n    }\n\n    /**\n     * Finalize the tile info's feature group.\n     */\n    finish(): any {\n        ExtendedTileInfo.finish(this.tileInfo);\n    }\n\n    private addText(name: Value | undefined): number {\n        return this.addStringValue(name, this.tileInfo.textCatalog, this.stringMap);\n    }\n\n    private addLayer(name: Value | undefined): number {\n        return this.addStringValue(name, this.tileInfo.layerCatalog!, this.layerMap);\n    }\n\n    private addClass(name: Value | undefined): number {\n        return this.addStringValue(name, this.tileInfo.classCatalog!, this.classMap);\n    }\n\n    private addType(name: Value | undefined): number {\n        return this.addStringValue(name, this.tileInfo.typeCatalog!, this.typeMap);\n    }\n\n    // Add a string to the strings catalog. Returns index into the catalog.\n    private addStringValue(\n        str: Value | undefined,\n        catalog: string[],\n        map: Map<string, number>\n    ): number {\n        if (str === undefined || str === null) {\n            return -1;\n        }\n        const name = str.toString();\n        let i = map.get(name);\n        if (i !== undefined) {\n            return i;\n        }\n        i = catalog.length;\n        catalog.push(name);\n        map.set(name, i);\n        return i;\n    }\n}\n\n/**\n * Support for [[ExtendedTileInfo]]. Defines the accessor that allows to access the polygon data.\n */\nexport interface ExtendedTileInfoPolygonAccessor {\n    /**\n     * Number of rings in the polygon.\n     */\n    numRings: number;\n\n    /**\n     * Return if ring is an outer ring.\n     *\n     * @param ringIndex Specify ring index.\n     * @return `true` if ring is an outer ring, `false` otherwise.\n     */\n    isOuterRing(ringIndex: number): boolean;\n\n    /**\n     * Return information about the vertices that make up the ring.\n     *\n     * @param ringIndex Specify ring index.\n     * @returns Info about the array, start and number of points in the ring.\n     */\n    getPoints(\n        ringIndex: number\n    ): {\n        points: ArrayLike<number>;\n        pointsStart: number;\n        numPointValues: number;\n    };\n}\n\n/**\n * Implementation of [[ExtendedTileInfoPolygonAccessor]].\n */\nclass ExtendedTileInfoPolygonAccessorImpl implements ExtendedTileInfoPolygonAccessor {\n    /**\n     * Accessed data for polygons feature group.\n     */\n    polygons?: PolygonFeatureGroup;\n    /**\n     * Feature's index in the group.\n     */\n    featureIndex: number = 0;\n    /**\n     * Indicates where the ring starts.\n     */\n    ringStart: number = 0;\n    /**\n     * Number of rings.\n     */\n    numRings: number = 0;\n\n    /**\n     * Setup the accessor for extended [[TileInfo]].\n     *\n     * @param polygons polygons feature group.\n     * @param featureIndex feature's index in the group.\n     * @param ringStart where the ring starts.\n     * @param numRings number of rings.\n     */\n    setup(\n        polygons: PolygonFeatureGroup,\n        featureIndex: number,\n        ringStart: number,\n        numRings: number\n    ) {\n        this.polygons = polygons;\n        this.featureIndex = featureIndex;\n        this.ringStart = ringStart;\n        this.numRings = numRings;\n    }\n\n    /**\n     * Shut down the accessor and free all references.\n     */\n    reset() {\n        this.polygons = undefined;\n        this.featureIndex = 0;\n        this.ringStart = 0;\n        this.numRings = 0;\n    }\n\n    isOuterRing(ringIndex: number): boolean {\n        assert(ringIndex >= 0);\n        assert(ringIndex < this.numRings);\n        assert(this.polygons !== undefined);\n        if (ringIndex < 0 || ringIndex >= this.numRings || this.polygons === undefined) {\n            throw new Error(\"ExtendedTileInfoPolygonAccessor: Invalid ring index\");\n        }\n        return this.polygons.innerRingIsOuterContour[this.ringStart + ringIndex] !== 0;\n    }\n\n    getPoints(\n        ringIndex: number\n    ): {\n        points: ArrayLike<number>;\n        pointsStart: number;\n        numPointValues: number;\n    } {\n        assert(ringIndex >= 0);\n        assert(ringIndex < this.numRings);\n        assert(this.polygons !== undefined);\n        if (ringIndex < 0 || ringIndex >= this.numRings || this.polygons === undefined) {\n            throw new Error(\"ExtendedTileInfoPolygonAccessor: Invalid ring index\");\n        }\n\n        // compute the start/size of the points in this ring. All `points` are actually just the\n        // indices of a single X/Y coordinate.\n        const pointsStart = this.polygons.innerRingStartIndex[this.ringStart + ringIndex];\n\n        let numPointValues: number;\n        if (ringIndex < this.numRings - 1) {\n            numPointValues =\n                this.polygons.innerRingStartIndex[this.ringStart + ringIndex + 1] - pointsStart;\n        } else {\n            if (this.ringStart + ringIndex < this.polygons.innerRingStartIndex.length - 1) {\n                numPointValues =\n                    this.polygons.innerRingStartIndex[this.ringStart + ringIndex + 1] - pointsStart;\n            } else {\n                numPointValues = this.polygons.positions.length - pointsStart;\n            }\n        }\n\n        return {\n            points: this.polygons.positions,\n            pointsStart,\n            numPointValues\n        };\n    }\n}\n\n/**\n * Interface that a client of [[ExtendedTileInfoAccessor]] has to implement.\n */\nexport interface ExtendedTileInfoHandler {\n    acceptPoint?(\n        featureId: number | undefined,\n        techniqueIndex: number,\n        x: number,\n        y: number,\n        label: number,\n        layerName: number,\n        className: number,\n        typeName: number\n    ): void;\n\n    acceptLine?(\n        featureId: number | undefined,\n        techniqueIndex: number,\n        label: number,\n        layerName: number,\n        className: number,\n        typeName: number,\n        points: ArrayLike<number>,\n        pointsStart: number,\n        numElements: number,\n        segmentId?: number,\n        startOffset?: number,\n        endOffset?: number\n    ): void;\n\n    acceptPolygon?(\n        featureId: number | undefined,\n        techniqueIndex: number,\n        label: number,\n        layerName: number,\n        className: number,\n        typeName: number,\n        polygonAccessor: ExtendedTileInfoPolygonAccessor\n    ): void;\n}\n\n/**\n * Supporting class for [[ExtendedTileInfo]]. Takes an [[ExtendedTileInfoHandler]] and calls an\n * `accept` for every feature of the [[ExtendedTileInfo]], or just all features of a specified\n * `featureId`.\n */\nexport class ExtendedTileInfoVisitor {\n    // static instance to work without allocations.\n    private static polygonAccessor = new ExtendedTileInfoPolygonAccessorImpl();\n\n    constructor(readonly tileInfo: ExtendedTileInfo) {}\n\n    /**\n     * Visit all feature in the [[ExtendedTileInfo]]\n     *\n     * @param handler Let the `handler` visit all features.\n     */\n    visitAll(handler: ExtendedTileInfoHandler) {\n        this.visitAllPointFeatures(handler);\n        this.visitAllLineFeatures(handler);\n        this.visitAllPolygonFeatures(handler);\n    }\n\n    /**\n     * Visit all features of a specified featureId.\n     *\n     * @param featureId The featureId to visit.\n     * @param handler The `handler` to use.\n     */\n    visitFeature(featureId: number, handler: ExtendedTileInfoHandler): number {\n        let numFeaturesFound = 0;\n        const numPointFeatures = this.tileInfo.pointGroup.numFeatures;\n        const pointFeatures = this.tileInfo.pointGroup.featureIds;\n        for (let i = 0; i < numPointFeatures; i++) {\n            if (pointFeatures[i] === featureId) {\n                numFeaturesFound++;\n                this.visitPointFeature(i, handler);\n            }\n        }\n        const numLineFeatures = this.tileInfo.lineGroup.numFeatures;\n        const lineFeatures = this.tileInfo.lineGroup.featureIds;\n        for (let i = 0; i < numLineFeatures; i++) {\n            if (lineFeatures[i] === featureId) {\n                numFeaturesFound++;\n                this.visitLineFeature(i, handler);\n            }\n        }\n        const numPolygonFeatures = this.tileInfo.polygonGroup.numFeatures;\n        const polygonsFeatures = this.tileInfo.polygonGroup.featureIds;\n        for (let i = 0; i < numPolygonFeatures; i++) {\n            if (polygonsFeatures[i] === featureId) {\n                numFeaturesFound++;\n                this.visitPolygonFeature(i, handler);\n            }\n        }\n        return numFeaturesFound;\n    }\n\n    /**\n     * Visit all `POINT` features.\n     *\n     * @param handler The `handler` to use.\n     */\n    visitAllPointFeatures(handler: ExtendedTileInfoHandler): void {\n        const numFeatures = this.tileInfo.pointGroup.numFeatures;\n\n        for (let i = 0; i < numFeatures; i++) {\n            this.visitPointFeature(i, handler);\n        }\n    }\n\n    /**\n     * Visit all `LINESTRING` features.\n     *\n     * @param handler The handler to use.\n     */\n    visitAllLineFeatures(handler: ExtendedTileInfoHandler): void {\n        const numFeatures = this.tileInfo.lineGroup.numFeatures;\n\n        for (let i = 0; i < numFeatures; i++) {\n            this.visitLineFeature(i, handler);\n        }\n    }\n\n    /**\n     * Visit all `POLYGON` features.\n     *\n     * @param handler The `handler` to use.\n     */\n    visitAllPolygonFeatures(handler: ExtendedTileInfoHandler): void {\n        const numFeatures = this.tileInfo.polygonGroup.numFeatures;\n\n        for (let i = 0; i < numFeatures; i++) {\n            this.visitPolygonFeature(i, handler);\n        }\n    }\n\n    private getTag(featureIndex: number, index: number[]): number {\n        return index !== undefined && index[featureIndex] >= 0 ? index[featureIndex] : -1;\n    }\n\n    /**\n     * Call the `handler` on a point feature.\n     *\n     * @param featureIndex The index of the feature into the feature table.\n     * @param handler The `handler` to use.\n     */\n    private visitPointFeature(featureIndex: number, handler: ExtendedTileInfoHandler): void {\n        const tileInfo = this.tileInfo;\n        const points = tileInfo.pointGroup;\n\n        const start = points.positionIndex[featureIndex];\n        const x = points.positions[start];\n        const y = points.positions[start + 1];\n\n        if (!!handler.acceptPoint) {\n            handler.acceptPoint(\n                points.featureIds[featureIndex],\n                points.techniqueIndex[featureIndex],\n                x,\n                y,\n                points.textIndex[featureIndex],\n                this.getTag(featureIndex, points.layerIndex!),\n                this.getTag(featureIndex, points.classIndex!),\n                this.getTag(featureIndex, points.typeIndex!)\n            );\n        }\n    }\n\n    /**\n     * Call the `handler` on a line feature.\n     *\n     * @param featureIndex The index of the feature into the feature table.\n     * @param handler The `handler` to use.\n     */\n    private visitLineFeature(featureIndex: number, handler: ExtendedTileInfoHandler): void {\n        const tileInfo = this.tileInfo;\n        const lines = tileInfo.lineGroup;\n\n        const numFeatures = lines.numFeatures;\n        const positionsStart = lines.positionIndex[featureIndex];\n        const numPointValues =\n            featureIndex === numFeatures - 1\n                ? lines.positions.length - positionsStart\n                : lines.positionIndex[featureIndex + 1] - positionsStart;\n\n        let segmentId: number | undefined;\n        let startOffset: number | undefined;\n        let endOffset: number | undefined;\n\n        if (lines.segmentIds !== undefined) {\n            segmentId = lines.segmentIds[featureIndex];\n            startOffset = lines.segmentStartOffsets![featureIndex];\n            endOffset = lines.segmentEndOffsets![featureIndex];\n        }\n\n        if (!!handler.acceptLine) {\n            handler.acceptLine(\n                lines.featureIds[featureIndex],\n                lines.techniqueIndex[featureIndex],\n                lines.textIndex[featureIndex],\n                this.getTag(featureIndex, lines.layerIndex!),\n                this.getTag(featureIndex, lines.classIndex!),\n                this.getTag(featureIndex, lines.typeIndex!),\n                tileInfo.lineGroup.positions,\n                positionsStart,\n                numPointValues,\n                segmentId,\n                startOffset,\n                endOffset\n            );\n        }\n    }\n\n    /**\n     * Call the `handler` on a polygon feature.\n     *\n     * @param featureIndex The index of the feature into the feature table.\n     * @param handler The `handler` to use.\n     */\n    private visitPolygonFeature(featureIndex: number, handler: ExtendedTileInfoHandler): void {\n        if (handler.acceptPolygon === undefined) {\n            return;\n        }\n\n        const tileInfo = this.tileInfo;\n        const polygons = tileInfo.polygonGroup;\n\n        const numFeatures = polygons.numFeatures;\n        const ringStart = polygons.outerRingStartIndex[featureIndex];\n        const numRings =\n            featureIndex === numFeatures - 1\n                ? polygons.innerRingStartIndex.length - ringStart\n                : polygons.outerRingStartIndex[featureIndex + 1] - ringStart;\n\n        // Use a static instance, so we do not allocate anything here\n        ExtendedTileInfoVisitor.polygonAccessor.setup(polygons, featureIndex, ringStart, numRings);\n\n        handler.acceptPolygon(\n            polygons.featureIds[featureIndex],\n            polygons.techniqueIndex[featureIndex],\n            polygons.textIndex[featureIndex],\n            this.getTag(featureIndex, polygons.layerIndex!),\n            this.getTag(featureIndex, polygons.classIndex!),\n            this.getTag(featureIndex, polygons.typeIndex!),\n            ExtendedTileInfoVisitor.polygonAccessor\n        );\n\n        // Free all data references.\n        ExtendedTileInfoVisitor.polygonAccessor.reset();\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    BooleanLiteralExpr,\n    CallExpr,\n    CaseExpr,\n    ContainsExpr,\n    Expr,\n    ExprVisitor,\n    HasAttributeExpr,\n    MatchExpr,\n    NullLiteralExpr,\n    NumberLiteralExpr,\n    ObjectLiteralExpr,\n    StringLiteralExpr,\n    VarExpr\n} from \"./Expr\";\n\n/**\n * [[ExprPool]] maintains a set of unique interned [[Expr]] objects.\n *\n * @hidden\n */\nexport class ExprPool implements ExprVisitor<Expr, void> {\n    private readonly m_booleanLiterals = new Map<boolean, BooleanLiteralExpr>();\n    private readonly m_numberLiterals = new Map<number, NumberLiteralExpr>();\n    private readonly m_stringLiterals = new Map<string, StringLiteralExpr>();\n    private readonly m_objectLiterals = new Map<object, ObjectLiteralExpr>();\n    private readonly m_varExprs = new Map<string, VarExpr>();\n    private readonly m_hasAttributeExprs = new Map<string, HasAttributeExpr>();\n    private readonly m_inExprs = new Map<Expr, ContainsExpr[]>();\n    private readonly m_callExprs = new Map<string, CallExpr[]>();\n\n    /**\n     * Add `expr` to this [[ExprPool]] and return a unique [[Expr]]\n     * object that is structurally equivalent to `expr`.\n     *\n     * @param expr The [[Expr]] to add to this [[ExprPool]].\n     * @returns A unique [[Expr]] that is structurally equivalent to `expr`.\n     */\n    add(expr: Expr): Expr {\n        return expr.accept(this, undefined);\n    }\n\n    visitNullLiteralExpr(expr: NullLiteralExpr, context: void): Expr {\n        return NullLiteralExpr.instance;\n    }\n\n    visitBooleanLiteralExpr(expr: BooleanLiteralExpr, context: void): Expr {\n        const e = this.m_booleanLiterals.get(expr.value);\n        if (e) {\n            return e;\n        }\n        this.m_booleanLiterals.set(expr.value, expr);\n        return expr;\n    }\n\n    visitNumberLiteralExpr(expr: NumberLiteralExpr, context: void): Expr {\n        const e = this.m_numberLiterals.get(expr.value);\n        if (e) {\n            return e;\n        }\n        this.m_numberLiterals.set(expr.value, expr);\n        return expr;\n    }\n\n    visitStringLiteralExpr(expr: StringLiteralExpr, context: void): Expr {\n        const e = this.m_stringLiterals.get(expr.value);\n        if (e) {\n            return e;\n        }\n        this.m_stringLiterals.set(expr.value, expr);\n        return expr;\n    }\n\n    visitObjectLiteralExpr(expr: ObjectLiteralExpr, context: void): Expr {\n        const e = this.m_objectLiterals.get(expr.value);\n        if (e) {\n            return e;\n        }\n        this.m_objectLiterals.set(expr.value, expr);\n        return expr;\n    }\n\n    visitVarExpr(expr: VarExpr, context: void): Expr {\n        const e = this.m_varExprs.get(expr.name);\n        if (e) {\n            return e;\n        }\n        this.m_varExprs.set(expr.name, expr);\n        return expr;\n    }\n\n    visitHasAttributeExpr(expr: HasAttributeExpr, context: void): Expr {\n        const e = this.m_hasAttributeExprs.get(expr.name);\n        if (e) {\n            return e;\n        }\n        this.m_hasAttributeExprs.set(expr.name, expr);\n        return expr;\n    }\n\n    visitContainsExpr(expr: ContainsExpr, context: void): Expr {\n        const value = expr.value.accept(this, context);\n        if (!this.m_inExprs.has(value)) {\n            this.m_inExprs.set(value, []);\n        }\n        const inExprs = this.m_inExprs.get(value)!;\n        for (const inExpr of inExprs) {\n            if (inExpr.elements.length !== expr.elements.length) {\n                continue;\n            }\n            // find the index of the first element in the cached 'in' expr\n            // that is not contained in 'expr.elements'.\n            const i = inExpr.elements.findIndex(x => !expr.elements.includes(x));\n            if (i === -1) {\n                return inExpr;\n            }\n        }\n        const e = new ContainsExpr(value, expr.elements);\n        this.m_inExprs.set(value, [e]);\n        return e;\n    }\n\n    visitMatchExpr(expr: MatchExpr, context: void): Expr {\n        const value = expr.value.accept(this, context);\n        const branches: typeof expr.branches = expr.branches.map(([label, body]) => [\n            label,\n            body.accept(this, context)\n        ]);\n        const fallback = expr.fallback.accept(this, context);\n        return new MatchExpr(value, branches, fallback);\n    }\n\n    visitCaseExpr(expr: CaseExpr, context: void): Expr {\n        const branches: typeof expr.branches = expr.branches.map(([condition, body]) => [\n            condition.accept(this, context),\n            body.accept(this, context)\n        ]);\n        const fallback = expr.fallback.accept(this, context);\n        return new CaseExpr(branches, fallback);\n    }\n\n    visitCallExpr(expr: CallExpr, context: void): Expr {\n        // rewrite the actual arguments\n        const expressions = expr.args.map(childExpr => childExpr.accept(this, context));\n        // ensure we have a valid set of interned expressions for the calls\n        if (!this.m_callExprs.has(expr.op)) {\n            this.m_callExprs.set(expr.op, []);\n        }\n        // get the calls for the given operator.\n        const calls = this.m_callExprs.get(expr.op)!;\n        for (const call of calls) {\n            // check the number of arguments\n            if (call.args.length !== expressions.length) {\n                continue;\n            }\n            // find the index of the first mismatch.\n            let index = 0;\n            for (; index < call.args.length; ++index) {\n                if (call.args[index] !== expressions[index]) {\n                    break;\n                }\n            }\n            if (index === call.args.length) {\n                // no mismatch found, return the 'interned' call.\n                return call;\n            }\n        }\n        const e = new CallExpr(expr.op, expressions);\n        calls.push(e);\n        return e;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { LoggerManager } from \"@here/harp-utils\";\nimport { Env, Expr, ExprScope, MapEnv, Value } from \"./Expr\";\nimport { getPropertyValue, isInterpolatedProperty } from \"./InterpolatedProperty\";\nimport { InterpolatedProperty } from \"./InterpolatedPropertyDefs\";\n\nconst logger = LoggerManager.instance.create(\"TechniqueAttr\");\n\nexport interface AttrEvaluationContext {\n    /**\n     * Expression evaluation environment containing variable bindings.\n     */\n    env: MapEnv;\n\n    /**\n     * Storage level of tile containing this feature.\n     *\n     * To be removed, when interpolators will be based on [[Expr]].\n     */\n    storageLevel: number;\n\n    /**\n     * Zoom level of tile containing this feature.\n     *\n     * To be removed, when interpolators will be based on [[Expr]].\n     */\n    zoomLevel: number;\n\n    /**\n     * Optional, cache of expression results.\n     *\n     * @see [[Expr.evaluate]]\n     */\n    cachedExprResults?: Map<Expr, Value>;\n}\n\n/**\n * Evaluate feature attr _without_ default value.\n *\n * @returns actual value or `undefined`\n */\nexport function evaluateTechniqueAttr<T = Value>(\n    context: Env | AttrEvaluationContext,\n    attrValue: T | Expr | InterpolatedProperty | undefined\n): T | undefined;\n\n/**\n * Evaluate feature attr _with_ default value.\n *\n * @returns actual value or `defaultValue`\n */\nexport function evaluateTechniqueAttr<T = Value>(\n    context: Env | AttrEvaluationContext,\n    attrValue: T | Expr | InterpolatedProperty | undefined,\n    defaultValue: T\n): T;\n\nexport function evaluateTechniqueAttr<T = Value>(\n    context: Env | AttrEvaluationContext,\n    attrValue: T | Expr | InterpolatedProperty | undefined,\n    defaultValue?: T\n): T | undefined {\n    const env = context instanceof Env ? context : context.env;\n\n    let evaluated: Value | undefined;\n    if (Expr.isExpr(attrValue)) {\n        try {\n            evaluated = attrValue.evaluate(\n                env,\n                ExprScope.Dynamic,\n                !(context instanceof Env) ? context.cachedExprResults : undefined\n            );\n        } catch (error) {\n            logger.error(`failed to evaluate expression '${JSON.stringify(attrValue)}': ${error}`);\n            evaluated = undefined;\n        }\n    } else if (isInterpolatedProperty(attrValue)) {\n        const storageLevel =\n            context instanceof Env ? (context.lookup(\"$zoom\") as number) : context.zoomLevel;\n        evaluated = getPropertyValue(attrValue, storageLevel) as any;\n    } else {\n        evaluated = (attrValue as unknown) as Value;\n    }\n    if (evaluated === undefined || evaluated === null) {\n        return defaultValue;\n    } else {\n        return (evaluated as unknown) as T;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { isJsonExpr } from \"./Expr\";\nimport { StyleDeclaration, Theme } from \"./Theme\";\n\n/**\n * The ThemeVisitor visits every style in the theme in a depth-first fashion.\n */\nexport class ThemeVisitor {\n    constructor(readonly theme: Theme) {}\n    /**\n     * Applies a function to every style in the theme.\n     *\n     * @param visitFunc Function to be called with `style` as an argument. Function should return\n     *                  `true` to cancel visitation.\n     * @returns `true` if function has finished prematurely.\n     */\n    visitStyles(visitFunc: (style: StyleDeclaration) => boolean): boolean {\n        const visit = (style: StyleDeclaration): boolean => {\n            if (isJsonExpr(style)) {\n                return false;\n            }\n            if (visitFunc(style)) {\n                return true;\n            }\n            return false;\n        };\n        if (this.theme.styles !== undefined) {\n            for (const styleSetName in this.theme.styles) {\n                if (this.theme.styles[styleSetName] !== undefined) {\n                    for (const style of this.theme.styles[styleSetName]) {\n                        if (visit(style)) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Theme } from \"@here/harp-datasource-protocol\";\nimport { TileKey, TilingScheme, webMercatorTilingScheme } from \"@here/harp-geoutils\";\nimport { DataSource } from \"./DataSource\";\nimport { TileGeometryCreator } from \"./geometry/TileGeometryCreator\";\nimport { Tile } from \"./Tile\";\n\n/**\n * Provides background geometry for all tiles.\n */\nexport class BackgroundDataSource extends DataSource {\n    private static readonly DEFAULT_TILING_SCHEME = webMercatorTilingScheme;\n    private m_tilingScheme: TilingScheme = BackgroundDataSource.DEFAULT_TILING_SCHEME;\n\n    constructor() {\n        super(\"background\");\n        this.cacheable = true;\n    }\n\n    updateStorageLevelOffset() {\n        let storageLevelOffset: number | undefined;\n\n        this.mapView.dataSources.forEach(ds => {\n            if (ds === this) {\n                return;\n            }\n            const tilingScheme = ds.getTilingScheme();\n            if (tilingScheme === this.m_tilingScheme) {\n                storageLevelOffset =\n                    storageLevelOffset === undefined\n                        ? ds.storageLevelOffset\n                        : Math.max(storageLevelOffset, ds.storageLevelOffset);\n            }\n        });\n\n        if (storageLevelOffset === undefined) {\n            storageLevelOffset = 0;\n        }\n\n        if (storageLevelOffset !== this.storageLevelOffset) {\n            this.storageLevelOffset = storageLevelOffset;\n            this.mapView.clearTileCache(this.name);\n        }\n    }\n\n    setTheme(theme: Theme, languages?: string[]) {\n        this.mapView.clearTileCache(this.name);\n    }\n\n    setTilingScheme(tilingScheme?: TilingScheme) {\n        const newScheme = tilingScheme || BackgroundDataSource.DEFAULT_TILING_SCHEME;\n        if (newScheme === this.m_tilingScheme) {\n            return;\n        }\n\n        this.m_tilingScheme = newScheme;\n        this.updateStorageLevelOffset();\n        this.mapView.clearTileCache(this.name);\n    }\n\n    getTilingScheme(): TilingScheme {\n        return this.m_tilingScheme;\n    }\n\n    getTile(tileKey: TileKey): Tile | undefined {\n        const tile = new Tile(this, tileKey);\n        tile.forceHasGeometry(true);\n        tile.removeDecodedTile(); // Skip geometry loading.\n        TileGeometryCreator.instance.addGroundPlane(tile, Number.MIN_SAFE_INTEGER);\n\n        return tile;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Projection, sphereProjection } from \"@here/harp-geoutils\";\nimport { Vector3 } from \"three\";\nimport { SubdivisionModifier } from \"./SubdivisionModifier\";\n\nconst VERTEX_POSITION_CACHE = [new Vector3(), new Vector3(), new Vector3()];\n\n/**\n * The [[SphericalGeometrySubdivisionModifier]] subdivides triangle mesh geometries positioned\n * on the surface of a sphere centered at `(0, 0, 0)`.\n */\nexport class SphericalGeometrySubdivisionModifier extends SubdivisionModifier {\n    /**\n     * Constructs a new [[SphericalGeometrySubdivisionModifier]].\n     *\n     * @param angle The maximum angle in radians between two vertices and the origin.\n     * @param projection The projection that defines the world space of this geometry.\n     */\n    constructor(readonly angle: number, readonly projection: Projection = sphereProjection) {\n        super();\n    }\n\n    protected shouldSplitTriangle(a: Vector3, b: Vector3, c: Vector3): number | undefined {\n        const aa = sphereProjection.reprojectPoint(this.projection, a, VERTEX_POSITION_CACHE[0]);\n        const bb = sphereProjection.reprojectPoint(this.projection, b, VERTEX_POSITION_CACHE[1]);\n        const cc = sphereProjection.reprojectPoint(this.projection, c, VERTEX_POSITION_CACHE[2]);\n\n        const alpha = aa.angleTo(bb);\n        const beta = bb.angleTo(cc);\n        const gamma = cc.angleTo(aa);\n\n        // find the maximum angle\n        const m = Math.max(alpha, Math.max(beta, gamma));\n\n        // split the triangle if needed.\n        if (m < this.angle) {\n            return undefined;\n        }\n\n        if (m === alpha) {\n            return 0;\n        } else if (m === beta) {\n            return 1;\n        } else if (m === gamma) {\n            return 2;\n        }\n\n        throw new Error(\"failed to split triangle\");\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { BufferAttribute, BufferGeometry, Vector3 } from \"three\";\n\nconst tmpVectorA = new Vector3();\nconst tmpVectorB = new Vector3();\nconst tmpVectorC = new Vector3();\n\n/**\n * The [[SubdivisionModifier]] subdivides triangle mesh geometries.\n */\nexport abstract class SubdivisionModifier {\n    /**\n     * Constructs a new [[SubdivisionModifier]].\n     */\n    constructor() {\n        // nothing to do\n    }\n\n    /**\n     * Subdivides the faces of the given [[THREE.BufferGeometry]].\n     *\n     * This method modifies (in-place) the vertices and the faces of the geometry.\n     * Please note that only the vertex position and their UV coordinates are subdivided.\n     * Normals, vertex colors and other attributes are left unmodified.\n     *\n     * @param geometry The [[THREE.BufferGeometry]] to subdivide.\n     */\n    modify(geometry: BufferGeometry): BufferGeometry {\n        const positionAttr = geometry.getAttribute(\"position\") as BufferAttribute;\n        const position = Array.from(positionAttr.array);\n\n        const uvAttr = geometry.getAttribute(\"uv\") as BufferAttribute;\n        const uv = uvAttr !== undefined ? Array.from(uvAttr.array) : undefined;\n\n        const edgeAttr = geometry.getAttribute(\"edge\") as BufferAttribute;\n        const edge = edgeAttr !== undefined ? Array.from(edgeAttr.array) : undefined;\n\n        const wallAttr = geometry.getAttribute(\"wall\") as BufferAttribute;\n        const wall = wallAttr !== undefined ? Array.from(wallAttr.array) : undefined;\n\n        const indexAttr = geometry.getIndex() as BufferAttribute;\n        const indices = Array.from(indexAttr.array);\n\n        // A cache containing the indices of the vertices added\n        // when subdiving the faces of the geometry.\n        const cache = new Map<string, number>();\n\n        /**\n         * Returns the index of the vertex positioned in the middle of the given vertices.\n         */\n        function middleVertex(i: number, j: number): number {\n            // Build a unique `key` for the pair of indices `(i, j)`.\n            const key = `${Math.min(i, j)}_${Math.max(i, j)}`;\n\n            const h = cache.get(key);\n\n            if (h !== undefined) {\n                // Nothing to do, a vertex in the middle of (i, j) was already created.\n                return h;\n            }\n\n            // The position of the new vertex.\n            tmpVectorA.set(position[i * 3], position[i * 3 + 1], position[i * 3 + 2]);\n            tmpVectorB.set(position[j * 3], position[j * 3 + 1], position[j * 3 + 2]);\n            tmpVectorC.lerpVectors(tmpVectorA, tmpVectorB, 0.5);\n\n            // The index of the new vertex.\n            const index = position.length / 3;\n            position.push(...tmpVectorC.toArray());\n            // Cache the position of the new vertex.\n            cache.set(key, index);\n\n            // The uvs of the new vertex.\n            if (uv !== undefined) {\n                tmpVectorA.set(uv[i * 2], uv[i * 2 + 1], 0);\n                tmpVectorB.set(uv[j * 2], uv[j * 2 + 1], 0);\n                tmpVectorC.lerpVectors(tmpVectorA, tmpVectorB, 0.5);\n                uv.push(tmpVectorC.x, tmpVectorC.y);\n            }\n\n            // The edge and wall attributes of the new vertex.\n            // If a new vertex has been introduced between i and j, connect the elements\n            // accordingly.\n            if (edge !== undefined) {\n                if (edge[i] === j) {\n                    edge.push(j);\n                    edge[i] = index;\n                } else if (edge[j] === i) {\n                    edge.push(i);\n                    edge[j] = index;\n                } else {\n                    edge.push(-1);\n                }\n            }\n            if (wall !== undefined) {\n                if (wall[i] === j) {\n                    wall.push(j);\n                    wall[i] = index;\n                } else if (wall[j] === i) {\n                    wall.push(i);\n                    wall[j] = index;\n                } else {\n                    wall.push(-1);\n                }\n            }\n\n            return index;\n        }\n\n        const newIndices = [];\n        while (indices.length >= 3) {\n            const v0 = indices.shift()!;\n            const v1 = indices.shift()!;\n            const v2 = indices.shift()!;\n\n            tmpVectorA.set(position[v0 * 3], position[v0 * 3 + 1], position[v0 * 3 + 2]);\n            tmpVectorB.set(position[v1 * 3], position[v1 * 3 + 1], position[v1 * 3 + 2]);\n            tmpVectorC.set(position[v2 * 3], position[v2 * 3 + 1], position[v2 * 3 + 2]);\n\n            const edgeToSplit = this.shouldSplitTriangle(tmpVectorA, tmpVectorB, tmpVectorC);\n\n            switch (edgeToSplit) {\n                case 0: {\n                    const v3 = middleVertex(v0, v1);\n                    indices.push(v0, v3, v2, v3, v1, v2);\n                    break;\n                }\n\n                case 1: {\n                    const v3 = middleVertex(v1, v2);\n                    indices.push(v0, v1, v3, v0, v3, v2);\n                    break;\n                }\n\n                case 2: {\n                    const v3 = middleVertex(v2, v0);\n                    indices.push(v0, v1, v3, v3, v1, v2);\n                    break;\n                }\n\n                case undefined: {\n                    newIndices.push(v0, v1, v2);\n                    break;\n                }\n\n                default:\n                    throw new Error(\"failed to subdivide the given geometry\");\n            }\n        }\n\n        positionAttr.array = new Float32Array(position);\n        positionAttr.count = position.length / positionAttr.itemSize;\n        positionAttr.needsUpdate = true;\n\n        geometry.setIndex(newIndices);\n\n        if (uv !== undefined) {\n            uvAttr.array = new Float32Array(uv);\n            uvAttr.count = uv.length / uvAttr.itemSize;\n            uvAttr.needsUpdate = true;\n        }\n\n        if (edge !== undefined) {\n            edgeAttr.array = new Float32Array(edge);\n            edgeAttr.count = edge.length / edgeAttr.itemSize;\n            edgeAttr.needsUpdate = true;\n        }\n\n        return geometry;\n    }\n\n    /**\n     * Returns if the given triangle should be subdivide.\n     *\n     * Implementations of this function should return the index of\n     * the edge of the triangle to split (0, 1, or 2) or undefined if\n     * the triangle doesn't need to be subdivided.\n     *\n     * @param a The position of the first vertex of the triangle.\n     * @param b The position of the second vertex of the triangle.\n     * @param c The position of the third vertex of the triangle.\n     */\n    protected abstract shouldSplitTriangle(a: Vector3, b: Vector3, c: Vector3): number | undefined;\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { MemoryUsage } from \"../TextCanvas\";\nimport { GlyphData } from \"./GlyphData\";\nimport { GlyphTextureCache } from \"./GlyphTextureCache\";\nimport { FontStyle, FontVariant, TextRenderStyle } from \"./TextStyle\";\n\nconst ASSETS_PATH = \"_Assets/\";\nconst BOLD_ASSETS_PATH = \"_BoldAssets/\";\nconst ITALIC_ASSETS_PATH = \"_ItalicAssets/\";\nconst BOLD_ITALIC_ASSETS_PATH = \"_BoldItalicAssets/\";\nconst REPLACEMENT_PATH = \"_Assets/Extra/\";\n\ninterface SrcGlyphData {\n    id: number;\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    xoffset: number;\n    yoffset: number;\n    xadvance: number;\n    page: number;\n    chnl: number;\n}\n\n/**\n * Metrics defining the placement and rendering of all glyphs in a given [[Font]].\n */\nexport interface FontMetrics {\n    size: number;\n    distanceRange: number;\n    base: number;\n    lineHeight: number;\n    lineGap: number;\n    capHeight: number;\n    xHeight: number;\n}\n\n/**\n * Description of all assets, charset and metrics that define a font inside a [[FontCatalog]].\n */\nexport interface Font {\n    name: string;\n    metrics: FontMetrics;\n    charset: string;\n    bold?: string;\n    italic?: string;\n    boldItalic?: string;\n}\n\n/**\n * Description of a continuous range of Unicode code points (as well as information on which fonts\n * supports it).\n */\nexport interface UnicodeBlock {\n    name: string;\n    min: number;\n    max: number;\n    fonts: string[];\n}\n\n/**\n * Collection of font assets used to render glyphs when using a [[TextCanvas]].\n *\n * @summary A `FontCatalog` works as a stack of SDF bitmap fonts (using the BMFont format) designed\n * to cover the widest Unicode code point range possible. In order to manage all these assets\n * elegantly, the assets inside the `FontCatalog` are stored on a per-Unicode-Block basis, and\n * assets for a block are only loaded once a glyph belonging to that block is requested.\n *\n * Bitmap information coming from all different fonts is then stored in a unified WebGL GPU Texture\n * resource, which can be sampled to render all currently loaded glyphs.\n *\n */\nexport class FontCatalog {\n    /**\n     * Loads a `FontCatalog`.\n     *\n     * @param url Asset url.\n     * @param maxCodePointCount Maximum number of unique code points bitmaps this `FontCatalog`'s\n     * internal texture can store simultaneously.\n     *\n     * @returns `FontCatalog` Promise.\n     */\n    static async load(path: string, maxCodePointCount: number): Promise<FontCatalog> {\n        const url = new URL(path, window.location.href);\n        const fontCatalog = await FontCatalog.loadJSON(url.href);\n\n        const replacementDirUrl = new URL(`${fontCatalog.name}${REPLACEMENT_PATH}`, url);\n        const replacementJson = await FontCatalog.loadJSON(\n            replacementDirUrl.href + \"Specials.json\"\n        );\n        const replacementTexture = await FontCatalog.loadTexture(\n            replacementDirUrl.href + \"Specials.png\"\n        );\n        replacementTexture.wrapS = THREE.ClampToEdgeWrapping;\n        replacementTexture.wrapT = THREE.ClampToEdgeWrapping;\n        replacementTexture.minFilter = THREE.NearestFilter;\n        replacementTexture.needsUpdate = true;\n\n        const replacementFont = fontCatalog.fonts.find((font: Font) => font.name === \"Extra\");\n        const replacementGlyph = new GlyphData(\n            65533,\n            \"Specials\",\n            replacementJson.chars[0].width,\n            replacementJson.chars[0].height,\n            replacementJson.chars[0].xadvance,\n            replacementJson.chars[0].xoffset,\n            replacementJson.chars[0].yoffset,\n            0.0,\n            0.0,\n            1.0,\n            1.0,\n            replacementTexture,\n            replacementFont!\n        );\n\n        const fontCatalogInfo = new FontCatalog(\n            url.href.substr(0, url.href.lastIndexOf(\"/\")),\n            fontCatalog.name,\n            fontCatalog.type,\n            fontCatalog.size,\n            fontCatalog.maxWidth,\n            fontCatalog.maxHeight,\n            fontCatalog.distanceRange,\n            fontCatalog.fonts,\n            fontCatalog.supportedBlocks,\n            maxCodePointCount,\n            replacementGlyph\n        );\n        return fontCatalogInfo;\n    }\n\n    static async loadTexture(url: string): Promise<THREE.Texture> {\n        return new Promise(resolve => {\n            new THREE.TextureLoader().load(url, resolve);\n        }) as Promise<THREE.Texture>;\n    }\n\n    static async loadJSON(url: string): Promise<any> {\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(`${url} Status Text:  ${response.statusText}`);\n        }\n        const rawJSON = await response.text();\n        return JSON.parse(rawJSON);\n    }\n\n    private m_glyphTextureCache: GlyphTextureCache;\n\n    private m_loadingJson: Map<string, Promise<any>>;\n    private m_loadingPages: Map<string, Promise<THREE.Texture>>;\n    private m_loadingGlyphs: Map<string, Promise<GlyphData>>;\n    private m_loadedJson: Map<string, any>;\n    private m_loadedPages: Map<string, THREE.Texture>;\n    private m_loadedGlyphs: Map<string, Map<number, GlyphData>>;\n\n    /**\n     * @hidden\n     * Creates a new FontCatalog.\n     *\n     * @param url FontCatalog's URL.\n     * @param name FontCatalog's name.\n     * @param type FontCatalog's type (sdf or msdf).\n     * @param size FontCatalog's glyph size (pixels).\n     * @param maxWidth FontCatalog's maximum glyph width (pixels).\n     * @param maxHeight FontCatalog's maximum glyph height (pixels).\n     * @param distanceRange Distance range used to generate the SDF bitmaps.\n     * @param fonts Array of supported fonts.\n     * @param unicodeBlocks Array of supported Unicode blocks.\n     * @param maxCodePointCount Maximum number of unique code points bitmaps this `FontCatalog`'s\n     * internal texture can store simultaneously.\n     * @param m_replacementGlyph [[GlyphData]] to be used whenever a Unicode code point is not\n     * supported by this `FontCatalog`.\n     *\n     * @returns New FontCatalog.\n     */\n    private constructor(\n        readonly url: string,\n        readonly name: string,\n        readonly type: string,\n        readonly size: number,\n        readonly maxWidth: number,\n        readonly maxHeight: number,\n        readonly distanceRange: number,\n        readonly fonts: Font[],\n        readonly unicodeBlocks: UnicodeBlock[],\n        readonly maxCodePointCount: number,\n        private m_replacementGlyph: GlyphData\n    ) {\n        this.m_glyphTextureCache = new GlyphTextureCache(\n            maxCodePointCount,\n            this.maxWidth + 1,\n            this.maxHeight + 1\n        );\n\n        this.m_loadingJson = new Map<string, Promise<any>>();\n        this.m_loadingPages = new Map<string, Promise<THREE.Texture>>();\n        this.m_loadingGlyphs = new Map<string, Promise<GlyphData>>();\n        this.m_loadedJson = new Map<string, any>();\n        this.m_loadedPages = new Map<string, THREE.Texture>();\n        this.m_loadedGlyphs = new Map<string, Map<number, GlyphData>>();\n    }\n\n    /**\n     * Release all allocated resources.\n     */\n    dispose() {\n        this.fonts.length = 0;\n        this.unicodeBlocks.length = 0;\n        this.m_glyphTextureCache.dispose();\n        this.m_loadingJson.clear();\n        this.m_loadingPages.clear();\n        this.m_loadingGlyphs.clear();\n        this.m_loadedJson.clear();\n        this.m_loadedPages.clear();\n        this.m_loadedGlyphs.clear();\n    }\n\n    /**\n     * Removes all loaded (and loading) assets.\n     */\n    clear() {\n        this.m_glyphTextureCache.clear();\n        this.m_loadingJson.clear();\n        this.m_loadingPages.clear();\n        this.m_loadingGlyphs.clear();\n        this.m_loadedJson.clear();\n        this.m_loadedPages.clear();\n        this.m_loadedGlyphs.clear();\n    }\n\n    /**\n     * Updates the internal WebGLRenderTarget.\n     * The update will copy the newly introduced glyphs since the previous update.\n     *\n     * @param renderer WebGLRenderer.\n     */\n    update(renderer: THREE.WebGLRenderer): void {\n        this.m_glyphTextureCache.update(renderer);\n    }\n\n    /**\n     * Internal WebGL Texture.\n     */\n    get texture(): THREE.Texture {\n        return this.m_glyphTextureCache.texture;\n    }\n\n    /**\n     * Internal WebGL Texture size.\n     */\n    get textureSize(): THREE.Vector2 {\n        return this.m_glyphTextureCache.textureSize;\n    }\n\n    /**\n     * Current internal loading state.\n     */\n    get isLoading(): boolean {\n        return (\n            this.m_loadingJson.size > 0 ||\n            this.m_loadingPages.size > 0 ||\n            this.m_loadingGlyphs.size > 0\n        );\n    }\n\n    /**\n     * Loads the description file for a specific [[UnicodeBlock]]. This speeds up consequent calls\n     * to `FontCatalog`.loadCharset() that require glyphs from this block to be loaded.\n     *\n     * @param block Requested [[UnicodeBlock]].\n     * @param font [[Font]] to retrieve this Unicode block from.\n     * @param fontStyle [[FontStyle]] assets to load.\n     * @param loadPages If `true`, all pages in this Unicode block will also be loaded.\n     *\n     * @returns Loaded Unicode Block json.\n     */\n    async loadBlock(\n        block: UnicodeBlock,\n        font: Font,\n        fontStyle: FontStyle,\n        loadPages?: boolean\n    ): Promise<any> {\n        const assetsPath = this.getAssetsPath(fontStyle, font);\n        const jsonPath = `${assetsPath}/${block.name.replace(/ /g, \"_\")}.json`;\n        let json = this.m_loadedJson.get(jsonPath);\n        if (json === undefined) {\n            let jsonPromise = this.m_loadingJson.get(jsonPath);\n            if (jsonPromise === undefined) {\n                try {\n                    jsonPromise = FontCatalog.loadJSON(jsonPath);\n                    this.m_loadingJson.set(jsonPath, jsonPromise);\n                    json = await jsonPromise;\n                    this.m_loadingJson.delete(jsonPath);\n                    this.m_loadedJson.set(jsonPath, json);\n                } catch (e) {\n                    // tslint:disable-next-line:no-console\n                    console.error(e);\n                    this.m_loadingJson.delete(jsonPath);\n                }\n            } else {\n                json = await jsonPromise;\n            }\n        }\n\n        const pagePromises: Array<Promise<THREE.Texture>> = [];\n        if (loadPages === true) {\n            for (const page of json.pages) {\n                pagePromises.push(this.loadPage(`${assetsPath}/${page}`));\n            }\n        }\n        await Promise.all(pagePromises);\n\n        return json;\n    }\n\n    /**\n     * Releases the description file for a specific [[UnicodeBlock]] (and all downloaded pages).\n     * Safe to call when no assets for this block have been loaded.\n     *\n     * @param block Requested [[UnicodeBlock]].\n     * @param font [[Font]] to remove this Unicode block from.\n     * @param fontStyle [[FontStyle]] assets to remove.\n     */\n    removeBlock(block: UnicodeBlock, font: Font, fontStyle: FontStyle): void {\n        const assetsPath = this.getAssetsPath(fontStyle, font);\n        const jsonPath = `${assetsPath}/${block.name.replace(/ /g, \"_\")}.json`;\n        const json = this.m_loadedJson.get(jsonPath);\n        if (json !== undefined) {\n            for (const page of json.pages) {\n                const pagePath = `${assetsPath}/${page}`;\n                this.m_loadingPages.delete(pagePath);\n                this.m_loadedPages.delete(pagePath);\n            }\n            this.m_loadingJson.delete(jsonPath);\n            this.m_loadedJson.delete(jsonPath);\n        }\n    }\n\n    /**\n     * Loads all the required glyphs needed to render the input text. Character repetition will not\n     * be considered, and only styled assets (with applied font selection, style and variants) will\n     * be loaded.\n     *\n     * @param input Input text.\n     * @param style Specific [[TextRenderStyle]] for which glyphs will be loaded.\n     *\n     * @returns Promise containing an array of all loaded [[GlyphData]] for the input text.\n     */\n    async loadCharset(input: string, style: TextRenderStyle): Promise<GlyphData[]> {\n        const fontName = style.fontName;\n        const fontStyle = style.fontStyle;\n        const shouldTransform =\n            style.fontVariant === FontVariant.AllCaps ||\n            style.fontVariant === FontVariant.SmallCaps;\n\n        const charset = (shouldTransform ? input.toUpperCase() : input).replace(\n            /[\\s\\S](?=([\\s\\S]+))/g,\n            (c, s) => {\n                return s.indexOf(c) + 1 ? \"\" : c;\n            }\n        );\n        const glyphPromises: Array<Promise<GlyphData>> = [];\n        for (const char of charset) {\n            const codePoint = char.codePointAt(0)!;\n            const font = this.getFont(codePoint, fontName);\n            const fontHash = `${font.name}_${fontStyle}`;\n            const glyphHash = `${fontHash}_${codePoint}`;\n\n            let fontGlyphMap = this.m_loadedGlyphs.get(fontHash);\n            if (fontGlyphMap === undefined) {\n                fontGlyphMap = new Map();\n                this.m_loadedGlyphs.set(fontHash, fontGlyphMap);\n            }\n\n            const glyph = fontGlyphMap.get(codePoint);\n            if (glyph === undefined) {\n                let glyphPromise = this.m_loadingGlyphs.get(glyphHash);\n                if (glyphPromise === undefined) {\n                    if (font.charset.indexOf(String.fromCodePoint(codePoint)) === -1) {\n                        const replacementGlyph = this.createReplacementGlyph(codePoint, char, font);\n                        fontGlyphMap!.set(codePoint, replacementGlyph);\n                        this.m_glyphTextureCache.add(glyphHash, replacementGlyph);\n                        continue;\n                    }\n\n                    let charUnicodeBlock: UnicodeBlock | undefined;\n                    for (const block of this.unicodeBlocks) {\n                        if (codePoint >= block.min && codePoint <= block.max) {\n                            charUnicodeBlock = block;\n                            break;\n                        }\n                    }\n\n                    glyphPromise = this.loadAssets(codePoint, fontStyle, charUnicodeBlock!, font);\n                    this.m_loadingGlyphs.set(glyphHash, glyphPromise);\n                    glyphPromise.then((loadedGlyph: GlyphData) => {\n                        this.m_loadingGlyphs.delete(glyphHash);\n                        fontGlyphMap!.set(codePoint, loadedGlyph);\n                        this.m_glyphTextureCache.add(glyphHash, loadedGlyph);\n                    });\n                }\n                glyphPromises.push(glyphPromise);\n            } else if (!this.m_glyphTextureCache.has(glyphHash)) {\n                glyphPromises.push(Promise.resolve(glyph));\n                this.m_glyphTextureCache.add(glyphHash, glyph);\n            }\n        }\n\n        return Promise.all(glyphPromises);\n    }\n\n    /**\n     * Retrieves the loaded [[GlyphData]] for a specific character.\n     * Returns `undefined` if the assets for this glyph haven't been loaded yet.\n     *\n     * @param codePoint Character's Unicode code point.\n     * @param font [[Font]] to get this glyph from.\n     * @param fontStyle Specific [[FontStyle]] to get glyphs for.\n     *\n     * @returns [[GlyphData]] for this code point.\n     */\n    getGlyph(codePoint: number, font: Font, fontStyle: FontStyle): GlyphData | undefined {\n        const fontGlyphMap = this.m_loadedGlyphs.get(`${font.name}_${fontStyle}`);\n        if (fontGlyphMap === undefined) {\n            return undefined;\n        }\n        return fontGlyphMap.get(codePoint);\n    }\n\n    /**\n     * Retrieves the loaded [[GlyphData]] for the specified text.\n     * Returns `undefined` if the assets for these glyphs haven't been loaded yet.\n     *\n     * @param input Input text.\n     * @param style Specific [[TextRenderStyle]] to get glyphs for.\n     * @param letterCaseArray Array containing the original letter case for the requested glyphs.\n     *\n     * @returns Array containing [[GlyphData]] for each character of the input text.\n     */\n    getGlyphs(\n        input: string,\n        style: TextRenderStyle,\n        letterCaseArray?: boolean[]\n    ): GlyphData[] | undefined {\n        const result = [];\n        const fontName = style.fontName;\n        const fontStyle = style.fontStyle;\n        const fontVariant = style.fontVariant;\n        const shouldTransform =\n            fontVariant === FontVariant.AllCaps || fontVariant === FontVariant.SmallCaps;\n        for (const character of input) {\n            const transformedCharacter = shouldTransform ? character.toUpperCase() : character;\n            for (const char of transformedCharacter) {\n                const codePoint = char.codePointAt(0)!;\n                const font = this.getFont(codePoint, fontName);\n                const glyphData = this.getGlyph(codePoint, font, fontStyle);\n                if (glyphData !== undefined) {\n                    result.push(glyphData);\n                    if (letterCaseArray !== undefined) {\n                        letterCaseArray.push(char !== character);\n                    }\n                } else {\n                    return undefined;\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Gets the best matched font for a specific character.\n     *\n     * @param codePoint Character's Unicode code point.\n     * @param fontName Font name suggestion.\n     *\n     * @returns Best matched font.\n     */\n    getFont(codePoint: number, fontName?: string): Font {\n        let selectedFontName: string = this.fonts[0].name;\n        for (const block of this.unicodeBlocks) {\n            if (codePoint >= block.min && codePoint <= block.max) {\n                selectedFontName =\n                    fontName !== undefined &&\n                    block.fonts.find(element => {\n                        return element === fontName;\n                    }) !== undefined\n                        ? fontName\n                        : block.fonts[0];\n                break;\n            }\n        }\n\n        return this.fonts.find(element => {\n            return element.name === selectedFontName;\n        })!;\n    }\n\n    /**\n     * Update the info with the memory footprint caused by objects owned by the `FontCatalog`.\n     *\n     * @param info The info object to increment with the values from this `FontCatalog`.\n     */\n    updateMemoryUsage(info: MemoryUsage) {\n        let numBytes = 0;\n\n        for (const block of this.unicodeBlocks) {\n            numBytes += (block.max - block.min) * 2;\n        }\n\n        // Always stored in RGBA internally.\n        let textureBytes =\n            this.m_glyphTextureCache.textureSize.x * this.m_glyphTextureCache.textureSize.y * 4;\n\n        for (const page in this.m_loadedPages.entries) {\n            if (this.m_loadedPages.get(page) !== undefined) {\n                const loadedPage = this.m_loadedPages.get(page);\n                if (loadedPage !== undefined) {\n                    textureBytes += loadedPage.image.width * loadedPage.image.height * 4;\n                }\n            }\n        }\n\n        info.heapSize += numBytes + textureBytes;\n        info.gpuSize += textureBytes;\n    }\n\n    private createReplacementGlyph(codePoint: number, char: string, font: Font): GlyphData {\n        const replacementGlyph = this.m_replacementGlyph.clone();\n        (replacementGlyph as any).codePoint = codePoint;\n        (replacementGlyph as any).character = char;\n        (replacementGlyph as any).font = font;\n        return replacementGlyph;\n    }\n\n    private async loadAssets(\n        codePoint: number,\n        fontStyle: FontStyle,\n        block: UnicodeBlock,\n        font: Font\n    ): Promise<GlyphData> {\n        const json = await this.loadBlock(block, font, fontStyle);\n        if (json === undefined) {\n            return this.m_replacementGlyph;\n        }\n\n        const sourceGlyphData = (json.chars as SrcGlyphData[]).find(char => char.id === codePoint);\n        const assetsPath = this.getAssetsPath(fontStyle, font);\n        const texturePath = `${assetsPath}/${json.pages[sourceGlyphData!.page]}`;\n        const texture = await this.loadPage(texturePath);\n\n        const glyphData = new GlyphData(\n            sourceGlyphData!.id,\n            block.name,\n            sourceGlyphData!.width,\n            sourceGlyphData!.height,\n            sourceGlyphData!.xadvance,\n            sourceGlyphData!.xoffset,\n            sourceGlyphData!.yoffset,\n            sourceGlyphData!.x / texture!.image.width,\n            1.0 - (sourceGlyphData!.y + sourceGlyphData!.height) / texture!.image.height,\n            (sourceGlyphData!.x + sourceGlyphData!.width) / texture!.image.width,\n            1.0 - sourceGlyphData!.y / texture!.image.height,\n            texture!,\n            font\n        );\n\n        return glyphData;\n    }\n\n    private async loadPage(pagePath: string): Promise<THREE.Texture> {\n        let page = this.m_loadedPages.get(pagePath);\n        if (page === undefined) {\n            let pagePromise = this.m_loadingPages.get(pagePath);\n            if (pagePromise === undefined) {\n                pagePromise = FontCatalog.loadTexture(pagePath);\n                this.m_loadingPages.set(pagePath, pagePromise);\n                page = await pagePromise;\n                page.wrapS = THREE.ClampToEdgeWrapping;\n                page.wrapT = THREE.ClampToEdgeWrapping;\n                page.minFilter = THREE.NearestFilter;\n                page.needsUpdate = true;\n                if (this.m_loadingPages.delete(pagePath)) {\n                    this.m_loadedPages.set(pagePath, page);\n                }\n                this.m_loadingPages.delete(pagePath);\n            } else {\n                page = await pagePromise;\n            }\n        }\n        return page;\n    }\n\n    private getAssetsPath(fontStyle: FontStyle, font: Font) {\n        let fontStylePath = ASSETS_PATH;\n        switch (fontStyle) {\n            case FontStyle.Bold:\n                if (font.bold !== undefined) {\n                    fontStylePath = BOLD_ASSETS_PATH;\n                }\n                break;\n            case FontStyle.Italic:\n                if (font.italic !== undefined) {\n                    fontStylePath = ITALIC_ASSETS_PATH;\n                }\n                break;\n            case FontStyle.BoldItalic:\n                if (font.boldItalic !== undefined) {\n                    fontStylePath = BOLD_ITALIC_ASSETS_PATH;\n                } else if (font.italic !== undefined) {\n                    fontStylePath = ITALIC_ASSETS_PATH;\n                } else if (font.bold !== undefined) {\n                    fontStylePath = BOLD_ASSETS_PATH;\n                }\n                break;\n        }\n        return `${this.url}/${this.name}${fontStylePath}${font.name!}`;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { LRUCache } from \"@here/harp-lrucache\";\nimport * as THREE from \"three\";\n\nimport { Font, FontMetrics } from \"./FontCatalog\";\nimport { GlyphData } from \"./GlyphData\";\nimport { GlyphClearMaterial, GlyphCopyMaterial } from \"./TextMaterials\";\n\n/**\n * Maximum number of texture atlas pages we can copy from in a single go. This amount is determined\n * by the maximum number of texture units available on a pixel shader for all devices:\n * https://webglstats.com/webgl/parameter/MAX_TEXTURE_IMAGE_UNITS\n */\nconst MAX_NUM_COPY_PAGES = 8;\n\n/**\n * Maximum texture size supported. This amount is determined by the maximum texture size supported\n * for all devices:\n * https://webglstats.com/webgl/parameter/MAX_TEXTURE_SIZE\n */\nconst MAX_TEXTURE_SIZE = 4096;\n\n/**\n * @hidden\n * Information stored for every entry in a [[GlyphTextureCache]].\n */\nexport interface GlyphCacheEntry {\n    glyphData: GlyphData;\n    location: THREE.Vector2;\n}\n\n/**\n * @hidden\n * Unified glyph SDF bitmap storage for all fonts in a [[FontCatalog]].\n * Implemented as an abstraction layer on top of an LRUCache and WebGLRenderTarget.\n */\nexport class GlyphTextureCache {\n    private m_cacheWidth: number;\n    private m_cacheHeight: number;\n    private m_textureSize: THREE.Vector2;\n    private m_entryCache: LRUCache<string, GlyphCacheEntry>;\n\n    private m_scene: THREE.Scene;\n    private m_camera: THREE.OrthographicCamera;\n    private m_rt: THREE.WebGLRenderTarget;\n\n    private m_copyTextureSet: Set<THREE.Texture>;\n    private m_copyTransform: THREE.Matrix3;\n    private m_copyPositions: THREE.Vector2[];\n    private m_copyMaterial: GlyphCopyMaterial;\n    private m_copyVertexBuffer: THREE.InterleavedBuffer;\n    private m_copyPositionAttribute: THREE.InterleavedBufferAttribute;\n    private m_copyUVAttribute: THREE.InterleavedBufferAttribute;\n    private m_copyGeometry: THREE.BufferGeometry;\n    private m_copyMesh: THREE.Mesh;\n    private m_copyGeometryDrawCount: number;\n\n    private m_clearMaterial: GlyphClearMaterial;\n    private m_clearPositionAttribute: THREE.BufferAttribute;\n    private m_clearGeometry: THREE.BufferGeometry;\n    private m_clearMesh: THREE.Mesh;\n    private m_clearGeometryDrawCount: number;\n\n    /**\n     * Creates a `GlyphTextureCache` object.\n     *\n     * @param capacity Cache's maximum glyph capacity.\n     * @param entryWidth Maximum entry width.\n     * @param entryHeight Maximum entry height.\n     *\n     * @returns New `GlyphTextureCache`.\n     */\n    constructor(\n        readonly capacity: number,\n        readonly entryWidth: number,\n        readonly entryHeight: number\n    ) {\n        const nRows = Math.floor(Math.sqrt(capacity));\n        this.m_cacheHeight = nRows * nRows < capacity ? nRows + 1 : nRows;\n        this.m_cacheWidth = nRows * this.m_cacheHeight < capacity ? nRows + 1 : nRows;\n\n        this.m_textureSize = new THREE.Vector2(\n            this.m_cacheWidth * entryWidth,\n            this.m_cacheHeight * entryHeight\n        );\n        if (this.m_textureSize.y > MAX_TEXTURE_SIZE || this.m_textureSize.x > MAX_TEXTURE_SIZE) {\n            // tslint:disable-next-line:no-console\n            console.warn(\n                \"GlyphTextureCache texture size (\" +\n                    this.m_textureSize.x +\n                    \", \" +\n                    this.m_textureSize.y +\n                    \") exceeds WebGL's widely supported MAX_TEXTURE_SIZE (\" +\n                    MAX_TEXTURE_SIZE +\n                    \").\\n\" +\n                    \"This could result in rendering errors on some devices.\\n\" +\n                    \"Please consider reducing its capacity or input assets size.\"\n            );\n        }\n\n        this.m_entryCache = new LRUCache<string, GlyphCacheEntry>(capacity);\n        this.initCacheEntries();\n\n        this.m_scene = new THREE.Scene();\n        this.m_camera = new THREE.OrthographicCamera(\n            0,\n            this.m_textureSize.x,\n            this.m_textureSize.y,\n            0\n        );\n        this.m_camera.position.z = 1;\n        this.m_camera.updateMatrixWorld(false);\n        this.m_rt = new THREE.WebGLRenderTarget(this.m_textureSize.x, this.m_textureSize.y, {\n            wrapS: THREE.ClampToEdgeWrapping,\n            wrapT: THREE.ClampToEdgeWrapping,\n            depthBuffer: false,\n            stencilBuffer: false\n        });\n\n        this.m_copyTextureSet = new Set<THREE.Texture>();\n        this.m_copyTransform = new THREE.Matrix3();\n        this.m_copyPositions = [];\n        this.m_copyPositions.push(\n            new THREE.Vector2(),\n            new THREE.Vector2(),\n            new THREE.Vector2(),\n            new THREE.Vector2()\n        );\n\n        this.m_copyMaterial = new GlyphCopyMaterial();\n        this.m_copyVertexBuffer = new THREE.InterleavedBuffer(new Float32Array(capacity * 20), 5);\n        this.m_copyVertexBuffer.setUsage(THREE.DynamicDrawUsage);\n\n        this.m_copyPositionAttribute = new THREE.InterleavedBufferAttribute(\n            this.m_copyVertexBuffer,\n            3,\n            0\n        );\n        this.m_copyUVAttribute = new THREE.InterleavedBufferAttribute(\n            this.m_copyVertexBuffer,\n            2,\n            3\n        );\n        this.m_copyGeometry = new THREE.BufferGeometry();\n        this.m_copyGeometry.setAttribute(\"position\", this.m_copyPositionAttribute);\n        this.m_copyGeometry.setAttribute(\"uv\", this.m_copyUVAttribute);\n\n        const copyIndexBuffer = new THREE.BufferAttribute(new Uint32Array(capacity * 6), 1);\n        copyIndexBuffer.setUsage(THREE.DynamicDrawUsage);\n        this.m_copyGeometry.setIndex(copyIndexBuffer);\n        this.m_copyMesh = new THREE.Mesh(this.m_copyGeometry, this.m_copyMaterial);\n        this.m_copyMesh.frustumCulled = false;\n        this.m_copyGeometryDrawCount = 0;\n\n        this.m_clearMaterial = new GlyphClearMaterial();\n        this.m_clearPositionAttribute = new THREE.BufferAttribute(\n            new Float32Array(capacity * 8),\n            2\n        );\n        this.m_clearPositionAttribute.setUsage(THREE.DynamicDrawUsage);\n        this.m_clearGeometry = new THREE.BufferGeometry();\n        this.m_clearGeometry.setAttribute(\"position\", this.m_clearPositionAttribute);\n        const clearIndexBuffer = new THREE.BufferAttribute(new Uint32Array(capacity * 6), 1);\n        clearIndexBuffer.setUsage(THREE.DynamicDrawUsage);\n\n        this.m_clearGeometry.setIndex(clearIndexBuffer);\n        this.m_clearMesh = new THREE.Mesh(this.m_clearGeometry, this.m_clearMaterial);\n        this.m_clearMesh.frustumCulled = false;\n        this.m_clearGeometryDrawCount = 0;\n\n        this.m_scene.add(this.m_clearMesh, this.m_copyMesh);\n    }\n\n    /**\n     * Release all allocated resources.\n     */\n    dispose(): void {\n        this.m_entryCache.clear();\n        this.m_scene.remove(this.m_clearMesh, this.m_copyMesh);\n        this.m_rt.dispose();\n        this.m_clearMaterial.dispose();\n        this.m_copyMaterial.dispose();\n        this.m_copyTextureSet.clear();\n        this.m_clearGeometry.dispose();\n        this.m_copyGeometry.dispose();\n    }\n\n    /**\n     * Internal WebGL Texture.\n     */\n    get texture(): THREE.Texture {\n        return this.m_rt.texture;\n    }\n\n    /**\n     * Internal WebGL Texture size.\n     */\n    get textureSize(): THREE.Vector2 {\n        return this.m_textureSize;\n    }\n\n    /**\n     * Add a new entry to the GlyphTextureCache. If the limit of entries is hit, the least requested\n     * entry will be replaced.\n     *\n     * @param hash Entry's hash.\n     * @param glyph Entry's glyph data.\n     */\n    add(hash: string, glyph: GlyphData): void {\n        const entry = this.m_entryCache.get(hash);\n        if (entry !== undefined) {\n            return;\n        }\n\n        const oldestEntry = this.m_entryCache.oldest;\n        if (oldestEntry === null) {\n            throw new Error(\"GlyphTextureCache is uninitialized!\");\n        }\n        this.clearCacheEntry(oldestEntry.value);\n        this.copyGlyphToCache(hash, glyph, oldestEntry.value.location);\n    }\n\n    /**\n     * Checks if an entry is in the cache.\n     *\n     * @param hash Entry's hash.\n     *\n     * @returns Test result.\n     */\n    has(hash: string): boolean {\n        return this.m_entryCache.has(hash);\n    }\n\n    /**\n     * Retrieves an entry from the cache.\n     *\n     * @param hash Entry's hash.\n     *\n     * @returns Retrieval result.\n     */\n    get(hash: string): GlyphCacheEntry | undefined {\n        return this.m_entryCache.get(hash);\n    }\n\n    /**\n     * Clears the internal LRUCache.\n     */\n    clear(): void {\n        this.m_copyGeometryDrawCount = 0;\n        this.m_clearGeometryDrawCount = 0;\n        this.m_entryCache.clear();\n        this.m_copyTextureSet.clear();\n        this.initCacheEntries();\n    }\n\n    /**\n     * Updates the internal WebGLRenderTarget.\n     * The update will copy the newly introduced glyphs since the previous update.\n     *\n     * @param renderer WebGLRenderer.\n     */\n    update(renderer: THREE.WebGLRenderer): void {\n        let oldRenderTarget: THREE.RenderTarget | null = null;\n\n        const willClearGeometry = this.m_clearGeometryDrawCount > 0;\n        const willCopyGeometry = this.m_copyGeometryDrawCount > 0;\n\n        if (willClearGeometry || willCopyGeometry) {\n            oldRenderTarget = renderer.getRenderTarget();\n            renderer.setRenderTarget(this.m_rt);\n        }\n\n        if (willClearGeometry) {\n            if (this.m_clearGeometry.index === null) {\n                throw new Error(\"GlyphTextureCache clear geometry index is uninitialized!\");\n            }\n            this.m_clearPositionAttribute.needsUpdate = true;\n            this.m_clearPositionAttribute.updateRange.offset = 0;\n            this.m_clearPositionAttribute.updateRange.count = this.m_clearGeometryDrawCount * 8;\n            this.m_clearGeometry.index.needsUpdate = true;\n            this.m_clearGeometry.index.updateRange.offset = 0;\n            this.m_clearGeometry.index.updateRange.count = this.m_clearGeometryDrawCount * 6;\n            this.m_clearGeometry.setDrawRange(0, this.m_clearGeometryDrawCount * 6);\n\n            this.m_clearMesh.visible = true;\n            this.m_copyMesh.visible = false;\n\n            renderer.render(this.m_scene, this.m_camera);\n            this.m_clearGeometryDrawCount = 0;\n            this.m_clearMesh.visible = false;\n        }\n\n        if (willCopyGeometry) {\n            if (this.m_copyGeometry.index === null) {\n                throw new Error(\"GlyphTextureCache copy geometry index is uninitialized!\");\n            }\n            this.m_copyVertexBuffer.needsUpdate = true;\n            this.m_copyVertexBuffer.updateRange.offset = 0;\n            this.m_copyVertexBuffer.updateRange.count = this.m_copyGeometryDrawCount * 20;\n            this.m_copyGeometry.index.needsUpdate = true;\n            this.m_copyGeometry.index.updateRange.offset = 0;\n            this.m_copyGeometry.index.updateRange.count = this.m_copyGeometryDrawCount * 6;\n            this.m_copyGeometry.setDrawRange(0, this.m_copyGeometryDrawCount * 6);\n\n            this.m_copyMesh.visible = true;\n            const srcPages = Array.from(this.m_copyTextureSet);\n            const nCopies = Math.ceil(this.m_copyTextureSet.size / MAX_NUM_COPY_PAGES);\n            for (let copyIndex = 0; copyIndex < nCopies; copyIndex++) {\n                const pageOffset = copyIndex * MAX_NUM_COPY_PAGES;\n                this.m_copyMaterial.uniforms.pageOffset.value = pageOffset;\n                for (let i = 0; i < MAX_NUM_COPY_PAGES; i++) {\n                    const pageIndex = pageOffset + i;\n                    if (pageIndex < this.m_copyTextureSet.size) {\n                        this.m_copyMaterial.uniforms[\"page\" + i].value = srcPages[pageIndex];\n                    }\n                }\n\n                renderer.render(this.m_scene, this.m_camera);\n            }\n            this.m_copyTextureSet.clear();\n            this.m_copyGeometryDrawCount = 0;\n        }\n        if (willClearGeometry || willCopyGeometry) {\n            renderer.setRenderTarget(oldRenderTarget);\n        }\n    }\n\n    private initCacheEntries() {\n        const dummyMetrics: FontMetrics = {\n            size: 0,\n            distanceRange: 0,\n            base: 0,\n            lineHeight: 0,\n            lineGap: 0,\n            capHeight: 0,\n            xHeight: 0\n        };\n        const dummyFont: Font = {\n            name: \"\",\n            metrics: dummyMetrics,\n            charset: \"\"\n        };\n\n        const dummyGlyphData = new GlyphData(\n            0,\n            \"\",\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            THREE.Texture.DEFAULT_IMAGE,\n            dummyFont\n        );\n\n        for (let i = 0; i < this.m_cacheHeight; i++) {\n            for (let j = 0; j < this.m_cacheWidth; j++) {\n                const dummyEntry: GlyphCacheEntry = {\n                    glyphData: dummyGlyphData,\n                    location: new THREE.Vector2(j, i)\n                };\n                this.m_entryCache.set(`Dummy_${i * this.m_cacheHeight + j}`, dummyEntry);\n            }\n        }\n    }\n\n    private copyGlyphToCache(hash: string, glyph: GlyphData, cacheLocation: THREE.Vector2) {\n        this.m_copyTextureSet.add(glyph.texture);\n        let copyTextureIndex = 0;\n        for (const value of this.m_copyTextureSet.values()) {\n            if (value === glyph.texture) {\n                break;\n            }\n            copyTextureIndex++;\n        }\n        glyph.copyIndex = copyTextureIndex;\n\n        this.m_copyTransform.set(\n            1.0,\n            0.0,\n            cacheLocation.x * this.entryWidth - glyph.offsetX,\n            0.0,\n            1.0,\n            cacheLocation.y * this.entryHeight - glyph.positions[0].y,\n            0.0,\n            0.0,\n            0.0\n        );\n        for (let i = 0; i < 4; ++i) {\n            this.m_copyPositions[i].set(glyph.positions[i].x, glyph.positions[i].y);\n            this.m_copyPositions[i].applyMatrix3(this.m_copyTransform);\n        }\n\n        if (this.m_copyGeometryDrawCount >= this.capacity) {\n            return;\n        }\n        const baseVertex = this.m_copyGeometryDrawCount * 4;\n        const baseIndex = this.m_copyGeometryDrawCount * 6;\n\n        for (let i = 0; i < 4; ++i) {\n            this.m_copyPositionAttribute.setXYZ(\n                baseVertex + i,\n                this.m_copyPositions[i].x,\n                this.m_copyPositions[i].y,\n                glyph.copyIndex\n            );\n            this.m_copyUVAttribute.setXY(\n                baseVertex + i,\n                glyph.sourceTextureCoordinates[i].x,\n                glyph.sourceTextureCoordinates[i].y\n            );\n        }\n\n        if (this.m_copyGeometry.index === null) {\n            throw new Error(\"GlyphTextureCache copy geometry index is uninitialized!\");\n        }\n        this.m_copyGeometry.index.setX(baseIndex, baseVertex);\n        this.m_copyGeometry.index.setX(baseIndex + 1, baseVertex + 1);\n        this.m_copyGeometry.index.setX(baseIndex + 2, baseVertex + 2);\n        this.m_copyGeometry.index.setX(baseIndex + 3, baseVertex + 2);\n        this.m_copyGeometry.index.setX(baseIndex + 4, baseVertex + 1);\n        this.m_copyGeometry.index.setX(baseIndex + 5, baseVertex + 3);\n\n        ++this.m_copyGeometryDrawCount;\n\n        const u0 = this.m_copyPositions[0].x / this.m_textureSize.x;\n        const v0 = this.m_copyPositions[0].y / this.m_textureSize.y;\n        const u1 = this.m_copyPositions[3].x / this.m_textureSize.x;\n        const v1 = this.m_copyPositions[3].y / this.m_textureSize.y;\n        glyph.dynamicTextureCoordinates[0].set(u0, v0);\n        glyph.dynamicTextureCoordinates[1].set(u1, v0);\n        glyph.dynamicTextureCoordinates[2].set(u0, v1);\n        glyph.dynamicTextureCoordinates[3].set(u1, v1);\n\n        glyph.isInCache = true;\n        this.m_entryCache.set(hash, {\n            glyphData: glyph,\n            location: cacheLocation\n        });\n    }\n\n    private clearCacheEntry(entry: GlyphCacheEntry) {\n        entry.glyphData.isInCache = false;\n        this.m_copyPositions[0].set(\n            entry.location.x * this.entryWidth,\n            entry.location.y * this.entryHeight\n        );\n        this.m_copyPositions[1].set(\n            (entry.location.x + 1) * this.entryWidth,\n            entry.location.y * this.entryHeight\n        );\n        this.m_copyPositions[2].set(\n            entry.location.x * this.entryWidth,\n            (entry.location.y + 1) * this.entryHeight\n        );\n        this.m_copyPositions[3].set(\n            (entry.location.x + 1) * this.entryWidth,\n            (entry.location.y + 1) * this.entryHeight\n        );\n\n        if (this.m_clearGeometryDrawCount >= this.capacity) {\n            return;\n        }\n        const baseVertex = this.m_clearGeometryDrawCount * 4;\n        const baseIndex = this.m_clearGeometryDrawCount * 6;\n\n        for (let i = 0; i < 4; ++i) {\n            this.m_clearPositionAttribute.setXY(\n                baseVertex + i,\n                this.m_copyPositions[i].x,\n                this.m_copyPositions[i].y\n            );\n        }\n\n        if (this.m_clearGeometry.index === null) {\n            throw new Error(\"GlyphTextureCache clear geometry index is uninitialized!\");\n        }\n        this.m_clearGeometry.index.setX(baseIndex, baseVertex);\n        this.m_clearGeometry.index.setX(baseIndex + 1, baseVertex + 1);\n        this.m_clearGeometry.index.setX(baseIndex + 2, baseVertex + 2);\n        this.m_clearGeometry.index.setX(baseIndex + 3, baseVertex + 2);\n        this.m_clearGeometry.index.setX(baseIndex + 4, baseVertex + 1);\n        this.m_clearGeometry.index.setX(baseIndex + 5, baseVertex + 3);\n\n        ++this.m_clearGeometryDrawCount;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { assert } from \"@here/harp-utils\";\n\n/** @hidden */\nexport class Entry<Key, Value> {\n    constructor(\n        public key: Key,\n        public value: Value,\n        public size: number,\n        public newer: Entry<Key, Value> | null,\n        public older: Entry<Key, Value> | null\n    ) {}\n}\n\n/**\n * Fixed size cache that evicts its entries in least-recently-used order when it overflows.\n * Modeled after standard JavaScript `Map` otherwise.\n */\nexport class LRUCache<Key, Value> {\n    /**\n     * Optional callback that is called on every item that is evicted from the cache.\n     *\n     * **Note**: This callback is not called when an item is explicitly deleted from the map via\n     * [[delete]] or [[clear]].\n     */\n    evictionCallback?: (key: Key, value: Value) => void;\n\n    /**\n     * Optional callback that is called on every item that should be evicted from the cache to\n     * determine if it can be removed, or should be locked in the cache.\n     *\n     * It returns `true` if the item can be removed from cache, `false` otherwise. Locking items in\n     * the cache should be a temporary measure, since if the cache is filled with non-evictable\n     * items only, it may grow beyond its capacity.\n     *\n     * **Note**: This callback is not called when an item is explicitly deleted from the map via\n     * [[delete]] or [[clear]].\n     */\n    canEvict?: (key: Key, value: Value) => boolean;\n    private m_capacity: number;\n    private m_size = 0;\n\n    /**\n     * The internal map object that keeps the key-value pairs and their order.\n     */\n    private m_map = new Map<Key, Entry<Key, Value>>();\n\n    /**\n     * The newest entry, i.e. the most recently used item.\n     */\n    private m_newest: Entry<Key, Value> | null = null;\n\n    /**\n     * The oldest entry, i.e. the least recently used item.\n     */\n    private m_oldest: Entry<Key, Value> | null = null;\n\n    /**\n     * A function determining the size per element.\n     */\n    private m_sizeFunction: (v: Value) => number;\n\n    /**\n     * Creates a new instance of `LRUCache`.\n     *\n     * The optional [[sizeFunction]] can be used to fine tune the memory consumption of all cached\n     * elements, thus [[cacheCapacity]] means then memory used (in MBs). Otherwise, if\n     * [[sizeFunction]] is not specified, the [[cacheCapacity]] accounts for the maximum\n     * number of elements stored.\n     *\n     * @param cacheCapacity Number used to configure the maximum cache size, may express\n     * number of entries or memory consumed in megabytes depending on [[sizeFunction]].\n     * @param sizeFunction A function determining the size per element.\n     */\n    constructor(cacheCapacity: number, sizeFunction: (v: Value) => number = () => 1) {\n        this.m_capacity = cacheCapacity;\n        this.m_sizeFunction = sizeFunction;\n    }\n\n    /**\n     * Iterates over all items from the most recently used item to the least recently used one.\n     *\n     * **Note**: Results are undefined if the entire cache is modified during iteration. You may\n     * although modify the current element in [[callbackfn]] function.\n     *\n     * @param callbackfn The callback to call for each item.\n     * @param thisArg Optional this argument for the callback.\n     */\n    forEach(\n        callbackfn: (value: Value, key: Key, map: LRUCache<Key, Value>) => void,\n        thisArg?: any\n    ): void {\n        let entry = this.m_newest;\n        while (entry !== null) {\n            const older = entry.older;\n            callbackfn.call(thisArg, entry.value, entry.key, this);\n            entry = older;\n        }\n    }\n\n    /**\n     * The size of the cache, i.e. the sum of all the sizes of all the objects in the cache.\n     *\n     * @returns The size of the cache.\n     */\n    get size(): number {\n        return this.m_size;\n    }\n\n    /**\n     * Returns the maximum capacity of the cache, i.e. the maximum number of elements this cache\n     * can contain or the total amount of memory that may be consumed by cache if element size\n     * function was specified in cache c-tor.\n     *\n     * @returns The capacity of the cache.\n     */\n    get capacity(): number {\n        return this.m_capacity;\n    }\n\n    /**\n     * @deprecated - DO NOT USE. Will be removed in future versions.\n     *\n     * Returns the internal map object that keeps the key-value pairs and their order.\n     *\n     * @returns The internal map object.\n     */\n    get map(): Map<Key, Entry<Key, Value>> {\n        // ### TODO - remove me. Cache must not expose its internal object,\n        // modifications to it are fatal for the internal state machine.\n        return this.m_map;\n    }\n\n    /**\n     * Returns the newest entry in the cache.\n     *\n     * @returns Newest entry in the cache.\n     */\n    get newest(): Entry<Key, Value> | null {\n        return this.m_newest;\n    }\n\n    /**\n     * Returns the oldest entry in the cache.\n     *\n     * Note: Does not promote the oldest item as most recently used item.\n     *\n     * @returns Oldest entry in the cache.\n     */\n    get oldest(): Entry<Key, Value> | null {\n        return this.m_oldest;\n    }\n\n    /**\n     * Resets the capacity of this cache. If `newCapacity` is smaller than the current cache size,\n     * all items will be evicted until the cache shrinks to `newCapacity`.\n     *\n     * @param newCapacity The new capacity of this cache.\n     */\n    setCapacity(newCapacity: number): void {\n        this.m_capacity = newCapacity;\n        this.evict();\n    }\n\n    /**\n     * Resets the cache capacity and function used to measure the element size.\n     *\n     * @param newCapacity The new capacity masured in units returned from [[sizeMeasure]] funtion.\n     * @param sizeMeasure Function that defines the size of element, if you want to measure\n     * number of elements only always return 1 from this function (default), you may also\n     * specify own function that measures entries by memory consumed, nubmer of sub-elements, etc.\n     */\n    setCapacityAndMeasure(newCapacity: number, sizeMeasure: (v: Value) => number = () => 1) {\n        this.m_capacity = newCapacity;\n        this.m_sizeFunction = sizeMeasure;\n        this.shrinkToCapacity();\n    }\n\n    /**\n     * Updates the size of all elements in this cache. If their aggregated size is larger than the\n     * capacity, items will be evicted until the cache shrinks to fit the capacity.\n     */\n    shrinkToCapacity(): void {\n        let size = 0;\n        const sizeFunction = this.m_sizeFunction;\n\n        let entry = this.m_newest;\n        while (entry !== null) {\n            const entrySize = sizeFunction(entry.value);\n            entry.size = entrySize;\n            size += entrySize;\n            entry = entry.older;\n        }\n\n        this.m_size = size;\n        this.evict();\n    }\n\n    /**\n     * Inserts or updates a key/value pair in the cache.\n     *\n     * If the key already existed in the cache, it will be updated and promoted to the most recently\n     * used item.\n     *\n     * If the key didn't exist in the cache, it will be inserted as most recently used item. An\n     * eviction of the least recently used item takes place if the cache exceeded its capacity.\n     *\n     * @param key The key for the key-value pair to insert or update.\n     * @param value The value for the key-value pair to insert or update.\n     */\n    set(key: Key, value: Value) {\n        const valueSize = this.m_sizeFunction(value);\n        let entry = this.m_map.get(key);\n        if (entry !== undefined) {\n            this.m_size = this.m_size - entry.size + valueSize;\n            entry.value = value;\n            entry.size = valueSize;\n            this.promoteEntry(entry);\n            this.evict();\n        } else {\n            if (valueSize > this.m_capacity) {\n                return; // single item too big to cache\n            }\n\n            entry = new Entry<Key, Value>(key, value, valueSize, null, null);\n            if (this.m_map.size === 0) {\n                this.m_newest = this.m_oldest = entry;\n            } else {\n                assert(this.m_newest !== null);\n                const newest: Entry<Key, Value> = this.m_newest!;\n                entry.older = this.m_newest;\n                newest.newer = entry;\n                this.m_newest = entry;\n            }\n            this.m_map.set(key, entry);\n            this.m_size += valueSize;\n            this.evict();\n        }\n    }\n\n    /**\n     * Looks up key in the cache and returns the associated value.\n     *\n     * @param key The key to look up.\n     * @returns The associated value, or `undefined` if the key-value pair is not in the cache.\n     */\n    get(key: Key): Value | undefined {\n        const entry = this.m_map.get(key);\n        if (entry === undefined) {\n            return undefined;\n        }\n\n        this.promoteEntry(entry);\n        return entry.value;\n    }\n\n    /**\n     * Test if a key/value pair is in the cache.\n     *\n     * @param key The key to look up.\n     * @returns `true` if the key-value pair is in the cache, `false` otherwise.\n     */\n    has(key: Key): boolean {\n        return this.m_map.has(key);\n    }\n\n    /**\n     * Clears the cache and removes all stored key-value pairs.\n     *\n     * Does not call the eviction callback. Use [[evictAll]] to clear the cache and call the\n     * eviction callback.\n     */\n    clear(): void {\n        this.m_newest = this.m_oldest = null;\n        this.m_size = 0;\n        this.m_map.clear();\n    }\n\n    /**\n     * Evicts all items from the cache, calling the eviction callback on each item.\n     *\n     * Use [[clear]] to remove all items without calling the eviction callback.\n     */\n    evictAll(): void {\n        const cb = this.evictionCallback;\n        if (cb !== undefined) {\n            this.forEach((value, key) => cb(key, value));\n        }\n        this.clear();\n    }\n\n    /**\n     * Evict selected elements from the cache using [[selector]] function.\n     *\n     * @param selector The function for selecting elements for eviction.\n     * @param thisArg Optional _this_ object reference.\n     */\n    evictSelected(selector: (value: Value, key: Key) => boolean, thisArg?: any) {\n        const cb = this.evictionCallback;\n        let entry = this.m_newest;\n        while (entry !== null) {\n            const entryOlder = entry.older;\n            if (selector.call(thisArg, entry.value, entry.key)) {\n                if (cb !== undefined) {\n                    cb(entry.key, entry.value);\n                }\n                this.deleteEntry(entry);\n                this.m_map.delete(entry.key);\n            }\n            entry = entryOlder;\n        }\n    }\n\n    /**\n     * Explicitly removes a key-value pair from the cache.\n     *\n     * **Note**: This is an explicit removal, thus, the eviction callback will not be called.\n     *\n     * @param key The key of the key-value pair to delete.\n     * @returns `true` if the key-value pair existed and was deleted, `false` otherwise.\n     */\n    delete(key: Key): boolean {\n        const entry = this.m_map.get(key);\n        if (entry === undefined) {\n            return false;\n        }\n        this.deleteEntry(entry);\n        return this.m_map.delete(key);\n    }\n\n    protected evict() {\n        while (this.m_oldest !== null && this.m_size > this.m_capacity) {\n            const evicted = this.evictOldest();\n            if (evicted === undefined) {\n                return;\n            }\n        }\n    }\n\n    protected evictOldest(): Entry<Key, Value> | undefined {\n        assert(this.m_oldest !== null);\n        const oldest = this.m_oldest!;\n        assert(oldest.older === null);\n        let itemToRemove = oldest;\n\n        if (this.canEvict !== undefined) {\n            while (!this.canEvict(itemToRemove.key, itemToRemove.value)) {\n                if (itemToRemove.newer === null) {\n                    return undefined;\n                }\n                itemToRemove = itemToRemove.newer;\n            }\n        }\n\n        if (itemToRemove === oldest) {\n            this.m_oldest = itemToRemove.newer;\n            if (itemToRemove.newer !== null) {\n                assert(itemToRemove.newer.older === itemToRemove);\n                itemToRemove.newer.older = null;\n            }\n        } else {\n            if (itemToRemove.newer !== null) {\n                assert(itemToRemove.newer.older === itemToRemove);\n                itemToRemove.newer.older = itemToRemove.older;\n                if (itemToRemove.older !== null) {\n                    itemToRemove.older.newer = itemToRemove.newer;\n                }\n            } else {\n                return undefined;\n            }\n        }\n\n        const isOk = this.m_map.delete(itemToRemove.key);\n        assert(isOk === true);\n        if (isOk && this.evictionCallback !== undefined) {\n            this.evictionCallback(itemToRemove.key, itemToRemove.value);\n        }\n        this.m_size -= itemToRemove.size;\n        return itemToRemove;\n    }\n\n    private deleteEntry(entry: Entry<Key, Value>): void {\n        if (entry === this.m_newest) {\n            this.m_newest = entry.older;\n        } else if (entry.newer) {\n            entry.newer.older = entry.older;\n        } else {\n            assert(false);\n        }\n\n        if (entry === this.m_oldest) {\n            this.m_oldest = entry.newer;\n        } else if (entry.older) {\n            entry.older.newer = entry.newer;\n        } else {\n            assert(false);\n        }\n\n        this.m_size -= entry.size;\n    }\n\n    private promoteEntry(entry: Entry<Key, Value>): void {\n        if (entry === this.m_newest) {\n            return;\n        } // already newest, nothing to do\n\n        // re-link newer and older items\n        if (entry.newer) {\n            assert(entry.newer.older === entry);\n            entry.newer.older = entry.older;\n        }\n        if (entry.older) {\n            assert(entry.older.newer === entry);\n            entry.older.newer = entry.newer;\n        }\n        if (entry === this.m_oldest) {\n            this.m_oldest = entry.newer;\n        }\n        // re-link ourselves\n        entry.newer = null;\n        entry.older = this.m_newest;\n\n        // finally, set ourselves as the newest entry\n        assert(this.m_newest !== null);\n        const newest = this.m_newest!;\n        assert(newest.newer === null);\n        newest.newer = entry;\n        this.m_newest = entry;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { FontCatalog } from \"./rendering/FontCatalog\";\nimport { GlyphData } from \"./rendering/GlyphData\";\nimport { TextBufferObject } from \"./rendering/TextBufferObject\";\nimport { QUAD_VERTEX_MEMORY_FOOTPRINT, TextGeometry } from \"./rendering/TextGeometry\";\nimport { SdfTextMaterial } from \"./rendering/TextMaterials\";\nimport { FontVariant, TextLayoutStyle, TextRenderStyle } from \"./rendering/TextStyle\";\nimport { LineTypesetter } from \"./typesetting/LineTypesetter\";\nimport { PathTypesetter, PathTypesettingParameters } from \"./typesetting/PathTypesetter\";\nimport { TypesettingParameters } from \"./typesetting/Typesetter\";\nimport { createSdfTextMaterial } from \"./utils/MaterialUtils\";\n\nconst tempTextPosition = new THREE.Vector3();\nconst tempTextBounds = {\n    array: [new THREE.Box2()],\n    offset: 0\n};\nlet tempVertexBuffer = new Float32Array();\n\ninterface TextPlacementParameters {\n    input: string | GlyphData[];\n    layer: TextCanvasLayer;\n    textPath?: THREE.Path | THREE.CurvePath<THREE.Vector2>;\n    textPathOverflow?: boolean;\n    bounds?: THREE.Box2;\n    individualBounds?: THREE.Box2[];\n    computeTextBuffer?: boolean;\n    letterCaseArray?: boolean[];\n}\n\n/**\n * Optional parameters passed on [[TextCanvas]].`measureText` function call.\n */\nexport interface MeasurementParameters {\n    /**\n     * Path where text should be placed on. Overrides the original position parameter.\n     */\n    path?: THREE.Path | THREE.CurvePath<THREE.Vector2>;\n\n    /**\n     * If `true`, text on a path will be placed even when its size its bigger than the path's size.\n     */\n    pathOverflow?: boolean;\n\n    /**\n     * Output per-character bounds.\n     */\n    outputCharacterBounds?: THREE.Box2[];\n\n    /**\n     * Array containing info on whether the glyphs are upper or lower case. Needed to support\n     * `SmallCaps`.\n     */\n    letterCaseArray?: boolean[];\n}\n\n/**\n * Optional parameters passed on [[TextCanvas]].`addText` function call.\n */\nexport interface AdditionParameters {\n    /**\n     * Path where text should be placed on. Overrides the original position parameter.\n     */\n    path?: THREE.Path | THREE.CurvePath<THREE.Vector2>;\n\n    /**\n     * If `true`, text on a path will be placed even when its size its bigger than the path's size.\n     */\n    pathOverflow?: boolean;\n\n    /**\n     * Layer where text will be added.\n     */\n    layer?: number;\n\n    /**\n     * If `true`, the input position parameter will be updated to contain the position of the last\n     * glyph added.\n     */\n    updatePosition?: boolean;\n\n    /**\n     * Object containing additional data intended to be retrieved during picking.\n     */\n    pickingData?: any;\n\n    /**\n     * Array containing info on whether the glyphs are upper or lower case. Needed to support\n     * `SmallCaps`.\n     */\n    letterCaseArray?: boolean[];\n}\n\n/**\n * Optional parameters passed on [[TextCanvas]].`createTextBufferObject` function call.\n */\nexport interface TextBufferCreationParameters {\n    /**\n     * Path where text should be placed on. Overrides the original position parameter.\n     */\n    path?: THREE.Path | THREE.CurvePath<THREE.Vector2>;\n\n    /**\n     * If `true`, text on a path will be placed even when its size its bigger than the path's size.\n     */\n    pathOverflow?: boolean;\n\n    /**\n     * Output text bounding-box.\n     */\n    outputBounds?: boolean;\n\n    /**\n     * Output per-character bounds.\n     */\n    outputCharacterBounds?: boolean;\n\n    /**\n     * Array containing info on whether the glyphs are upper or lower case. Needed to support\n     * `SmallCaps`.\n     */\n    letterCaseArray?: boolean[];\n\n    /**\n     * If `true`, both the [[TextRenderStyle]] and [[TextLayoutStyle]] used to generate the\n     * [[TextBufferObject]] will be stored in it.\n     */\n    storeStyles?: boolean;\n}\n\n/**\n * Optional parameters passed on [[TextCanvas]].`addTextBufferObject` function call.\n */\nexport interface TextBufferAdditionParameters {\n    layer?: number;\n    position?: THREE.Vector3;\n    scale?: number;\n    rotation?: number;\n    color?: THREE.Color;\n    opacity?: number;\n    backgroundColor?: THREE.Color;\n    backgroundOpacity?: number;\n    pickingData?: any;\n}\n\n/**\n * Default's [[TextCanvas]] layer identifier.\n */\nexport const DEFAULT_TEXT_CANVAS_LAYER = 0;\n\n/**\n * [[TextCanvas]] rendering layer.\n */\nexport interface TextCanvasLayer {\n    id: number;\n    storage: TextGeometry;\n}\n\n/**\n * [[TextCanvas]] construction parameters.\n */\nexport interface TextCanvasParameters {\n    /**\n     * WebGLRenderer internally used by this `TextCanvas`.\n     */\n    renderer: THREE.WebGLRenderer;\n\n    /**\n     * Initial [[FontCatalog]].\n     */\n    fontCatalog: FontCatalog;\n\n    /**\n     * Minimum amount of glyphs each [[TextCanvas]] layer can store.\n     */\n    minGlyphCount: number;\n\n    /**\n     * Maximum amount of glyphs each [[TextCanvas]] layer can store.\n     */\n    maxGlyphCount: number;\n\n    /**\n     * Material used to render text.\n     */\n    material?: THREE.Material;\n\n    /**\n     * Material used to render text background.\n     */\n    backgroundMaterial?: THREE.Material;\n}\n\n/**\n * Describes estimated usage of memory on heap and GPU.\n */\nexport interface MemoryUsage {\n    heapSize: number;\n    gpuSize: number;\n}\n\n/**\n * three.js text rendering engine which can manage and render high-quality, transformable, stylable\n * and properly layout SDF and MSDF text.\n */\nexport class TextCanvas {\n    /**\n     * Minimum amount of glyphs each [[TextCanvas]] layer can store.\n     */\n    readonly minGlyphCount: number;\n\n    /**\n     * Maximum amount of glyphs each [[TextCanvas]] layer can store.\n     */\n    readonly maxGlyphCount: number;\n\n    private m_renderer: THREE.WebGLRenderer;\n    private m_fontCatalog: FontCatalog;\n\n    private readonly m_defaultTextRenderStyle: TextRenderStyle;\n    private m_currentTextRenderStyle: TextRenderStyle;\n    private readonly m_defaultTextLayoutStyle: TextLayoutStyle;\n    private m_currentTextLayoutStyle: TextLayoutStyle;\n\n    private m_material: SdfTextMaterial | THREE.Material;\n    private m_bgMaterial: SdfTextMaterial | THREE.Material;\n    private m_ownsMaterial: boolean;\n    private m_ownsBgMaterial: boolean;\n\n    private m_defaultLayer: TextCanvasLayer;\n    private m_layers: TextCanvasLayer[];\n\n    private m_lineTypesetter: LineTypesetter;\n    private m_pathTypesetter: PathTypesetter;\n\n    /**\n     * Constructs a new `TextCanvas`.\n     *\n     * @param params `TextCanvas` construction parameters.\n     *\n     * @returns New `TextCanvas`.\n     */\n    constructor(params: TextCanvasParameters) {\n        this.m_renderer = params.renderer;\n        this.m_fontCatalog = params.fontCatalog;\n        this.minGlyphCount = params.minGlyphCount;\n        this.maxGlyphCount = params.maxGlyphCount;\n\n        if (params.material === undefined) {\n            this.m_ownsMaterial = true;\n            this.m_material = createSdfTextMaterial({ fontCatalog: params.fontCatalog });\n        } else {\n            this.m_ownsMaterial = false;\n            this.m_material = params.material;\n        }\n        if (params.backgroundMaterial === undefined) {\n            this.m_ownsBgMaterial = true;\n            this.m_bgMaterial = createSdfTextMaterial({\n                fontCatalog: params.fontCatalog,\n                isBackground: true\n            });\n        } else {\n            this.m_ownsBgMaterial = false;\n            this.m_bgMaterial = params.backgroundMaterial;\n        }\n\n        this.m_defaultLayer = {\n            id: DEFAULT_TEXT_CANVAS_LAYER,\n            storage: new TextGeometry(\n                new THREE.Scene(),\n                this.m_material,\n                this.m_bgMaterial,\n                this.minGlyphCount,\n                this.maxGlyphCount\n            )\n        };\n        this.m_layers = [this.m_defaultLayer];\n\n        this.m_defaultTextRenderStyle = new TextRenderStyle();\n        this.m_currentTextRenderStyle = this.m_defaultTextRenderStyle;\n        this.m_defaultTextLayoutStyle = new TextLayoutStyle();\n        this.m_currentTextLayoutStyle = this.m_defaultTextLayoutStyle;\n\n        this.m_lineTypesetter = new LineTypesetter();\n        this.m_pathTypesetter = new PathTypesetter();\n    }\n\n    /**\n     * Currently active [[FontCatalog]].\n     */\n    get fontCatalog(): FontCatalog {\n        return this.m_fontCatalog;\n    }\n    set fontCatalog(value: FontCatalog) {\n        this.m_fontCatalog = value;\n\n        const material = this.m_material as THREE.RawShaderMaterial;\n        material.uniforms.sdfTexture.value = this.m_fontCatalog.texture;\n        material.uniforms.sdfParams.value = new THREE.Vector4(\n            this.m_fontCatalog.textureSize.x,\n            this.m_fontCatalog.textureSize.y,\n            this.m_fontCatalog.size,\n            this.m_fontCatalog.distanceRange\n        );\n        material.defines.MSDF = this.m_fontCatalog.type === \"msdf\" ? 1.0 : 0.0;\n\n        const bgMaterial = this.m_bgMaterial as THREE.RawShaderMaterial;\n        bgMaterial.uniforms.sdfTexture.value = this.m_fontCatalog.texture;\n        bgMaterial.uniforms.sdfParams.value = new THREE.Vector4(\n            this.m_fontCatalog.textureSize.x,\n            this.m_fontCatalog.textureSize.y,\n            this.m_fontCatalog.size,\n            this.m_fontCatalog.distanceRange\n        );\n        bgMaterial.defines.MSDF = this.m_fontCatalog.type === \"msdf\" ? 1.0 : 0.0;\n    }\n\n    /**\n     * Currently active text rendering material.\n     */\n    get material(): THREE.Material {\n        return this.m_material;\n    }\n    set material(value: THREE.Material) {\n        if (this.m_ownsMaterial) {\n            this.m_material.dispose();\n            this.m_ownsMaterial = false;\n        }\n\n        this.m_material = value;\n        for (const layer of this.m_layers) {\n            layer.storage.mesh.material = this.m_material;\n        }\n    }\n\n    /**\n     * Currently active text background rendering material.\n     */\n    get backgroundMaterial(): THREE.Material {\n        return this.m_bgMaterial;\n    }\n    set backgroundMaterial(value: THREE.Material) {\n        if (this.m_ownsBgMaterial) {\n            this.m_bgMaterial.dispose();\n            this.m_ownsBgMaterial = false;\n        }\n\n        this.m_bgMaterial = value;\n        for (const layer of this.m_layers) {\n            layer.storage.backgroundMesh.material = this.m_bgMaterial;\n        }\n    }\n\n    /**\n     * Currently active text rendering style.\n     */\n    get textRenderStyle(): TextRenderStyle {\n        return this.m_currentTextRenderStyle;\n    }\n    set textRenderStyle(style: TextRenderStyle) {\n        this.m_currentTextRenderStyle = style;\n    }\n\n    /**\n     * Currently active text layout style.\n     */\n    get textLayoutStyle(): TextLayoutStyle {\n        return this.m_currentTextLayoutStyle;\n    }\n    set textLayoutStyle(style: TextLayoutStyle) {\n        this.m_currentTextLayoutStyle = style;\n    }\n\n    /**\n     * Clears all the placed glyphs in this `TextCanvas` (as well as resetting the current style).\n     */\n    clear() {\n        for (const layer of this.m_layers) {\n            layer.storage.clear();\n        }\n        this.m_currentTextRenderStyle = this.m_defaultTextRenderStyle;\n    }\n\n    /**\n     * Renders the content of this `TextCanvas`.\n     *\n     * @param camera Orthographic camera.\n     * @param target Optional render target.\n     * @param clear Optional render target clear operation.\n     */\n    render(camera: THREE.OrthographicCamera, target?: THREE.WebGLRenderTarget, clear?: boolean) {\n        this.m_fontCatalog.update(this.m_renderer);\n        let oldTarget: THREE.RenderTarget | null = null;\n        if (target !== undefined) {\n            oldTarget = this.m_renderer.getRenderTarget();\n            this.m_renderer.setRenderTarget(target);\n        }\n        if (clear === true) {\n            this.m_renderer.clear(true);\n        }\n        for (const layer of this.m_layers) {\n            layer.storage.update();\n            this.m_renderer.clear(false, true);\n            this.m_renderer.render(layer.storage.scene, camera);\n        }\n        if (target !== undefined) {\n            this.m_renderer.setRenderTarget(oldTarget);\n        }\n    }\n\n    /**\n     * Creates a new `TextCanvas` rendering layer and returns. If there was already a layer for the\n     * input `layerId`, it just returns this one instead.\n     *\n     * @param layerId Desired layer identifier.\n     *\n     * @returns Created [[TextCanvasLayer]].\n     */\n    addLayer(layerId: number): TextCanvasLayer {\n        let result = this.getLayer(layerId);\n        if (result === undefined) {\n            result = {\n                id: layerId,\n                storage: new TextGeometry(\n                    new THREE.Scene(),\n                    this.m_material,\n                    this.m_bgMaterial,\n                    this.minGlyphCount,\n                    this.maxGlyphCount\n                )\n            };\n\n            this.m_layers.push(result);\n            this.m_layers.sort((a: TextCanvasLayer, b: TextCanvasLayer) => {\n                return a.id - b.id;\n            });\n        }\n        return result;\n    }\n\n    /**\n     * Retrieves a specific `TextCanvas` rendering layer.\n     *\n     * @param layerId Desired layer identifier.\n     *\n     * @returns Selected [[TextCanvasLayer]].\n     */\n    getLayer(layerId: number): TextCanvasLayer | undefined {\n        return this.m_layers.find(layer => layer.id === layerId);\n    }\n\n    /**\n     * Retrieves all `TextCanvas` rendering layers.\n     *\n     * @returns Array of [[TextCanvasLayer]]s.\n     */\n    getAllLayers(): TextCanvasLayer[] {\n        return this.m_layers;\n    }\n\n    /**\n     * Returns the computed bounding box for the input text. The current [[TextRenderStyle]] and\n     * [[TextLayoutStyle]] will influence the results of this function.\n     *\n     * @param text Input text. Provide an array of [[GlyphData]] for better performance.\n     * @param outputBounds Output text bounding box.\n     * @param params Optional measurement parameters.\n     *\n     * @returns Result of the measurement. If `false`, some error occurred during execution and the\n     * input text couldn't be properly measured.\n     */\n    measureText(\n        text: string | GlyphData[],\n        outputBounds: THREE.Box2,\n        params?: MeasurementParameters\n    ): boolean {\n        tempTextPosition.set(0, 0, 0);\n\n        let path;\n        let pathOverflow;\n        let upperCaseArray;\n        let outputCharacterBounds;\n        if (params !== undefined) {\n            path = params.path;\n            pathOverflow = params.pathOverflow;\n            outputCharacterBounds = params.outputCharacterBounds;\n            if (params.path !== undefined) {\n                const pathOrigin = params.path.getPoint(0);\n                if (pathOrigin === null) {\n                    return false;\n                }\n                tempTextPosition.set(pathOrigin.x, pathOrigin.y, 0.0);\n            }\n            if (params.letterCaseArray) {\n                upperCaseArray = params.letterCaseArray;\n            }\n        }\n\n        return this.placeText({\n            input: text,\n            layer: this.m_defaultLayer,\n            textPath: path,\n            textPathOverflow: pathOverflow,\n            bounds: outputBounds,\n            individualBounds: outputCharacterBounds,\n            letterCaseArray: upperCaseArray\n        });\n    }\n\n    /**\n     * Adds the input text to this `TextCanvas` in the specified screen position. The current\n     * [[TextRenderStyle]] and [[TextLayoutStyle]] will influence the results of this function.\n     *\n     * @param text Input text. Provide an array of [[GlyphData]] for better performance.\n     * @param position Screen position.\n     * @param params Optional addition parameters.\n     *\n     * @returns Result of the addition. If `false`, some error occurred during execution and the\n     * input text couldn't be properly added.\n     */\n    addText(\n        text: string | GlyphData[],\n        position: THREE.Vector3,\n        params?: AdditionParameters\n    ): boolean {\n        tempTextPosition.copy(position);\n\n        let path;\n        let pathOverflow;\n        let upperCaseArray;\n        let targetLayer = this.m_defaultLayer;\n        if (params !== undefined) {\n            path = params.path;\n            pathOverflow = params.pathOverflow;\n            if (params.layer !== undefined) {\n                let tempLayer = this.getLayer(params.layer);\n                if (tempLayer === undefined) {\n                    tempLayer = this.addLayer(params.layer);\n                }\n                targetLayer = tempLayer;\n            }\n            if (params.path !== undefined) {\n                tempTextPosition.set(0, 0, tempTextPosition.z);\n            }\n            if (params.letterCaseArray) {\n                upperCaseArray = params.letterCaseArray;\n            }\n        }\n        const prevDrawCount = targetLayer.storage.drawCount;\n\n        const result = this.placeText({\n            input: text,\n            textPath: path,\n            textPathOverflow: pathOverflow,\n            layer: targetLayer,\n            letterCaseArray: upperCaseArray\n        });\n        if (result && params !== undefined) {\n            if (params.updatePosition === true) {\n                position.copy(tempTextPosition);\n            }\n            if (params.pickingData !== undefined) {\n                targetLayer.storage.addPickingData(\n                    prevDrawCount,\n                    targetLayer.storage.drawCount,\n                    params.pickingData\n                );\n            }\n        } else if (!result) {\n            (targetLayer.storage as any).m_drawCount = prevDrawCount;\n        }\n        return result;\n    }\n\n    /**\n     * Creates a new [[TextBufferObject]]. The computed text vertex buffer is equivalent to the\n     * result of performing the `addText` function for the input text in the screen origin.\n     *\n     * @param text Input text. Provide an array of [[GlyphData]] for better performance.\n     * @param params Optional creation parameters.\n     *\n     * @returns New [[TextBufferObject]] (or `undefined` if requested text glyphs couldn't be\n     * retrieved from the current [[FontCatalog]]).\n     */\n    createTextBufferObject(\n        text: string | GlyphData[],\n        params?: TextBufferCreationParameters\n    ): TextBufferObject | undefined {\n        tempTextPosition.set(0, 0, 0);\n\n        let glyphArray;\n        let upperCaseArray: boolean[] | undefined;\n        const smallCapsEnabled =\n            this.m_currentTextRenderStyle.fontVariant === FontVariant.SmallCaps;\n        if (typeof text !== \"string\") {\n            glyphArray = text;\n            if (params !== undefined && params.letterCaseArray) {\n                upperCaseArray = params.letterCaseArray;\n            }\n        } else {\n            upperCaseArray = [];\n            glyphArray = this.m_fontCatalog.getGlyphs(\n                text,\n                this.m_currentTextRenderStyle,\n                smallCapsEnabled ? upperCaseArray : undefined\n            );\n            if (glyphArray === undefined) {\n                return undefined;\n            }\n        }\n\n        let path;\n        let pathOverflow;\n        let textBounds;\n        let characterBounds;\n        let renderStyle;\n        let layoutStyle;\n        if (params !== undefined) {\n            path = params.path;\n            pathOverflow = params.pathOverflow;\n            if (params.outputBounds === true) {\n                textBounds = new THREE.Box2();\n            }\n            if (params.outputCharacterBounds === true) {\n                characterBounds = [];\n            }\n            if (params.storeStyles === true) {\n                renderStyle = this.m_currentTextRenderStyle;\n                layoutStyle = this.m_currentTextLayoutStyle;\n            }\n        }\n\n        this.placeText({\n            input: text,\n            layer: this.m_defaultLayer,\n            computeTextBuffer: true,\n            textPath: path,\n            textPathOverflow: pathOverflow,\n            bounds: textBounds,\n            individualBounds: characterBounds,\n            letterCaseArray: upperCaseArray\n        });\n\n        return new TextBufferObject(\n            glyphArray,\n            new Float32Array(tempVertexBuffer),\n            textBounds,\n            characterBounds,\n            renderStyle,\n            layoutStyle\n        );\n    }\n\n    /**\n     * Adds a previously created [[TextBufferObject]] to the `TextCanvas`. Additional parameters can\n     * be provided to override the attributes stored in the buffer.\n     *\n     * @param textBufferObject [[TextBufferObject]] to add.\n     * @param params Optional addition parameters.\n     *\n     * @returns Result of the addition. If `false`, some error occurred during execution and the\n     * input text couldn't be properly added.\n     */\n    addTextBufferObject(\n        textBufferObject: TextBufferObject,\n        params?: TextBufferAdditionParameters\n    ): boolean {\n        let targetLayer = this.m_defaultLayer;\n        let position;\n        let scale;\n        let rotation;\n        let color;\n        let opacity;\n        let bgColor;\n        let bgOpacity;\n\n        if (params !== undefined) {\n            if (params.layer !== undefined) {\n                let tempLayer = this.getLayer(params.layer);\n                if (tempLayer === undefined) {\n                    tempLayer = this.addLayer(params.layer);\n                }\n                targetLayer = tempLayer;\n            }\n            position = params.position;\n            scale = params.scale;\n            rotation = params.rotation;\n            color = params.color;\n            opacity = params.opacity;\n            bgColor = params.backgroundColor;\n            bgOpacity = params.backgroundOpacity;\n        }\n        const prevDrawCount = targetLayer.storage.drawCount;\n\n        const result = targetLayer.storage.addTextBufferObject(\n            textBufferObject,\n            position,\n            scale,\n            rotation,\n            color,\n            opacity,\n            bgColor,\n            bgOpacity\n        );\n        if (result && params !== undefined) {\n            if (params.pickingData !== undefined) {\n                targetLayer.storage.addPickingData(\n                    prevDrawCount,\n                    targetLayer.storage.drawCount,\n                    params.pickingData\n                );\n            }\n        } else if (!result) {\n            (targetLayer.storage as any).m_drawCount = prevDrawCount;\n        }\n        return result;\n    }\n\n    /**\n     * Executes the `pickCallback` for all previously stored picking data for text covering the\n     * specified screen position.\n     *\n     * @param screenPosition Screen coordinate of picking position.\n     * @param pickCallback Callback to be called for every picked element.\n     */\n    pickText(position: THREE.Vector2, callback: (pickData: any | undefined) => void): void {\n        for (const layer of this.m_layers) {\n            layer.storage.pick(position, callback);\n        }\n    }\n\n    /**\n     * Update the info with the memory footprint caused by objects owned by the `TextCanvas`.\n     *\n     * @param info The info object to increment with the values from this `TextCanvas`.\n     */\n    getMemoryUsage(info: MemoryUsage) {\n        this.m_fontCatalog.updateMemoryUsage(info);\n\n        for (const layer of this.m_layers) {\n            layer.storage.updateMemoryUsage(info);\n        }\n    }\n\n    // Places all glyphs for input text. Depending on parameters, it can store the resulting glyphs\n    // in the current [[TextGeometry]] (or into a separate buffer) or compute the bounding box for\n    // the input (as a whole or on a per-character basis).\n    private placeText(params: TextPlacementParameters): boolean {\n        if (params.input.length === 0 || this.m_currentTextLayoutStyle.maxLines! === 0) {\n            if (params.bounds !== undefined) {\n                params.bounds.min.set(0, 0);\n                params.bounds.max.set(0, 0);\n            }\n            if (params.individualBounds !== undefined) {\n                params.individualBounds.length = 0;\n            }\n            return true;\n        }\n\n        let glyphArray;\n        let smallCapsTransformations: boolean[] | undefined;\n        const smallCapsEnabled =\n            this.m_currentTextRenderStyle.fontVariant === FontVariant.SmallCaps;\n        if (typeof params.input !== \"string\") {\n            glyphArray = params.input;\n            if (params.letterCaseArray) {\n                smallCapsTransformations = params.letterCaseArray;\n            }\n        } else {\n            smallCapsTransformations = [];\n            glyphArray = this.m_fontCatalog.getGlyphs(\n                params.input,\n                this.m_currentTextRenderStyle,\n                smallCapsEnabled ? smallCapsTransformations : undefined\n            );\n            if (glyphArray === undefined) {\n                return false;\n            }\n        }\n\n        let glyphBounds;\n        if (params.individualBounds !== undefined) {\n            tempTextBounds.array = params.individualBounds;\n            tempTextBounds.offset = 0;\n            glyphBounds = tempTextBounds;\n        }\n        if (params.bounds !== undefined) {\n            params.bounds.min.set(Infinity, Infinity);\n            params.bounds.max.set(-Infinity, -Infinity);\n        }\n        if (params.computeTextBuffer === true) {\n            tempVertexBuffer = new Float32Array(glyphArray.length * QUAD_VERTEX_MEMORY_FOOTPRINT);\n        }\n\n        const isPath = params.textPath !== undefined;\n        const typesettingParams: TypesettingParameters | PathTypesettingParameters = {\n            glyphs: glyphArray,\n            fontCatalog: this.m_fontCatalog,\n            textRenderStyle: this.m_currentTextRenderStyle,\n            textLayoutStyle: this.m_currentTextLayoutStyle,\n            position: tempTextPosition,\n            geometry: params.layer.storage,\n            smallCapsArray: smallCapsEnabled ? smallCapsTransformations : undefined,\n            globalBounds: params.bounds,\n            individualBounds: glyphBounds,\n            vertexBuffer: params.computeTextBuffer === true ? tempVertexBuffer : undefined\n        };\n\n        let result = true;\n        if (isPath) {\n            Object.assign(typesettingParams as PathTypesettingParameters, {\n                path: params.textPath,\n                pathOverflow: params.textPathOverflow === true\n            });\n            result = this.m_pathTypesetter.arrangeGlyphs(\n                typesettingParams as PathTypesettingParameters\n            );\n        } else {\n            result = this.m_lineTypesetter.arrangeGlyphs(typesettingParams);\n        }\n        if (glyphBounds !== undefined) {\n            glyphBounds.array.length = glyphBounds.offset;\n        }\n\n        return result;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { QUAD_VERTEX_MEMORY_FOOTPRINT } from \"../rendering/TextGeometry\";\nimport { FontStyle, FontVariant, WrappingMode } from \"../rendering/TextStyle\";\nimport { TypesettingUtils } from \"../utils/TypesettingUtils\";\nimport { UnicodeUtils } from \"../utils/UnicodeUtils\";\nimport { Typesetter, TypesettingParameters } from \"./Typesetter\";\n\n/**\n * @hidden\n * [[Typesetter]] implementation that handles multi-line complex layout text.\n */\nexport class LineTypesetter implements Typesetter {\n    private m_tempTransform: THREE.Matrix3;\n    private m_tempCorners: THREE.Vector3[];\n    private m_tempLineDirection: UnicodeUtils.Direction;\n    private m_tempRunDirection: UnicodeUtils.Direction;\n    private m_tempPixelSize: number;\n    private m_tempPixelBgSize: number;\n    private m_tempScale: number;\n    private m_tempSmallCaps: boolean;\n\n    private m_currentParams?: TypesettingParameters;\n\n    /**\n     * Creates a `LineTypesetter` object.\n     *\n     * @returns New `LineTypesetter`.\n     */\n    constructor() {\n        this.m_tempTransform = new THREE.Matrix3();\n        this.m_tempCorners = [\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3()\n        ];\n        this.m_tempLineDirection = UnicodeUtils.Direction.LTR;\n        this.m_tempRunDirection = UnicodeUtils.Direction.LTR;\n        this.m_tempPixelSize = 1.0;\n        this.m_tempPixelBgSize = 1.0;\n        this.m_tempScale = 1.0;\n        this.m_tempSmallCaps = false;\n    }\n\n    /**\n     * Arranges the specified glyphs using this `LineTypesetter`. Text will be placed into multiple\n     * bidirectional lines, that will be generated taking into account [[textLayoutStyle]] features,\n     * such as:\n     * - Maximum line width.\n     * - Word and character wrapping.\n     * - Maximum number of lines.\n     * - Vertical and horizontal alignment.\n     * - Leading (spacing between lines).\n     *\n     * @param params Typesetting parameters.\n     *\n     * @returns If `false`, some error occurred during execution and the output should be dismissed.\n     */\n    arrangeGlyphs(params: TypesettingParameters): boolean {\n        // Initializes common typesetting parameters (used across all functions in this class).\n        this.m_currentParams = params;\n        this.m_tempLineDirection = TypesettingUtils.getDirection(this.m_currentParams.glyphs, 0);\n        this.m_tempRunDirection = this.m_tempLineDirection;\n        this.m_tempPixelSize = TypesettingUtils.getPixelSize(\n            this.m_currentParams.textRenderStyle.fontSize.size,\n            this.m_currentParams.textRenderStyle.fontSize.unit,\n            this.m_currentParams.fontCatalog.size\n        );\n        this.m_tempScale = this.m_tempPixelSize / this.m_currentParams.fontCatalog.size;\n        this.m_tempPixelBgSize = Math.min(\n            TypesettingUtils.getPixelSize(\n                this.m_currentParams.textRenderStyle.fontSize.backgroundSize,\n                this.m_currentParams.textRenderStyle.fontSize.unit,\n                this.m_currentParams.fontCatalog.size\n            ),\n            this.m_currentParams!.fontCatalog.distanceRange * this.m_tempScale\n        );\n        this.m_tempSmallCaps = this.m_currentParams!.smallCapsArray !== undefined;\n\n        this.m_currentParams.position.y +=\n            this.m_currentParams.textLayoutStyle.verticalAlignment *\n            this.m_currentParams.glyphs[0].font.metrics.capHeight *\n            this.m_tempScale;\n\n        const isOnlyMeasured =\n            this.m_currentParams.globalBounds !== undefined &&\n            this.m_currentParams.vertexBuffer === undefined;\n\n        // Compute line origin and height.\n        const origin = this.m_currentParams.position.x;\n        const lineHeight =\n            this.m_currentParams.glyphs[0].font.metrics.lineHeight +\n            this.m_currentParams.textLayoutStyle.leading;\n\n        // Initialize line-breaking and wrapping variables.\n        let lineStartIdx = 0;\n        let glyphWrapIdx = 0;\n        let wordWrapIdx = 0;\n        let lineStartX = 0;\n        let lineCurrX = 0;\n        let glyphWrapX = 0;\n        let wordWrapX = 0;\n\n        let lineCount = 0;\n        let isBidirectionalLine = false;\n        for (let i = 0; i < this.m_currentParams.glyphs.length; ++i) {\n            if (lineCount > this.m_currentParams.textLayoutStyle.maxLines - 1) {\n                break;\n            }\n            const glyphData = this.m_currentParams.glyphs[i];\n            if (!glyphData.isInCache && !isOnlyMeasured) {\n                return false;\n            }\n\n            const isNewLine = UnicodeUtils.isNewLine(glyphData.codePoint);\n            const isWhiteSpace = UnicodeUtils.isWhiteSpace(glyphData.codePoint);\n\n            // Check if this line should be treated as bidirectional.\n            if (!isBidirectionalLine && glyphData.direction === -this.m_tempLineDirection) {\n                isBidirectionalLine = true;\n            }\n            // Advance the line's current X offset (only for printable characters).\n            if (UnicodeUtils.isPrintable(glyphData.codePoint)) {\n                lineCurrX +=\n                    (glyphData.advanceX + this.m_currentParams.textLayoutStyle.tracking) *\n                    this.m_tempScale *\n                    (this.m_tempSmallCaps\n                        ? TypesettingUtils.getSmallCapsScale(\n                              this.m_currentParams.glyphs,\n                              this.m_currentParams.smallCapsArray!,\n                              i,\n                              this.m_currentParams.textRenderStyle.fontVariant\n                          )\n                        : 1.0);\n            }\n            // If this is the first character in a line, update the line's X offset values (needed\n            // to properly center and wrap).\n            if (i === lineStartIdx) {\n                lineStartX = lineCurrX;\n                glyphWrapX = lineCurrX;\n                wordWrapX = lineCurrX;\n            }\n\n            // Check if should break the current line.\n            if (\n                isNewLine ||\n                (this.m_currentParams.textLayoutStyle.wrappingMode === WrappingMode.Character &&\n                    lineCurrX > this.m_currentParams.textLayoutStyle.lineWidth) ||\n                (this.m_currentParams.textLayoutStyle.wrappingMode === WrappingMode.Word &&\n                    lineCurrX > this.m_currentParams.textLayoutStyle.lineWidth &&\n                    wordWrapX !== lineStartX)\n            ) {\n                // Perform wrapping.\n                if (this.m_currentParams.textLayoutStyle.wrappingMode !== WrappingMode.None) {\n                    let wrapPointIdx = glyphWrapIdx;\n                    let wrapPointX = glyphWrapX;\n                    // Only wrap words when more than a single word fits into the current line.\n                    if (\n                        this.m_currentParams.textLayoutStyle.wrappingMode === WrappingMode.Word &&\n                        wordWrapX !== lineStartX\n                    ) {\n                        wrapPointIdx = wordWrapIdx;\n                        wrapPointX = wordWrapX;\n                    }\n\n                    lineCurrX = wrapPointX;\n                    i = Math.min(\n                        isNewLine ? (lineStartIdx === i ? wrapPointIdx : i) : wrapPointIdx,\n                        this.m_currentParams.glyphs.length - 1\n                    );\n                }\n\n                // Calculate the correct starting position for the line base on alignment, and place\n                // all glyphs in it.\n                const lineAlignment =\n                    this.m_tempLineDirection === UnicodeUtils.Direction.RTL && isBidirectionalLine\n                        ? 1.0 + this.m_currentParams.textLayoutStyle.horizontalAlignment\n                        : this.m_currentParams.textLayoutStyle.horizontalAlignment;\n                this.m_currentParams.position.x =\n                    this.m_currentParams.position.x + lineCurrX * lineAlignment;\n                if (\n                    !this.placeLine(lineStartIdx, i, this.m_tempLineDirection, isBidirectionalLine)\n                ) {\n                    return false;\n                }\n\n                // Update the line position.\n                this.m_currentParams.position.y -= lineHeight * this.m_tempScale;\n                this.m_currentParams.position.x = origin;\n\n                // Find the beginning of a new line (removing trailing white spaces).\n                while (\n                    i !== lineStartIdx &&\n                    i + 1 < this.m_currentParams.glyphs.length &&\n                    UnicodeUtils.isWhiteSpace(this.m_currentParams.glyphs[i + 1].codePoint)\n                ) {\n                    ++i;\n                }\n                lineStartIdx = i + 1;\n                if (lineStartIdx === this.m_currentParams.glyphs.length) {\n                    break;\n                }\n\n                // Only reset the line's direction when a new line character is found (to keep\n                // correct bidirectional behaviour when a bidirectional run is placed between\n                // multiple lines).\n                if (isNewLine) {\n                    this.m_tempLineDirection = TypesettingUtils.getDirection(\n                        this.m_currentParams.glyphs,\n                        lineStartIdx\n                    );\n                    this.m_tempRunDirection = this.m_tempLineDirection;\n                }\n\n                // Reset the line placement parameters.\n                lineStartX = 0;\n                lineCurrX = 0;\n                glyphWrapIdx = lineStartIdx;\n                glyphWrapX = 0;\n                wordWrapIdx = lineStartIdx;\n                wordWrapX = 0;\n                isBidirectionalLine = false;\n                lineCount++;\n            }\n            // If not, should if we should record any new wrapping points.\n            else if (\n                this.m_currentParams.textLayoutStyle.wrappingMode !== WrappingMode.None &&\n                !isWhiteSpace\n            ) {\n                // Update the per-glyph wrapping point.\n                glyphWrapIdx = i;\n                glyphWrapX = lineCurrX;\n\n                // Update the word wrapping point (only if mode is correctly set and we are\n                // currently placed at the end of a word).\n                if (\n                    this.m_currentParams.textLayoutStyle.wrappingMode === WrappingMode.Word &&\n                    i + 1 < this.m_currentParams.glyphs.length &&\n                    (UnicodeUtils.isWhiteSpace(this.m_currentParams.glyphs[i + 1].codePoint) ||\n                        UnicodeUtils.isNewLine(this.m_currentParams.glyphs[i + 1].codePoint))\n                ) {\n                    wordWrapIdx = i;\n                    wordWrapX = lineCurrX;\n                }\n            }\n        }\n\n        // If we still haven't placed all characters, place a final line.\n        if (\n            lineCount <= this.m_currentParams.textLayoutStyle.maxLines - 1 &&\n            lineStartIdx <= this.m_currentParams.glyphs.length - 1\n        ) {\n            const offset =\n                this.m_tempLineDirection === UnicodeUtils.Direction.RTL && isBidirectionalLine\n                    ? 1.0 + this.m_currentParams.textLayoutStyle.horizontalAlignment\n                    : this.m_currentParams.textLayoutStyle.horizontalAlignment;\n            this.m_currentParams.position.setX(\n                this.m_currentParams.position.x + lineCurrX * offset\n            );\n            if (\n                !this.placeLine(\n                    lineStartIdx,\n                    this.m_currentParams.glyphs.length - 1,\n                    this.m_tempLineDirection,\n                    isBidirectionalLine\n                )\n            ) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    // Place characters alongside a line. Text direction is taken into account, and text is broken\n    // into directional runs.\n    private placeLine(\n        startIdx: number,\n        endIdx: number,\n        direction: UnicodeUtils.Direction,\n        isBidirectional: boolean\n    ): boolean {\n        // If the line is not bidirectional, place it as a single directional run.\n        if (!isBidirectional) {\n            return this.placeRun(startIdx, endIdx, direction);\n        }\n\n        // Gather common typesetting parameters.\n        const glyphDataArray = this.m_currentParams!.glyphs;\n        const smallCapsArray = this.m_currentParams!.smallCapsArray;\n        const textRenderStyle = this.m_currentParams!.textRenderStyle;\n        const textLayoutStyle = this.m_currentParams!.textLayoutStyle;\n        const position = this.m_currentParams!.position;\n\n        // Initialize line placement parameters.\n        const isRTL = direction === UnicodeUtils.Direction.RTL;\n        const origin = position.x;\n        let offset = 0;\n        let runStart = startIdx;\n\n        for (let i = startIdx; i <= endIdx; ++i) {\n            const glyphData = glyphDataArray[i];\n\n            // If the current glyph changes the line direction, place the current run.\n            if (glyphData.direction === -this.m_tempRunDirection) {\n                if (isRTL) {\n                    position.x = origin + offset;\n                }\n                if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {\n                    return false;\n                }\n                if (!isRTL) {\n                    position.x = origin + offset;\n                }\n\n                runStart = i;\n                this.m_tempRunDirection *= -1.0;\n            }\n            // If the current glyph has neutral direction (i.e. white space) and we're in the middle\n            // of a run with direction opposite to the line's main direction, check for the closest\n            // strong direction in the run.\n            else if (\n                glyphData.direction === UnicodeUtils.Direction.Neutral &&\n                this.m_tempRunDirection === -direction\n            ) {\n                let neutralIdx = i;\n                while (\n                    neutralIdx + 1 < glyphDataArray.length &&\n                    Math.abs(glyphDataArray[neutralIdx].direction) !== 1\n                ) {\n                    ++neutralIdx;\n                }\n\n                // If the closest strong direction in the run is not the current run's direction,\n                // place the current run.\n                if (glyphDataArray[neutralIdx].direction !== this.m_tempRunDirection) {\n                    if (isRTL) {\n                        position.x = origin + offset;\n                    }\n                    if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {\n                        return false;\n                    }\n                    if (!isRTL) {\n                        position.x = origin + offset;\n                    }\n\n                    runStart = i;\n                    this.m_tempRunDirection *= -1.0;\n                }\n            }\n\n            // Advance the offset position in the line.\n            offset +=\n                (glyphData.advanceX + textLayoutStyle.tracking) *\n                this.m_tempScale *\n                (this.m_tempSmallCaps\n                    ? TypesettingUtils.getSmallCapsScale(\n                          glyphDataArray,\n                          smallCapsArray!,\n                          i,\n                          textRenderStyle.fontVariant\n                      )\n                    : 1.0) *\n                direction;\n        }\n\n        // If we still haven't placed all characters in the line, place a final run.\n        if (runStart <= endIdx) {\n            if (isRTL) {\n                position.x = origin + offset;\n            }\n            if (!this.placeRun(runStart, endIdx, this.m_tempRunDirection)) {\n                return false;\n            }\n            if (!isRTL) {\n                position.x = origin + offset;\n            }\n        }\n\n        return true;\n    }\n\n    // Place a directional run of index inside a line.\n    private placeRun(startIdx: number, endIdx: number, direction: UnicodeUtils.Direction): boolean {\n        // Gather common typesetting parameters.\n        const glyphDataArray = this.m_currentParams!.glyphs;\n        const smallCapsArray = this.m_currentParams!.smallCapsArray;\n        const fontCatalog = this.m_currentParams!.fontCatalog;\n        const textRenderStyle = this.m_currentParams!.textRenderStyle;\n        const textLayoutStyle = this.m_currentParams!.textLayoutStyle;\n        const position = this.m_currentParams!.position;\n        const geometry = this.m_currentParams!.geometry;\n        const globalBounds = this.m_currentParams!.globalBounds;\n        const individualBounds = this.m_currentParams!.individualBounds;\n        const vertexBuffer = this.m_currentParams!.vertexBuffer;\n\n        // Move through the glyph array following the run's direction (as the order of the glyphs in\n        // memory might not match the order on glyphs on scree).\n        const start = direction === UnicodeUtils.Direction.LTR ? startIdx : endIdx;\n        const end = direction === UnicodeUtils.Direction.LTR ? endIdx : startIdx;\n        for (\n            let i = start;\n            direction === UnicodeUtils.Direction.RTL ? i >= end : i <= end;\n            i += direction\n        ) {\n            // Only process printable characters.\n            const glyphData = glyphDataArray[i];\n            if (!UnicodeUtils.isPrintable(glyphData.codePoint)) {\n                continue;\n            }\n\n            // When placing a RTL run, we need to check for weak runs (numerical runs of characters\n            // that don't change the overall run direction, but should always be displayed as LTR\n            // text).\n            if (\n                startIdx !== endIdx &&\n                i !== 0 &&\n                direction === UnicodeUtils.Direction.RTL &&\n                glyphData.direction === UnicodeUtils.Direction.Weak\n            ) {\n                let weakRunStart = i;\n                let weakGlyph = glyphDataArray[weakRunStart - 1];\n                while (\n                    weakRunStart !== startIdx &&\n                    (weakGlyph.direction === UnicodeUtils.Direction.Weak ||\n                        (weakGlyph.direction === UnicodeUtils.Direction.Neutral &&\n                            !UnicodeUtils.isWhiteSpace(weakGlyph.codePoint)))\n                ) {\n                    --weakRunStart;\n                    weakGlyph = glyphDataArray[weakRunStart - 1];\n                }\n\n                this.placeRun(Math.max(weakRunStart, startIdx), i, UnicodeUtils.Direction.LTR);\n\n                i = weakRunStart;\n                continue;\n            }\n\n            // Compute various rendering parameters for this glyph.\n            const glyphFont = glyphData.font;\n            const glyphFontMetrics = glyphFont.metrics;\n            const fontStyle = textRenderStyle.fontStyle;\n\n            const isBoldEmulated =\n                (fontStyle === FontStyle.Bold && glyphFont.bold === undefined) ||\n                (fontStyle === FontStyle.BoldItalic &&\n                    glyphFont.bold === undefined &&\n                    glyphFont.boldItalic === undefined);\n            const isItalicEmulated =\n                (fontStyle === FontStyle.Italic && glyphFont.italic === undefined) ||\n                (fontStyle === FontStyle.BoldItalic &&\n                    glyphFont.italic === undefined &&\n                    glyphFont.boldItalic === undefined);\n\n            const isSmallCaps = this.m_tempSmallCaps\n                ? smallCapsArray![i] && textRenderStyle.fontVariant === FontVariant.SmallCaps\n                : false;\n            const smallCapsScale = isSmallCaps\n                ? glyphFontMetrics.xHeight / glyphFontMetrics.capHeight\n                : 1.0;\n            const glyphScale = this.m_tempScale * smallCapsScale;\n\n            const emulationWeight =\n                ((isBoldEmulated ? 0.02 : 0.0) + (isSmallCaps ? 0.01 : 0.0)) *\n                (fontCatalog.size / fontCatalog.distanceRange);\n            const bgWeight =\n                (0.5 * this.m_tempPixelBgSize!) /\n                (fontCatalog.distanceRange * Math.max(glyphScale, 1.0));\n            const isMirrored =\n                UnicodeUtils.isRtlMirrored(glyphData.codePoint) &&\n                direction === UnicodeUtils.Direction.RTL;\n            const verticalOffset =\n                glyphFontMetrics.lineHeight -\n                glyphFontMetrics.base -\n                glyphFontMetrics.distanceRange * 0.5;\n\n            // Compute the glyphs transformation matrix and apply to all corners of a glyph.\n            TypesettingUtils.computeGlyphTransform(\n                this.m_tempTransform,\n                position,\n                glyphScale,\n                textLayoutStyle.canvasRotation,\n                textRenderStyle.rotation\n            );\n            for (let j = 0; j < 4; ++j) {\n                const glyphVertexPosition = glyphData.positions[j];\n                const horizontalOffset =\n                    isItalicEmulated && j > 1\n                        ? TypesettingUtils.OBLIQUE_OFFSET * glyphFontMetrics.size\n                        : 0.0;\n                this.m_tempCorners[j].set(\n                    glyphVertexPosition.x + horizontalOffset,\n                    glyphVertexPosition.y - verticalOffset,\n                    glyphVertexPosition.z\n                );\n                this.m_tempCorners[j].applyMatrix3(this.m_tempTransform);\n            }\n\n            // Depending on the typesetting options, add the computed glyph to the TextGeometry or\n            // update the text bounds.\n            if (globalBounds === undefined && vertexBuffer === undefined) {\n                if (\n                    !geometry.add(\n                        glyphData,\n                        this.m_tempCorners,\n                        emulationWeight,\n                        emulationWeight + bgWeight,\n                        isMirrored,\n                        textRenderStyle\n                    )\n                ) {\n                    return false;\n                }\n            } else {\n                if (globalBounds !== undefined) {\n                    TypesettingUtils.updateBounds(\n                        this.m_tempCorners,\n                        globalBounds,\n                        individualBounds\n                    );\n                }\n                if (vertexBuffer !== undefined) {\n                    geometry.addToBuffer(\n                        vertexBuffer,\n                        i * QUAD_VERTEX_MEMORY_FOOTPRINT,\n                        glyphData,\n                        this.m_tempCorners,\n                        emulationWeight,\n                        emulationWeight + bgWeight,\n                        isMirrored,\n                        textRenderStyle\n                    );\n                }\n            }\n\n            // Advance the current position and proceed to next glyph in the run.\n            position.set(\n                position.x +\n                    (glyphData.advanceX + textLayoutStyle.tracking) *\n                        glyphScale *\n                        Math.cos(textLayoutStyle.lineRotation),\n                position.y +\n                    (glyphData.advanceX + textLayoutStyle.tracking) *\n                        glyphScale *\n                        Math.sin(textLayoutStyle.lineRotation),\n                position.z\n            );\n        }\n\n        return true;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { QUAD_VERTEX_MEMORY_FOOTPRINT } from \"../rendering/TextGeometry\";\nimport { FontStyle, FontVariant } from \"../rendering/TextStyle\";\nimport { TypesettingUtils } from \"../utils/TypesettingUtils\";\nimport { UnicodeUtils } from \"../utils/UnicodeUtils\";\nimport { Typesetter, TypesettingParameters } from \"./Typesetter\";\n\n/**\n * @hidden\n * Parameters passed when placing glyphs using [[PathTypesetter]]'s `arrangeGlyphs` function.\n */\nexport interface PathTypesettingParameters extends TypesettingParameters {\n    /**\n     * Path to be followed when arranging glyphs.\n     */\n    path: THREE.Path | THREE.CurvePath<THREE.Vector2>;\n\n    /**\n     * If `true`, text on a path will be placed even when its size its bigger than the path's size.\n     */\n    pathOverflow: boolean;\n}\n\n/**\n * @hidden\n * [[Typesetter]] implementation that arranges glyphs alongside a specified path.\n */\nexport class PathTypesetter implements Typesetter {\n    private m_tempTransform: THREE.Matrix3;\n    private m_tempCorners: THREE.Vector3[];\n    private m_tempLineDirection: UnicodeUtils.Direction;\n    private m_tempRunDirection: UnicodeUtils.Direction;\n    private m_tempPixelSize: number;\n    private m_tempPixelBgSize: number;\n    private m_tempScale: number;\n    private m_tempSmallCaps: boolean;\n\n    private m_tempPathPosition: THREE.Vector3;\n    private m_tempPathLength: number;\n    private m_tempPathOffset: number;\n\n    private m_currentParams?: PathTypesettingParameters;\n\n    /**\n     * Creates a `PathTypesetter` object.\n     *\n     * @returns New `PathTypesetter`.\n     */\n    constructor() {\n        this.m_tempTransform = new THREE.Matrix3();\n        this.m_tempCorners = [\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3()\n        ];\n        this.m_tempLineDirection = UnicodeUtils.Direction.LTR;\n        this.m_tempRunDirection = UnicodeUtils.Direction.LTR;\n        this.m_tempPixelSize = 1.0;\n        this.m_tempPixelBgSize = 1.0;\n        this.m_tempScale = 1.0;\n        this.m_tempSmallCaps = false;\n\n        this.m_tempPathPosition = new THREE.Vector3();\n        this.m_tempPathLength = 0.0;\n        this.m_tempPathOffset = 0.0;\n    }\n\n    /**\n     * Arranges the specified glyphs using this `PathTypesetter`. Text will be placed into a single\n     * bidirectional line that follows the specified path. Characters will be orientated and placed\n     * alongside this path following [[TextLayout]]'s [[VerticalAlignment]] and\n     * [[HorizontalAlignment]].\n     *\n     * @param params Typesetting parameters.\n     *\n     * @returns If `false`, some error occurred during execution and the output should be dismissed.\n     */\n    arrangeGlyphs(params: PathTypesettingParameters): boolean {\n        // Initializes common typesetting parameters (used across all functions in this class).\n        this.m_currentParams = params;\n        this.m_tempLineDirection = TypesettingUtils.getDirection(this.m_currentParams.glyphs, 0);\n        this.m_tempRunDirection = this.m_tempLineDirection;\n        this.m_tempPixelSize = TypesettingUtils.getPixelSize(\n            this.m_currentParams.textRenderStyle.fontSize.size,\n            this.m_currentParams.textRenderStyle.fontSize.unit,\n            this.m_currentParams.fontCatalog.size\n        );\n        this.m_tempScale = this.m_tempPixelSize / this.m_currentParams.fontCatalog.size;\n        this.m_tempPixelBgSize = Math.min(\n            TypesettingUtils.getPixelSize(\n                this.m_currentParams.textRenderStyle.fontSize.backgroundSize,\n                this.m_currentParams.textRenderStyle.fontSize.unit,\n                this.m_currentParams.fontCatalog.size\n            ),\n            this.m_currentParams!.fontCatalog.distanceRange * this.m_tempScale\n        );\n        this.m_tempSmallCaps = this.m_currentParams!.smallCapsArray !== undefined;\n\n        this.m_tempPathLength = this.m_currentParams.path.getLength();\n        this.m_tempPathOffset = 0.0;\n\n        const isOnlyMeasured =\n            this.m_currentParams.globalBounds !== undefined &&\n            this.m_currentParams.vertexBuffer === undefined;\n\n        // To be able to properly set the horizontal alignment on a path, we need to first retrieve\n        // how much of the path the input text covers, so we can calculate the correct initial\n        // offset.\n        let isBidirectional = false;\n        let pathWidth = 0.0;\n        for (let i = 0; i < this.m_currentParams.glyphs.length; ++i) {\n            const glyphData = this.m_currentParams.glyphs[i];\n            if (!glyphData.isInCache && !isOnlyMeasured) {\n                return false;\n            }\n\n            if (!UnicodeUtils.isPrintable(glyphData.codePoint)) {\n                continue;\n            }\n            if (!isBidirectional && glyphData.direction === -this.m_tempLineDirection) {\n                isBidirectional = true;\n            }\n\n            pathWidth +=\n                (glyphData.advanceX + this.m_currentParams.textLayoutStyle.tracking) *\n                this.m_tempScale *\n                (this.m_tempSmallCaps\n                    ? TypesettingUtils.getSmallCapsScale(\n                          this.m_currentParams.glyphs,\n                          this.m_currentParams.smallCapsArray!,\n                          i,\n                          this.m_currentParams.textRenderStyle.fontVariant\n                      )\n                    : 1.0);\n        }\n        this.m_tempPathOffset = Math.min(\n            Math.max(\n                -this.m_currentParams.textLayoutStyle.horizontalAlignment +\n                    (this.m_currentParams.textLayoutStyle.horizontalAlignment * pathWidth) /\n                        this.m_tempPathLength,\n                0\n            ),\n            1\n        );\n\n        // Place the input text as a single path line.\n        return this.placeLine(this.m_tempLineDirection, isBidirectional);\n    }\n\n    // Place characters alongside a path line. Text direction is taken into account, and text is\n    // broken into directional runs.\n    private placeLine(direction: UnicodeUtils.Direction, isBidirectional: boolean): boolean {\n        // If the line is not bidirectional, place it as a single directional run.\n        if (!isBidirectional) {\n            return this.placeRun(0, this.m_currentParams!.glyphs.length - 1, direction);\n        }\n\n        // Gather common typesetting parameters.\n        const glyphDataArray = this.m_currentParams!.glyphs;\n\n        // Initialize line placement parameters.\n        let runStart = 0;\n        for (let i = runStart; i < glyphDataArray.length; ++i) {\n            const glyphData = glyphDataArray[i];\n\n            // If the current glyph changes the line direction, place the current run.\n            if (glyphData.direction === -this.m_tempRunDirection) {\n                if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {\n                    return false;\n                }\n\n                runStart = i;\n                this.m_tempRunDirection *= -1.0;\n            }\n            // If the current glyph has neutral direction (i.e. white space) and we're in the middle\n            // of a run with direction opposite to the line's main direction, check for the closest\n            // strong direction in the run.\n            else if (\n                glyphData.direction === UnicodeUtils.Direction.Neutral &&\n                this.m_tempRunDirection === -direction\n            ) {\n                let neutralIdx = i;\n                while (\n                    neutralIdx + 1 < glyphDataArray.length &&\n                    Math.abs(glyphDataArray[neutralIdx].direction) !== 1\n                ) {\n                    ++neutralIdx;\n                }\n\n                // If the closest strong direction in the run is not the current run's direction,\n                // place the current run.\n                if (glyphDataArray[neutralIdx].direction !== this.m_tempRunDirection) {\n                    if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {\n                        return false;\n                    }\n\n                    runStart = i;\n                    this.m_tempRunDirection *= -1.0;\n                }\n            }\n        }\n\n        // If we still haven't placed all characters in the line, place a final run.\n        if (runStart < glyphDataArray.length) {\n            if (!this.placeRun(runStart, glyphDataArray.length - 1, this.m_tempRunDirection)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    // Place a directional run of index inside a path line.\n    private placeRun(startIdx: number, endIdx: number, direction: UnicodeUtils.Direction): boolean {\n        // Gather common typesetting parameters.\n        const glyphDataArray = this.m_currentParams!.glyphs;\n        const smallCapsArray = this.m_currentParams!.smallCapsArray;\n        const fontCatalog = this.m_currentParams!.fontCatalog;\n        const textRenderStyle = this.m_currentParams!.textRenderStyle;\n        const textLayoutStyle = this.m_currentParams!.textLayoutStyle;\n        const position = this.m_currentParams!.position;\n        const geometry = this.m_currentParams!.geometry;\n        const globalBounds = this.m_currentParams!.globalBounds;\n        const individualBounds = this.m_currentParams!.individualBounds;\n        const vertexBuffer = this.m_currentParams!.vertexBuffer;\n        const path = this.m_currentParams!.path;\n\n        const defaultGlyphRotation = textRenderStyle.rotation;\n        const normalDisplacement =\n            textLayoutStyle.verticalAlignment *\n            glyphDataArray[0].font.metrics.capHeight *\n            this.m_tempScale;\n\n        // Move through the glyph array following the run's direction (as the order of the glyphs in\n        // memory might not match the order on glyphs on scree).\n        const start = direction === UnicodeUtils.Direction.LTR ? startIdx : endIdx;\n        const end = direction === UnicodeUtils.Direction.LTR ? endIdx : startIdx;\n        for (\n            let i = start;\n            direction === UnicodeUtils.Direction.RTL ? i >= end : i <= end;\n            i += direction\n        ) {\n            // Only process printable characters.\n            const glyphData = glyphDataArray[i];\n            if (!UnicodeUtils.isPrintable(glyphData.codePoint)) {\n                continue;\n            }\n\n            // When placing a RTL run, we need to check for weak runs (numerical runs of characters\n            // that don't change the overall run direction, but should always be displayed as LTR\n            // text).\n            if (\n                startIdx !== endIdx &&\n                i !== 0 &&\n                direction === UnicodeUtils.Direction.RTL &&\n                glyphData.direction === UnicodeUtils.Direction.Weak\n            ) {\n                let weakRunStart = i;\n                let weakGlyph = glyphDataArray[weakRunStart - 1];\n                while (\n                    weakRunStart !== startIdx &&\n                    (weakGlyph.direction === UnicodeUtils.Direction.Weak ||\n                        (weakGlyph.direction === UnicodeUtils.Direction.Neutral &&\n                            !UnicodeUtils.isWhiteSpace(weakGlyph.codePoint)))\n                ) {\n                    --weakRunStart;\n                    weakGlyph = glyphDataArray[weakRunStart - 1];\n                }\n\n                this.placeRun(Math.max(weakRunStart, startIdx), i, UnicodeUtils.Direction.LTR);\n\n                i = weakRunStart;\n                continue;\n            }\n\n            // Compute various rendering parameters for this glyph.\n            const glyphFont = glyphData.font;\n            const glyphFontMetrics = glyphFont.metrics;\n            const fontStyle = textRenderStyle.fontStyle;\n\n            const isBoldEmulated =\n                (fontStyle === FontStyle.Bold && glyphFont.bold === undefined) ||\n                (fontStyle === FontStyle.BoldItalic &&\n                    glyphFont.bold === undefined &&\n                    glyphFont.boldItalic === undefined);\n            const isItalicEmulated =\n                (fontStyle === FontStyle.Italic && glyphFont.italic === undefined) ||\n                (fontStyle === FontStyle.BoldItalic &&\n                    glyphFont.italic === undefined &&\n                    glyphFont.boldItalic === undefined);\n\n            const isSmallCaps = this.m_tempSmallCaps\n                ? smallCapsArray![i] && textRenderStyle.fontVariant === FontVariant.SmallCaps\n                : false;\n            const smallCapsScale = isSmallCaps\n                ? glyphFontMetrics.xHeight / glyphFontMetrics.capHeight\n                : 1.0;\n            const glyphScale = this.m_tempScale * smallCapsScale;\n\n            const emulationWeight =\n                ((isBoldEmulated ? 0.02 : 0.0) + (isSmallCaps ? 0.01 : 0.0)) *\n                (fontCatalog.size / fontCatalog.distanceRange);\n            const bgWeight =\n                (0.5 * this.m_tempPixelBgSize!) /\n                (fontCatalog.distanceRange * Math.max(glyphScale, 1.0));\n            const isMirrored =\n                UnicodeUtils.isRtlMirrored(glyphData.codePoint) &&\n                direction === UnicodeUtils.Direction.RTL;\n\n            const verticalOffset =\n                glyphFontMetrics.lineHeight -\n                glyphFontMetrics.base -\n                glyphFontMetrics.distanceRange * 0.5;\n\n            // Update the current interpolated path position and angle.\n            const textPoint = path.getPoint(this.m_tempPathOffset);\n            if (textPoint === null) {\n                return this.m_currentParams!.pathOverflow;\n            }\n            const tangent = path.getTangent(this.m_tempPathOffset);\n            const normal = new THREE.Vector2(-tangent.y, tangent.x).multiplyScalar(\n                normalDisplacement\n            );\n            const angle = Math.atan2(tangent.y, tangent.x);\n            this.m_tempPathPosition.set(normal.x + textPoint.x, normal.y + textPoint.y, position.z);\n            textRenderStyle.rotation = defaultGlyphRotation + angle;\n\n            // Compute the glyphs transformation matrix and apply to all corners of a glyph.\n            TypesettingUtils.computeGlyphTransform(\n                this.m_tempTransform,\n                this.m_tempPathPosition,\n                glyphScale,\n                0.0,\n                textRenderStyle.rotation\n            );\n            for (let j = 0; j < 4; ++j) {\n                const glyphVertexPosition = glyphData.positions[j];\n                const horizontalOffset =\n                    isItalicEmulated && j > 1\n                        ? TypesettingUtils.OBLIQUE_OFFSET * glyphFontMetrics.size\n                        : 0.0;\n                this.m_tempCorners[j].set(\n                    glyphVertexPosition.x + horizontalOffset,\n                    glyphVertexPosition.y - verticalOffset,\n                    glyphVertexPosition.z\n                );\n                this.m_tempCorners[j].applyMatrix3(this.m_tempTransform);\n\n                this.m_tempCorners[j].x -= position.x;\n                this.m_tempCorners[j].y -= position.y;\n            }\n\n            // Depending on the typesetting options, add the computed glyph to the TextGeometry or\n            // update the text bounds.\n            if (globalBounds === undefined && vertexBuffer === undefined) {\n                if (\n                    !geometry.add(\n                        glyphData,\n                        this.m_tempCorners,\n                        emulationWeight,\n                        emulationWeight + bgWeight,\n                        isMirrored,\n                        textRenderStyle\n                    )\n                ) {\n                    return false;\n                }\n            } else {\n                if (globalBounds !== undefined) {\n                    TypesettingUtils.updateBounds(\n                        this.m_tempCorners,\n                        globalBounds,\n                        individualBounds\n                    );\n                }\n                if (vertexBuffer !== undefined) {\n                    geometry.addToBuffer(\n                        vertexBuffer,\n                        i * QUAD_VERTEX_MEMORY_FOOTPRINT,\n                        glyphData,\n                        this.m_tempCorners,\n                        emulationWeight,\n                        emulationWeight + bgWeight,\n                        isMirrored,\n                        textRenderStyle\n                    );\n                }\n            }\n\n            // Restore the original glyph rotation.\n            textRenderStyle.rotation = defaultGlyphRotation;\n\n            // Advance the current position and proceed to next glyph in the run.\n            this.m_tempPathOffset +=\n                ((glyphData.advanceX + textLayoutStyle.tracking) * glyphScale) /\n                this.m_tempPathLength;\n        }\n\n        return true;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nenum ContextualForm {\n    Initial,\n    Medial,\n    Final\n}\n\nenum CombinedForm {\n    Isolated,\n    Connected\n}\n\n/**\n * Converter between arabic isolated forms (in Unicode Block 'Arabic') and their contextual forms\n * (in Unicode Block 'Arabic Presentation Forms-B').\n */\nexport class ContextualArabicConverter {\n    private static m_instance: ContextualArabicConverter;\n    static get instance(): ContextualArabicConverter {\n        if (this.m_instance === undefined) {\n            this.m_instance = new ContextualArabicConverter();\n        }\n        return this.m_instance;\n    }\n\n    private m_singleCharactersMap: Map<number, ReadonlyArray<number | undefined>> = new Map();\n    private m_combinedCharactersMap: Map<\n        number,\n        Map<number, ReadonlyArray<number | undefined>>\n    > = new Map();\n    private m_neutralCharacters: number[];\n\n    private constructor() {\n        // Single characters.\n        this.m_singleCharactersMap.set(0x0621, [undefined, undefined, undefined]); // HAMZA\n        this.m_singleCharactersMap.set(0x0622, [undefined, undefined, 0xfe82]); // ALEF_MADDA\n        this.m_singleCharactersMap.set(0x0623, [undefined, undefined, 0xfe84]); // ALEF_HAMZA_ABOVE\n        this.m_singleCharactersMap.set(0x0624, [undefined, undefined, 0xfe86]); // WAW_HAMZA\n        this.m_singleCharactersMap.set(0x0625, [undefined, undefined, 0xfe88]); // ALEF_HAMZA_BELOW\n        this.m_singleCharactersMap.set(0x0626, [0xfe8b, 0xfe8c, 0xfe8a]); // YEH_HAMZA\n        this.m_singleCharactersMap.set(0x0627, [undefined, undefined, 0xfe8e]); // ALEF\n        this.m_singleCharactersMap.set(0x0628, [0xfe91, 0xfe92, 0xfe90]); // BEH\n        this.m_singleCharactersMap.set(0x0629, [undefined, undefined, 0xfe94]); // TEH_MARBUTA\n        this.m_singleCharactersMap.set(0x062a, [0xfe97, 0xfe98, 0xfe96]); // TEH\n        this.m_singleCharactersMap.set(0x062b, [0xfe9b, 0xfe9c, 0xfe9a]); // THEH\n        this.m_singleCharactersMap.set(0x062c, [0xfe9f, 0xfea0, 0xfe9e]); // JEEM\n        this.m_singleCharactersMap.set(0x062d, [0xfea3, 0xfea4, 0xfea2]); // HAH\n        this.m_singleCharactersMap.set(0x062e, [0xfea7, 0xfea8, 0xfea6]); // KHAH\n        this.m_singleCharactersMap.set(0x062f, [undefined, undefined, 0xfeaa]); // DAL\n        this.m_singleCharactersMap.set(0x0630, [undefined, undefined, 0xfeac]); // THAL\n        this.m_singleCharactersMap.set(0x0631, [undefined, undefined, 0xfeae]); // REH\n        this.m_singleCharactersMap.set(0x0632, [undefined, undefined, 0xfeb0]); // ZAIN\n        this.m_singleCharactersMap.set(0x0633, [0xfeb3, 0xfeb4, 0xfeb2]); // SEEN\n        this.m_singleCharactersMap.set(0x0634, [0xfeb7, 0xfeb8, 0xfeb6]); // SHEEN\n        this.m_singleCharactersMap.set(0x0635, [0xfebb, 0xfebc, 0xfeba]); // SAD\n        this.m_singleCharactersMap.set(0x0636, [0xfebf, 0xfec0, 0xfebe]); // DAD\n        this.m_singleCharactersMap.set(0x0637, [0xfec3, 0xfec4, 0xfec2]); // TAH\n        this.m_singleCharactersMap.set(0x0638, [0xfec7, 0xfec8, 0xfec6]); // ZAH\n        this.m_singleCharactersMap.set(0x0639, [0xfecb, 0xfecc, 0xfeca]); // AIN\n        this.m_singleCharactersMap.set(0x063a, [0xfecf, 0xfed0, 0xfece]); // GHAIN\n        this.m_singleCharactersMap.set(0x0640, [0x0640, 0x0640, 0x0640]); // TATWEEL\n        this.m_singleCharactersMap.set(0x0641, [0xfed3, 0xfed4, 0xfed2]); // FEH\n        this.m_singleCharactersMap.set(0x0642, [0xfed7, 0xfed8, 0xfed6]); // QAF\n        this.m_singleCharactersMap.set(0x0643, [0xfedb, 0xfedc, 0xfeda]); // KAF\n        this.m_singleCharactersMap.set(0x0644, [0xfedf, 0xfee0, 0xfede]); // LAM\n        this.m_singleCharactersMap.set(0x0645, [0xfee3, 0xfee4, 0xfee2]); // MEEM\n        this.m_singleCharactersMap.set(0x0646, [0xfee7, 0xfee8, 0xfee6]); // NOON\n        this.m_singleCharactersMap.set(0x0647, [0xfeeb, 0xfeec, 0xfeea]); // HEH\n        this.m_singleCharactersMap.set(0x0648, [undefined, undefined, 0xfeee]); // WAW\n        this.m_singleCharactersMap.set(0x0649, [undefined, undefined, 0xfef0]); // ALEF_MAKSURA\n        this.m_singleCharactersMap.set(0x064a, [0xfef3, 0xfef4, 0xfef2]); // YEH\n        this.m_singleCharactersMap.set(0x067e, [0xfb58, 0xfb59, 0xfb57]); // PEH\n        this.m_singleCharactersMap.set(0x06cc, [0xfbfe, 0xfbff, 0xfbfd]); // Farsi Yeh\n        this.m_singleCharactersMap.set(0x0686, [0xfb7c, 0xfb7d, 0xfb7b]); // Tcheh\n        this.m_singleCharactersMap.set(0x06a9, [0xfb90, 0xfb91, 0xfb8f]); // Keheh\n        this.m_singleCharactersMap.set(0x06af, [0xfb94, 0xfb95, 0xfb93]); // Gaf\n        this.m_singleCharactersMap.set(0x0698, [undefined, undefined, 0xfb8b]); // Jeh\n\n        // Combined characters.\n        this.m_combinedCharactersMap.set(0x0644, new Map());\n        // LAM_ALEF_MADDA\n        this.m_combinedCharactersMap.get(0x0644)!.set(0x0622, [0xfef5, 0xfef6]);\n        // LAM_ALEF_HAMZA_ABOVE\n        this.m_combinedCharactersMap.get(0x0644)!.set(0x0623, [0xfef7, 0xfef8]);\n        // LAM_ALEF_HAMZA_BELOW\n        this.m_combinedCharactersMap.get(0x0644)!.set(0x0625, [0xfef9, 0xfefa]);\n        // LAM_ALEF\n        this.m_combinedCharactersMap.get(0x0644)!.set(0x0627, [0xfefb, 0xfefc]);\n\n        // Neutral characters.\n        this.m_neutralCharacters = [\n            0x0610, // ARABIC SIGN SALLALLAHOU ALAYHE WASSALLAM\n            0x0612, // ARABIC SIGN ALAYHE ASSALLAM\n            0x0613, // ARABIC SIGN RADI ALLAHOU ANHU\n            0x0614, // ARABIC SIGN TAKHALLUS\n            0x0615, // ARABIC SMALL HIGH TAH\n            0x064b, // ARABIC FATHATAN\n            0x064c, // ARABIC DAMMATAN\n            0x064d, // ARABIC KASRATAN\n            0x064e, // ARABIC FATHA\n            0x064f, // ARABIC DAMMA\n            0x0650, // ARABIC KASRA\n            0x0651, // ARABIC SHADDA\n            0x0652, // ARABIC SUKUN\n            0x0653, // ARABIC MADDAH ABOVE\n            0x0654, // ARABIC HAMZA ABOVE\n            0x0655, // ARABIC HAMZA BELOW\n            0x0656, // ARABIC SUBSCRIPT ALEF\n            0x0657, // ARABIC INVERTED DAMMA\n            0x0658, // ARABIC MARK NOON GHUNNA\n            0x0670, // ARABIC LETTER SUPERSCRIPT ALEF\n            0x06d6, // ARABIC SMALL HIGH LIGATURE SAD WITH LAM WITH ALEF MAKSURA\n            0x06d7, // ARABIC SMALL HIGH LIGATURE QAF WITH LAM WITH ALEF MAKSURA\n            0x06d8, // ARABIC SMALL HIGH MEEM INITIAL FORM\n            0x06d9, // ARABIC SMALL HIGH LAM ALEF\n            0x06da, // ARABIC SMALL HIGH JEEM\n            0x06db, // ARABIC SMALL HIGH THREE DOTS\n            0x06dc, // ARABIC SMALL HIGH SEEN\n            0x06df, // ARABIC SMALL HIGH ROUNDED ZERO\n            0x06e0, // ARABIC SMALL HIGH UPRIGHT RECTANGULAR ZERO\n            0x06e1, // ARABIC SMALL HIGH DOTLESS HEAD OF KHAH\n            0x06e2, // ARABIC SMALL HIGH MEEM ISOLATED FORM\n            0x06e3, // ARABIC SMALL LOW SEEN\n            0x06e4, // ARABIC SMALL HIGH MADDA\n            0x06e7, // ARABIC SMALL HIGH YEH\n            0x06e8, // ARABIC SMALL HIGH NOON\n            0x06ea, // ARABIC EMPTY CENTRE LOW STOP\n            0x06eb, // ARABIC EMPTY CENTRE HIGH STOP\n            0x06ec, // ARABIC ROUNDED HIGH STOP WITH FILLED CENTRE\n            0x06ed // ARABIC SMALL LOW MEEM\n        ];\n    }\n\n    /**\n     * Converts isolated arabic characters into their contextual form.\n     *\n     * @param input String with isolated arabic characters.\n     */\n    convert(input: string): string {\n        let output = \"\";\n        for (let i = 0; i < input.length; ++i) {\n            const currentCodePoint = input.charCodeAt(i);\n\n            // Only process arabic characters in the map.\n            if (this.isArabicCharacter(currentCodePoint)) {\n                // Find the first previous non-neutral character.\n                let prevIndex = i - 1;\n                for (; prevIndex >= 0; --prevIndex) {\n                    if (!this.isNeutral(input.charCodeAt(prevIndex))) {\n                        break;\n                    }\n                }\n\n                // Check if the previous character has ligatures with following characters.\n                let prevCodePoint = prevIndex >= 0 ? input.charCodeAt(prevIndex) : undefined;\n                if (prevCodePoint !== undefined) {\n                    const prevMap = this.getCharacterMap(prevCodePoint);\n                    if (\n                        prevMap === undefined ||\n                        (prevMap[ContextualForm.Initial] === undefined &&\n                            prevMap[ContextualForm.Medial] === undefined)\n                    ) {\n                        prevCodePoint = undefined;\n                    }\n                }\n\n                // Find the first next non-neutral character.\n                let nextIndex = i + 1;\n                for (; nextIndex < input.length; ++nextIndex) {\n                    if (!this.isNeutral(input.charCodeAt(nextIndex))) {\n                        break;\n                    }\n                }\n\n                // Check if the next character has ligatures with previous characters.\n                let nextCodePoint =\n                    nextIndex < input.length ? input.charCodeAt(nextIndex) : undefined;\n                if (nextCodePoint !== undefined) {\n                    const nextMap = this.getCharacterMap(nextCodePoint);\n                    if (\n                        nextMap === undefined ||\n                        (nextMap[ContextualForm.Medial] === undefined &&\n                            nextMap[ContextualForm.Final] === undefined)\n                    ) {\n                        nextCodePoint = undefined;\n                    }\n                }\n\n                // Check for Lam Alef combinated forms.\n                if (\n                    currentCodePoint === 0x0644 &&\n                    nextCodePoint !== undefined &&\n                    (nextCodePoint === 0x0622 ||\n                        nextCodePoint === 0x0623 ||\n                        nextCodePoint === 0x0625 ||\n                        nextCodePoint === 0x0627)\n                ) {\n                    const combinedMap = this.getCombinedCharacterMap(\n                        currentCodePoint,\n                        nextCodePoint\n                    )!;\n                    if (prevCodePoint !== undefined) {\n                        output += String.fromCharCode(combinedMap[CombinedForm.Connected]!);\n                    } else {\n                        output += String.fromCharCode(combinedMap[CombinedForm.Isolated]!);\n                    }\n\n                    // Skip the next character and continue.\n                    ++i;\n                    continue;\n                }\n\n                // Check for single character contextual forms.\n                const map = this.getCharacterMap(currentCodePoint)!;\n                // Intermediate.\n                if (\n                    prevCodePoint !== undefined &&\n                    nextCodePoint !== undefined &&\n                    map[ContextualForm.Medial] !== undefined\n                ) {\n                    output += String.fromCharCode(map[ContextualForm.Medial]!);\n                }\n                // Final.\n                else if (prevCodePoint !== undefined && map[ContextualForm.Final] !== undefined) {\n                    output += String.fromCharCode(map[ContextualForm.Final]!);\n                }\n                // Initial.\n                else if (nextCodePoint !== undefined && map[ContextualForm.Initial] !== undefined) {\n                    output += String.fromCharCode(map[ContextualForm.Initial]!);\n                }\n                // Isolated.\n                else {\n                    output += String.fromCharCode(currentCodePoint);\n                }\n            } else {\n                output += String.fromCharCode(currentCodePoint);\n            }\n        }\n\n        return output;\n    }\n\n    private isArabicCharacter(codePoint: number): boolean {\n        return this.m_singleCharactersMap.has(codePoint);\n    }\n\n    private getCharacterMap(codePoint: number): ReadonlyArray<number | undefined> | undefined {\n        return this.m_singleCharactersMap.get(codePoint);\n    }\n\n    private getCombinedCharacterMap(\n        codePoint: number,\n        nextCodePoint: number\n    ): ReadonlyArray<number | undefined> | undefined {\n        const map = this.m_combinedCharactersMap.get(codePoint);\n        if (map !== undefined) {\n            return map.get(nextCodePoint);\n        }\n        return undefined;\n    }\n\n    private isNeutral(codePoint: number): boolean {\n        for (const character of this.m_neutralCharacters) {\n            if (character === codePoint) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Vector3Like } from \"@here/harp-geoutils\";\nimport * as THREE from \"three\";\n\n/**\n * This path in world coordinates is projected to screen space and blocks all other labels.\n *\n * It could be used for example:\n * - Border rejects labels.\n * - Route blocks street labels from being rendered underneath.\n *\n * Could potentially be expanded in future to have a priority, however for now, this isn't required.\n */\n\nexport class PathBlockingElement {\n    /**\n     * Note, [[screenSpaceLines]] is only used as a performance improvement and contains no\n     * useful information. They are used to contain the screen space coordinates of the\n     * points. By allocating the space here, we avoid per frame allocations, see\n     * [[TextElementsRenderer.prepopulateScreenWithBlockingElements]].\n     */\n    readonly screenSpaceLines: THREE.Line3[];\n\n    /**\n     * Constructs a path from a list of points.\n     * Pre allocates the [[screenSpaceLines]] used to render.\n     * @param points Points in world coordinates.\n     */\n    constructor(readonly points: Vector3Like[]) {\n        this.screenSpaceLines = new Array<THREE.Line3>(points.length >= 2 ? points.length - 1 : 0);\n        for (let i = 0; i < this.screenSpaceLines.length; i++) {\n            this.screenSpaceLines[i] = new THREE.Line3(new THREE.Vector3(), new THREE.Vector3());\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { Math2D } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { MemoryUsage } from \"@here/harp-text-canvas\";\nimport { getPixelFromImage, screenToUvCoordinates } from \"./PixelPicker\";\n\n/**\n * Declares an interface for a `struct` containing a [[BoxBuffer]]'s attribute state information.\n */\nexport interface State {\n    positionAttributeCount: number;\n    colorAttributeCount: number;\n    uvAttributeCount: number;\n    indexAttributeCount: number;\n    pickInfoCount: number;\n}\n\n/**\n * Initial number of boxes in BoxBuffer.\n */\nconst START_BOX_BUFFER_SIZE = 0;\n\n/**\n * Maximum number of boxes in BoxBuffer.\n */\nconst MAX_BOX_BUFFER_SIZE = 32 * 1024;\n\n/**\n * Number of vertices per box/glyph element: 4 corners.\n */\nconst NUM_VERTICES_PER_ELEMENT = 4;\n\n/**\n * Number of indices added per box/glyph: 2 triangles, 6 indices.\n */\nconst NUM_INDICES_PER_ELEMENT = 6;\n\n/**\n * Number of values per position.\n */\nconst NUM_POSITION_VALUES_PER_VERTEX = 3;\n\n/**\n * Number of values per color.\n */\nconst NUM_COLOR_VALUES_PER_VERTEX = 4;\n\n/**\n * Number of values per UV.\n */\nconst NUM_UV_VALUES_PER_VERTEX = 4;\n\n/**\n * Number of values per index.\n */\nconst NUM_INDEX_VALUES_PER_VERTEX = 1;\n\n/**\n * Number of bytes for float in an Float32Array.\n */\nconst NUM_BYTES_PER_FLOAT = 4;\n\n/**\n * Number of bytes for integer number in an UInt32Array.\n */\nconst NUM_BYTES_PER_INT32 = 4;\n\n/**\n * SubClass of [[THREE.Mesh]] to identify meshes that have been created by [[BoxBuffer]] and\n * [[TextBuffer]]. Add the isEmpty flag to quickly test for empty meshes.\n */\nexport class BoxBufferMesh extends THREE.Mesh {\n    constructor(geometry: THREE.BufferGeometry, material: THREE.Material | THREE.Material[]) {\n        super(geometry, material);\n\n        this.type = \"BoxBufferMesh\";\n    }\n\n    /**\n     * A mesh that has no positions and indices set is defined to be empty.\n     *\n     * @returns `True` if no indices have been added to the mesh.\n     */\n    get isEmpty(): boolean {\n        if (this.geometry === undefined) {\n            return true;\n        } else {\n            const bufferGeometry = this.geometry as THREE.BufferGeometry;\n            return bufferGeometry.index === null || bufferGeometry.index.count === 0;\n        }\n    }\n}\n\n/**\n * Buffer for (untransformed) `Box2` objects. Can be used to create a single geometry for screen-\n * aligned boxes, like POIs.\n */\nexport class BoxBuffer {\n    /**\n     * [[BufferAttribute]] holding the `BoxBuffer` position data.\n     */\n    protected positionAttribute?: THREE.BufferAttribute;\n\n    /**\n     * [[BufferAttribute]] holding the `BoxBuffer` color data.\n     */\n    protected colorAttribute?: THREE.BufferAttribute;\n\n    /**\n     * [[BufferAttribute]] holding the `BoxBuffer` uv data.\n     */\n    protected uvAttribute?: THREE.BufferAttribute;\n\n    /**\n     * [[BufferAttribute]] holding the `BoxBuffer` index data.\n     */\n    protected indexAttribute?: THREE.BufferAttribute;\n    protected pickInfos: Array<any | undefined>;\n\n    /**\n     * [[BufferGeometry]] holding all the different [[BufferAttribute]]s.\n     */\n    protected geometry: THREE.BufferGeometry | undefined;\n\n    /**\n     * [[Mesh]] used for rendering.\n     */\n    protected internalMesh: BoxBufferMesh | undefined;\n\n    private m_size: number = 0;\n\n    /**\n     * Creates a new `BoxBuffer`.\n     *\n     * @param material Material to be used for [[Mesh]] of this `BoxBuffer`.\n     * @param renderOrder Optional renderOrder of this buffer.\n     * @param startElementCount Initial number of elements this `BoxBuffer` can hold.\n     * @param maxElementCount Maximum number of elements this `BoxBuffer` can hold.\n     */\n    constructor(\n        readonly material: THREE.Material | THREE.Material[],\n        readonly renderOrder: number = 0,\n        readonly startElementCount = START_BOX_BUFFER_SIZE,\n        readonly maxElementCount = MAX_BOX_BUFFER_SIZE\n    ) {\n        this.resizeBuffer(startElementCount);\n        this.pickInfos = new Array();\n    }\n\n    /**\n     * Duplicate this `BoxBuffer` with same material and renderOrder.\n     *\n     * @returns A clone of this `BoxBuffer`.\n     */\n    clone(): BoxBuffer {\n        return new BoxBuffer(this.material, this.renderOrder);\n    }\n\n    /**\n     * Dispose of the geometry.\n     */\n    dispose() {\n        if (this.geometry !== undefined) {\n            this.geometry.dispose();\n            this.geometry = undefined;\n        }\n        this.internalMesh = undefined;\n    }\n\n    /**\n     * Return the current number of elements the buffer can hold.\n     */\n    get size(): number {\n        return this.m_size;\n    }\n\n    /**\n     * Clear's the `BoxBuffer` attribute buffers.\n     */\n    reset() {\n        if (this.positionAttribute !== undefined) {\n            this.positionAttribute.count = 0;\n            this.colorAttribute!.count = 0;\n            this.uvAttribute!.count = 0;\n            this.indexAttribute!.count = 0;\n            this.pickInfos!.length = 0;\n        }\n    }\n\n    /**\n     * Returns `true` if this `BoxBuffer` can hold the specified amount of glyphs. If the buffer\n     * can only add the glyph by increasing the buffer size, the resize() method is called, which\n     * will then create a new geometry for the mesh.\n     *\n     * @param glyphCount Number of glyphs to be added to the buffer.\n     * @returns `true` if the element (box or glyph) can be added to the buffer, `false` otherwise.\n     */\n    canAddElements(glyphCount = 1): boolean {\n        const indexAttribute = this.indexAttribute!;\n        if (\n            indexAttribute.count + glyphCount * NUM_INDICES_PER_ELEMENT >=\n            indexAttribute.array.length\n        ) {\n            // Too many elements for the current buffer, check if we can resize the buffer.\n            if (indexAttribute.array.length >= this.maxElementCount * NUM_INDICES_PER_ELEMENT) {\n                return false;\n            }\n\n            const newSize = Math.min(this.maxElementCount, this.size === 0 ? 256 : this.size * 2);\n            this.resize(newSize);\n        }\n        return true;\n    }\n\n    /**\n     * Returns this `BoxBuffer`'s attribute [[State]].\n     */\n    saveState(): State {\n        const state: State = {\n            positionAttributeCount: this.positionAttribute!.count,\n            colorAttributeCount: this.colorAttribute!.count,\n            uvAttributeCount: this.uvAttribute!.count,\n            indexAttributeCount: this.indexAttribute!.count,\n            pickInfoCount: this.pickInfos!.length\n        };\n        return state;\n    }\n\n    /**\n     * Store this `BoxBuffer`'s attribute [[State]] to a previously stored one.\n     *\n     * @param state [[State]] struct describing a previous attribute state.\n     */\n    restoreState(state: State) {\n        this.positionAttribute!.count = state.positionAttributeCount;\n        this.colorAttribute!.count = state.colorAttributeCount;\n        this.uvAttribute!.count = state.uvAttributeCount;\n        this.indexAttribute!.count = state.indexAttributeCount;\n        this.pickInfos!.length = state.pickInfoCount;\n    }\n\n    /**\n     * Adds a new box to this `BoxBuffer`.\n     *\n     * @param screenBox [[Math2D.Box]] holding screen coordinates for this box.\n     * @param uvBox [[Math2D.UvBox]] holding uv coordinates for this box.\n     * @param color Box's color.\n     * @param opacity Box's opacity.\n     * @param distance Box's distance to camera.\n     * @param pickInfo Box's picking information.\n     */\n    addBox(\n        screenBox: Math2D.Box,\n        uvBox: Math2D.UvBox,\n        color: THREE.Color,\n        opacity: number,\n        distance: number,\n        pickInfo?: any\n    ): boolean {\n        if (!this.canAddElements()) {\n            return false;\n        }\n\n        const { s0, t0, s1, t1 } = uvBox;\n        const { x, y, w, h } = screenBox;\n\n        const r = Math.round(color.r * 255);\n        const g = Math.round(color.g * 255);\n        const b = Math.round(color.b * 255);\n        const a = Math.round(opacity * 255);\n\n        const positionAttribute = this.positionAttribute!;\n        const colorAttribute = this.colorAttribute!;\n        const uvAttribute = this.uvAttribute!;\n        const indexAttribute = this.indexAttribute!;\n\n        const baseVertex = positionAttribute.count;\n        const baseIndex = indexAttribute.count;\n\n        positionAttribute.setXYZ(baseVertex, x, y, distance);\n        positionAttribute.setXYZ(baseVertex + 1, x + w, y, distance);\n        positionAttribute.setXYZ(baseVertex + 2, x, y + h, distance);\n        positionAttribute.setXYZ(baseVertex + 3, x + w, y + h, distance);\n\n        colorAttribute.setXYZW(baseVertex, r, g, b, a);\n        colorAttribute.setXYZW(baseVertex + 1, r, g, b, a);\n        colorAttribute.setXYZW(baseVertex + 2, r, g, b, a);\n        colorAttribute.setXYZW(baseVertex + 3, r, g, b, a);\n\n        uvAttribute.setXY(baseVertex, s0, t0);\n        uvAttribute.setXY(baseVertex + 1, s1, t0);\n        uvAttribute.setXY(baseVertex + 2, s0, t1);\n        uvAttribute.setXY(baseVertex + 3, s1, t1);\n\n        indexAttribute.setX(baseIndex, baseVertex);\n        indexAttribute.setX(baseIndex + 1, baseVertex + 1);\n        indexAttribute.setX(baseIndex + 2, baseVertex + 2);\n        indexAttribute.setX(baseIndex + 3, baseVertex + 2);\n        indexAttribute.setX(baseIndex + 4, baseVertex + 1);\n        indexAttribute.setX(baseIndex + 5, baseVertex + 3);\n\n        positionAttribute.count += NUM_VERTICES_PER_ELEMENT;\n        colorAttribute.count += NUM_VERTICES_PER_ELEMENT;\n        uvAttribute.count += NUM_VERTICES_PER_ELEMENT;\n        indexAttribute.count += NUM_INDICES_PER_ELEMENT;\n\n        this.pickInfos.push(pickInfo);\n\n        return true;\n    }\n\n    /**\n     * Updates a [[BufferGeometry]] object to reflect the changes in this `TextBuffer`'s attribute\n     * data.\n     */\n    updateBufferGeometry() {\n        const positionAttribute = this.positionAttribute!;\n        const colorAttribute = this.colorAttribute!;\n        const uvAttribute = this.uvAttribute!;\n        const indexAttribute = this.indexAttribute!;\n\n        if (positionAttribute.count > 0) {\n            positionAttribute.needsUpdate = true;\n            positionAttribute.updateRange.offset = 0;\n            positionAttribute.updateRange.count =\n                positionAttribute.count * NUM_VERTICES_PER_ELEMENT;\n        }\n\n        if (colorAttribute.count > 0) {\n            colorAttribute.needsUpdate = true;\n            colorAttribute.updateRange.offset = 0;\n            colorAttribute.updateRange.count = colorAttribute.count * NUM_VERTICES_PER_ELEMENT;\n        }\n\n        if (uvAttribute.count > 0) {\n            uvAttribute.needsUpdate = true;\n            uvAttribute.updateRange.offset = 0;\n            uvAttribute.updateRange.count = uvAttribute.count * NUM_VERTICES_PER_ELEMENT;\n        }\n\n        if (indexAttribute.count > 0) {\n            indexAttribute.needsUpdate = true;\n            indexAttribute.updateRange.offset = 0;\n            indexAttribute.updateRange.count = indexAttribute.count;\n        }\n\n        if (this.geometry !== undefined) {\n            this.geometry.clearGroups();\n            this.geometry.addGroup(0, this.indexAttribute!.count);\n        }\n    }\n\n    /**\n     * Check if the buffer is empty. If it is empty, the memory usage is minimized to reduce\n     * footprint.\n     */\n    cleanUp() {\n        // If there is nothing in this buffer, resize it, it may never be used again.\n        if (this.indexAttribute!.count === 0 && this.size > START_BOX_BUFFER_SIZE) {\n            this.clearAttributes();\n        }\n    }\n\n    /**\n     * Determine if the mesh is empty.\n     */\n    get isEmpty(): boolean {\n        return this.internalMesh!.isEmpty;\n    }\n\n    /**\n     * Get the [[Mesh]] object. The geometry instance of the mesh may change if the buffers are\n     * resized. The mesh, once created, will not change, so it can always be added to the scene.\n     */\n    get mesh(): BoxBufferMesh {\n        if (this.internalMesh === undefined) {\n            this.resize();\n        }\n        return this.internalMesh!;\n    }\n\n    /**\n     * Fill the picking results for the pixel with the given screen coordinate. If multiple\n     * boxes are found, the order of the results is unspecified.\n     *\n     * @param screenPosition Screen coordinate of picking position.\n     * @param pickCallback Callback to be called for every picked element.\n     * @param imageData Image data to test if the pixel is transparent\n     */\n    pickBoxes(\n        screenPosition: THREE.Vector2,\n        pickCallback: (pickData: any | undefined) => void,\n        imageData?: ImageBitmap | ImageData\n    ) {\n        const n = this.pickInfos.length;\n        const pickInfos = this.pickInfos;\n        const positions = this.positionAttribute!;\n        const screenX = screenPosition.x;\n        const screenY = screenPosition.y;\n\n        const canvas = document.createElement(\"canvas\");\n        for (let pickInfoIndex = 0; pickInfoIndex < n; pickInfoIndex++) {\n            const positionIndex = pickInfoIndex * NUM_VERTICES_PER_ELEMENT;\n\n            const minX = positions.getX(positionIndex);\n            if (screenX < minX) {\n                continue;\n            }\n\n            const maxX = positions.getX(positionIndex + 1);\n            if (screenX > maxX) {\n                continue;\n            }\n\n            const minY = positions.getY(positionIndex);\n            if (screenY < minY) {\n                continue;\n            }\n\n            const maxY = positions.getY(positionIndex + 2);\n            if (screenY > maxY) {\n                continue;\n            }\n\n            const box = new Math2D.Box(minX, minY, maxX - minX, maxY - minY);\n            if (\n                imageData !== undefined &&\n                pickInfos[pickInfoIndex].poiInfo !== undefined &&\n                pickInfos[pickInfoIndex].poiInfo.uvBox !== undefined &&\n                this.isPixelTransparent(\n                    imageData,\n                    screenX,\n                    screenY,\n                    box,\n                    pickInfos[pickInfoIndex].poiInfo.uvBox,\n                    canvas\n                )\n            ) {\n                continue;\n            }\n\n            if (pickInfos[pickInfoIndex] !== undefined) {\n                pickCallback(pickInfos[pickInfoIndex]);\n            }\n        }\n    }\n\n    /**\n     * Creates a new [[Geometry]] object from all the attribute data stored in this `BoxBuffer`.\n     * The [[Mesh]] object may be created if it is not initialized already.\n     *\n     * @param newSize Optional number of elements to resize the buffer to.\n     * @param forceResize Optional flag to force a resize even if new size is smaller than before.\n     */\n    resize(newSize?: number, forceResize?: boolean): BoxBufferMesh {\n        if (this.geometry !== undefined) {\n            this.geometry.dispose();\n        }\n\n        this.geometry = new THREE.BufferGeometry();\n\n        if (newSize !== undefined && (forceResize === true || newSize > this.size)) {\n            this.resizeBuffer(newSize);\n        }\n\n        this.geometry.setAttribute(\"position\", this.positionAttribute!);\n        this.geometry.setAttribute(\"color\", this.colorAttribute!);\n        this.geometry.setAttribute(\"uv\", this.uvAttribute!);\n        this.geometry.setIndex(this.indexAttribute!);\n        this.geometry.addGroup(0, this.indexAttribute!.count);\n\n        if (this.internalMesh === undefined) {\n            this.internalMesh = new BoxBufferMesh(this.geometry, this.material);\n            this.internalMesh.renderOrder = this.renderOrder;\n        } else {\n            this.internalMesh.geometry = this.geometry;\n        }\n        return this.internalMesh;\n    }\n\n    /**\n     * Update the info with the memory footprint caused by objects owned by the `BoxBuffer`.\n     *\n     * @param info The info object to increment with the values from this `BoxBuffer`.\n     */\n    updateMemoryUsage(info: MemoryUsage) {\n        const numBytes =\n            this.positionAttribute!.count * NUM_POSITION_VALUES_PER_VERTEX * NUM_BYTES_PER_FLOAT +\n            this.colorAttribute!.count * NUM_COLOR_VALUES_PER_VERTEX +\n            this.uvAttribute!.count * NUM_UV_VALUES_PER_VERTEX * NUM_BYTES_PER_FLOAT +\n            this.indexAttribute!.count * NUM_BYTES_PER_INT32; // May be UInt16, so we overestimate\n\n        info.heapSize += numBytes;\n        info.gpuSize += numBytes;\n    }\n\n    /**\n     * Check if a pixel is transparent or not.\n     *\n     * @param imageData Data containing the pixels.\n     * @param xScreenPos X position of the pixel.\n     * @param yScreenPos Y position of the pixel.\n     * @param box Bounding box of the image in screen coordinates.\n     * @param uvBox Uv box referred to the given bounding box.\n     * @param canvas Canvas element that will be used to draw the image, in case the imageData is an\n     *      ImageBitmap\n     */\n    protected isPixelTransparent(\n        imageData: ImageBitmap | ImageData,\n        xScreenPos: number,\n        yScreenPos: number,\n        box: Math2D.Box,\n        uvBox: Math2D.UvBox,\n        canvas?: HTMLCanvasElement\n    ): boolean {\n        let pixelIsTransparent = false;\n\n        const { u, v } = screenToUvCoordinates(xScreenPos, yScreenPos, box, uvBox);\n\n        const imageWidth = imageData.width;\n        const x = imageWidth * u;\n        const imageHeight = imageData.height;\n        const y = imageHeight * v;\n\n        const pixel = getPixelFromImage(x, y, imageData, canvas);\n\n        if (pixel !== undefined && pixel[3] === 0) {\n            pixelIsTransparent = true;\n        }\n        return pixelIsTransparent;\n    }\n\n    /**\n     * Remove current attributes and arrays. Minimizes memory footprint.\n     */\n    protected clearAttributes() {\n        this.positionAttribute = undefined;\n        this.colorAttribute = undefined;\n        this.uvAttribute = undefined;\n        this.indexAttribute = undefined;\n        this.resize(START_BOX_BUFFER_SIZE, true);\n    }\n\n    /**\n     * Resize the attribute buffers. New value must be larger than the previous one.\n     *\n     * @param newSize New number of elements in the buffer. Number has to be larger than the\n     *      previous size.\n     */\n    protected resizeBuffer(newSize: number) {\n        const newPositionArray = new Float32Array(\n            newSize * NUM_VERTICES_PER_ELEMENT * NUM_POSITION_VALUES_PER_VERTEX\n        );\n\n        if (this.positionAttribute !== undefined && this.positionAttribute.array.length > 0) {\n            const positionAttributeCount = this.positionAttribute.count;\n            newPositionArray.set(this.positionAttribute.array);\n            this.positionAttribute.array = newPositionArray;\n            this.positionAttribute.count = positionAttributeCount;\n        } else {\n            this.positionAttribute = new THREE.BufferAttribute(\n                newPositionArray,\n                NUM_POSITION_VALUES_PER_VERTEX\n            );\n            this.positionAttribute.count = 0;\n            this.positionAttribute.setUsage(THREE.DynamicDrawUsage);\n        }\n\n        const newColorArray = new Uint8Array(\n            newSize * NUM_VERTICES_PER_ELEMENT * NUM_COLOR_VALUES_PER_VERTEX\n        );\n\n        if (this.colorAttribute !== undefined) {\n            const colorAttributeCount = this.colorAttribute.count;\n            newColorArray.set(this.colorAttribute.array);\n            this.colorAttribute.array = newColorArray;\n            this.colorAttribute.count = colorAttributeCount;\n        } else {\n            this.colorAttribute = new THREE.BufferAttribute(\n                newColorArray,\n                NUM_COLOR_VALUES_PER_VERTEX,\n                true\n            );\n            this.colorAttribute.count = 0;\n            this.colorAttribute.setUsage(THREE.DynamicDrawUsage);\n        }\n\n        const newUvArray = new Float32Array(\n            newSize * NUM_VERTICES_PER_ELEMENT * NUM_UV_VALUES_PER_VERTEX\n        );\n\n        if (this.uvAttribute !== undefined) {\n            const uvAttributeCount = this.uvAttribute.count;\n            newUvArray.set(this.uvAttribute.array);\n            this.uvAttribute.array = newUvArray;\n            this.uvAttribute.count = uvAttributeCount;\n        } else {\n            this.uvAttribute = new THREE.BufferAttribute(newUvArray, NUM_UV_VALUES_PER_VERTEX);\n            this.uvAttribute.count = 0;\n            this.uvAttribute.setUsage(THREE.DynamicDrawUsage);\n        }\n\n        const numIndexValues = newSize * NUM_INDICES_PER_ELEMENT * NUM_INDEX_VALUES_PER_VERTEX;\n\n        const newIndexArray =\n            numIndexValues > 65535\n                ? new Uint32Array(numIndexValues)\n                : new Uint16Array(numIndexValues);\n\n        if (this.indexAttribute !== undefined) {\n            const indexAttributeCount = this.indexAttribute.count;\n            newIndexArray.set(this.indexAttribute.array);\n            this.indexAttribute.array = newIndexArray;\n            this.indexAttribute.count = indexAttributeCount;\n        } else {\n            this.indexAttribute = new THREE.BufferAttribute(\n                newIndexArray,\n                NUM_INDEX_VALUES_PER_VERTEX\n            );\n            this.indexAttribute.count = 0;\n            this.indexAttribute.setUsage(THREE.DynamicDrawUsage);\n        }\n\n        this.m_size = newSize;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Math2D, MathUtils } from \"@here/harp-utils\";\n\n/**\n * It returns an array containing the channel colors for the pixel at the given coordinates.\n *\n * @param xPos X value of the pixel.\n * @param yPos Y value of the pixel.\n * @param imageData Data containing the pixels.\n * @param canvas Canvas element that will be used to draw the image, in case the imageData is an\n * ImageBitmap\n */\nexport function getPixelFromImage(\n    xPos: number,\n    yPos: number,\n    imageData: ImageData | ImageBitmap,\n    canvas?: HTMLCanvasElement\n): Uint8ClampedArray | undefined {\n    let pickedColor;\n\n    const isImageBitmap = (imgData: ImageBitmap | ImageData) => {\n        return (imgData as ImageBitmap).close !== undefined;\n    };\n\n    if (isImageBitmap(imageData!)) {\n        if (canvas === undefined) {\n            canvas = document.createElement(\"canvas\");\n        }\n        pickedColor = getPixelFromImageBitmap(imageData as ImageBitmap, xPos, yPos, canvas);\n    } else {\n        const pixelsData = imageData as ImageData;\n        const stride = pixelsData.data.length / (pixelsData.height * pixelsData.width);\n        pickedColor = getPixelFromImageData(pixelsData, xPos, yPos, stride);\n    }\n    return pickedColor;\n}\n\n/**\n * Given the x and y position in screen coordinates inside the target box, it map them to the UV\n * coordinates.\n * @param screenX X value in screen coordinates.\n * @param screenY Y value in screen coordinates.\n * @param box Bounding box in screen coordinates.\n * @param uvBox Uv box referred to the given bounding box.\n */\nexport function screenToUvCoordinates(\n    screenX: number,\n    screenY: number,\n    box: Math2D.Box,\n    uvBox: Math2D.UvBox\n): { u: number; v: number } {\n    const minX = box.x;\n    const maxX = box.x + box.w;\n    const minY = box.y;\n    const maxY = box.y + box.h;\n    const u = MathUtils.map(screenX, minX, maxX, uvBox.s0, uvBox.s1);\n    const v = MathUtils.map(screenY, minY, maxY, uvBox.t0, uvBox.t1);\n\n    return { u, v };\n}\n\n/**\n * It returns an Uint8ClampedArray containing the color channel values for the given pixel\n * coordinates. It returns undefined if the given coordinates are out of range.\n *\n * @param image Bitmap image in which the pixels are stored.\n * @param xPos X value of the pixel.\n * @param yPos Y value of the pixel.\n * @param canvas HTML Canvas element on which the image is drawn.\n */\nexport function getPixelFromImageBitmap(\n    image: ImageBitmap,\n    xPos: number,\n    yPos: number,\n    canvas: HTMLCanvasElement\n): Uint8ClampedArray | undefined {\n    if (xPos > image.width || xPos < 0 || yPos > image.height || yPos < 0) {\n        return undefined;\n    }\n\n    let pixelData;\n\n    canvas.width = image.width;\n    canvas.height = image.height;\n\n    const context = canvas.getContext(\"2d\");\n    if (context !== null) {\n        context.drawImage(\n            image,\n            0,\n            0,\n            image.width,\n            image.height,\n            0,\n            0,\n            canvas.width,\n            canvas.height\n        );\n        pixelData = context.getImageData(xPos, yPos, 1, 1).data;\n    }\n    return pixelData;\n}\n\n/**\n * It returns an Uint8ClampedArray containing the color channel values for the given pixel\n * coordinates. It returns undefined if the given coordinates are out of range.\n *\n * @param image Image data in which the pixels are stored.\n * @param xPos X value of the pixel.\n * @param yPos Y value of the pixel.\n * @param stride The stride value of the image data.\n */\nexport function getPixelFromImageData(\n    imgData: ImageData,\n    xPos: number,\n    yPos: number,\n    stride: number\n): Uint8ClampedArray | undefined {\n    const getPixel = (imageData: ImageData, index: number, strd: number) => {\n        const i = index * strd;\n        const d = imageData.data;\n        const pixel = new Uint8ClampedArray(strd);\n        for (let s = 0; s < strd; s++) {\n            pixel[0] = d[i + s];\n        }\n        return pixel;\n    };\n    if (xPos > imgData.width || xPos < 0 || yPos > imgData.height || yPos < 0) {\n        return undefined;\n    }\n    return getPixel(imgData, yPos * imgData.width + xPos, stride);\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { IChannel } from \"@here/harp-utils\";\n\nexport class PlacementStats {\n    totalGroups: number = 0;\n    resortedGroups: number = 0;\n    total: number = 0;\n    uninitialized: number = 0;\n    tooFar: number = 0;\n    numNotVisible: number = 0;\n    numPathTooSmall: number = 0;\n    numCannotAdd: number = 0;\n    numRenderedPoiIcons: number = 0;\n    numRenderedPoiTexts: number = 0;\n    numPoiTextsInvisible: number = 0;\n    numRenderedTextElements: number = 0;\n\n    constructor(private readonly m_logger: IChannel) {}\n\n    clear() {\n        this.totalGroups = 0;\n        this.resortedGroups = 0;\n        this.total = 0;\n        this.uninitialized = 0;\n        this.tooFar = 0;\n        this.numNotVisible = 0;\n        this.numPathTooSmall = 0;\n        this.numCannotAdd = 0;\n        this.numRenderedPoiIcons = 0;\n        this.numRenderedPoiTexts = 0;\n        this.numPoiTextsInvisible = 0;\n        this.numRenderedTextElements = 0;\n    }\n    log() {\n        const numNotRendered =\n            this.uninitialized +\n            this.numPoiTextsInvisible +\n            this.tooFar +\n            this.numNotVisible +\n            this.numCannotAdd;\n        this.m_logger.debug(\"Total groups\", this.totalGroups);\n        this.m_logger.debug(\"Resorted groups\", this.resortedGroups);\n        this.m_logger.debug(\"Total labels\", this.total);\n        this.m_logger.debug(\"Rendered labels\", this.numRenderedTextElements);\n        this.m_logger.debug(\"Rejected labels\", numNotRendered);\n        this.m_logger.debug(\"Unitialized labels\", this.uninitialized);\n        this.m_logger.debug(\"Rendered poi icons\", this.numRenderedPoiIcons);\n        this.m_logger.debug(\"Rendered poi texts\", this.numRenderedPoiTexts);\n        this.m_logger.debug(\"Poi text invisible\", this.numPoiTextsInvisible);\n        this.m_logger.debug(\"Too far\", this.tooFar);\n        this.m_logger.debug(\"Not visible\", this.numNotVisible);\n        this.m_logger.debug(\"Path too small\", this.numPathTooSmall);\n        this.m_logger.debug(\"Rejected, max glyphs reached\", this.numCannotAdd);\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\n/**\n * @hidden\n */\nexport class SimpleLineCurve extends THREE.LineCurve {\n    private m_lengths?: number[];\n\n    constructor(v1: THREE.Vector2, v2: THREE.Vector2) {\n        super(v1, v2);\n    }\n\n    getLengths(): number[] {\n        if (this.m_lengths === undefined) {\n            this.m_lengths = [0, this.v2.distanceTo(this.v1)];\n        }\n        return this.m_lengths;\n    }\n}\n\n/**\n * @hidden\n */\nexport class PathParam {\n    private m_point: THREE.Vector2 | undefined;\n\n    constructor(readonly path: THREE.Path, readonly index: number, readonly t: number) {}\n\n    get curve(): THREE.Curve<THREE.Vector2> {\n        return this.path.curves[this.index];\n    }\n\n    get point(): THREE.Vector2 {\n        if (this.m_point === undefined) {\n            this.m_point = this.curve.getPoint(this.t);\n        }\n        return this.m_point;\n    }\n}\n\n/**\n * @hidden\n */\nexport class SimplePath extends THREE.Path {\n    private m_cache?: number[];\n\n    constructor() {\n        super();\n    }\n\n    getLengths(): number[] {\n        if (this.m_cache) {\n            return this.m_cache;\n        }\n        let sum = 0;\n        const lengths = new Array<number>();\n        lengths.push(0);\n\n        this.curves.forEach(curve => {\n            const lineCurve = curve as THREE.LineCurve;\n            sum += lineCurve.v1.distanceTo(lineCurve.v2);\n            lengths.push(sum);\n        });\n        this.m_cache = lengths;\n        return lengths;\n    }\n\n    getParamAt(t: number): PathParam | null {\n        const distance = t * this.getLength();\n        const curveLengths = this.getCurveLengths();\n\n        for (let index = 0; index < curveLengths.length; ++index) {\n            if (curveLengths[index] < distance) {\n                continue;\n            }\n\n            const diff = curveLengths[index] - distance;\n            const curve = this.curves[index] as THREE.LineCurve;\n            const segmentLength = curve.getLength();\n            const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n            return new PathParam(this, index, u);\n        }\n\n        return null;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nconst DEFAULT_FONT_CATALOG = \"./resources/fonts/Default_FontCatalog.json\";\n\n/**\n * Default number of labels/POIs rendered in the scene\n */\nconst DEFAULT_MAX_NUM_RENDERED_TEXT_ELEMENTS = 500;\n\n/**\n * Number of elements that are put into second queue. This second chance queue is used to render\n * TextElements that have not been on screen before. This is a quick source for elements that can\n * appear when the camera moves a bit, before new elements are placed.\n */\nconst DEFAULT_MAX_NUM_SECOND_CHANCE_ELEMENTS = 300;\n\n/**\n * Maximum distance for text labels expressed as a ratio of distance to from the camera (0) to the\n * far plane (1.0). May be synchronized with fog value ?\n */\nconst DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS = 0.99;\n\n/**\n * Minimum scaling factor that may be applied to labels when their are distant from focus point.\n */\nconst DEFAULT_LABEL_DISTANCE_SCALE_MIN = 0.7;\n\n/**\n * Maximum scaling factor that may be applied to labels due to their distance from focus point.\n */\nconst DEFAULT_LABEL_DISTANCE_SCALE_MAX = 1.5;\n\nconst MIN_GLYPH_COUNT = 1024;\n\nconst MAX_GLYPH_COUNT = 32768;\n\nexport interface TextElementsRendererOptions {\n    /**\n     * The path to the font catalog file. Default is [[DEFAULT_FONT_CATALOG]].\n     */\n    fontCatalog?: string;\n    /**\n     * Optional initial number of glyphs (characters) for labels. In situations with limited,\n     * available memory, decreasing this number may be beneficial.\n     *\n     * @default [[MIN_GLYPH_COUNT]]\n     */\n    minNumGlyphs?: number;\n    /**\n     * Optional limit of number of glyphs (characters) for labels. In situations with limited,\n     * available memory, decreasing this number may be beneficial.\n     *\n     * @default [[MAX_GLYPH_COUNT]]\n     */\n    maxNumGlyphs?: number;\n    /**\n     * Limits the number of [[DataSource]] labels visible, such as road names and POIs.\n     * On small devices, you can reduce this number to to increase performance.\n     * @default [[DEFAULT_MAX_NUM_RENDERED_TEXT_ELEMENTS]].\n     */\n    maxNumVisibleLabels?: number;\n    /**\n     * The number of [[TextElement]]s that the [[TextElementsRenderer]] tries to render even\n     * if they were not visible during placement. This property only applies to [[TextElement]]s\n     * that were culled by the frustum; useful for map movements and animations.\n     * @default [[DEFAULT_MAX_NUM_SECOND_CHANCE_ELEMENTS]].\n     */\n    numSecondChanceLabels?: number;\n    /**\n     * The maximum distance for [[TextElement]] to be rendered, expressed as a fraction of\n     * the distance between the near and far plane [0, 1.0].\n     * @default [[DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS]].\n     */\n    maxDistanceRatioForTextLabels?: number;\n    /**\n     * The maximum distance for [[TextElement]] with icons to be rendered,\n     * expressed as a fraction of the distance\n     * between the near and far plane [0, 1.0].\n     * @default [[DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS]].\n     */\n    maxDistanceRatioForPoiLabels?: number;\n    /**\n     * The minimum scaling factor that may be applied to [[TextElement]]s due to their distance.\n     * If not defined the default value specified in [[TextElementsRenderer]] will be used.\n     * @default [[DEFAULT_LABEL_DISTANCE_SCALE_MIN]].\n     */\n    labelDistanceScaleMin?: number;\n    /**\n     * The maximum scaling factor that may be applied to [[TextElement]]s due to their distance.\n     * If not defined the default value specified in [[TextElementsRenderer]] will be used.\n     * @default [[DEFAULT_LABEL_DISTANCE_SCALE_MAX]].\n     */\n    labelDistanceScaleMax?: number;\n\n    /**\n     * Disable all fading animations for debugging and performance measurement.\n     * @default `false`\n     */\n    disableFading?: boolean;\n}\n\n/**\n * Initializes undefined text renderer options to default values.\n * @param options The options to be initialized.\n */\nexport function initializeDefaultOptions(options: TextElementsRendererOptions) {\n    if (options.fontCatalog === undefined) {\n        options.fontCatalog = DEFAULT_FONT_CATALOG;\n    }\n\n    if (options.minNumGlyphs === undefined) {\n        options.minNumGlyphs = MIN_GLYPH_COUNT;\n    }\n    if (options.maxNumGlyphs === undefined) {\n        options.maxNumGlyphs = MAX_GLYPH_COUNT;\n    }\n    if (options.maxNumVisibleLabels === undefined) {\n        options.maxNumVisibleLabels = DEFAULT_MAX_NUM_RENDERED_TEXT_ELEMENTS;\n    }\n    // TODO: Unused so far.\n    if (options.numSecondChanceLabels === undefined) {\n        options.numSecondChanceLabels = DEFAULT_MAX_NUM_SECOND_CHANCE_ELEMENTS;\n    }\n    if (options.labelDistanceScaleMin === undefined) {\n        options.labelDistanceScaleMin = DEFAULT_LABEL_DISTANCE_SCALE_MIN;\n    }\n    if (options.labelDistanceScaleMax === undefined) {\n        options.labelDistanceScaleMax = DEFAULT_LABEL_DISTANCE_SCALE_MAX;\n    }\n    if (options.maxDistanceRatioForTextLabels === undefined) {\n        options.maxDistanceRatioForTextLabels = DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS;\n    }\n    if (options.maxDistanceRatioForPoiLabels === undefined) {\n        options.maxDistanceRatioForPoiLabels = DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS;\n    }\n\n    if (options.disableFading === undefined) {\n        options.disableFading = false;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { assert, LoggerManager, LogLevel } from \"@here/harp-utils\";\nimport { TextElement } from \"./TextElement\";\nimport { TextElementGroup } from \"./TextElementGroup\";\nimport { TextElementFilter, TextElementGroupState } from \"./TextElementGroupState\";\nimport { TextElementState } from \"./TextElementState\";\n\nconst logger = LoggerManager.instance.create(\"TextElementsStateCache\", { level: LogLevel.Log });\n\n/**\n * Label distance tolerance squared in meters. Point labels with the same name that are closer in\n * world space than this value are treated as the same label. Used to identify duplicate labels in\n * overlapping tiles and label replacements at different storage levels.\n */\nfunction getDedupSqDistTolerance(zoomLevel: number) {\n    // Defining here a minimum tolerance of 10m at zoom level 13 or higher.\n    const minSqTol = 100;\n    const minSqTolLevel = 13;\n    const maxLevelDelta = 4;\n    const levelDelta = Math.min(\n        maxLevelDelta,\n        minSqTolLevel - Math.min(minSqTolLevel, Math.floor(zoomLevel))\n    );\n    // Distance tolerance computed applying a factor over an arbitrary minimum tolerance for a\n    // chosen zoom level. The factor is an exponential function on zoom level delta wrt minimum\n    // tolerance zoom level.\n    // error = sqrt(sqError) = sqrt(minSqError* 2^(4d)) = minError*2^(2d)\n\n    //tslint:disable-next-line: no-bitwise\n    return minSqTol << (levelDelta << 2);\n}\n\nconst tmpCachedDuplicate: { entries: TextElementState[]; index: number } = {\n    entries: [],\n    index: -1\n};\n\nfunction getCacheKey(element: TextElement): string | number {\n    return element.hasFeatureId() ? element.featureId! : element.text;\n}\n\n/**\n * Caches the state of text element groups currently rendered as well as the text element states\n * belonging to them, including their fading state and text deduplication information.\n */\nexport class TextElementStateCache {\n    private readonly m_referenceMap = new Map<TextElementGroup, TextElementGroupState>();\n    private m_sortedGroupStates: TextElementGroupState[] | undefined;\n\n    // Cache for point labels which may have duplicates in same tile or in neighboring tiles.\n    private readonly m_textMap = new Map<string | number, TextElementState[]>();\n\n    /**\n     * Gets the state corresponding to a given text element group or sets a newly created state if\n     * not found. It updates the states of the text elements belonging to the group using the\n     * specified parameters.\n     * @param textElementGroup The group of which the state will be obtained.\n     * @param textElementFilter Filter used to decide if a text element must be initialized,\n     * @see [[TextElementGroupState]] construction.\n     * @returns Tuple with the group state as first element and a boolean indicating whether the\n     * state was found in cache (`true`) or newly created (`false`) as second element.\n     */\n    getOrSet(\n        textElementGroup: TextElementGroup,\n        textElementFilter: TextElementFilter\n    ): [TextElementGroupState, boolean] {\n        let groupState = this.get(textElementGroup);\n\n        if (groupState !== undefined) {\n            assert(groupState.size === textElementGroup.elements.length);\n            groupState.updateElements(textElementFilter);\n            return [groupState, true];\n        }\n\n        groupState = new TextElementGroupState(textElementGroup, textElementFilter);\n        this.set(textElementGroup, groupState);\n\n        return [groupState, false];\n    }\n\n    get size(): number {\n        return this.m_referenceMap.size;\n    }\n\n    /**\n     * @returns All text element group states in the cache by group priority.\n     */\n    get sortedGroupStates(): TextElementGroupState[] {\n        if (this.m_sortedGroupStates === undefined) {\n            this.m_sortedGroupStates = Array.from(this.m_referenceMap.values());\n            this.m_sortedGroupStates.sort((a: TextElementGroupState, b: TextElementGroupState) => {\n                return b.group.priority - a.group.priority;\n            });\n        }\n\n        assert(this.m_referenceMap.size === this.m_sortedGroupStates.length);\n        return this.m_sortedGroupStates;\n    }\n\n    /**\n     * Updates state of all cached groups, discarding those that are not needed anymore.\n     * @param time The current time.\n     * @param disableFading `True` if fading is currently disabled, `false` otherwise.\n     * @param findReplacements `True` to replace each visible unvisited text element with a\n     * visited duplicate.\n     * @param zoomLevel Current zoom level.\n     * @returns `True` if any textElementGroup was evicted from cache, false otherwise.\n     */\n    update(time: number, disableFading: boolean, findReplacements: boolean, zoomLevel: number) {\n        const replaceCallback = findReplacements\n            ? this.replaceElement.bind(this, zoomLevel)\n            : undefined;\n\n        let anyEviction = false;\n        for (const [key, groupState] of this.m_referenceMap.entries()) {\n            if (groupState.visited) {\n                groupState.updateFading(time, disableFading);\n            } else {\n                if (findReplacements) {\n                    groupState.traverseVisibleElements(replaceCallback!);\n                }\n                this.m_referenceMap.delete(key);\n                this.m_sortedGroupStates = undefined;\n                anyEviction = true;\n            }\n        }\n        return anyEviction;\n    }\n\n    /**\n     * Clears visited state for all text element groups in cache.\n     */\n    clearVisited() {\n        for (const groupState of this.m_referenceMap.values()) {\n            groupState.visited = false;\n        }\n    }\n\n    clearTextCache() {\n        this.m_textMap.clear();\n    }\n\n    /**\n     * Clears the whole cache contents.\n     */\n    clear() {\n        this.m_referenceMap.clear();\n        this.m_sortedGroupStates = undefined;\n        this.m_textMap.clear();\n    }\n\n    /**\n     * Removes duplicates for a given text element.\n     *\n     * @param zoomLevel Current zoom level.\n     * @param elementState State of the text element to deduplicate.\n     * @returns True if it's the remaining element after deduplication, false if it's been marked\n     * as duplicate.\n     */\n    deduplicateElement(zoomLevel: number, elementState: TextElementState): boolean {\n        const element = elementState.element;\n        const cacheKey = getCacheKey(element);\n        const cacheResult = this.findDuplicate(elementState, cacheKey, zoomLevel);\n\n        if (cacheResult === undefined) {\n            // Text not found so far, add this element to cache.\n            this.m_textMap.set(cacheKey, [elementState]);\n            return true;\n        }\n\n        if (cacheResult.index === -1) {\n            // No duplicate found among elements with same text,add this one to cache.\n            cacheResult.entries.push(elementState);\n            return true;\n        }\n\n        // Duplicate found, check whether there's a label already visible and keep that one.\n        const cachedDuplicate = cacheResult.entries[cacheResult.index];\n\n        if (!cachedDuplicate.visible && elementState.visible) {\n            // New label is visible, substitute the cached label.\n            cacheResult.entries[cacheResult.index] = elementState;\n            cachedDuplicate.reset();\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Replaces a visible unvisited text element with a visited duplicate.\n     * @param zoomLevel Current zoom level.\n     * @param elementState State of the text element to deduplicate.\n     */\n    replaceElement(zoomLevel: number, elementState: TextElementState): void {\n        assert(elementState.visible);\n        const element = elementState.element;\n        const cacheResult = this.findDuplicate(elementState, getCacheKey(element), zoomLevel);\n\n        if (cacheResult === undefined || cacheResult.index === -1) {\n            // No replacement found;\n            return;\n        }\n\n        const replacement = cacheResult.entries[cacheResult.index];\n        assert(!replacement.visible);\n\n        replacement.replace(elementState);\n    }\n\n    /**\n     * Gets the state corresponding to a given text element group.\n     * @param textElementGroup The group of which the state will be obtained.\n     * @returns The group state if cached, otherwise `undefined`.\n     */\n    private get(textElementGroup: TextElementGroup): TextElementGroupState | undefined {\n        const groupState = this.m_referenceMap.get(textElementGroup);\n\n        if (groupState !== undefined) {\n            groupState.visited = true;\n        }\n        return groupState;\n    }\n\n    /**\n     * Sets a specified state for a given text element group.\n     * @param textElementGroup  The group of which the state will be set.\n     * @param textElementGroupState The state to set for the group.\n     */\n    private set(textElementGroup: TextElementGroup, textElementGroupState: TextElementGroupState) {\n        assert(textElementGroup.elements.length > 0);\n        this.m_referenceMap.set(textElementGroup, textElementGroupState);\n        this.m_sortedGroupStates = undefined;\n    }\n\n    private findDuplicate(\n        elementState: TextElementState,\n        cacheKey: string | number,\n        zoomLevel: number\n    ): { entries: TextElementState[]; index: number } | undefined {\n        // Point labels may have duplicates (as can path labels), Identify them\n        // and keep the one we already display.\n\n        const element = elementState.element;\n        const cachedEntries = this.m_textMap.get(cacheKey);\n\n        if (cachedEntries === undefined) {\n            // No labels found with the same key.\n            return undefined;\n        }\n\n        tmpCachedDuplicate.entries = cachedEntries;\n\n        if (element.hasFeatureId()) {\n            // Cached entries with same feature id found, find the entry with the same tile offset.\n            tmpCachedDuplicate.index = cachedEntries.findIndex(\n                entry => entry.element.tileOffset === element.tileOffset\n            );\n            if (tmpCachedDuplicate.index === -1) {\n                return tmpCachedDuplicate;\n            }\n            const cachedElement = cachedEntries[tmpCachedDuplicate.index].element;\n            assert(element.featureId === cachedElement.featureId);\n\n            if (cachedElement.text !== element.text) {\n                tmpCachedDuplicate.index = -1;\n                // Labels with different text shouldn't share the same feature id. This points to\n                // an issue on the map data side. Submit a ticket to the corresponding map backend\n                // issue tracking system if available (e.g. OLPRPS project in JIRA for OMV),\n                // indicating affected labels including tile keys, texts and feature id.\n                logger.warn(\n                    `Text feature id ${element.featureId} collision between \"${element.text} and \\\n                     ${cachedElement.text}`\n                );\n            }\n            return tmpCachedDuplicate;\n        }\n\n        // Other labels found with the same text. Check if they're near enough to be considered\n        // duplicates.\n        const maxSqDistError = getDedupSqDistTolerance(zoomLevel);\n        const entryCount = cachedEntries.length;\n        const elementPosition = element.position;\n        const elementVisible = elementState.visible;\n        let duplicateIndex: number = -1;\n        for (let i = 0; i < entryCount; ++i) {\n            const cachedEntry = cachedEntries[i];\n            if (elementVisible && cachedEntry.visible) {\n                // Two text elements visible at the same time are always considered distinct.\n                continue;\n            }\n            const distSquared = elementPosition.distanceToSquared(cachedEntry.element.position);\n\n            if (distSquared < maxSqDistError) {\n                duplicateIndex = i;\n                break;\n            }\n        }\n\n        tmpCachedDuplicate.index = duplicateIndex;\n        return tmpCachedDuplicate;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { assert } from \"@here/harp-utils\";\nimport { TextElementGroup } from \"./TextElementGroup\";\nimport { TextElementState } from \"./TextElementState\";\n\n/**\n * Type of functions used to do early rejection of elements during group state creation or update.\n * @param textElementState The state of the text element to check.\n * @returns `undefined` if element was rejected, otherwise its current view distance.\n */\nexport type TextElementFilter = (textElementState: TextElementState) => number | undefined;\n\n/**\n * `TextElementGroupState` keeps the state of a text element group and each element in it while\n * they're being rendered.\n */\nexport class TextElementGroupState {\n    private m_textElementStates: TextElementState[];\n    private m_visited: boolean = false;\n\n    /**\n     * Creates the state for specified group.\n     * @param group The group of which the state will be created.\n     * @param filter Function used to do early rejection. @see [[TextElementFilter]].\n     */\n    constructor(readonly group: TextElementGroup, filter: TextElementFilter) {\n        assert(group.elements.length > 0);\n        const length = group.elements.length;\n        this.m_textElementStates = new Array(length);\n        this.m_visited = true;\n\n        // TODO: HARP-7648. Reduce number of allocations here:\n        // a) Avoid creating the state for labels that don't pass early placement checks and make\n        //    this checks more strict.\n        // b) Break label state objects into a set of arrays held at group level, one for each\n        //    primitive field in the label state.\n        for (let i = 0; i < length; ++i) {\n            const textElement = group.elements[i];\n            const state = new TextElementState(textElement);\n            const textDistance = filter(state);\n            state.update(textDistance);\n            this.m_textElementStates[i] = state;\n        }\n    }\n\n    /**\n     * Indicates whether the group has been submitted to the [[TextElementsRenderer]] in the current\n     * frame.\n     */\n    get visited(): boolean {\n        return this.m_visited;\n    }\n\n    set visited(visited: boolean) {\n        this.m_visited = visited;\n    }\n\n    /**\n     * @returns the priority of the text elements in the group.\n     */\n    get priority() {\n        return this.m_textElementStates[0].element.priority;\n    }\n\n    /**\n     * Updates the fading state of all text elements within the group to the specified time.\n     * @param time The time to which the fading state will be updated.\n     * @param disableFading `true` if fading is disabled, `false` otherwise.\n     */\n    updateFading(time: number, disableFading: boolean): void {\n        for (const elementState of this.m_textElementStates) {\n            if (elementState !== undefined) {\n                elementState.updateFading(time, disableFading);\n            }\n        }\n    }\n\n    /**\n     * Calls the specified callback for every visible text elements in the group.\n     * @param visibleElementsCallback Functions that will be called for every visible text element\n     * in the group.\n     */\n    traverseVisibleElements(visibleElementsCallback: (e: TextElementState) => void): void {\n        for (const elementState of this.m_textElementStates) {\n            if (elementState !== undefined && elementState.visible) {\n                visibleElementsCallback(elementState);\n            }\n        }\n    }\n\n    /**\n     * Updates the states of elements within the group.\n     * @param filter Function used to do early rejection. @see [[TextElementFilter]].\n     */\n    updateElements(filter: TextElementFilter) {\n        for (const elementState of this.m_textElementStates) {\n            const textDistance = filter(elementState);\n            elementState.update(textDistance);\n        }\n    }\n\n    get size(): number {\n        return this.m_textElementStates.length;\n    }\n\n    /**\n     * Returns text element states.\n     * @returns Array of element states.\n     */\n    get textElementStates(): TextElementState[] {\n        return this.m_textElementStates;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { assert } from \"@here/harp-utils\";\nimport { RenderState } from \"./RenderState\";\nimport { TextElement } from \"./TextElement\";\nimport { TextElementType } from \"./TextElementType\";\n\n/**\n * `TextElementState` keeps the current state of a text element while it's being rendered.\n */\nexport class TextElementState {\n    /**\n     * @hidden\n     * Used during label placement to reserve space from front to back.\n     */\n    private m_viewDistance: number | undefined;\n\n    /**\n     * @hidden\n     * Used during rendering. The array type is used for line markers only, which have a points\n     * array and multiple icon positions to render. Since line markers use the same renderState\n     * for text part and icon, there is no separate array of [[RenderState]]s for the text parts\n     * of the line markers.\n     */\n    private m_iconRenderStates?: RenderState | RenderState[];\n\n    /**\n     * @hidden\n     * Used during rendering.\n     */\n    private m_textRenderState?: RenderState;\n\n    constructor(readonly element: TextElement) {}\n\n    get initialized(): boolean {\n        return this.m_textRenderState !== undefined || this.m_iconRenderStates !== undefined;\n    }\n\n    /**\n     * @returns `true` if any component of the element is visible, `false` otherwise.\n     */\n    get visible(): boolean {\n        if (this.m_textRenderState !== undefined && this.m_textRenderState.isVisible()) {\n            return true;\n        }\n\n        const iconRenderState = this.iconRenderState;\n        if (iconRenderState !== undefined && iconRenderState.isVisible()) {\n            return true;\n        }\n\n        const iconRenderStates = this.iconRenderStates;\n        if (iconRenderStates === undefined) {\n            return false;\n        }\n\n        for (const state of iconRenderStates) {\n            if (state.isVisible()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Resets the element to an initialized state.\n     */\n    reset() {\n        if (this.m_textRenderState !== undefined) {\n            this.m_textRenderState.reset();\n        }\n\n        if (this.iconRenderState) {\n            (this.m_iconRenderStates as RenderState).reset();\n        } else if (this.m_iconRenderStates !== undefined) {\n            for (const renderState of this.m_iconRenderStates as RenderState[]) {\n                renderState.reset();\n            }\n        }\n        this.m_viewDistance = undefined;\n    }\n\n    /**\n     * Replaces given text element, inheriting its current state.\n     * The predecessor text element state is erased.\n     * @param predecessor Text element state to be replaced.\n     */\n    replace(predecessor: TextElementState) {\n        this.m_textRenderState = predecessor.m_textRenderState;\n        this.m_iconRenderStates = predecessor.m_iconRenderStates;\n        predecessor.m_textRenderState = undefined;\n        predecessor.m_iconRenderStates = undefined;\n\n        if (this.element.glyphs === undefined) {\n            // Use the predecessor glyphs, bounds and case array until proper ones are computed.\n            this.element.glyphs = predecessor.element.glyphs;\n            this.element.bounds = predecessor.element.bounds;\n            this.element.glyphCaseArray = predecessor.element.glyphCaseArray;\n        }\n    }\n\n    /**\n     * Returns the last computed distance of the text element to the camera.\n     * @returns Distance to camera.\n     */\n    get viewDistance(): number | undefined {\n        return this.m_viewDistance;\n    }\n\n    /**\n     * Updates the text element state.\n     * @param viewDistance The new view distance to set. If `undefined`, element is considered to\n     * be out of view.\n     */\n    update(viewDistance: number | undefined) {\n        if (this.initialized) {\n            this.setViewDistance(viewDistance);\n        } else if (viewDistance !== undefined) {\n            this.initialize(viewDistance);\n        }\n    }\n\n    /**\n     * Sets the distance of the element to the current view center.\n     * @param viewDistance The new view distance to set. If `undefined`, element is considered to\n     * be out of view.\n     */\n    setViewDistance(viewDistance: number | undefined) {\n        if (viewDistance === this.m_viewDistance) {\n            return;\n        }\n        this.m_viewDistance = viewDistance;\n    }\n\n    /**\n     * Return the last distance that has been computed for sorting during placement. This may not be\n     * the actual distance if the camera is moving, as the distance is computed only during\n     * placement. If the property `alwaysOnTop` is true, the value returned is always `0`.\n     *\n     * @returns 0 or negative distance to camera.\n     */\n    get renderDistance(): number {\n        return this.element.alwaysOnTop === true\n            ? 0\n            : this.m_viewDistance !== undefined\n            ? -this.m_viewDistance\n            : 0;\n    }\n\n    /**\n     * @returns The text render state.\n     */\n    get textRenderState(): RenderState | undefined {\n        return this.m_textRenderState;\n    }\n\n    /**\n     * Returns the icon render state for the case where the text element has only one icon.\n     * @returns The icon render state if the text element has a single icon, otherwise undefined.\n     */\n    get iconRenderState(): RenderState | undefined {\n        if (this.m_iconRenderStates === undefined) {\n            return undefined;\n        }\n\n        return this.m_iconRenderStates instanceof RenderState ? this.m_iconRenderStates : undefined;\n    }\n\n    /**\n     * Returns the icon render states for text elements with multiple icons.\n     * @returns The icon render states if the text element has multiple icons, otherwise undefined.\n     */\n    get iconRenderStates(): RenderState[] | undefined {\n        if (this.m_iconRenderStates === undefined) {\n            return undefined;\n        }\n\n        return this.m_iconRenderStates instanceof RenderState\n            ? undefined\n            : (this.m_iconRenderStates as RenderState[]);\n    }\n\n    /**\n     * Updates the fading state to the specified time.\n     * @param time The current time.\n     * @param disableFading If `True` there will be no fading transitions, i.e., state will go\n     * directly from FadedIn to FadedOut and viceversa.\n     */\n    updateFading(time: number, disableFading: boolean): void {\n        if (this.m_textRenderState !== undefined) {\n            this.m_textRenderState.updateFading(time, disableFading);\n        }\n\n        if (this.iconRenderState !== undefined) {\n            const iconRenderState = this.m_iconRenderStates as RenderState;\n            iconRenderState.updateFading(time, disableFading);\n        } else if (this.iconRenderStates !== undefined) {\n            for (const renderState of this.m_iconRenderStates as RenderState[]) {\n                renderState.updateFading(time, disableFading);\n            }\n        }\n    }\n\n    /**\n     * @param viewDistance Current distance of the element to the view center.\n     */\n    private initialize(viewDistance: number) {\n        assert(this.m_textRenderState === undefined);\n        assert(this.m_iconRenderStates === undefined);\n\n        this.setViewDistance(viewDistance);\n\n        if (this.element.type === TextElementType.LineMarker) {\n            this.m_iconRenderStates = new Array<RenderState>();\n            for (const _point of this.element.points as THREE.Vector3[]) {\n                const iconRenderStates = this.m_iconRenderStates as RenderState[];\n                const renderState = new RenderState();\n                iconRenderStates.push(renderState);\n            }\n            return;\n        }\n\n        this.m_textRenderState = new RenderState();\n\n        if (this.element.type === TextElementType.PoiLabel) {\n            this.m_iconRenderStates = new RenderState();\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { assert, MathUtils } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\n/**\n * State of fading.\n */\nexport enum FadingState {\n    Undefined = 0,\n    FadingIn = 1,\n    FadedIn = 2,\n    FadingOut = -1,\n    FadedOut = -2\n}\n\n/**\n * Time to fade in/fade out the labels in milliseconds.\n */\nexport const DEFAULT_FADE_TIME = 800;\n\n/**\n * State of rendering of the icon and text part of the `TextElement`. Mainly for fading the elements\n * in and out, to compute the opacity.\n *\n * @hidden\n */\nexport class RenderState {\n    private m_state = FadingState.Undefined;\n\n    /**\n     * Create a `RenderState`.\n     *\n     * @param value Current fading value [0..1].\n     * @param startTime Time stamp the fading started.\n     * @param opacity Computed opacity depending on value.\n     */\n    constructor(public value = 0.0, public startTime = 0, public opacity = 1.0) {}\n\n    /**\n     * Reset existing `RenderState` to appear like a fresh state.\n     */\n    reset() {\n        this.m_state = FadingState.Undefined;\n        this.value = 0.0;\n        this.startTime = 0.0;\n        this.opacity = 1.0;\n    }\n\n    /**\n     * @returns `true` if element state is `FadingState.Undefined`.\n     */\n    isUndefined(): boolean {\n        return this.m_state === FadingState.Undefined;\n    }\n\n    /**\n     * @returns `true` if element is either fading in or fading out.\n     */\n    isFading(): boolean {\n        const fading =\n            this.m_state === FadingState.FadingIn || this.m_state === FadingState.FadingOut;\n        return fading;\n    }\n\n    /**\n     * @returns `true` if element is fading in.\n     */\n    isFadingIn(): boolean {\n        const fadingIn = this.m_state === FadingState.FadingIn;\n        return fadingIn;\n    }\n\n    /**\n     * @returns `true` if element is fading out.\n     */\n    isFadingOut(): boolean {\n        const fadingOut = this.m_state === FadingState.FadingOut;\n        return fadingOut;\n    }\n\n    /**\n     * @returns `true` if element is done with fading in.\n     */\n    isFadedIn(): boolean {\n        const fadedIn = this.m_state === FadingState.FadedIn;\n        return fadedIn;\n    }\n\n    /**\n     * @returns `true` if element is done with fading out.\n     */\n    isFadedOut(): boolean {\n        const fadedOut = this.m_state === FadingState.FadedOut;\n        return fadedOut;\n    }\n\n    /**\n     * @returns `true` if state is neither faded out nor undefined.\n     */\n    isVisible(): boolean {\n        return this.m_state !== FadingState.FadedOut && this.m_state !== FadingState.Undefined;\n    }\n\n    /**\n     * Updates the state to [[FadingState.FadingIn]].\n     * If previous state is [[FadingState.FadingIn]] or [[FadingState.FadedIn]] it remains\n     * unchanged.\n     *\n     * @param time Current time.\n     */\n    startFadeIn(time: number) {\n        if (this.m_state === FadingState.FadingIn || this.m_state === FadingState.FadedIn) {\n            return;\n        }\n\n        if (this.m_state === FadingState.FadingOut) {\n            // The fadeout is not complete: compute the virtual fadingStartTime in the past, to get\n            // a correct end time:\n            this.value = 1.0 - this.value;\n            this.startTime = time - this.value * DEFAULT_FADE_TIME;\n        } else {\n            this.startTime = time;\n            this.value = 0.0;\n            this.opacity = 0;\n        }\n\n        this.m_state = FadingState.FadingIn;\n    }\n\n    /**\n     * Updates the state to [[FadingState.FadingOut]].\n     * If previous state is [[FadingState.FadingOut]] or [[FadingState.FadedOut]] it remains\n     * unchanged.\n     *\n     * @param time Current time.\n     */\n    startFadeOut(time: number) {\n        if (this.m_state === FadingState.FadingOut || this.m_state === FadingState.FadedOut) {\n            return;\n        }\n\n        if (this.m_state === FadingState.FadingIn) {\n            // The fade-in is not complete: compute the virtual fadingStartTime in the past, to get\n            // a correct end time:\n            this.startTime = time - this.value * DEFAULT_FADE_TIME;\n            this.value = 1.0 - this.value;\n        } else {\n            this.startTime = time;\n            this.value = 0.0;\n            this.opacity = 1;\n        }\n\n        this.m_state = FadingState.FadingOut;\n    }\n\n    /**\n     * Updates opacity to current time, changing the state to [[FadingState.FadedOut]] or\n     * [[FadingState.FadedIn]] when the opacity becomes 0 or 1 respectively.\n     * It does nothing if [[isFading]] !== `true`.\n     *\n     * @param time Current time.\n     * @param disableFading `true` if fading is disabled, `false` otherwise.\n     */\n    updateFading(time: number, disableFading: boolean): void {\n        if (this.m_state !== FadingState.FadingIn && this.m_state !== FadingState.FadingOut) {\n            return;\n        }\n\n        if (this.startTime === 0) {\n            this.startTime = time;\n        }\n\n        const fadingTime = time - this.startTime;\n        const startValue = this.m_state === FadingState.FadingIn ? 0 : 1;\n        const endValue = this.m_state === FadingState.FadingIn ? 1 : 0;\n\n        if (disableFading || fadingTime >= DEFAULT_FADE_TIME) {\n            this.value = 1.0;\n            this.opacity = endValue;\n            this.m_state =\n                this.m_state === FadingState.FadingIn ? FadingState.FadedIn : FadingState.FadedOut;\n        } else {\n            // TODO: HARP-7648. Do this once for all labels (calculate the last frame value\n            // increment).\n            this.value = fadingTime / DEFAULT_FADE_TIME;\n\n            this.opacity = THREE.Math.clamp(\n                MathUtils.smootherStep(startValue, endValue, this.value),\n                0,\n                1\n            );\n            assert(this.isFading());\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { IChannel } from \"@here/harp-utils\";\nimport { PrePlacementResult } from \"./Placement\";\n\nexport class UpdateStats {\n    tiles: number = 0;\n    totalGroups: number = 0;\n    newGroups: number = 0;\n    totalLabels: number = 0;\n    results = new Array<number>(PrePlacementResult.Count);\n\n    constructor(private readonly m_logger: IChannel) {\n        this.results.fill(0);\n    }\n\n    clear() {\n        this.tiles = 0;\n        this.totalGroups = 0;\n        this.newGroups = 0;\n        this.totalLabels = 0;\n        this.results.fill(0);\n    }\n    log() {\n        this.m_logger.debug(\"Tiles\", this.tiles);\n        this.m_logger.debug(\"Total groups\", this.totalGroups);\n        this.m_logger.debug(\"New groups\", this.newGroups);\n        this.m_logger.debug(\"Total labels\", this.totalLabels);\n        this.m_logger.debug(\"Placed labels\", this.results[PrePlacementResult.Ok]);\n        this.m_logger.debug(\"Invisible\", this.results[PrePlacementResult.Invisible]);\n        this.m_logger.debug(\"Poi not ready\", this.results[PrePlacementResult.NotReady]);\n        this.m_logger.debug(\"Too far\", this.results[PrePlacementResult.TooFar]);\n        this.m_logger.debug(\"Duplicate\", this.results[PrePlacementResult.Duplicate]);\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { PriorityListGroup } from \"@here/harp-utils\";\nimport { TextElement } from \"./TextElement\";\n\n/**\n * Group of [[TextElement]] sharing same priority.\n */\nexport class TextElementGroup extends PriorityListGroup<TextElement> {}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GroupedPriorityList } from \"@here/harp-utils\";\nimport { TextElement } from \"./TextElement\";\n\n/**\n * List of [[TextElement]] groups sorted by priority.\n */\nexport class TextElementGroupPriorityList extends GroupedPriorityList<TextElement> {}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport * as THREE from \"three\";\n\nimport {\n    IBloomEffect,\n    IOutlineEffect,\n    ISepiaEffect,\n    IVignetteEffect\n} from \"@here/harp-datasource-protocol\";\nimport { SepiaShader, VignetteShader } from \"@here/harp-materials\";\nimport { IPassManager } from \"./IPassManager\";\nimport { LowResRenderPass } from \"./LowResRenderPass\";\nimport { MSAARenderPass, MSAASampling } from \"./MSAARenderPass\";\nimport { OutlineEffect } from \"./Outline\";\nimport { RenderPass, ShaderPass } from \"./Pass\";\nimport { BloomPass } from \"./UnrealBloomPass\";\n\nconst DEFAULT_DYNAMIC_MSAA_SAMPLING_LEVEL = MSAASampling.Level_1;\nconst DEFAULT_STATIC_MSAA_SAMPLING_LEVEL = MSAASampling.Level_4;\n\n/**\n * Interface for the antialias settings passed when instantiating a [[MapView]], and transferred to\n * the [[MapRenderingManager]] instance. These parameters can be changed at runtime as opposed to\n * the native WebGL antialiasing.\n */\nexport interface IMapAntialiasSettings {\n    /**\n     * Whether the MSAA is enabled or not.\n     *\n     * @default `false`\n     */\n    msaaEnabled: boolean;\n\n    /**\n     * The sampling level to use for MSAA during continuous rendering.\n     *\n     * @default `MSAASampling.Level_1`\n     */\n    dynamicMsaaSamplingLevel?: MSAASampling;\n\n    /**\n     * The sampling level to use for MSAA when the rendering stops.\n     *\n     * @default `MSAASampling.Level_4`\n     */\n    staticMsaaSamplingLevel?: MSAASampling;\n}\n\n/**\n * The `MapRenderingManager` class manages the map rendering (as opposed to text) by dispatching the\n * [[MapRenderingManager.render]] call to a set of internal [[Pass]] instances. It provides an API\n * to modify some of the rendering processes like the antialiasing behaviour at runtime.\n */\nexport interface IMapRenderingManager extends IPassManager {\n    /**\n     * Bloom effect parameters.\n     */\n    bloom: IBloomEffect;\n\n    /**\n     * Outline effect parameters.\n     */\n    outline: IOutlineEffect;\n\n    /**\n     * Vignette effect parameters.\n     */\n    vignette: IVignetteEffect;\n\n    /**\n     * Sepia effect parameters.\n     */\n    sepia: ISepiaEffect;\n\n    /**\n     * Set a `pixelRatio` for dynamic rendering (i.e. during animations). If a value is specified,\n     * the `LowResRenderPass` will be employed to used to render the scene into a lower resolution\n     * render target, which will then be rendered to the screen.\n     */\n    lowResPixelRatio?: number;\n\n    /**\n     * The level of MSAA sampling while the user interacts. It should be a low level so that the\n     * MSAA does not impact the framerate.\n     */\n    dynamicMsaaSamplingLevel: MSAASampling;\n\n    /**\n     * Enable or disable the MSAA. If disabled, `MapRenderingManager` will use the renderer provided\n     * in the [[MapRenderingManager.render]] method to render the scene.\n     */\n    msaaEnabled: boolean;\n\n    /**\n     * The higher level of MSAA sampling for a last frame to render, when the camera is static. It\n     * can be a high level, providing high quality renders requiring few tens of seconds, since no\n     * frame is expected to immediately follow in the requestAnimationFrame. It is still limited by\n     * zooming, since zooming is not requestAnimationFrame-based and can lead to stuttering if the\n     * render time is too long, except on desktop Mac, where mouse interaction already implements\n     * some damping. Higher levels of sampling may lead to noticeable color banding, visible in\n     * areas with a slight color gradient, like large areas or the sky background.\n     */\n    staticMsaaSamplingLevel: MSAASampling;\n\n    /**\n     * The method to call to render the map. This method depends on an `isStaticFrame` boolean that\n     * notifies the pass manager to switch to a higher level render quality for the last frame.\n     *\n     * @param renderer The ThreeJS WebGLRenderer instance to render the map with.\n     * @param isStaticFrame Whether the frame to render is static or dynamic. Selects level of\n     * antialiasing.\n     * @param time Optional time argument provided by the requestAnimationFrame, to pass to\n     * sub-passes.\n     */\n    render(\n        renderer: THREE.WebGLRenderer,\n        scene: THREE.Scene,\n        camera: THREE.PerspectiveCamera | THREE.OrthographicCamera,\n        isStaticFrame: boolean,\n        time?: number\n    ): void;\n\n    /**\n     * Updating the outline rebuilds the outline materials of every outlined mesh.\n     *\n     * @param options outline options from the [[Theme]].\n     */\n    updateOutline(options: {\n        thickness: number;\n        color: string;\n        ghostExtrudedPolygons: boolean;\n    }): void;\n}\n\n/**\n * The implementation of [[IMapRenderingManager]] to instantiate in [[MapView]] and manage the map\n * rendering.\n */\nexport class MapRenderingManager implements IMapRenderingManager {\n    bloom = {\n        enabled: false,\n        strength: 1.5,\n        radius: 0.4,\n        threshold: 0.85\n    };\n    outline = {\n        enabled: false,\n        thickness: 0.005,\n        color: \"#000000\",\n        ghostExtrudedPolygons: false,\n        needsUpdate: false\n    };\n    vignette = {\n        enabled: false,\n        offset: 1.0,\n        darkness: 1.0\n    };\n    sepia = {\n        enabled: false,\n        amount: 0.5\n    };\n\n    private m_width: number = 1;\n    private m_height: number = 1;\n\n    private m_outlineEffect?: OutlineEffect;\n    private m_msaaPass: MSAARenderPass;\n    private m_renderPass: RenderPass = new RenderPass();\n    private m_target1: THREE.WebGLRenderTarget = new THREE.WebGLRenderTarget(1, 1);\n    private m_target2: THREE.WebGLRenderTarget = new THREE.WebGLRenderTarget(1, 1);\n    private m_bloomPass?: BloomPass;\n    private m_sepiaPass: ShaderPass = new ShaderPass(SepiaShader);\n    private m_vignettePass: ShaderPass = new ShaderPass(VignetteShader);\n    private m_readBuffer: THREE.WebGLRenderTarget;\n    private m_dynamicMsaaSamplingLevel: MSAASampling;\n    private m_staticMsaaSamplingLevel: MSAASampling;\n    private m_lowResPass: LowResRenderPass;\n\n    /**\n     * The constructor of `MapRenderingManager`.\n     *\n     * @param width Width of the frame buffer.\n     * @param height Height of the frame buffer.\n     * @param lowResPixelRatio The `pixelRatio` determines the resolution of the internal\n     *  `WebGLRenderTarget`. Values between 0.5 and `window.devicePixelRatio` can be tried to give\n     * good results. A value of `undefined` disables the low res render pass. The value should not\n     * be larger than`window.devicePixelRatio`.\n     * @param antialiasSetting The object defining the demeanor of MSAA.\n     */\n    constructor(\n        width: number,\n        height: number,\n        lowResPixelRatio: number | undefined,\n        antialiasSettings: IMapAntialiasSettings | undefined = { msaaEnabled: false }\n    ) {\n        this.m_readBuffer = new THREE.WebGLRenderTarget(width, height);\n        this.m_msaaPass = new MSAARenderPass();\n        this.m_msaaPass.enabled =\n            antialiasSettings !== undefined ? antialiasSettings.msaaEnabled === true : false;\n        this.m_dynamicMsaaSamplingLevel =\n            antialiasSettings.dynamicMsaaSamplingLevel === undefined\n                ? DEFAULT_DYNAMIC_MSAA_SAMPLING_LEVEL\n                : antialiasSettings.dynamicMsaaSamplingLevel;\n        this.m_staticMsaaSamplingLevel =\n            antialiasSettings.staticMsaaSamplingLevel === undefined\n                ? DEFAULT_STATIC_MSAA_SAMPLING_LEVEL\n                : antialiasSettings.staticMsaaSamplingLevel;\n        this.m_lowResPass = new LowResRenderPass(lowResPixelRatio);\n        this.m_lowResPass.enabled = lowResPixelRatio !== undefined;\n    }\n\n    updateOutline(options: { thickness: number; color: string; ghostExtrudedPolygons: boolean }) {\n        this.outline.color = options.color;\n        this.outline.thickness = options.thickness;\n        this.outline.ghostExtrudedPolygons = options.ghostExtrudedPolygons;\n        this.outline.needsUpdate = true;\n    }\n\n    /**\n     * The method to call to render the map with the `MapRenderingManager` instance. It contains the\n     * chain of sub-passes that can transfer the write and read buffers, and other sheer rendering\n     * conditions as disabling AA when a high DPI device is in use.\n     *\n     * @param renderer The ThreeJS WebGLRenderer instance to render the map with.\n     * @param scene The ThreeJS Scene instance containing the map objects to render.\n     * @param camera The ThreeJS Camera instance to render the scene through.\n     * @param isStaticFrame Whether the frame to render is static or dynamic. Selects level of\n     * antialiasing.\n     */\n    render(\n        renderer: THREE.WebGLRenderer,\n        scene: THREE.Scene,\n        camera: THREE.PerspectiveCamera | THREE.OrthographicCamera,\n        isStaticFrame: boolean\n    ) {\n        const target = null;\n        if (!isStaticFrame && this.m_lowResPass.pixelRatio !== undefined) {\n            // Not designed to be combined with our own MSAA\n            this.m_lowResPass.renderToScreen = true;\n            this.m_lowResPass.render(renderer, scene, camera, target, this.m_readBuffer);\n            return;\n        }\n\n        const usePostEffects =\n            this.bloom.enabled ||\n            this.outline.enabled ||\n            this.vignette.enabled ||\n            this.sepia.enabled;\n\n        let activeTarget: null | THREE.WebGLRenderTarget = null;\n\n        // 1. If the bloom is enabled, clear the depth.\n        if (this.bloom.enabled || this.vignette.enabled || this.sepia.enabled) {\n            renderer.setRenderTarget(this.m_target1);\n            renderer.clearDepth();\n        }\n\n        // 2. Render the map.\n\n        if (this.m_msaaPass.enabled) {\n            // Use a higher MSAA sampling level for static rendering.\n            this.m_msaaPass.samplingLevel = isStaticFrame\n                ? this.m_staticMsaaSamplingLevel\n                : this.m_dynamicMsaaSamplingLevel;\n            // MSAA is the only effect for the moment.\n            this.m_msaaPass.renderToScreen = !usePostEffects;\n            // Render to the specified target with the MSAA pass.\n            this.m_msaaPass.render(renderer, scene, camera, target, this.m_readBuffer);\n        } else {\n            if (this.bloom.enabled || this.vignette.enabled || this.sepia.enabled) {\n                activeTarget = this.m_target1;\n                this.m_renderPass.render(renderer, scene, camera, this.m_target1, null!);\n            } else if (!this.outline.enabled || (this.outline.enabled && !this.bloom.enabled)) {\n                renderer.render(scene, camera);\n            }\n        }\n\n        // 3. Apply effects\n        if (this.outline.enabled) {\n            if (this.m_outlineEffect === undefined) {\n                this.m_outlineEffect = new OutlineEffect(renderer);\n            }\n            if (this.outline.needsUpdate) {\n                this.m_outlineEffect.color = this.outline.color;\n                this.m_outlineEffect.thickness = this.outline.thickness;\n                this.m_outlineEffect.ghostExtrudedPolygons = this.outline.ghostExtrudedPolygons;\n                this.outline.needsUpdate = false;\n            }\n            const nextEffectEnabled =\n                this.bloom.enabled || this.vignette.enabled || this.sepia.enabled;\n            if (nextEffectEnabled) {\n                activeTarget = this.m_target1;\n            }\n            renderer.setRenderTarget(nextEffectEnabled ? activeTarget : null!);\n            this.m_outlineEffect.render(scene, camera);\n        }\n\n        if (this.bloom.enabled) {\n            if (this.m_bloomPass === undefined) {\n                this.m_bloomPass = new BloomPass(\n                    new THREE.Vector2(this.m_width, this.m_height),\n                    this.bloom.strength,\n                    this.bloom.radius,\n                    this.bloom.threshold\n                );\n            }\n            const nextEffectEnabled = this.vignette.enabled || this.sepia.enabled;\n            this.m_bloomPass.renderToScreen = !nextEffectEnabled;\n            this.m_bloomPass.radius = this.bloom.radius;\n            this.m_bloomPass.strength = this.bloom.strength;\n            this.m_bloomPass.threshold = this.bloom.threshold;\n            this.m_bloomPass.render(renderer, scene, camera, null!, activeTarget!);\n        } else if (this.m_bloomPass !== undefined) {\n            this.m_bloomPass.dispose();\n            this.m_bloomPass = undefined;\n        }\n\n        if (this.vignette.enabled) {\n            const oldTarget = activeTarget!;\n            const nextEffectEnabled = this.sepia.enabled;\n            this.m_vignettePass.uniforms.offset.value = this.vignette.offset;\n            this.m_vignettePass.uniforms.darkness.value = this.vignette.darkness;\n            this.m_vignettePass.renderToScreen = !nextEffectEnabled;\n            if (nextEffectEnabled) {\n                activeTarget = activeTarget === this.m_target1 ? this.m_target2 : this.m_target1;\n            }\n            this.m_vignettePass.render(renderer, scene, camera, activeTarget!, oldTarget);\n        }\n\n        if (this.sepia.enabled) {\n            this.m_sepiaPass.renderToScreen = true;\n            this.m_sepiaPass.uniforms.amount.value = this.sepia.amount;\n            this.m_sepiaPass.render(renderer, scene, camera, null!, activeTarget!);\n        }\n    }\n\n    /**\n     * The resize function to call on resize events to resize the render targets. It shall include\n     * the resize methods of all the sub-passes used in `MapRenderingManager`.\n     *\n     * @param width New width to use.\n     * @param height New height to use.\n     */\n    setSize(width: number, height: number) {\n        this.m_readBuffer.setSize(width, height);\n        this.m_msaaPass.setSize(width, height);\n        if (this.m_bloomPass !== undefined) {\n            this.m_bloomPass.setSize(width, height);\n        }\n        this.m_lowResPass.setSize(width, height);\n        this.m_target1.setSize(width, height);\n        this.m_target2.setSize(width, height);\n        this.m_width = width;\n        this.m_height = height;\n    }\n\n    /**\n     * The `lowResPixelRatio` determines the resolution of the internal `WebGLRenderTarget`. Values\n     * between 0.5 and `window.devicePixelRatio` can be tried to give  good results. A value of\n     * `undefined` disables the low res render pass. The value should not be larger than\n     * `window.devicePixelRatio`.\n     */\n    get lowResPixelRatio(): number | undefined {\n        return this.m_lowResPass.pixelRatio;\n    }\n\n    set lowResPixelRatio(pixelRatio: number | undefined) {\n        this.m_lowResPass.pixelRatio = pixelRatio;\n        this.m_lowResPass.enabled = pixelRatio !== undefined;\n    }\n\n    /**\n     * Set the level of sampling while the user interacts.\n     *\n     * @param samplingLevel The sampling level.\n     */\n    set dynamicMsaaSamplingLevel(samplingLevel: MSAASampling) {\n        this.m_dynamicMsaaSamplingLevel = samplingLevel;\n    }\n\n    /**\n     * Return the sampling level defined during continuous rendering.\n     */\n    get dynamicMsaaSamplingLevel(): MSAASampling {\n        return this.m_dynamicMsaaSamplingLevel;\n    }\n\n    /**\n     * Enable or disable the MSAA. If disabled, `MapRenderingManager` will use the renderer provided\n     * in the [[MapRenderingManager.render]] method to render the scene.\n     *\n     * @param value If `true`, MSAA is enabled, disabled otherwise.\n     */\n    set msaaEnabled(value: boolean) {\n        this.m_msaaPass.enabled = value;\n    }\n\n    /**\n     * Return whether the MSAA is enabled.\n     */\n    get msaaEnabled(): boolean {\n        return this.m_msaaPass.enabled;\n    }\n\n    /**\n     * Set the sampling level for rendering static frames.\n     *\n     * @param samplingLevel The sampling level.\n     */\n    set staticMsaaSamplingLevel(samplingLevel: MSAASampling) {\n        this.m_staticMsaaSamplingLevel = samplingLevel;\n    }\n\n    /**\n     * Return the sampling level defined for rendering static frames.\n     */\n\n    get staticMsaaSamplingLevel(): MSAASampling {\n        return this.m_staticMsaaSamplingLevel;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { CopyMaterial, CopyShader } from \"@here/harp-materials\";\nimport * as THREE from \"three\";\n\nimport { Pass } from \"./Pass\";\n\n/**\n * The `LowResRenderPass` renders the scene at a lower resolution into an internal\n * `WebGLRenderTarget`, and then copies the result into the frame buffer. The size of the internal\n * buffer is determined by the current frame buffer size multiplied by `pixelRatio`.\n *\n * @note Since no anti-aliasing is applied during dynamic rendering, visual artifacts may be\n * visible.\n */\nexport class LowResRenderPass extends Pass {\n    private m_renderTarget: THREE.WebGLRenderTarget | null = null;\n    private readonly m_localCamera: THREE.OrthographicCamera = new THREE.OrthographicCamera(\n        -1,\n        1,\n        1,\n        -1,\n        0,\n        1\n    );\n    private readonly m_quadScene: THREE.Scene = new THREE.Scene();\n    private readonly m_quadUniforms: { [uniformName: string]: THREE.IUniform } =\n        CopyShader.uniforms;\n    private readonly m_quadMaterial: THREE.ShaderMaterial = new CopyMaterial(this.m_quadUniforms);\n    private readonly m_quad: THREE.Mesh = new THREE.Mesh(\n        new THREE.PlaneBufferGeometry(2, 2),\n        this.m_quadMaterial\n    );\n    private m_pixelRatio: number | undefined;\n    private m_savedWidth = 0;\n    private m_savedHeight = 0;\n\n    /**\n     * The constructor for `LowResRenderPass`. It builds an internal scene with a camera looking at\n     * a quad.\n     *\n     * @param lowResPixelRatio The `pixelRatio` determines the resolution of the internal\n     *  `WebGLRenderTarget`. Values between 0.5 and `window.devicePixelRatio` can be tried to give\n     * good results. A value of `undefined` disables the low res render pass. The value should not\n     * be larger than`window.devicePixelRatio`.\n     */\n    constructor(public lowResPixelRatio?: number) {\n        super();\n        this.m_quad.frustumCulled = false;\n        this.m_quadScene.add(this.m_quad);\n        this.m_pixelRatio = lowResPixelRatio;\n    }\n\n    /**\n     * Releases all used resources.\n     */\n    dispose() {\n        this.m_quadMaterial.dispose();\n        this.m_quad.geometry.dispose();\n        if (this.m_renderTarget !== null) {\n            this.m_renderTarget.dispose();\n            this.m_renderTarget = null;\n        }\n    }\n\n    /**\n     * If a value is specified, a low resolution render pass is used to render the scene into a\n     * low resolution render target, before it is copied to the screen.\n     *\n     * A value of `undefined` disables the low res render pass. The value should not be larger than\n     * `window.devicePixelRatio`.\n     *\n     * @default `undefined`\n     */\n    set pixelRatio(ratio: number | undefined) {\n        this.m_pixelRatio = ratio;\n        if (this.m_renderTarget && this.pixelRatio !== undefined) {\n            this.m_renderTarget.setSize(\n                Math.floor(this.m_savedWidth * this.pixelRatio),\n                Math.floor(this.m_savedHeight * this.pixelRatio)\n            );\n        }\n    }\n\n    get pixelRatio(): number | undefined {\n        return this.m_pixelRatio;\n    }\n\n    /**\n     * The render function of `LowResRenderPass`. It renders the whole scene into an internal\n     * `WebGLRenderTarget` instance with a lower resolution, using the passed in `WebGLRenderer`.\n     * The low resolution image is then copied to the `writeBuffer`, which is `undefined` in case it\n     * is the screen.\n     *\n     * @param renderer The ThreeJS WebGLRenderer instance to render the scene with.\n     * @param scene The ThreeJS Scene instance to render the scene with.\n     * @param camera The ThreeJS Camera instance to render the scene with.\n     * @param writeBuffer A ThreeJS WebGLRenderTarget instance to render the scene to.\n     * @param readBuffer A ThreeJS WebGLRenderTarget instance to render the scene.\n     */\n    render(\n        renderer: THREE.WebGLRenderer,\n        scene: THREE.Scene,\n        camera: THREE.PerspectiveCamera | THREE.OrthographicCamera,\n        writeBuffer: THREE.WebGLRenderTarget | null,\n        readBuffer: THREE.WebGLRenderTarget\n    ) {\n        if (!this.enabled || this.pixelRatio === undefined) {\n            return;\n        }\n\n        // Initiates the local render target with the read buffer's dimensions, if not available.\n        if (this.m_renderTarget === null) {\n            this.m_savedWidth = readBuffer.width;\n            this.m_savedHeight = readBuffer.height;\n            this.m_renderTarget = new THREE.WebGLRenderTarget(\n                Math.floor(this.m_savedWidth * this.pixelRatio),\n                Math.floor(this.m_savedHeight * this.pixelRatio),\n                {\n                    minFilter: THREE.LinearFilter,\n                    magFilter: THREE.LinearFilter,\n                    format: THREE.RGBAFormat,\n                    depthBuffer: true,\n                    stencilBuffer: true\n                }\n            );\n            this.m_renderTarget.texture.name = \"LowResRenderPass.sample\";\n        }\n\n        this.m_quadUniforms.tDiffuse.value = this.m_renderTarget.texture;\n        this.m_quadUniforms.opacity.value = 1.0;\n\n        const oldRenderTarget = renderer.getRenderTarget();\n        renderer.setRenderTarget(this.m_renderTarget);\n        renderer.clear();\n        // Render into the low resolution internal render target.\n        renderer.render(scene, camera);\n\n        // Render the low resolution target into the screen.\n        // NOTE: three.js doesn't like undefined as renderTarget, but works with `null`\n        renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);\n        renderer.clear();\n        renderer.render(this.m_quadScene, this.m_localCamera);\n        renderer.setRenderTarget(oldRenderTarget);\n    }\n\n    /**\n     * Resize the internal render target to match the new size specified. The size of internal\n     * buffer depends on the `pixelRatio`.\n     *\n     * @param width New width to apply to the render target.\n     * @param height New height to apply to the render target.\n     */\n    setSize(width: number, height: number) {\n        this.m_savedWidth = width;\n        this.m_savedHeight = height;\n        if (this.m_renderTarget && this.pixelRatio !== undefined) {\n            this.m_renderTarget.setSize(\n                Math.floor(width * this.pixelRatio),\n                Math.floor(height * this.pixelRatio)\n            );\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { chainCallbacks } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nconst vertexShaderChunk = `\n    uniform float outlineThickness;\n\n    vec4 calculateOutline( vec4 pos, vec3 objectNormal, vec4 skinned ) {\n\n        float thickness = outlineThickness;\n        const float ratio = 1.0;\n        vec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + objectNormal, 1.0 );\n        vec4 norm = normalize( pos - pos2 );\n        return pos + norm * thickness * pos.w * ratio;\n\n    }`;\n\nconst vertexShaderChunk2 = `\n    #if ! defined( LAMBERT ) && ! defined( PHONG ) && ! defined( TOON ) && ! defined( STANDARD )\n        #ifndef USE_ENVMAP\n            vec3 objectNormal = normalize( normal );\n        #endif\n    #endif\n\n    #ifdef FLIP_SIDED\n        objectNormal = -objectNormal;\n    #endif\n\n    #ifdef DECLARE_TRANSFORMED\n        vec3 transformed = vec3( position );\n    #endif\n\n    gl_Position = calculateOutline( gl_Position, objectNormal, vec4( transformed, 1.0 ) );\n\n    #include <fog_vertex>`;\n\nconst fragmentShader = `\n    #include <common>\n    #include <fog_pars_fragment>\n\n    uniform vec3 outlineColor;\n    uniform float outlineAlpha;\n\n    void main() {\n\n        gl_FragColor = vec4( outlineColor, outlineAlpha );\n\n        #include <fog_fragment>\n\n    }`;\n\nexport class OutlineEffect {\n    enabled: boolean = true;\n\n    autoClear: boolean;\n    domElement: HTMLCanvasElement;\n    shadowMap: THREE.WebGLShadowMap;\n\n    private m_defaultThickness: number = 0.02;\n    private m_defaultColor: THREE.Color = new THREE.Color(0, 0, 0);\n    private m_defaultAlpha: number = 1;\n    private m_defaultKeepAlive: boolean = false;\n    private m_ghostExtrudedPolygons: boolean = false;\n\n    private m_cache: any = {};\n    private m_removeThresholdCount: number = 60;\n    private m_originalMaterials: any = {};\n    private m_originalOnBeforeRenders: any = {};\n\n    private m_shaderIDs: { [key: string]: string } = {\n        MeshBasicMaterial: \"basic\",\n        MeshLambertMaterial: \"lambert\",\n        MeshPhongMaterial: \"phong\",\n        MeshToonMaterial: \"phong\",\n        MeshStandardMaterial: \"physical\",\n        MeshPhysicalMaterial: \"physical\"\n    };\n    private m_uniformsChunk = {\n        outlineThickness: { value: this.m_defaultThickness },\n        outlineColor: { value: this.m_defaultColor },\n        outlineAlpha: { value: this.m_defaultAlpha }\n    };\n\n    constructor(private m_renderer: THREE.WebGLRenderer) {\n        this.autoClear = m_renderer.autoClear;\n        this.domElement = m_renderer.domElement;\n        this.shadowMap = m_renderer.shadowMap;\n    }\n\n    set thickness(thickness: number) {\n        this.m_defaultThickness = thickness;\n        this.m_uniformsChunk.outlineThickness.value = thickness;\n        this.m_cache = {};\n    }\n\n    set color(color: string) {\n        this.m_defaultColor.set(color);\n        this.m_cache = {};\n    }\n\n    set ghostExtrudedPolygons(ghost: boolean) {\n        this.m_ghostExtrudedPolygons = ghost;\n    }\n\n    clear(color: boolean, depth: boolean, stencil: boolean) {\n        this.m_renderer.clear(color, depth, stencil);\n    }\n\n    getPixelRatio() {\n        return this.m_renderer.getPixelRatio();\n    }\n\n    setPixelRatio(value: number) {\n        this.m_renderer.setPixelRatio(value);\n    }\n\n    getSize(target: THREE.Vector2) {\n        return this.m_renderer.getSize(target);\n    }\n\n    setSize(width: number, height: number, updateStyle: boolean) {\n        this.m_renderer.setSize(width, height, updateStyle);\n    }\n\n    setViewport(x: number, y: number, width: number, height: number) {\n        this.m_renderer.setViewport(x, y, width, height);\n    }\n\n    setScissor(x: number, y: number, width: number, height: number) {\n        this.m_renderer.setScissor(x, y, width, height);\n    }\n\n    setScissorTest(boolean: boolean) {\n        this.m_renderer.setScissorTest(boolean);\n    }\n\n    setRenderTarget(renderTarget: THREE.WebGLRenderTarget) {\n        this.m_renderer.setRenderTarget(renderTarget);\n    }\n\n    render(scene: THREE.Scene, camera: THREE.Camera) {\n        // Re-rendering the scene with the outline effect enables to hide the\n        // extruded polygons and show only the outlines (it is a hack and should be\n        // implemented another way!).\n        if (this.m_ghostExtrudedPolygons) {\n            if (!this.enabled) {\n                this.m_renderer.render(scene, camera);\n                return;\n            }\n\n            const currentAutoClear = this.m_renderer.autoClear;\n            this.m_renderer.autoClear = this.autoClear;\n\n            this.m_renderer.render(scene, camera);\n\n            this.m_renderer.autoClear = currentAutoClear;\n        }\n\n        this.renderOutline(scene, camera);\n    }\n\n    renderOutline(scene: THREE.Scene, camera: THREE.Camera) {\n        const currentAutoClear = this.m_renderer.autoClear;\n        const currentSceneAutoUpdate = scene.autoUpdate;\n        const currentSceneBackground = scene.background;\n        const currentShadowMapEnabled = this.m_renderer.shadowMap.enabled;\n\n        scene.autoUpdate = false;\n        scene.background = null;\n        this.m_renderer.autoClear = false;\n        this.m_renderer.shadowMap.enabled = false;\n\n        scene.traverse(this.setOutlineMaterial.bind(this));\n\n        this.m_renderer.render(scene, camera);\n\n        scene.traverse(this.restoreOriginalMaterial.bind(this));\n\n        this.cleanupCache();\n\n        scene.autoUpdate = currentSceneAutoUpdate;\n        scene.background = currentSceneBackground;\n        this.m_renderer.autoClear = currentAutoClear;\n        this.m_renderer.shadowMap.enabled = currentShadowMapEnabled;\n    }\n\n    private createInvisibleMaterial() {\n        return new THREE.ShaderMaterial({ name: \"invisible\", visible: false });\n    }\n\n    private createMaterial(originalMaterial: THREE.Material) {\n        const shaderID = this.m_shaderIDs[originalMaterial.type];\n        let originalUniforms;\n        let originalVertexShader;\n\n        if (shaderID !== undefined) {\n            const shader = THREE.ShaderLib[shaderID];\n            originalUniforms = shader.uniforms;\n            originalVertexShader = shader.vertexShader;\n        } else if ((originalMaterial as any).isRawShaderMaterial === true) {\n            originalUniforms = (originalMaterial as any).uniforms;\n            originalVertexShader = (originalMaterial as any).vertexShader;\n\n            if (\n                !/attribute\\s+vec3\\s+position\\s*;/.test(originalVertexShader) ||\n                !/attribute\\s+vec3\\s+normal\\s*;/.test(originalVertexShader)\n            ) {\n                return this.createInvisibleMaterial();\n            }\n        } else if ((originalMaterial as any).isShaderMaterial === true) {\n            originalUniforms = (originalMaterial as any).uniforms;\n            originalVertexShader = (originalMaterial as any).vertexShader;\n        } else {\n            return this.createInvisibleMaterial();\n        }\n\n        const uniforms = { ...originalUniforms, ...this.m_uniformsChunk };\n\n        const vertexShader = originalVertexShader\n            // put vertexShaderChunk right before \"void main() {...}\"\n            .replace(/void\\s+main\\s*\\(\\s*\\)/, vertexShaderChunk + \"\\nvoid main()\")\n            // put vertexShaderChunk2 the end of \"void main() {...}\"\n            // Note: here assums originalVertexShader ends with \"}\" of \"void main() {...}\"\n            .replace(/\\}\\s*$/, vertexShaderChunk2 + \"\\n}\")\n            // remove any light related lines\n            // Note: here is very sensitive to originalVertexShader\n            // TODO: consider safer way\n            .replace(/#include\\s+<[\\w_]*light[\\w_]*>/g, \"\");\n\n        const defines = {};\n\n        if (\n            !/vec3\\s+transformed\\s*=/.test(originalVertexShader) &&\n            !/#include\\s+<begin_vertex>/.test(originalVertexShader)\n        ) {\n            (defines as any).DECLARE_TRANSFORMED = true;\n        }\n\n        return new THREE.ShaderMaterial({\n            defines,\n            uniforms,\n            vertexShader,\n            fragmentShader,\n            side: THREE.BackSide,\n            //wireframe: true,\n            skinning: false,\n            morphTargets: false,\n            morphNormals: false,\n            fog: false\n        });\n    }\n\n    private getOutlineMaterialFromCache(originalMaterial: THREE.Material) {\n        let data = this.m_cache[originalMaterial.uuid];\n\n        if (data === undefined) {\n            data = {\n                material: this.createMaterial(originalMaterial),\n                used: true,\n                keepAlive: this.m_defaultKeepAlive,\n                count: 0\n            };\n\n            this.m_cache[originalMaterial.uuid] = data;\n        }\n\n        data.used = true;\n\n        return data.material;\n    }\n\n    private getOutlineMaterial(originalMaterial: THREE.Material) {\n        const outlineMaterial = this.getOutlineMaterialFromCache(originalMaterial);\n\n        this.m_originalMaterials[outlineMaterial.uuid] = originalMaterial;\n\n        this.updateOutlineMaterial(outlineMaterial, originalMaterial);\n\n        return outlineMaterial;\n    }\n\n    private setOutlineMaterial(object: THREE.Object3D) {\n        if ((object as THREE.Mesh).material === undefined) {\n            return;\n        }\n\n        if (Array.isArray((object as THREE.Mesh).material)) {\n            for (\n                let i = 0, il = ((object as THREE.Mesh).material as THREE.Material[]).length;\n                i < il;\n                i++\n            ) {\n                ((object as THREE.Mesh).material as THREE.Material[])[i] = this.getOutlineMaterial(\n                    ((object as THREE.Mesh).material as THREE.Material[])[i]\n                );\n            }\n        } else {\n            (object as THREE.Mesh).material = this.getOutlineMaterial(\n                (object as THREE.Mesh).material as THREE.Material\n            );\n        }\n\n        this.m_originalOnBeforeRenders[object.uuid] = object.onBeforeRender;\n        object.onBeforeRender = chainCallbacks(\n            object.onBeforeRender,\n            this.onBeforeRender.bind(this)\n        );\n    }\n\n    private restoreOriginalMaterial(object: THREE.Object3D) {\n        if ((object as THREE.Mesh).material === undefined) {\n            return;\n        }\n\n        if (Array.isArray((object as THREE.Mesh).material)) {\n            for (\n                let i = 0, il = ((object as THREE.Mesh).material as THREE.Material[]).length;\n                i < il;\n                i++\n            ) {\n                ((object as THREE.Mesh).material as THREE.Material[])[i] = this.m_originalMaterials[\n                    ((object as THREE.Mesh).material as THREE.Material[])[i].uuid\n                ];\n            }\n        } else {\n            (object as THREE.Mesh).material = this.m_originalMaterials[\n                ((object as THREE.Mesh).material as THREE.Material).uuid\n            ];\n        }\n\n        object.onBeforeRender = this.m_originalOnBeforeRenders[object.uuid];\n    }\n\n    private onBeforeRender(\n        renderer: THREE.WebGLRenderer,\n        scene: THREE.Scene,\n        camera: THREE.Camera,\n        geometry: THREE.Geometry | THREE.BufferGeometry,\n        material: THREE.Material,\n        group: THREE.Group\n    ) {\n        const originalMaterial = this.m_originalMaterials[material.uuid];\n\n        // just in case\n        if (originalMaterial === undefined) {\n            return;\n        }\n\n        this.updateUniforms(material, originalMaterial);\n    }\n\n    private updateUniforms(material: THREE.Material, originalMaterial: THREE.Material) {\n        const outlineParameters = originalMaterial.userData.outlineParameters;\n\n        (material as any).uniforms.outlineAlpha.value = originalMaterial.opacity;\n\n        if (outlineParameters !== undefined) {\n            if (outlineParameters.thickness !== undefined) {\n                (material as any).uniforms.outlineThickness.value = outlineParameters.thickness;\n            }\n            if (outlineParameters.color !== undefined) {\n                (material as any).uniforms.outlineColor.value.fromArray(outlineParameters.color);\n            }\n            if (outlineParameters.alpha !== undefined) {\n                (material as any).uniforms.outlineAlpha.value = outlineParameters.alpha;\n            }\n        }\n    }\n\n    private updateOutlineMaterial(material: THREE.Material, originalMaterial: THREE.Material) {\n        if (material.name === \"invisible\") {\n            return;\n        }\n\n        const outlineParameters = originalMaterial.userData.outlineParameters;\n\n        (material as any).skinning = (originalMaterial as any).skinning;\n        (material as any).morphTargets = (originalMaterial as any).morphTargets;\n        (material as any).morphNormals = (originalMaterial as any).morphNormals;\n        material.fog = originalMaterial.fog;\n\n        if (outlineParameters !== undefined) {\n            material.visible =\n                originalMaterial.visible === false\n                    ? false\n                    : outlineParameters.visible !== undefined\n                    ? outlineParameters.visible\n                    : true;\n\n            material.transparent =\n                outlineParameters.alpha !== undefined && outlineParameters.alpha < 1.0\n                    ? true\n                    : originalMaterial.transparent;\n\n            if (outlineParameters.keepAlive !== undefined) {\n                this.m_cache[originalMaterial.uuid].keepAlive = outlineParameters.keepAlive;\n            }\n        } else {\n            material.transparent = originalMaterial.transparent;\n            material.visible = originalMaterial.visible;\n        }\n\n        if ((originalMaterial as any).wireframe === true || originalMaterial.depthTest === false) {\n            material.visible = false;\n        }\n    }\n\n    private cleanupCache() {\n        let keys;\n\n        // clear originialMaterials\n        keys = Object.keys(this.m_originalMaterials);\n\n        for (let i = 0, il = keys.length; i < il; i++) {\n            this.m_originalMaterials[keys[i]] = undefined;\n        }\n\n        // clear originalOnBeforeRenders\n        keys = Object.keys(this.m_originalOnBeforeRenders);\n\n        for (let i = 0, il = keys.length; i < il; i++) {\n            this.m_originalOnBeforeRenders[keys[i]] = undefined;\n        }\n\n        // remove unused outlineMaterial from cache\n        keys = Object.keys(this.m_cache);\n\n        for (const key of keys) {\n            if (this.m_cache[key].used === false) {\n                this.m_cache[key].count++;\n\n                if (\n                    this.m_cache[key].keepAlive === false &&\n                    this.m_cache[key].count > this.m_removeThresholdCount\n                ) {\n                    delete this.m_cache[key];\n                }\n            } else {\n                this.m_cache[key].used = false;\n                this.m_cache[key].count = 0;\n            }\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { CopyShader, LuminosityHighPassShader } from \"@here/harp-materials\";\nimport * as THREE from \"three\";\nimport { Pass } from \"./Pass\";\n\nconst BlurDirectionX = new THREE.Vector2(1.0, 0.0);\nconst BlurDirectionY = new THREE.Vector2(0.0, 1.0);\n\n/**\n * The TS version of ThreeJS's UnrealBloomPass.\n */\nexport class BloomPass extends Pass {\n    strength: number;\n    radius: number;\n    threshold: number;\n    resolution: THREE.Vector2 = new THREE.Vector2(256, 256);\n    private m_renderTargetsHorizontal: THREE.WebGLRenderTarget[] = [];\n    private m_renderTargetsVertical: THREE.WebGLRenderTarget[] = [];\n    private m_nMips: number = 5;\n    private m_highPassUniforms: any;\n    private m_materialHighPassFilter: THREE.ShaderMaterial;\n    private m_separableBlurMaterials: THREE.ShaderMaterial[] = [];\n    private m_materialCopy: THREE.ShaderMaterial;\n    private m_copyUniforms: any;\n    private m_compositeMaterial: THREE.ShaderMaterial;\n\n    private m_camera: THREE.OrthographicCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n    private m_scene: THREE.Scene = new THREE.Scene();\n    private m_basic = new THREE.MeshBasicMaterial();\n    private m_quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2));\n\n    private m_bloomTintColors: THREE.Vector3[] = [\n        new THREE.Vector3(1, 1, 1),\n        new THREE.Vector3(1, 1, 1),\n        new THREE.Vector3(1, 1, 1),\n        new THREE.Vector3(1, 1, 1),\n        new THREE.Vector3(1, 1, 1)\n    ];\n\n    private m_renderTargetBright: THREE.WebGLRenderTarget;\n\n    constructor(resolution: THREE.Vector2, strength: number, radius: number, threshold: number) {\n        super();\n\n        this.strength = strength;\n        this.radius = radius;\n        this.threshold = threshold;\n        this.resolution = resolution;\n\n        this.m_quad.frustumCulled = false;\n        this.m_scene.add(this.m_quad);\n\n        const pars = {\n            minFilter: THREE.LinearFilter,\n            magFilter: THREE.LinearFilter,\n            format: THREE.RGBAFormat\n        };\n\n        let resx = Math.round(this.resolution.x / 2);\n        let resy = Math.round(this.resolution.y / 2);\n\n        this.m_renderTargetBright = new THREE.WebGLRenderTarget(resx, resy, pars);\n        this.m_renderTargetBright.texture.name = \"UnrealBloomPass.bright\";\n        this.m_renderTargetBright.texture.generateMipmaps = false;\n\n        for (let i = 0; i < this.m_nMips; i++) {\n            const renderTargetHorizonal = new THREE.WebGLRenderTarget(resx, resy, pars);\n            renderTargetHorizonal.texture.name = \"UnrealBloomPass.h\" + i;\n            renderTargetHorizonal.texture.generateMipmaps = false;\n            this.m_renderTargetsHorizontal.push(renderTargetHorizonal);\n\n            const renderTargetVertical = new THREE.WebGLRenderTarget(resx, resy, pars);\n            renderTargetVertical.texture.name = \"UnrealBloomPass.v\" + i;\n            renderTargetVertical.texture.generateMipmaps = false;\n            this.m_renderTargetsVertical.push(renderTargetVertical);\n\n            resx = Math.round(resx / 2);\n            resy = Math.round(resy / 2);\n        }\n\n        this.m_highPassUniforms = THREE.UniformsUtils.clone(LuminosityHighPassShader.uniforms);\n\n        // tslint:disable:no-string-literal\n        this.m_highPassUniforms[\"luminosityThreshold\"].value = threshold;\n        this.m_highPassUniforms[\"smoothWidth\"].value = 0.01;\n\n        this.m_materialHighPassFilter = new THREE.ShaderMaterial({\n            uniforms: this.m_highPassUniforms,\n            vertexShader: LuminosityHighPassShader.vertexShader,\n            fragmentShader: LuminosityHighPassShader.fragmentShader,\n            defines: {}\n        });\n\n        // Gaussian Blur Materials\n        const kernelSizeArray = [3, 5, 7, 9, 11];\n        resx = Math.round(this.resolution.x / 2);\n        resy = Math.round(this.resolution.y / 2);\n        for (let i = 0; i < this.m_nMips; i++) {\n            this.m_separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));\n            this.m_separableBlurMaterials[i].uniforms[\"texSize\"].value = new THREE.Vector2(\n                resx,\n                resy\n            );\n            resx = Math.round(resx / 2);\n            resy = Math.round(resy / 2);\n        }\n\n        // Composite material\n        this.m_compositeMaterial = this.getCompositeMaterial(this.m_nMips);\n        this.m_compositeMaterial.uniforms[\n            \"blurTexture1\"\n        ].value = this.m_renderTargetsVertical[0].texture;\n        this.m_compositeMaterial.uniforms[\n            \"blurTexture2\"\n        ].value = this.m_renderTargetsVertical[1].texture;\n        this.m_compositeMaterial.uniforms[\n            \"blurTexture3\"\n        ].value = this.m_renderTargetsVertical[2].texture;\n        this.m_compositeMaterial.uniforms[\n            \"blurTexture4\"\n        ].value = this.m_renderTargetsVertical[3].texture;\n        this.m_compositeMaterial.uniforms[\n            \"blurTexture5\"\n        ].value = this.m_renderTargetsVertical[4].texture;\n        this.m_compositeMaterial.uniforms[\"bloomStrength\"].value = strength;\n        this.m_compositeMaterial.uniforms[\"bloomRadius\"].value = 0.1;\n        this.m_compositeMaterial.needsUpdate = true;\n\n        const bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];\n        this.m_compositeMaterial.uniforms[\"bloomFactors\"].value = bloomFactors;\n        this.m_compositeMaterial.uniforms[\"bloomTintColors\"].value = this.m_bloomTintColors;\n\n        this.m_copyUniforms = THREE.UniformsUtils.clone(CopyShader.uniforms);\n        this.m_copyUniforms[\"opacity\"].value = 1.0;\n        // tslint:enable:no-string-literal\n\n        this.m_materialCopy = new THREE.ShaderMaterial({\n            uniforms: this.m_copyUniforms,\n            vertexShader: CopyShader.vertexShader,\n            fragmentShader: CopyShader.fragmentShader,\n            blending: THREE.AdditiveBlending,\n            depthTest: false,\n            depthWrite: false,\n            transparent: true\n        });\n    }\n    dispose() {\n        for (const rt of this.m_renderTargetsHorizontal) {\n            rt.dispose();\n        }\n        for (const rt of this.m_renderTargetsVertical) {\n            rt.dispose();\n        }\n        this.m_renderTargetBright.dispose();\n    }\n    setSize(width: number, height: number) {\n        let resx = Math.round(width / 2);\n        let resy = Math.round(height / 2);\n        this.m_renderTargetBright.setSize(resx, resy);\n        for (let i = 0; i < this.m_nMips; i++) {\n            this.m_renderTargetsHorizontal[i].setSize(resx, resy);\n            this.m_renderTargetsVertical[i].setSize(resx, resy);\n            // tslint:disable-next-line:no-string-literal\n            this.m_separableBlurMaterials[i].uniforms[\"texSize\"].value = new THREE.Vector2(\n                resx,\n                resy\n            );\n            resx = Math.round(resx / 2);\n            resy = Math.round(resy / 2);\n        }\n    }\n    render(\n        renderer: THREE.WebGLRenderer,\n        scene: THREE.Scene,\n        camera: THREE.Camera,\n        writeBuffer: THREE.WebGLRenderTarget | null,\n        readBuffer: THREE.WebGLRenderTarget\n    ) {\n        // tslint:disable:no-string-literal\n\n        // Render input to screen\n        if (this.renderToScreen) {\n            this.m_quad.material = this.m_basic;\n            this.m_basic.map = readBuffer.texture;\n            renderer.setRenderTarget(null!);\n            renderer.clear();\n            renderer.render(this.m_scene, this.m_camera);\n        }\n\n        // 1. Extract bright areas\n        this.m_highPassUniforms[\"tDiffuse\"].value = readBuffer.texture;\n        this.m_highPassUniforms[\"luminosityThreshold\"].value = this.threshold;\n        this.m_quad.material = this.m_materialHighPassFilter;\n\n        renderer.setRenderTarget(this.m_renderTargetBright);\n        renderer.clear();\n        renderer.render(this.m_scene, this.m_camera);\n\n        // 2. Blur all the mips progressively\n        let inputRenderTarget = this.m_renderTargetBright;\n\n        for (let i = 0; i < this.m_nMips; i++) {\n            this.m_quad.material = this.m_separableBlurMaterials[i];\n\n            this.m_separableBlurMaterials[i].uniforms[\"colorTexture\"].value =\n                inputRenderTarget.texture;\n            this.m_separableBlurMaterials[i].uniforms[\"direction\"].value = BlurDirectionX;\n            renderer.setRenderTarget(this.m_renderTargetsHorizontal[i]);\n            renderer.clear();\n            renderer.render(this.m_scene, this.m_camera);\n\n            this.m_separableBlurMaterials[i].uniforms[\n                \"colorTexture\"\n            ].value = this.m_renderTargetsHorizontal[i].texture;\n            this.m_separableBlurMaterials[i].uniforms[\"direction\"].value = BlurDirectionY;\n            renderer.setRenderTarget(this.m_renderTargetsVertical[i]);\n            renderer.clear();\n            renderer.render(this.m_scene, this.m_camera);\n\n            inputRenderTarget = this.m_renderTargetsVertical[i];\n        }\n\n        // Composite all the mips\n        this.m_quad.material = this.m_compositeMaterial;\n        this.m_compositeMaterial.uniforms[\"bloomStrength\"].value = this.strength;\n        this.m_compositeMaterial.uniforms[\"bloomRadius\"].value = this.radius;\n        this.m_compositeMaterial.uniforms[\"bloomTintColors\"].value = this.m_bloomTintColors;\n\n        renderer.setRenderTarget(this.m_renderTargetsHorizontal[0]);\n        renderer.clear();\n        renderer.render(this.m_scene, this.m_camera);\n\n        // Blend it additively over the input texture\n        this.m_quad.material = this.m_materialCopy;\n        this.m_copyUniforms[\"tDiffuse\"].value = this.m_renderTargetsHorizontal[0].texture;\n\n        if (this.renderToScreen) {\n            renderer.setRenderTarget(null!);\n            renderer.render(this.m_scene, this.m_camera);\n        } else {\n            renderer.setRenderTarget(readBuffer);\n            renderer.render(this.m_scene, this.m_camera);\n        }\n        // tslint:enable:no-string-literal\n    }\n\n    getSeperableBlurMaterial(kernelRadius: number): THREE.ShaderMaterial {\n        return new THREE.ShaderMaterial({\n            defines: {\n                KERNEL_RADIUS: kernelRadius,\n                SIGMA: kernelRadius\n            },\n\n            uniforms: {\n                colorTexture: { value: null },\n                texSize: { value: new THREE.Vector2(0.5, 0.5) },\n                direction: { value: new THREE.Vector2(0.5, 0.5) }\n            },\n\n            vertexShader: `varying vec2 vUv;\n            void main() {\n                vUv = uv;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n            }`,\n\n            fragmentShader: `#include <common>\n            varying vec2 vUv;\n            uniform sampler2D colorTexture;\n            uniform vec2 texSize;\n            uniform vec2 direction;\n\n            float gaussianPdf(in float x, in float sigma) {\n                return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n            }\n            void main() {\\n\\\n                vec2 invSize = 1.0 / texSize;\n                float fSigma = float(SIGMA);\n                float weightSum = gaussianPdf(0.0, fSigma);\n                vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\n                for( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n                    float x = float(i);\n                    float w = gaussianPdf(x, fSigma);\n                    vec2 uvOffset = direction * invSize * x;\n                    vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\n                    vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\n                    diffuseSum += (sample1 + sample2) * w;\n                    weightSum += 2.0 * w;\n                }\n                gl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n            }`\n        });\n    }\n\n    getCompositeMaterial(nMips: number): THREE.ShaderMaterial {\n        return new THREE.ShaderMaterial({\n            defines: {\n                NUM_MIPS: nMips\n            },\n\n            uniforms: {\n                blurTexture1: { value: null },\n                blurTexture2: { value: null },\n                blurTexture3: { value: null },\n                blurTexture4: { value: null },\n                blurTexture5: { value: null },\n                dirtTexture: { value: null },\n                bloomStrength: { value: 1.0 },\n                bloomFactors: { value: null },\n                bloomTintColors: { value: null },\n                bloomRadius: { value: 0.0 }\n            },\n\n            vertexShader: `varying vec2 vUv;\n                void main() {\n                    vUv = uv;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n                }`,\n\n            fragmentShader: `varying vec2 vUv;\n                uniform sampler2D blurTexture1;\n                uniform sampler2D blurTexture2;\n                uniform sampler2D blurTexture3;\n                uniform sampler2D blurTexture4;\n                uniform sampler2D blurTexture5;\n                uniform sampler2D dirtTexture;\n                uniform float bloomStrength;\n                uniform float bloomRadius;\n                uniform float bloomFactors[NUM_MIPS];\n                uniform vec3 bloomTintColors[NUM_MIPS];\n\n                float lerpBloomFactor(const in float factor) {\n                    float mirrorFactor = 1.2 - factor;\n                    return mix(factor, mirrorFactor, bloomRadius);\n                }\n\n                void main() {\n                    gl_FragColor = bloomStrength * (\nlerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\nlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\nlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\nlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\nlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n                }`\n        });\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Message sent by web worker that requests to resolve actual\n * URLs of it's dependencies.\n *\n * Main thread is expected.\n */\nexport interface WorkerBootstrapRequest {\n    type: \"worker-bootstrap-request\";\n\n    /// Names of dependencies, usually NPM package names.\n    dependencies: string[];\n}\n\nexport interface WorkerBootstrapResponse {\n    type: \"worker-bootstrap-response\";\n\n    /// Actual URL scripts requested in [[WorkerBootstrapRequest]].\n    resolvedDependencies: string[];\n}\n\nexport function isWorkerBootstrapRequest(message: any): message is WorkerBootstrapRequest {\n    return (\n        message &&\n        message.type === \"worker-bootstrap-request\" &&\n        Array.isArray(message.dependencies)\n    );\n}\n\nexport function isWorkerBootstrapResponse(message: any): message is WorkerBootstrapResponse {\n    return (\n        message &&\n        message.type === \"worker-bootstrap-response\" &&\n        Array.isArray(message.resolvedDependencies)\n    );\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    OrientedBox3,\n    Projection,\n    ProjectionType,\n    TileKey,\n    TilingScheme\n} from \"@here/harp-geoutils\";\nimport { assert } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\nimport { DataSource } from \"./DataSource\";\nimport { CalculationStatus, ElevationRangeSource } from \"./ElevationRangeSource\";\nimport { MapTileCuller } from \"./MapTileCuller\";\nimport { MapView } from \"./MapView\";\nimport { MapViewUtils, TileOffsetUtils } from \"./Utils\";\n\n/**\n * Represents a unique TileKey and the area it takes up on screen.\n *\n * Note, in certain tiling projections, it is possible to have an offset, which represents a tile\n * which has fully wrapped around, hence this defaults to 0 to simplify usage for projections which\n * don't require it.\n */\nexport class TileKeyEntry {\n    constructor(\n        public tileKey: TileKey,\n        public area: number,\n        public offset: number = 0,\n        public minElevation: number = 0,\n        public maxElevation: number = 0\n    ) {}\n}\n\nfunction getGeoBox(tilingScheme: TilingScheme, childTileKey: TileKey, offset: number) {\n    const geoBox = tilingScheme.getGeoBox(childTileKey);\n    const longitudeOffset = 360.0 * offset;\n    geoBox.northEast.longitude += longitudeOffset;\n    geoBox.southWest.longitude += longitudeOffset;\n    return geoBox;\n}\n\nnamespace FrustumIntersection {\n    export interface Result {\n        /**\n         * Tiles intersected by the frustum. Keys are a combination of morton code and tile offset,\n         * see [[TileOffsetUtils.getKeyForTileKeyAndOffset]].\n         */\n        readonly tileKeyEntries: Map<number, TileKeyEntry>;\n        /**\n         * True if the intersection was calculated using precise elevation data, false if it's an\n         * approximation.\n         */\n        calculationFinal: boolean;\n    }\n}\n\n/**\n * Computes the tiles intersected by the frustum defined by the current camera setup.\n */\nexport class FrustumIntersection {\n    private readonly m_frustum: THREE.Frustum = new THREE.Frustum();\n    // used to project global coordinates into camera local coordinates\n    private readonly m_viewProjectionMatrix = new THREE.Matrix4();\n    private readonly m_mapTileCuller: MapTileCuller;\n    private m_rootTileKeys: TileKeyEntry[] = [];\n    private readonly m_tileKeyEntries: Map<number, TileKeyEntry> = new Map();\n\n    constructor(\n        private readonly m_camera: THREE.PerspectiveCamera,\n        readonly mapView: MapView,\n        private readonly m_extendedFrustumCulling: boolean,\n        private readonly m_tileWrappingEnabled: boolean\n    ) {\n        this.m_mapTileCuller = new MapTileCuller(m_camera);\n    }\n\n    /**\n     * Return camera used for generating frustum.\n     */\n    get camera(): THREE.PerspectiveCamera {\n        return this.m_camera;\n    }\n\n    /**\n     * Return projection used to convert geo coordinates to world coordinates.\n     */\n    get projection(): Projection {\n        return this.mapView.projection;\n    }\n\n    /**\n     * Updates the frustum to match the current camera setup.\n     */\n    updateFrustum(projectionMatrixOverride?: THREE.Matrix4) {\n        this.m_viewProjectionMatrix.multiplyMatrices(\n            projectionMatrixOverride !== undefined\n                ? projectionMatrixOverride\n                : this.m_camera.projectionMatrix,\n            this.m_camera.matrixWorldInverse\n        );\n\n        this.m_frustum.setFromMatrix(this.m_viewProjectionMatrix);\n\n        if (this.m_extendedFrustumCulling) {\n            this.m_mapTileCuller.setup();\n        }\n        this.computeRequiredInitialRootTileKeys(this.m_camera.position);\n    }\n\n    /**\n     * Computes the tiles intersected by the updated frustum, see [[updateFrustum]].\n     *\n     * @param tilingScheme The tiling scheme used to generate the tiles.\n     * @param maxTileLevel The maximum tile level that will be checked for intersections.\n     * @param elevationRangeSource Source of elevation range data if any.\n     * @returns The computation result, see [[FrustumIntersection.Result]].\n     */\n    compute(\n        tilingScheme: TilingScheme,\n        maxTileLevel: number,\n        elevationRangeSource: ElevationRangeSource | undefined,\n        zoomLevels: number[],\n        dataSources: DataSource[]\n    ): FrustumIntersection.Result {\n        this.m_tileKeyEntries.clear();\n        let calculationFinal = true;\n\n        for (const item of this.m_rootTileKeys) {\n            this.m_tileKeyEntries.set(\n                TileOffsetUtils.getKeyForTileKeyAndOffset(item.tileKey, item.offset),\n                new TileKeyEntry(\n                    item.tileKey,\n                    Infinity,\n                    item.offset,\n                    item.minElevation,\n                    item.maxElevation\n                )\n            );\n        }\n\n        const useElevationRangeSource: boolean =\n            elevationRangeSource !== undefined &&\n            elevationRangeSource.getTilingScheme() === tilingScheme;\n\n        const tileBounds = new THREE.Box3();\n        const workList = [...this.m_rootTileKeys];\n\n        while (workList.length > 0) {\n            const tileEntry = workList.pop();\n\n            if (tileEntry === undefined) {\n                continue;\n            }\n\n            const tileKey = tileEntry.tileKey;\n            if (tileKey.level > maxTileLevel) {\n                continue;\n            }\n\n            const proceed = dataSources.some((ds, i) => ds.shouldSubdivide(zoomLevels[i], tileKey));\n            if (proceed === false) {\n                continue;\n            }\n\n            const uniqueKey = TileOffsetUtils.getKeyForTileKeyAndOffset(tileKey, tileEntry.offset);\n            const cachedTileEntry = this.m_tileKeyEntries.get(uniqueKey);\n\n            assert(cachedTileEntry !== undefined);\n            assert(cachedTileEntry!.area > 0);\n\n            for (const childTileKey of tilingScheme.getSubTileKeys(tileKey)) {\n                const offset = tileEntry.offset;\n                const tileKeyAndOffset = TileOffsetUtils.getKeyForTileKeyAndOffset(\n                    childTileKey,\n                    offset\n                );\n\n                assert(this.m_tileKeyEntries.get(tileKeyAndOffset) === undefined);\n\n                const geoBox = getGeoBox(tilingScheme, childTileKey, offset);\n\n                // For tiles without elevation range source, default 0 (getGeoBox always\n                // returns box with altitude min/max equal to zero) will be propagated as\n                // min and max elevation, these tiles most probably contains features that\n                // lays directly on the ground surface.\n                if (useElevationRangeSource) {\n                    const range = elevationRangeSource!.getElevationRange(childTileKey);\n                    geoBox.southWest.altitude = range.minElevation;\n                    geoBox.northEast.altitude = range.maxElevation;\n                    calculationFinal =\n                        calculationFinal &&\n                        range.calculationStatus === CalculationStatus.FinalPrecise;\n                }\n\n                let subTileArea = 0;\n\n                const obbIntersections: boolean =\n                    this.mapView.projection.type === ProjectionType.Spherical;\n                if (obbIntersections) {\n                    const obb = new OrientedBox3();\n                    this.mapView.projection.projectBox(geoBox, obb);\n                    subTileArea = this.computeSubTileArea(obb);\n                } else {\n                    this.mapView.projection.projectBox(geoBox, tileBounds);\n                    subTileArea = this.computeSubTileArea(tileBounds);\n                }\n\n                if (subTileArea > 0) {\n                    const subTileEntry = new TileKeyEntry(\n                        childTileKey,\n                        subTileArea,\n                        offset,\n                        geoBox.southWest.altitude, // minElevation\n                        geoBox.northEast.altitude // maxElevation\n                    );\n                    this.m_tileKeyEntries.set(tileKeyAndOffset, subTileEntry);\n                    workList.push(subTileEntry);\n                }\n            }\n        }\n        return { tileKeyEntries: this.m_tileKeyEntries, calculationFinal };\n    }\n\n    // Computes the rough screen area of the supplied box.\n    // TileBounds must be in world space.\n    private computeSubTileArea(tileBounds: THREE.Box3 | OrientedBox3) {\n        if (tileBounds instanceof THREE.Box3) {\n            if (\n                (!this.m_extendedFrustumCulling ||\n                    this.m_mapTileCuller.frustumIntersectsTileBox(tileBounds)) &&\n                this.m_frustum.intersectsBox(tileBounds)\n            ) {\n                const contour = [\n                    new THREE.Vector3(tileBounds.min.x, tileBounds.min.y, 0).applyMatrix4(\n                        this.m_viewProjectionMatrix\n                    ),\n                    new THREE.Vector3(tileBounds.max.x, tileBounds.min.y, 0).applyMatrix4(\n                        this.m_viewProjectionMatrix\n                    ),\n                    new THREE.Vector3(tileBounds.max.x, tileBounds.max.y, 0).applyMatrix4(\n                        this.m_viewProjectionMatrix\n                    ),\n                    new THREE.Vector3(tileBounds.min.x, tileBounds.max.y, 0).applyMatrix4(\n                        this.m_viewProjectionMatrix\n                    )\n                ];\n\n                contour.push(contour[0]);\n\n                const n = contour.length;\n\n                let subTileArea = 0;\n                for (let p = n - 1, q = 0; q < n; p = q++) {\n                    subTileArea += contour[p].x * contour[q].y - contour[q].x * contour[p].y;\n                }\n\n                return Math.abs(subTileArea * 0.5);\n            }\n            return 0;\n        } else {\n            if (!tileBounds.intersects(this.m_frustum)) {\n                return 0;\n            }\n\n            // NOTE: It maybe possible to use bounding spheres instead\n            // of bounding box as optimization\n            // // Compute rough screen area by projecting bounding sphere\n            // // to screen space\n            // // Use diagonal of box as diameter of sphere\n            // const size = tileBounds.getSize();\n            // const r = 0.5 * Math.sqrt(size.x * size.x + size.y * size.y + size.z + size.z);\n\n            // const projectedPoint = new THREE.Vector4(\n            //     tileBounds.position.x,\n            //     tileBounds.position.y,\n            //     tileBounds.position.z,\n            //     1.0\n            // ).applyMatrix4(this.m_viewProjectionMatrix);\n\n            // // Dividing by w projects sphere radius to screen space\n            // const projectedR = r / projectedPoint.w;\n            // return Math.PI * projectedR * projectedR;\n\n            // Estimate screen space area of oriented box by projecting corners to screen space\n            // and creating a screen space aligned 2D box\n            const center = tileBounds.getCenter();\n            const extents = tileBounds.extents;\n            const modelViewProjMatrix = this.m_viewProjectionMatrix\n                .clone()\n                .multiply(new THREE.Matrix4().makeTranslation(center.x, center.y, center.z))\n                .multiply(tileBounds.getRotationMatrix());\n\n            const projectedPoints = [\n                new THREE.Vector3(-extents.x, -extents.y, -extents.z).applyMatrix4(\n                    modelViewProjMatrix\n                ),\n                new THREE.Vector3(extents.x, -extents.y, -extents.z).applyMatrix4(\n                    modelViewProjMatrix\n                ),\n                new THREE.Vector3(extents.x, extents.y, -extents.z).applyMatrix4(\n                    modelViewProjMatrix\n                ),\n                new THREE.Vector3(-extents.x, extents.y, -extents.z).applyMatrix4(\n                    modelViewProjMatrix\n                ),\n                new THREE.Vector3(-extents.x, -extents.y, extents.z).applyMatrix4(\n                    modelViewProjMatrix\n                ),\n                new THREE.Vector3(extents.x, -extents.y, extents.z).applyMatrix4(\n                    modelViewProjMatrix\n                ),\n                new THREE.Vector3(extents.x, extents.y, extents.z).applyMatrix4(\n                    modelViewProjMatrix\n                ),\n                new THREE.Vector3(-extents.x, extents.y, extents.z).applyMatrix4(\n                    modelViewProjMatrix\n                )\n            ];\n            const screenBox = new THREE.Box2();\n            const tmpVector2 = new THREE.Vector2();\n            for (const point of projectedPoints) {\n                tmpVector2.set(point.x, point.y);\n                screenBox.expandByPoint(tmpVector2);\n            }\n            const size = screenBox.getSize(tmpVector2);\n\n            return size.x * size.y;\n        }\n    }\n\n    /**\n     * Create a list of root nodes to test against the frustum. The root nodes each start at level 0\n     * and have an offset (see [[Tile]]) based on:\n     * - the current position [[worldCenter]].\n     * - the height of the camera above the world.\n     * - the field of view of the camera (the maximum value between the horizontal / vertical\n     *   values)\n     * - the tilt of the camera (because we see more tiles when tilted).\n     *\n     * @param worldCenter The center of the camera in world space.\n     */\n    private computeRequiredInitialRootTileKeys(worldCenter: THREE.Vector3) {\n        this.m_rootTileKeys = [];\n        const rootTileKey = TileKey.fromRowColumnLevel(0, 0, 0);\n        const tileWrappingEnabled = this.mapView.projection.type === ProjectionType.Planar;\n\n        if (!tileWrappingEnabled || !this.m_tileWrappingEnabled) {\n            this.m_rootTileKeys.push(new TileKeyEntry(rootTileKey, 0, 0, 0));\n            return;\n        }\n\n        const worldGeoPoint = this.mapView.projection.unprojectPoint(worldCenter);\n        const startOffset = Math.round(worldGeoPoint.longitude / 360.0);\n\n        // This algorithm computes the number of offsets we need to test. The following diagram may\n        // help explain the algorithm below.\n        //\n        //   |\n        //   |.\\ .\n        //   | . \\  .\n        // z |  .  \\   .c2\n        //   |  c1.  \\b    .\n        //   |     .   \\      .\n        //___|a___d1.____\\e______.d2______f\n        //\n        // Where:\n        // -  is the camera\n        // - z is the height of the camera above the ground.\n        // - a is a right angle.\n        // - b is the look at vector of the camera.\n        // - c1 and c2 are the frustum planes of the camera.\n        // - c1 to c2 is the fov.\n        // - d1 and d2 are the intersection points of the frustum with the world plane.\n        // - e is the tilt/pitch of the camera.\n        // - f is the world\n        //\n        // The goal is to find the distance from e->d2. This is a longitude value, and we convert it\n        // to some offset range. Note e->d2 >= e->d1 (because we can't have a negative tilt).\n        // To find e->d2, we use the right triangle , a, d2 and subtract the distance a->d2 with\n        // a->e.\n        // a->d2 is found using the angle between a and d2 from the , this is simply e (because of\n        // similar triangles, angle between a,  and e equals the tilt) + half of the fov (because\n        // we need the angle between e,  and d2) and using trigonometry, result is therefore:\n        // (tan(a->d2) * z).\n        // a->e needs just the tilt and trigonometry to compute, result is: (tan(a->e) * z).\n\n        const camera = this.m_camera;\n        const cameraPitch = MapViewUtils.extractAttitude(this.mapView, camera).pitch;\n        // Ensure that the aspect is >= 1.\n        const aspect = camera.aspect > 1 ? camera.aspect : 1 / camera.aspect;\n        // Angle between a->d2, note, the fov is vertical, hence we translate to horizontal.\n        const totalAngleRad = THREE.Math.degToRad((camera.fov * aspect) / 2) + cameraPitch;\n        // Length a->d2\n        const worldLengthHorizontalFull = Math.tan(totalAngleRad) * camera.position.z;\n        // Length a->e\n        const worldLengthHorizontalSmallerHalf = Math.tan(cameraPitch) * camera.position.z;\n        // Length e -> d2\n        const worldLengthHorizontal = worldLengthHorizontalFull - worldLengthHorizontalSmallerHalf;\n        const worldLeftPoint = new THREE.Vector3(\n            worldCenter.x - worldLengthHorizontal,\n            worldCenter.y,\n            worldCenter.z\n        );\n        const worldLeftGeoPoint = this.mapView.projection.unprojectPoint(worldLeftPoint);\n        // We multiply by SQRT2 because we need to account for a rotated view (in which case there\n        // are more tiles that can be seen).\n        const offsetRange = THREE.Math.clamp(\n            Math.ceil(\n                Math.abs((worldGeoPoint.longitude - worldLeftGeoPoint.longitude) / 360) * Math.SQRT2\n            ),\n            0,\n            // We can store currently up to 16 unique keys(2^4, where 4 is the default bit-shift\n            // value which is used currently in the [[VisibleTileSet]] methods) hence we can have a\n            // maximum range of 7 (because 2*7+1 = 15).\n            7\n        );\n        for (\n            let offset = -offsetRange + startOffset;\n            offset <= offsetRange + startOffset;\n            offset++\n        ) {\n            this.m_rootTileKeys.push(new TileKeyEntry(rootTileKey, 0, offset, 0, 0));\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\n/**\n * Second step tile culling: Do additional check for intersection of box and frustum by checking if\n * the frustum is outside any plane of the tiles `bbox` (oriented, not AABB). It's in the inverse of\n * the standard frustum test, which excludes many cases where the large terrain tiles straddle the\n * planes of the frustum.\n *\n * @see http://www.iquilezles.org/www/articles/frustumcorrect/frustumcorrect.htm\n */\nexport class MapTileCuller {\n    private m_globalFrustumMin = new THREE.Vector3();\n    private m_globalFrustumMax = new THREE.Vector3();\n\n    private m_frustumCorners = [\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3()\n    ];\n\n    /**\n     * Constructs a `MapTileCuller`.\n     *\n     * @param m_camera A `THREE.Camera`.\n     */\n    constructor(private m_camera: THREE.Camera) {}\n\n    /**\n     * Sets up culling and computes frustum corners. You mus call this function before the culling\n     * starts.\n     */\n    setup() {\n        const frustumCorners = this.getFrustumCorners();\n\n        const matrix = this.m_camera.matrixWorld;\n\n        this.m_globalFrustumMin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n        this.m_globalFrustumMax.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n\n        for (const frustumCorner of frustumCorners) {\n            frustumCorner.applyMatrix4(matrix);\n\n            this.m_globalFrustumMin.x = Math.min(this.m_globalFrustumMin.x, frustumCorner.x);\n            this.m_globalFrustumMin.y = Math.min(this.m_globalFrustumMin.y, frustumCorner.y);\n            this.m_globalFrustumMin.z = Math.min(this.m_globalFrustumMin.z, frustumCorner.z);\n\n            this.m_globalFrustumMax.x = Math.max(this.m_globalFrustumMax.x, frustumCorner.x);\n            this.m_globalFrustumMax.y = Math.max(this.m_globalFrustumMax.y, frustumCorner.y);\n            this.m_globalFrustumMax.z = Math.max(this.m_globalFrustumMax.z, frustumCorner.z);\n        }\n    }\n\n    /**\n     * Checks if the tile's bounding box intersects with the current view's frustum.\n     *\n     * @param tileBounds The bounding box for the tile.\n     */\n    frustumIntersectsTileBox(tileBounds: THREE.Box3): boolean {\n        const globalFrustumMin = this.m_globalFrustumMin;\n        const globalFrustumMax = this.m_globalFrustumMax;\n\n        if (\n            globalFrustumMax.x < tileBounds.min.x ||\n            globalFrustumMax.y < tileBounds.min.y ||\n            globalFrustumMax.z < tileBounds.min.z ||\n            globalFrustumMin.x > tileBounds.max.x ||\n            globalFrustumMin.y > tileBounds.max.y ||\n            globalFrustumMin.z > tileBounds.max.z\n        ) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns the eight corners of the frustum.\n     */\n    private getFrustumCorners(): THREE.Vector3[] {\n        const frustumCorners = this.m_frustumCorners;\n        const invProjMatrix = (this.m_camera as any).projectionMatrixInverse as THREE.Matrix4;\n\n        let cornerIndex = 0;\n\n        function addPoint(x: number, y: number, z: number) {\n            frustumCorners[cornerIndex++].set(x, y, z).applyMatrix4(invProjMatrix);\n        }\n\n        const w = 1;\n        const h = 1;\n        const n = -1;\n        const f = 1;\n\n        // near\n        addPoint(-w, -h, n);\n        addPoint(w, -h, n);\n        addPoint(-w, h, n);\n        addPoint(w, h, n);\n\n        // far\n        addPoint(-w, -h, f);\n        addPoint(w, -h, f);\n        addPoint(-w, h, f);\n        addPoint(w, h, f);\n\n        return frustumCorners;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeometryKind } from \"@here/harp-datasource-protocol\";\nimport * as THREE from \"three\";\nimport { ElevationProvider } from \"../ElevationProvider\";\nimport { TextElement } from \"../text/TextElement\";\nimport { Tile, TileObject } from \"../Tile\";\n\n/**\n * Overlays the specified object's geometry on the elevation represented by the given displacement\n * map .\n *\n * @param object The object to be overlaid.\n * @param displacementMap Texture representing the elevation data used to overlay the object.\n */\nfunction overlayObject(object: TileObject, displacementMap: THREE.DataTexture): void {\n    if (!(\"material\" in object)) {\n        return;\n    }\n\n    const material = (object as any).material;\n\n    if (\"displacementMap\" in material) {\n        (material as any).displacementMap = displacementMap;\n    }\n}\n\n/**\n * Overlays the specified coordinates on top of elevation data if available.\n *\n * @param worldCoords World coordinates to overlay.\n * @param elevationProvider Used to get elevation data.\n * @param tile The tile to which the coordinates are relative.\n */\nfunction overlayPosition(\n    worldCoords: THREE.Vector3,\n    elevationProvider: ElevationProvider,\n    tile: Tile\n) {\n    const geoCoords = tile.mapView.projection.unprojectPoint(worldCoords);\n    const height = elevationProvider.getHeight(geoCoords);\n\n    if (height !== undefined) {\n        geoCoords.altitude = height;\n        tile.mapView.projection.projectPoint(geoCoords, worldCoords);\n    }\n}\n\n/**\n * Overlays a text element on top of elevation data if available.\n *\n * @param textElement The text element whose geometry will be overlaid.\n * @param elevationProvider Used to get elevation data.\n * @param tile The tile the text element belongs to.\n */\nfunction overlayTextElement(\n    textElement: TextElement,\n    elevationProvider: ElevationProvider,\n    tile: Tile\n) {\n    // TODO: Move calculation of text element geoCoordinates to decoder.\n    if (textElement.path === undefined) {\n        overlayPosition(textElement.position, elevationProvider, tile);\n        return;\n    }\n\n    for (const position of textElement.path) {\n        overlayPosition(position, elevationProvider, tile);\n    }\n}\n\n// Overlay of text elements within a tile is spread through this many frames to minimize the time\n// spent per frame on elevation overlay.\nconst TEXT_OVERLAY_SPREAD_FRAME_COUNT = 60;\n\n/**\n * Overlays the geometry in the given tile on top of elevation data if available.\n *\n * @param tile The tile whose geometry will be overlaid.\n */\nexport function overlayOnElevation(tile: Tile): void {\n    const elevationProvider = tile.mapView.elevationProvider;\n\n    if (elevationProvider === undefined || tile.objects.length === 0) {\n        return;\n    }\n    const displacementMap = elevationProvider.getDisplacementMap(tile.tileKey);\n    if (displacementMap === undefined || tile.objects.length === 0) {\n        return;\n    }\n\n    const firstObject = tile.objects[0];\n    if (\n        !firstObject.userData ||\n        !firstObject.userData.kind ||\n        !firstObject.userData.kind.find((kind: GeometryKind) => {\n            return kind !== GeometryKind.All && kind !== GeometryKind.Terrain;\n        })\n    ) {\n        return;\n    }\n\n    for (const object of tile.objects) {\n        overlayObject(object, displacementMap.texture);\n    }\n\n    // TODO: Start overlaying text elements as soon as there's some text.\n    if (!tile.allGeometryLoaded) {\n        return;\n    }\n\n    if (tile.allTextElementsOverlaid) {\n        return;\n    }\n\n    const textElementsPerFrame = Math.ceil(\n        tile.textElementGroups.count() / TEXT_OVERLAY_SPREAD_FRAME_COUNT\n    );\n\n    const groups = tile.textElementGroups.sortedGroups;\n    let { groupIndex, elementIndex } = tile.nextTextElementToOverlay;\n    let textElementsCount = 0;\n\n    while (groupIndex < groups.length) {\n        const group = groups[groupIndex];\n        while (textElementsCount < textElementsPerFrame && elementIndex < group.elements.length) {\n            overlayTextElement(group.elements[elementIndex], elevationProvider, tile);\n            elementIndex++;\n            textElementsCount++;\n        }\n\n        if (elementIndex >= group.elements.length) {\n            ++groupIndex;\n            elementIndex = 0;\n        } else {\n            break;\n        }\n    }\n    tile.nextTextElementToOverlay = { groupIndex, elementIndex };\n    tile.textElementsChanged = true;\n    tile.mapView.update();\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { GeometryKind, GeometryKindSet } from \"@here/harp-datasource-protocol\";\n\nimport { MapView } from \"../MapView\";\nimport { Tile } from \"../Tile\";\nimport { Phase, PhasedTileGeometryLoader } from \"./PhasedTileGeometryLoader\";\nimport { TileGeometryManagerBase } from \"./TileGeometryManager\";\n\n/**\n * The default phases to load geometry.\n */\nconst DefaultPhases: Phase[] = [\n    [GeometryKind.Background, GeometryKind.Terrain, GeometryKind.Area, GeometryKind.Border],\n    [GeometryKind.Line],\n    [GeometryKind.Building],\n    [GeometryKind.Label],\n    [GeometryKind.All]\n];\n\n// FIXME: This should (always) be the first phase, no?\nconst DefaultBasicGeometryKinds: GeometryKindSet = new GeometryKindSet(DefaultPhases[0]);\n\n/**\n * Manages the loading of [[Tile]] geometry in phases.\n */\nexport class PhasedTileGeometryManager extends TileGeometryManagerBase {\n    private m_maxUpdatedTilePerFrame = 5;\n    private m_loadPhaseDefinitions: Phase[] = DefaultPhases;\n    private m_basicGeometryKinds: GeometryKindSet = DefaultBasicGeometryKinds;\n\n    /**\n     * Creates an instance of PhasedTileGeometryManager. Keeps the reference to the [[MapView]].\n     *\n     * @param {MapView} mapView\n     */\n    constructor(mapView: MapView) {\n        super(mapView);\n    }\n\n    initTile(tile: Tile): void {\n        if (tile.dataSource.useGeometryLoader) {\n            tile.tileGeometryLoader = new PhasedTileGeometryLoader(\n                tile,\n                this.m_loadPhaseDefinitions,\n                this.m_basicGeometryKinds\n            );\n        }\n    }\n\n    updateTiles(tiles: Tile[]): void {\n        let needUpdate = this.mapView.isDynamicFrame\n            ? this.updateSomeTiles(tiles)\n            : this.updateAllTilesTogether(tiles);\n\n        if (this.m_tileUpdateCallback) {\n            for (const tile of tiles) {\n                this.m_tileUpdateCallback(tile);\n            }\n        }\n\n        // updateTileObjectVisibility() has always to be called.\n        needUpdate = this.updateTileObjectVisibility(tiles) || needUpdate;\n\n        if (needUpdate || !this.checkTilesFinished(tiles)) {\n            this.mapView.update();\n        }\n    }\n\n    private checkTilesFinished(tiles: Tile[]): boolean {\n        for (const tile of tiles) {\n            const phasedGeometryLoader = tile.tileGeometryLoader as PhasedTileGeometryLoader;\n            if (phasedGeometryLoader !== undefined && !phasedGeometryLoader.allGeometryLoaded) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Update the tiles during dynamic frames. Number of tiles to update may be limited.\n     *\n     * @param {Tile[]} tiles\n     */\n    private updateSomeTiles(tiles: Tile[]): boolean {\n        let numTilesUpdated = 0;\n\n        for (const tile of tiles) {\n            const phasedGeometryLoader = tile.tileGeometryLoader as PhasedTileGeometryLoader;\n\n            if (phasedGeometryLoader !== undefined) {\n                if (\n                    phasedGeometryLoader.update(\n                        this.enableFilterByKind ? this.enabledGeometryKinds : undefined,\n                        this.enableFilterByKind ? this.disabledGeometryKinds : undefined\n                    )\n                ) {\n                    numTilesUpdated++;\n                    if (\n                        this.m_maxUpdatedTilePerFrame > 0 &&\n                        numTilesUpdated >= this.m_maxUpdatedTilePerFrame\n                    ) {\n                        break;\n                    }\n                }\n            }\n        }\n        return numTilesUpdated > 0;\n    }\n\n    /**\n     * Update the tiles during static frames. Before advancing to the next phase, any tiles lagging\n     * behind are allowed to catch up to their next phase. Only then all tiles will advance to the\n     * next phase together.\n     *\n     * @param {Tile[]} tiles\n     */\n    private updateAllTilesTogether(tiles: Tile[]): boolean {\n        let lowestPhase: number | undefined;\n        let needUpdate = false;\n\n        for (const tile of tiles) {\n            const phasedGeometryLoader = tile.tileGeometryLoader as PhasedTileGeometryLoader;\n\n            if (\n                phasedGeometryLoader !== undefined &&\n                (lowestPhase === undefined || phasedGeometryLoader.currentPhase < lowestPhase)\n            ) {\n                lowestPhase = phasedGeometryLoader.currentPhase;\n            }\n        }\n\n        if (lowestPhase !== undefined && lowestPhase < this.m_loadPhaseDefinitions.length) {\n            const nextPhase = lowestPhase + 1;\n            needUpdate = this.updateTilesIfNeeded(tiles, nextPhase);\n        }\n        return needUpdate;\n    }\n\n    /**\n     * Update the tiles during static frames only if their phase is lower than the `toPhase`.\n     *\n     * @param {Tile[]} tiles\n     */\n    private updateTilesIfNeeded(tiles: Tile[], toPhase: number): boolean {\n        let needUpdate = false;\n\n        for (const tile of tiles) {\n            const phasedGeometryLoader = tile.tileGeometryLoader as PhasedTileGeometryLoader;\n            if (phasedGeometryLoader !== undefined) {\n                if (\n                    phasedGeometryLoader.updateToPhase(\n                        toPhase,\n                        this.enableFilterByKind ? this.enabledGeometryKinds : undefined,\n                        this.enableFilterByKind ? this.disabledGeometryKinds : undefined\n                    )\n                ) {\n                    needUpdate = true;\n                }\n            }\n        }\n        return needUpdate;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {\n    DecodedTile,\n    GeometryKind,\n    GeometryKindSet,\n    isLineMarkerTechnique,\n    isPoiTechnique,\n    isTextTechnique,\n    Technique\n} from \"@here/harp-datasource-protocol\";\nimport { PerformanceTimer } from \"@here/harp-utils\";\n\nimport { PerformanceStatistics } from \"../Statistics\";\nimport { Tile } from \"../Tile\";\nimport { TileGeometryCreator } from \"./TileGeometryCreator\";\nimport { TileGeometryLoader } from \"./TileGeometryLoader\";\n\n/**\n * Describes the kinds of geometry that should be loaded in a single phase.\n */\nexport type Phase = GeometryKind[];\n\n/**\n * The `PhasedTileGeometryLoader` loads the geometry of a [[Tile]] using a list of [[Phase]]s.\n *\n */\nexport class PhasedTileGeometryLoader implements TileGeometryLoader {\n    private m_decodedTile?: DecodedTile;\n    private m_isFinished: boolean = false;\n    private m_availableGeometryKinds: GeometryKindSet | undefined;\n    private m_geometryKindsLoaded: GeometryKindSet = new GeometryKindSet();\n    private m_currentPhaseIndex = 0;\n\n    /**\n     * Creates an instance of PhasedTileGeometryLoader of a [[Tile]]. It stores the phases in which\n     * its geometry should be created.\n     *\n     * @param {Tile} m_tile Tile the loader manages.\n     * @param {Phase[]} m_loadPhaseDefinitions The definitions of the loading phases.\n     * @param {GeometryKindSet} m_basicGeometryKinds The set of [[GeometryKind]] s that have to be\n     *      created before the [[Tile]] is made visible.\n     */\n    constructor(\n        private m_tile: Tile,\n        private m_loadPhaseDefinitions: Phase[],\n        private m_basicGeometryKinds: GeometryKindSet\n    ) {}\n\n    /**\n     * The [[Tile]] this loader is managing.\n     */\n    get tile(): Tile {\n        return this.m_tile;\n    }\n\n    /**\n     * The index into the array of loading phases.\n     */\n    get currentPhase(): number {\n        return this.m_currentPhaseIndex;\n    }\n\n    /**\n     * The number of phases defined.\n     */\n    get numberOfPhases(): number {\n        return this.m_loadPhaseDefinitions.length;\n    }\n\n    /**\n     * The set of [[GeometryKind]]s already created in this [[Tile]].\n     */\n    get geometryKindsCreated(): GeometryKindSet {\n        return this.m_geometryKindsLoaded;\n    }\n\n    /**\n     * The set of [[GeometryKind]]s available in this [[Tile]].\n     */\n    get availableGeometryKinds(): GeometryKindSet | undefined {\n        return this.m_availableGeometryKinds;\n    }\n\n    /**\n     * Returns `true` if all basic [[GeometryKind]]s have been loaded. The set of basic\n     * [[GeometryKind]]s is defined in the constructor of `PhasedTileGeometryLoader`.\n     */\n    get basicGeometryLoaded(): boolean {\n        for (const kind of this.m_basicGeometryKinds) {\n            if (!this.m_geometryKindsLoaded.has(kind)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns `true` if all [[GeometryKind]]s have been loaded.\n     */\n    get allGeometryLoaded(): boolean {\n        return this.currentPhase >= this.m_loadPhaseDefinitions.length;\n    }\n\n    /**\n     * Set the [[DecodedTile]] of the tile. Is called after the decoded tile has been loaded, and\n     * prepares its content for later processing in the 'updateXXX' methods.\n     *\n     * @param {DecodedTile} decodedTile The decoded tile with the flat geometry data belonging to\n     *      this tile.\n     * @returns {DecodedTile} The processed decoded tile.\n     */\n    setDecodedTile(decodedTile: DecodedTile): DecodedTile {\n        this.m_decodedTile = decodedTile;\n        this.m_currentPhaseIndex = 0;\n        this.m_geometryKindsLoaded.clear();\n\n        if (this.m_decodedTile !== undefined) {\n            this.m_availableGeometryKinds = TileGeometryLoader.prepareDecodedTile(\n                this.m_decodedTile\n            );\n        }\n        return this.m_decodedTile;\n    }\n\n    /**\n     * Update the tile to have all the content in its decoded tile. Load phases will be ignored.\n     *\n     * @param {(GeometryKindSet | undefined)} enabledKinds The [[GeometryKind]]s that should be\n     *      enabled.\n     * @param {(GeometryKindSet | undefined)} disabledKinds The [[GeometryKind]]s that should be\n     *      disabled.\n     * @returns {boolean} `true` if actual geometry has been created.\n     */\n    updateCompletely(\n        enabledKinds: GeometryKindSet | undefined,\n        disabledKinds: GeometryKindSet | undefined\n    ): boolean {\n        return this.update(enabledKinds, disabledKinds, true);\n    }\n\n    /**\n     * Update the tile to the specified phase (index). All intermediate phases between the current\n     * and the specified phase will be processed.\n     *\n     * @param toPhase A value between 0 and `numberOfPhases`.\n     * @param {(GeometryKindSet | undefined)} enabledKinds The [[GeometryKind]]s that should be\n     *      enabled.\n     * @param {(GeometryKindSet | undefined)} disabledKinds The [[GeometryKind]]s that should be\n     *      disabled.\n     * @returns {boolean} `true` if `updateToPhase` was successful.\n     */\n    updateToPhase(\n        toPhase: number,\n        enabledKinds: GeometryKindSet | undefined,\n        disabledKinds: GeometryKindSet | undefined\n    ): boolean {\n        let didUpdate = false;\n        toPhase = Math.min(toPhase, this.numberOfPhases);\n        while (this.currentPhase < toPhase) {\n            if (!this.update(enabledKinds, disabledKinds)) {\n                break;\n            }\n            didUpdate = true;\n        }\n        return didUpdate;\n    }\n\n    /**\n     * Create all geometries in the current phase, or ignore the phases and create all remaining\n     * geometries if `doFullUpdate` is `true`.\n     *\n     * @param {(GeometryKindSet | undefined)} enabledKinds The [[GeometryKind]]s that should be\n     *      enabled.\n     * @param {(GeometryKindSet | undefined)} disabledKinds The [[GeometryKind]]s that should be\n     *      disabled.\n     * @param doFullUpdate If a value of `true` is specified, the current phase is ignored and all\n     *      remaining geometries are created.\n     * @returns {boolean} `true` if `update` was successful. If `currentPhase` is smaller than\n     *      `numberOfPhases`, `update` can be called again. If `false` is returned, another call to\n     *      `update` is not required.\n     */\n    update(\n        enabledKinds: GeometryKindSet | undefined,\n        disabledKinds: GeometryKindSet | undefined,\n        doFullUpdate: boolean = false\n    ): boolean {\n        const tile = this.tile;\n        const loadPhaseDefinitions = this.m_loadPhaseDefinitions;\n\n        if (!tile.dataSource.cacheable) {\n            this.m_currentPhaseIndex = loadPhaseDefinitions.length;\n            return false;\n        }\n\n        let decodedTile = this.m_decodedTile;\n        const currentPhase = this.currentPhase;\n\n        // First time this tile is handled:\n        if (decodedTile === undefined && tile.decodedTile !== undefined) {\n            decodedTile = this.setDecodedTile(tile.decodedTile);\n            TileGeometryCreator.instance.processTechniques(\n                decodedTile,\n                enabledKinds,\n                disabledKinds\n            );\n            tile.clear();\n        }\n\n        if (decodedTile === undefined || currentPhase >= this.numberOfPhases) {\n            return false;\n        }\n\n        const geometryCreator = TileGeometryCreator.instance;\n\n        const stats = PerformanceStatistics.instance;\n        let now = 0;\n\n        if (stats.enabled) {\n            now = PerformanceTimer.now();\n        }\n\n        if (doFullUpdate) {\n            geometryCreator.createAllGeometries(tile, decodedTile);\n\n            // Mark it as finished.\n            this.m_currentPhaseIndex = loadPhaseDefinitions.length;\n        } else {\n            const currentPhaseDefinition = loadPhaseDefinitions[currentPhase];\n\n            for (const kind of currentPhaseDefinition) {\n                this.createKind(geometryCreator, kind);\n            }\n        }\n\n        if (stats.enabled) {\n            stats.currentFrame.addValue(\n                \"geometry.geometryCreationTime\",\n                PerformanceTimer.now() - now\n            );\n        }\n\n        if (this.nextPhase() === undefined) {\n            // All done, update the stats\n            if (stats.enabled) {\n                const currentFrame = stats.currentFrame;\n\n                currentFrame.addValue(\"geometryCount.numGeometries\", decodedTile.geometries.length);\n                currentFrame.addValue(\"geometryCount.numTechniques\", decodedTile.techniques.length);\n                currentFrame.addValue(\n                    \"geometryCount.numPoiGeometries\",\n                    decodedTile.poiGeometries !== undefined ? decodedTile.poiGeometries.length : 0\n                );\n                currentFrame.addValue(\n                    \"geometryCount.numTextGeometries\",\n                    decodedTile.textGeometries !== undefined ? decodedTile.textGeometries.length : 0\n                );\n                currentFrame.addValue(\n                    \"geometryCount.numTextPathGeometries\",\n                    decodedTile.textPathGeometries !== undefined\n                        ? decodedTile.textPathGeometries.length\n                        : 0\n                );\n                currentFrame.addValue(\n                    \"geometryCount.numPathGeometries\",\n                    decodedTile.pathGeometries !== undefined ? decodedTile.pathGeometries.length : 0\n                );\n                currentFrame.addMessage(\n                    `Decoded tile: ${tile.dataSource.name} # lvl=${tile.tileKey.level} ` +\n                        `col=${tile.tileKey.column} row=${tile.tileKey.row}`\n                );\n            }\n\n            this.finish();\n        }\n        return true;\n    }\n\n    get isFinished(): boolean {\n        return this.m_isFinished;\n    }\n\n    dispose(): void {\n        this.m_decodedTile = undefined;\n    }\n\n    reset(): void {\n        this.m_decodedTile = undefined;\n        this.m_isFinished = false;\n        this.m_availableGeometryKinds = undefined;\n        this.m_geometryKindsLoaded.clear();\n        this.m_currentPhaseIndex = 0;\n    }\n\n    /**\n     * Increment the current phase to activate the next phase of geometries.\n     *\n     * @returns {(number | undefined)} The index into the now active current pase, or `undefined` if\n     *      the last phase has been reached.\n     */\n    protected nextPhase(): number | undefined {\n        if (this.m_currentPhaseIndex < this.m_loadPhaseDefinitions.length) {\n            this.m_currentPhaseIndex++;\n        }\n\n        return this.m_currentPhaseIndex < this.m_loadPhaseDefinitions.length\n            ? this.m_currentPhaseIndex\n            : undefined;\n    }\n\n    /**\n     * Create all geometries of the specified [[GeometryKind]] `kindToCreate`.\n     *\n     * @param {TileGeometryCreator} geometryCreator\n     * @param {GeometryKind} kindToCreate\n     */\n    protected createKind(geometryCreator: TileGeometryCreator, kindToCreate: GeometryKind): void {\n        if (this.m_geometryKindsLoaded.has(kindToCreate)) {\n            return;\n        }\n        this.m_geometryKindsLoaded.add(kindToCreate);\n\n        const tile = this.tile;\n        const decodedTile = this.m_decodedTile;\n\n        if (decodedTile !== undefined) {\n            const filter = (technique: Technique): boolean => {\n                if (technique.enabled === false) {\n                    return false;\n                }\n\n                const techniqueKind = technique.kind;\n\n                // All kinds are allowed, except those which are explicitly disabled.\n                if (kindToCreate === GeometryKind.All) {\n                    return true;\n                }\n\n                if (techniqueKind instanceof Set) {\n                    const techniqueKinds = techniqueKind as GeometryKindSet;\n\n                    // Check if that technique fits the expected kindToCreate.\n                    return techniqueKinds.has(kindToCreate);\n                } else {\n                    return techniqueKind === kindToCreate;\n                }\n            };\n\n            geometryCreator.createObjects(tile, decodedTile, filter);\n\n            const textFilter = (technique: Technique): boolean => {\n                if (\n                    !isPoiTechnique(technique) &&\n                    !isLineMarkerTechnique(technique) &&\n                    !isTextTechnique(technique)\n                ) {\n                    return false;\n                }\n                return filter(technique);\n            };\n\n            // TextElements do not get their geometry created by Tile, but are managed on a\n            // higher level.\n            geometryCreator.createTextElements(tile, decodedTile, textFilter);\n\n            geometryCreator.preparePois(tile, decodedTile);\n        }\n    }\n\n    private finish() {\n        this.m_decodedTile = undefined;\n        this.m_tile.loadingFinished();\n        this.m_tile.removeDecodedTile();\n        this.m_isFinished = true;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { TextCanvas } from \"@here/harp-text-canvas\";\nimport { MapView } from \"../MapView\";\nimport { PoiRenderer } from \"./PoiRenderer\";\n\nexport class PoiRendererFactory {\n    /**\n     * Creates an instance of poi renderer factory.\n     * @param m_mapView\n     */\n    constructor(private readonly m_mapView: MapView) {}\n\n    /**\n     * Creates poi renderer\n     * @param textCanvas\n     * @returns\n     */\n    createPoiRenderer(textCanvas: TextCanvas): PoiRenderer {\n        return new PoiRenderer(this.m_mapView, textCanvas);\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport * from \"./lib/StyleSetEvaluator\";\nexport * from \"./lib/Extruder\";\nexport * from \"./lib/IMeshBuffers\";\nexport * from \"./lib/Outliner\";\nexport * from \"./lib/Expr\";\nexport * from \"./lib/ThreeBufferUtils\";\nexport * from \"./lib/GeoJsonDataType\";\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Fills an index buffer with the indices for the extruded walls for a polygon contour.\n *\n * @param indexBuffer Index buffer to be filled.\n * @param vertexOffset Starting offset of the vertices composing the contour.\n * @param vertexStride Number of elements per contour vertex.\n * @param contour Vertices that compose the contour.\n * @param contourEdges Collection of booleans indicating if contour edges should be added.\n * @param boundaryWalls If `false`, walls in tile boundaries will not be created.\n *\n */\nexport function addExtrudedWalls(\n    indexBuffer: number[],\n    vertexOffset: number,\n    vertexStride: number,\n    contour: number[],\n    contourEdges?: boolean[],\n    boundaryWalls?: boolean\n): void {\n    // Infer the index buffer's position of the vertices that form the extruded-polygons' walls\n    // by stepping through the contour segment by segment.\n    const nSegments = contour.length / vertexStride;\n    for (let i = 0; i < nSegments; ++i) {\n        const vFootprint0 = vertexOffset + i * 2;\n        const vRoof0 = vFootprint0 + 1;\n        const vFootprint1 = vertexOffset + ((i + 1) % nSegments) * 2;\n        const vRoof1 = vFootprint1 + 1;\n        if (boundaryWalls !== false || contourEdges === undefined) {\n            indexBuffer.push(vFootprint0, vRoof0, vRoof1, vRoof1, vFootprint1, vFootprint0);\n        } else if (contourEdges[i]) {\n            indexBuffer.push(vFootprint0, vRoof0, vRoof1, vRoof1, vFootprint1, vFootprint0);\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nconst currEdgeStart = new THREE.Vector2();\nconst currEdgeGoal = new THREE.Vector2();\nconst prevEdgeStart = new THREE.Vector2();\nconst prevEdgeGoal = new THREE.Vector2();\n\n/**\n * Fills an index buffer with the indices for the edges of a polygon contour.\n *\n * @param indexBuffer Edge index buffer to be filled.\n * @param vertexOffset Starting offset of the vertices composing the contour.\n * @param vertexStride Number of elements per contour vertex.\n * @param polygonContour Vertices that compose the contour.\n * @param polygonContourEdges Collection of booleans indicating if contour edges should be added.\n */\nexport function addPolygonEdges(\n    indexBuffer: number[],\n    vertexOffset: number,\n    vertexStride: number,\n    polygonContour: number[],\n    polygonContourEdges: boolean[],\n    isExtruded?: boolean,\n    addFootprintEdges?: boolean,\n    wallEdgeSlope?: number\n) {\n    for (let i = 0; i < polygonContourEdges.length; ++i) {\n        if (polygonContourEdges[i]) {\n            if (isExtruded === true) {\n                const vFootprint0 = vertexOffset + i * 2;\n                const vRoof0 = vFootprint0 + 1;\n                const vFootprint1 = vertexOffset + ((i + 1) % polygonContourEdges.length) * 2;\n                const vRoof1 = vFootprint1 + 1;\n\n                if (addFootprintEdges === true) {\n                    indexBuffer.push(vFootprint0, vFootprint1);\n                }\n                indexBuffer.push(vRoof0, vRoof1);\n\n                const prevEdgeIdx = (i === 0 ? polygonContourEdges.length : i) - 1;\n                if (polygonContourEdges[prevEdgeIdx]) {\n                    if (wallEdgeSlope !== undefined) {\n                        const v0x = polygonContour[i * vertexStride];\n                        const v0y = polygonContour[i * vertexStride + 1];\n                        const v1x =\n                            polygonContour[((i + 1) % polygonContourEdges.length) * vertexStride];\n                        const v1y =\n                            polygonContour[\n                                ((i + 1) % polygonContourEdges.length) * vertexStride + 1\n                            ];\n\n                        currEdgeStart.set(v0x, v0y);\n                        currEdgeGoal.set(v1x, v1y);\n                        prevEdgeStart.set(\n                            polygonContour[prevEdgeIdx * vertexStride],\n                            polygonContour[prevEdgeIdx * vertexStride + 1]\n                        );\n                        prevEdgeGoal.set(currEdgeStart.x, currEdgeStart.y);\n\n                        if (\n                            prevEdgeGoal\n                                .sub(prevEdgeStart)\n                                .normalize()\n                                .dot(currEdgeGoal.sub(currEdgeStart).normalize()) <= wallEdgeSlope\n                        ) {\n                            indexBuffer.push(vFootprint0, vRoof0);\n                        }\n                    } else {\n                        indexBuffer.push(vFootprint0, vRoof0);\n                    }\n                }\n            } else {\n                const vFoot0 = vertexOffset + i;\n                const vRoof0 = vertexOffset + ((i + 1) % polygonContourEdges.length);\n                indexBuffer.push(vFoot0, vRoof0);\n            }\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    BufferAttribute as ThreeBufferAttribute,\n    BufferGeometry as ThreeBufferGeometry,\n    InterleavedBufferAttribute as ThreeInterleavedBufferAttribute,\n    TypedArray\n} from \"three\";\nimport {\n    BufferAttribute,\n    BufferElementType,\n    Geometry,\n    GeometryType,\n    InterleavedBufferAttribute\n} from \"./DecodedTile\";\n\n/**\n * Collection of helper methods to convert\n * {@link https://threejs.org/docs/index.html#api/en/core/BufferGeometry|three.js BufferGeometry}\n * to [[Geometry]] that allows creation and transfering of THREE BufferGeometry in webworkers.\n * See also [[CustomDatasourceExample]].\n */\nexport namespace ThreeBufferUtils {\n    export function getBufferElementType(buffer: TypedArray): BufferElementType {\n        if (buffer instanceof Int8Array) {\n            return \"int8\";\n        } else if (buffer instanceof Uint8Array) {\n            return \"uint8\";\n        } else if (buffer instanceof Int16Array) {\n            return \"int16\";\n        } else if (buffer instanceof Uint16Array) {\n            return \"uint16\";\n        } else if (buffer instanceof Int32Array) {\n            return \"int32\";\n        } else if (buffer instanceof Uint32Array) {\n            return \"uint32\";\n        } else if (buffer instanceof Float32Array) {\n            return \"float\";\n        }\n\n        throw new Error(`Unsupported buffer type ${name}`);\n    }\n\n    export function fromThreeBufferAttribute(\n        bufferAttribute: ThreeBufferAttribute\n    ): BufferAttribute {\n        const buffer = (bufferAttribute.array as any) as TypedArray;\n        return {\n            name: bufferAttribute.name,\n            buffer: buffer.buffer,\n            type: getBufferElementType(buffer),\n            itemCount: bufferAttribute.itemSize,\n            normalized: bufferAttribute.normalized\n        };\n    }\n\n    export function fromThreeInterleavedBufferAttribute(\n        bufferAttribute: ThreeInterleavedBufferAttribute\n    ): InterleavedBufferAttribute {\n        throw new Error(\"Not implemented yet\");\n    }\n\n    export function fromThreeBufferGeometry(\n        bufferGeometry: ThreeBufferGeometry,\n        techniqueIndex: number\n    ): Geometry {\n        const vertexAttributes: BufferAttribute[] = [];\n        const attributeNames = Object.getOwnPropertyNames(bufferGeometry.attributes);\n        for (const name of attributeNames) {\n            const attribute = bufferGeometry.attributes[name];\n            // FIXME: Also support InterleavedBufferAttribute\n            const vertexAttribute = fromThreeBufferAttribute(attribute as ThreeBufferAttribute);\n            vertexAttribute.name = name;\n            vertexAttributes.push(vertexAttribute);\n        }\n        const index =\n            bufferGeometry.index !== null\n                ? fromThreeBufferAttribute(bufferGeometry.index)\n                : undefined;\n\n        let count = 0;\n        if (index !== undefined) {\n            count = bufferGeometry.index === null ? 0 : bufferGeometry.index.count;\n        } else {\n            // If there is no index buffer, try to deduce the count from the position attribute.\n            const posAttr = bufferGeometry.attributes.position as ThreeBufferAttribute;\n            if (posAttr === undefined) {\n                throw new Error(\"Missing position attibute to deduce item count\");\n            }\n            count = posAttr.count;\n        }\n\n        return {\n            type: GeometryType.Unspecified,\n            vertexAttributes,\n            index,\n            groups: [{ start: 0, count, technique: techniqueIndex }]\n        };\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { LoggerManager, Math2D } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\nimport { debugContext } from \"./DebugContext\";\n\ndeclare const require: any;\n\n// tslint:disable-next-line:no-var-requires\nconst RBush = require(\"rbush\");\n\nconst logger = LoggerManager.instance.create(\"ScreenCollissions\");\n\nexport interface IBox {\n    minX: number;\n    minY: number;\n    maxX: number;\n    maxY: number;\n    type: string;\n}\n\nexport interface CollisionBox extends IBox {\n    type: \"box\";\n}\n\nexport interface LineWithBound extends IBox {\n    type: \"line\";\n    line: THREE.Line3;\n}\n/**\n * @hidden\n */\nexport class ScreenCollisions {\n    /**\n     * Converts a [[THREE.Box2]] to an internal [[Math2D.Box]].\n     *\n     * @param threeBox The [[THREE.Box2]] to convert.\n     * @param box2 The conversion target.\n     */\n    static toBox2D(threeBox: THREE.Box2, box2: Math2D.Box) {\n        box2.x = threeBox.min.x;\n        box2.y = threeBox.min.y;\n        box2.w = threeBox.max.x - threeBox.min.x;\n        box2.h = threeBox.max.y - threeBox.min.y;\n    }\n\n    /** The screen bounding box. */\n    readonly screenBounds = new Math2D.Box();\n\n    /** Tree of allocated bounds. */\n\n    private rtree = new RBush();\n\n    /**\n     * Constructs a new ScreenCollisions object.\n     */\n    constructor() {\n        //\n    }\n\n    /**\n     * Resets the list of allocated screen bounds.\n     */\n    reset() {\n        this.rtree.clear();\n    }\n\n    /**\n     * Updates the screen bounds that are used to check if bounding boxes are visible.\n     *\n     * @param width The width of the container.\n     * @param height The height of the container.\n     */\n    update(width: number, height: number) {\n        this.screenBounds.set(width / -2, height / -2, width, height);\n        this.reset();\n    }\n\n    /**\n     * Marks the region of the screen intersecting with the given bounding box as allocated.\n     *\n     * @param bounds The bounding box in NDC scaled coordinates (i.e. top left is -width/2,\n     * -height/2)\n     */\n    allocate(bounds: Math2D.Box): void {\n        const bbox = {\n            minX: bounds.x,\n            minY: bounds.y,\n            maxX: bounds.x + bounds.w,\n            maxY: bounds.y + bounds.h,\n            type: \"box\"\n        };\n        this.rtree.insert(bbox);\n    }\n\n    /**\n     * Inserts the given bounds into the rtree.\n     *\n     * @param bounds The bounding boxes (the bounding boxes must be in the space returned from the\n     * ScreenProjector.project method).\n     */\n    allocateIBoxes(bounds: IBox[]) {\n        this.rtree.load(bounds);\n    }\n\n    /**\n     * Checks if the given bounding box is already allocated.\n     *\n     * @param bounds The bounding box in world coordinates.\n     */\n    isAllocated(bounds: Math2D.Box | CollisionBox): boolean {\n        const collisionBox = bounds instanceof Math2D.Box ? this.toCollisionBox(bounds) : bounds;\n        const results = this.rtree.search(collisionBox);\n        for (const result of results) {\n            switch (result.type) {\n                case \"box\":\n                    return true;\n                case \"line\": {\n                    const boundedLine = result as LineWithBound;\n                    if (this.intersectsLine(collisionBox, boundedLine)) {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks if the given screen bounds intersects with the frustum of the active camera.\n     *\n     * @param bounds The bounding box in world coordinates.\n     */\n    isVisible(bounds: Math2D.Box): boolean {\n        return this.screenBounds.intersects(bounds);\n    }\n\n    /**\n     * Computes the intersection between the supplied CollisionBox and the LineWithBound.\n     * @note The [[CollisionBox]] is in Screen Bounds space, whereas the line must be\n     * in Screen Coordinate space\n     * @deprecated Because this is meant just for testing.\n     */\n    intersectsLine(bbox: CollisionBox, boundedLine: LineWithBound): boolean {\n        const line = boundedLine.line;\n\n        // Note, these aren't normalized, but it doesn't matter, we are just interested\n        // in the sign.\n        const lineXDiffTransformed = line.end.x - line.start.x;\n\n        // Sign of bottom left, bottom right, top left and top right corners.\n        let signBL: number;\n        let signBR: number;\n        let signTL: number;\n        let signTR: number;\n        if (lineXDiffTransformed !== 0) {\n            const lineYDiffTransformed = line.end.y - line.start.y;\n            const normalX = lineYDiffTransformed;\n            const normalY = -lineXDiffTransformed;\n            const D = line.start.y - (lineYDiffTransformed / lineXDiffTransformed) * line.start.x;\n\n            signBL = Math.sign(bbox.minX * normalX + (bbox.minY - D) * normalY);\n            signBR = Math.sign(bbox.maxX * normalX + (bbox.minY - D) * normalY);\n            signTL = Math.sign(bbox.minX * normalX + (bbox.maxY - D) * normalY);\n            signTR = Math.sign(bbox.maxX * normalX + (bbox.maxY - D) * normalY);\n        } else {\n            signBL = Math.sign(bbox.minX - line.start.x);\n            signBR = Math.sign(bbox.maxX - line.start.x);\n            signTL = Math.sign(bbox.minX - line.start.x);\n            signTR = Math.sign(bbox.maxX - line.start.x);\n        }\n        return signBL !== signBR || signBL !== signTL || signBL !== signTR;\n    }\n\n    private toCollisionBox(bounds: Math2D.Box): CollisionBox {\n        return {\n            minX: bounds.x,\n            minY: bounds.y,\n            maxX: bounds.x + bounds.w,\n            maxY: bounds.y + bounds.h,\n            type: \"box\"\n        };\n    }\n}\n\n/**\n * @hidden\n *\n * Shows requests for screen space during labelling in an HTML canvas, which should be sized like\n * the actual map canvas. It can be placed on top of the map canvas to show exactly which requests\n * for screen space were done.\n *\n * Also logs statistics.\n */\nexport class ScreenCollisionsDebug extends ScreenCollisions {\n    /** 2D rendering context. */\n    private m_renderContext: CanvasRenderingContext2D | null = null;\n    private m_renderingEnabled = false;\n    private m_numAllocations = 0;\n    private m_numSuccessfulTests = 0;\n    private m_numFailedTests = 0;\n    private m_numSuccessfulVisibilityTests = 0;\n    private m_numFailedVisibilityTests = 0;\n\n    /**\n     * Constructs a new ScreenCollisions object which renders its state to a 2D canvas.\n     */\n    constructor(debugCanvas: HTMLCanvasElement) {\n        super();\n\n        if (debugCanvas !== undefined && debugCanvas !== null) {\n            this.m_renderContext = debugCanvas.getContext(\"2d\");\n        }\n    }\n\n    /**\n     * Resets the list of allocated bounds and clears the debug canvas.\n     */\n    reset() {\n        super.reset();\n\n        this.m_numAllocations = 0;\n        this.m_numSuccessfulTests = 0;\n        this.m_numFailedTests = 0;\n        this.m_numSuccessfulVisibilityTests = 0;\n        this.m_numFailedVisibilityTests = 0;\n    }\n\n    /**\n     * Updates the screen bounds used to check if bounding boxes are visible.\n     *\n     * @param width The width of the container.\n     * @param height The height of the container.\n     */\n    update(width: number, height: number) {\n        if (this.m_renderingEnabled) {\n            logger.log(\n                // tslint:disable-next-line: max-line-length\n                `Allocations: ${this.m_numAllocations} Successful Tests: ${this.m_numSuccessfulTests} Failed Tests: ${this.m_numFailedTests}  Successful Visibility Tests: ${this.m_numSuccessfulVisibilityTests}  Failed Visibility Tests: ${this.m_numFailedVisibilityTests} `\n            );\n        }\n\n        super.update(width, height);\n\n        if (this.m_renderContext !== null) {\n            this.m_renderContext.canvas.width = width;\n            this.m_renderContext.canvas.height = height;\n        }\n\n        // activate in the browser with:\n        // window.__debugContext.setValue(\"DEBUG_SCREEN_COLLISIONS\", true)\n        this.m_renderingEnabled = debugContext.getValue(\"DEBUG_SCREEN_COLLISIONS\");\n    }\n\n    /**\n     * Marks the region of the screen intersecting with the given bounding box as allocated.\n     *\n     * @param bounds the bounding box in world coordinates.\n     */\n    allocate(bounds: Math2D.Box): void {\n        super.allocate(bounds);\n\n        this.m_numAllocations++;\n\n        if (this.m_renderingEnabled && this.m_renderContext !== null) {\n            this.m_renderContext.strokeStyle = \"#6666ff\";\n            this.m_renderContext.strokeRect(\n                bounds.x - this.screenBounds.x,\n                this.screenBounds.y + this.screenBounds.h - bounds.y - 1,\n                bounds.w,\n                -bounds.h\n            );\n        }\n    }\n\n    allocateIBoxes(boundsArray: IBox[]) {\n        for (const bounds of boundsArray) {\n            this.m_numAllocations++;\n\n            if (this.m_renderingEnabled && this.m_renderContext !== null) {\n                this.m_renderContext.strokeStyle = \"#aa2222\";\n                this.m_renderContext.strokeRect(\n                    bounds.minX - this.screenBounds.x,\n                    this.screenBounds.y + this.screenBounds.h - bounds.minY - 1,\n                    bounds.maxX - bounds.minX,\n                    -(bounds.maxY - bounds.minY)\n                );\n            }\n        }\n        super.allocateIBoxes(boundsArray);\n    }\n\n    /**\n     * Checks if the given bounding box is already allocated.\n     *\n     * @param bounds The bounding box in world coordinates.\n     */\n    isAllocated(bounds: Math2D.Box): boolean {\n        const isFailed = super.isAllocated(bounds);\n\n        if (this.m_renderingEnabled && this.m_renderContext !== null) {\n            const offset = isFailed ? 2 : 0;\n            this.m_renderContext.strokeStyle = isFailed ? \"#FF0000\" : \"#00ff00\";\n            this.m_renderContext.strokeRect(\n                bounds.x - this.screenBounds.x - offset,\n                this.screenBounds.y + this.screenBounds.h - bounds.y - 1 + offset,\n                bounds.w + 2 * offset,\n                -bounds.h - 2 * offset\n            );\n        }\n\n        if (isFailed) {\n            this.m_numFailedTests++;\n        } else {\n            this.m_numSuccessfulTests++;\n        }\n\n        return isFailed;\n    }\n\n    /**\n     * Checks if the given screen bounds intersects with the frustum of the active camera.\n     *\n     * @param bounds The bounding box in world coordinates.\n     */\n    isVisible(bounds: Math2D.Box): boolean {\n        const visible = super.isVisible(bounds);\n\n        if (visible) {\n            this.m_numSuccessfulVisibilityTests++;\n        } else {\n            this.m_numFailedVisibilityTests++;\n        }\n        return visible;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Vector3Like } from \"@here/harp-geoutils\";\nimport * as THREE from \"three\";\n\n/**\n * Determines whether a position in NDC (Normalized Device Coordinates) is inside the screen.\n * @param ndc The position to check.\n */\nfunction isOnScreen(ndc: THREE.Vector3) {\n    return ndc.z > -1 && ndc.z < 1 && ndc.x >= -1 && ndc.x <= 1 && ndc.y >= -1 && ndc.y <= 1;\n}\n\n/**\n * @hidden\n * Handles the projection of world coordinates to screen coordinates.\n */\nexport class ScreenProjector {\n    static tempV2 = new THREE.Vector2();\n    static tempV3 = new THREE.Vector3();\n\n    private m_width: number = 0;\n    private m_height: number = 0;\n\n    /**\n     * Constructs a new `ScreenProjector`.\n     *\n     * @param m_camera Camera to project against.\n     */\n    constructor(private m_camera: THREE.Camera) {}\n\n    /**\n     * Height of the screen.\n     */\n    get width(): number {\n        return this.m_width;\n    }\n\n    /**\n     * Width of the screen.\n     */\n    get height(): number {\n        return this.m_height;\n    }\n\n    /**\n     * Apply current projectionViewMatrix of the camera to project the source vector into\n     * screen coordinates.\n     *\n     * @param {(Vector3Like)} source The source vector to project.\n     * @param {THREE.Vector2} target The target vector.\n     * @returns {THREE.Vector2} The projected vector (the parameter 'target') or undefined if\n     * outside the near / far plane.\n     */\n    project(\n        source: Vector3Like,\n        target: THREE.Vector2 = new THREE.Vector2()\n    ): THREE.Vector2 | undefined {\n        const p = this.projectVector(source, ScreenProjector.tempV3);\n        if (p.z > -1 && p.z < 1) {\n            return this.ndcToScreen(p, target);\n        }\n        return undefined;\n    }\n\n    /**\n     * Apply current projectionViewMatrix of the camera to project the source vector into\n     * screen coordinates.\n     *\n     * @param {(Vector3Like)} source The source vector to project.\n     * @param {THREE.Vector2} target The target vector.\n     * @returns {THREE.Vector2} The projected vector (the parameter 'target') or undefined if\n     * outside the screen.\n     */\n    projectOnScreen(\n        source: Vector3Like,\n        target: THREE.Vector2 = new THREE.Vector2()\n    ): THREE.Vector2 | undefined {\n        const p = this.projectVector(source, ScreenProjector.tempV3);\n        if (isOnScreen(p)) {\n            return this.ndcToScreen(p, target);\n        }\n        return undefined;\n    }\n\n    /**\n     * Apply current projectionViewMatrix of the camera to project the source vector into\n     * screen coordinates. The z component between -1 and 1 is also returned.\n     *\n     * @param {(Vector3Like)} source The source vector to project.\n     * @param {THREE.Vector3} target The target vector.\n     * @returns {THREE.Vector3} The projected vector (the parameter 'target') or undefined if\n     * outside the near / far plane.\n     */\n    project3(\n        source: Vector3Like,\n        target: THREE.Vector3 = new THREE.Vector3()\n    ): THREE.Vector3 | undefined {\n        const p = this.projectVector(source, ScreenProjector.tempV3);\n        if (p.z > -1 && p.z < 1) {\n            target.set((p.x * this.m_width) / 2, (p.y * this.m_height) / 2, p.z);\n            return target;\n        }\n        return undefined;\n    }\n\n    /**\n     * Apply current projectionViewMatrix of the camera to project the source vector. Stores\n     * result in NDC in the target vector.\n     *\n     * @param {(Vector3Like)} source The source vector to project.\n     * @param {THREE.Vector3} target The target vector.\n     * @returns {THREE.Vector3} The projected vector (the parameter 'target').\n     */\n    projectVector(source: Vector3Like, target: THREE.Vector3): THREE.Vector3 {\n        target.set(source.x, source.y, source.z).project(this.m_camera);\n        return target;\n    }\n\n    /**\n     * Fast test to check if projected point is on screen.\n     *\n     * @returns {boolean} `true` if point is on screen, `false` otherwise.\n     */\n    onScreen(source: Vector3Like): boolean {\n        const p = this.projectVector(source, ScreenProjector.tempV3);\n        return isOnScreen(p);\n    }\n\n    /**\n     * Update the `ScreenProjector` with the latest values of the screen and the camera.\n     *\n     * @param {THREE.Camera} camera Camera to project against.\n     * @param {number} width Width of screen/canvas.\n     * @param {number} height Height of screen/canvas.\n     */\n    update(camera: THREE.Camera, width: number, height: number) {\n        this.m_camera = camera;\n        this.m_width = width;\n        this.m_height = height;\n    }\n\n    private ndcToScreen(ndc: THREE.Vector3, screenCoords: THREE.Vector2): THREE.Vector2 {\n        return screenCoords.set((ndc.x * this.m_width) / 2, (ndc.y * this.m_height) / 2);\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { CubemapSky, GradientSky } from \"@here/harp-datasource-protocol\";\nimport { ProjectionType } from \"@here/harp-geoutils\";\nimport { SkyCubemapTexture } from \"./SkyCubemapTexture\";\nimport { SkyGradientTexture } from \"./SkyGradientTexture\";\n\nimport * as THREE from \"three\";\n\n/**\n * Class that handles [[MapView]]'s sky background.\n */\nexport class SkyBackground {\n    private m_skyTexture?: SkyGradientTexture | SkyCubemapTexture;\n\n    /**\n     * Constructs a new `SkyBackground`.\n     *\n     * @param m_sky Sky configuration parameters.\n     * @param m_projectionType [[MapView]]'s projection type.\n     * @param camera [[MapView]]'s camera.\n     */\n    constructor(\n        private m_sky: GradientSky | CubemapSky,\n        private m_projectionType: ProjectionType,\n        camera: THREE.Camera\n    ) {\n        switch (this.m_sky.type) {\n            case \"gradient\":\n                this.m_skyTexture = new SkyGradientTexture(this.m_sky, this.m_projectionType);\n                this.updateCamera(camera);\n                break;\n            case \"cubemap\": {\n                this.m_skyTexture = new SkyCubemapTexture(this.m_sky);\n                break;\n            }\n        }\n    }\n\n    /**\n     * Disposes allocated resources.\n     */\n    dispose() {\n        this.m_skyTexture!.dispose();\n    }\n\n    /**\n     * Sky texture.\n     */\n    get texture(): THREE.Texture {\n        return this.m_skyTexture!.texture;\n    }\n\n    /**\n     * This method updates the skybox based on the camera position (needed for some types of sky).\n     *\n     * @param camera The camera used in the map view.\n     */\n    updateCamera(camera: THREE.Camera) {\n        if (this.m_sky.type === \"gradient\") {\n            (this.m_skyTexture! as SkyGradientTexture).update(camera);\n        }\n    }\n\n    /**\n     * Updates the sky texture with new parameters.\n     *\n     * @param params New sky configuration parameters.\n     * @param projectionType Which projection is used, this may also change (in which case the\n     * textures should be recreated).\n     */\n    updateTexture(params: GradientSky | CubemapSky, projectionType: ProjectionType) {\n        const isSameSkyType =\n            this.m_sky.type === params.type && this.m_projectionType === projectionType;\n        switch (params.type) {\n            case \"gradient\":\n                if (isSameSkyType) {\n                    (this.m_skyTexture! as SkyGradientTexture).updateTexture(params);\n                } else {\n                    this.m_skyTexture = new SkyGradientTexture(params, projectionType);\n                }\n                break;\n            case \"cubemap\": {\n                if (isSameSkyType) {\n                    (this.m_skyTexture! as SkyCubemapTexture).updateTexture(params);\n                } else {\n                    this.m_skyTexture = new SkyCubemapTexture(params);\n                }\n                break;\n            }\n        }\n        this.m_projectionType = projectionType;\n        this.m_sky = params;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GradientSky } from \"@here/harp-datasource-protocol\";\nimport { ProjectionType } from \"@here/harp-geoutils\";\nimport { getOptionValue } from \"@here/harp-utils\";\nimport { Color, CubeTexture, DataTexture, Line3, Plane, RGBFormat, Texture, Vector3 } from \"three\";\n\nexport const DEFAULT_TEXTURE_SIZE = 512;\nexport const DEFAULT_MONOMIAL_POWER = 1;\n\n// Vectors used for skybox bitmap computation.\nconst cameraDir = [\n    new Vector3(1, 0, 0),\n    new Vector3(-1, 0, 0),\n    new Vector3(0, -1, 0),\n    new Vector3(0, 1, 0),\n    new Vector3(0, 0, 1),\n    new Vector3(0, 0, -1)\n];\nconst cameraRight = [\n    new Vector3(0, 0, -1),\n    new Vector3(0, 0, 1),\n    new Vector3(1, 0, 0),\n    new Vector3(1, 0, 0),\n    new Vector3(1, 0, 0),\n    new Vector3(-1, 0, 0)\n];\nconst cameraUp = [\n    new Vector3(0, 1, 0),\n    new Vector3(0, 1, 0),\n    new Vector3(0, 0, 1),\n    new Vector3(0, 0, -1),\n    new Vector3(0, 1, 0),\n    new Vector3(0, 1, 0)\n];\n\n/**\n * Class tha generates a texture containing a linear gradient, to be used with [[SkyBackground]].\n *\n * The gradient is mapped onto a sphere, where `topColor` maps to the top of the upper hemisphere,\n * `bottomColor` to the bottom of the upper hemisphere, and `groundColor` fills the bottom\n *  hemisphere..\n */\nexport class SkyGradientTexture {\n    private m_width: number;\n    private m_faceCount: number;\n    private m_faces: DataTexture[];\n    private m_skybox?: CubeTexture;\n\n    // Used only in the planar case.\n    private m_farClipPlaneDividedVertically?: THREE.Line3;\n    private m_groundPlane?: THREE.Plane;\n    private m_bottomMidFarPoint?: THREE.Vector3;\n    private m_topMidFarPoint?: THREE.Vector3;\n    private m_horizonPosition?: THREE.Vector3;\n    private m_farClipPlaneCorners?: THREE.Vector3[];\n\n    /**\n     * Constructs a new `SkyGradientTexture`.\n     *\n     * @param sky Initial [[GradientSky]] configuration.\n     * @param m_projectionType [[MapView]]'s projection type.\n     * @param m_height Optional height parameter.\n     */\n    constructor(\n        sky: GradientSky,\n        private m_projectionType: ProjectionType,\n        private m_height: number = DEFAULT_TEXTURE_SIZE\n    ) {\n        const topColor = new Color(sky.topColor);\n        const bottomColor = new Color(sky.bottomColor);\n        const groundColor = new Color(sky.groundColor);\n\n        this.m_width = this.m_projectionType === ProjectionType.Planar ? 1.0 : this.m_height;\n        this.m_faceCount = this.m_projectionType === ProjectionType.Planar ? 1.0 : 6.0;\n        this.m_faces = [];\n        for (let i = 0; i < this.m_faceCount; ++i) {\n            const data = new Uint8Array(3 * this.m_width * this.m_height);\n            this.fillTextureData(data, i, topColor, bottomColor, groundColor, sky.monomialPower);\n\n            const texture = new DataTexture(data, this.m_width, this.m_height, RGBFormat);\n            texture.needsUpdate = true;\n            texture.unpackAlignment = 1;\n            this.m_faces.push(texture);\n        }\n\n        if (this.m_projectionType === ProjectionType.Spherical) {\n            this.m_skybox = new CubeTexture(this.m_faces);\n            this.m_skybox.needsUpdate = true;\n        } else {\n            this.m_farClipPlaneDividedVertically = new Line3();\n            this.m_groundPlane = new Plane(new Vector3(0, 0, 1));\n            this.m_bottomMidFarPoint = new Vector3();\n            this.m_topMidFarPoint = new Vector3();\n            this.m_horizonPosition = new Vector3();\n            this.m_farClipPlaneCorners = [\n                new Vector3(),\n                new Vector3(),\n                new Vector3(),\n                new Vector3()\n            ];\n        }\n    }\n\n    /**\n     * Disposes allocated resources.\n     */\n    dispose() {\n        for (let i = 0; i < this.m_faceCount; ++i) {\n            this.m_faces[i].dispose();\n        }\n        if (this.m_projectionType === ProjectionType.Spherical) {\n            this.m_skybox!.dispose();\n        }\n    }\n\n    /**\n     * `SkyGradientTexture`'s texture resource (simple texture or cubemap depending on\n     * [[MapView]]'s projection).\n     */\n    get texture(): Texture {\n        return this.m_projectionType === ProjectionType.Planar ? this.m_faces[0] : this.m_skybox!;\n    }\n\n    /**\n     * This method updates the position of the texture depending on the camera frustum.\n     *\n     * @param camera The camera used in the map view.\n     */\n    update(camera: THREE.Camera) {\n        if (this.m_projectionType === ProjectionType.Planar) {\n            this.setHorizonPosition(camera);\n            this.updateTexturePosition();\n        }\n    }\n\n    /**\n     * Updates the `SkyGradientTexture` with new parameters.\n     *\n     * @param params New [[GradientSky]] configuration.\n     */\n    updateTexture(sky: GradientSky) {\n        for (let i = 0; i < this.m_faceCount; ++i) {\n            this.fillTextureData(\n                this.m_faces[i].image.data,\n                i,\n                new Color(sky.topColor),\n                new Color(sky.bottomColor),\n                new Color(sky.groundColor),\n                sky.monomialPower\n            );\n            this.m_faces[i].needsUpdate = true;\n        }\n        if (this.m_projectionType === ProjectionType.Spherical) {\n            this.m_skybox!.needsUpdate = true;\n        }\n    }\n\n    // When creating the texture, a Uint8Array is required, because the resulting texture passed\n    // to the scene as a background, is a texImage2D object, that does not accept UintClampedArray\n    // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D\n    // But, when updating the texture, a Uint8ClampedArray is passed as argument, because\n    // this.m_texture.image.data returns a Uint8ClampedArray. That's why this method accepts both.\n    private fillTextureData(\n        data: Uint8ClampedArray | Uint8Array,\n        faceIdx: number,\n        topColor: Color,\n        bottomColor: Color,\n        groundColor: Color,\n        monomialPower?: number\n    ) {\n        const color = new Color();\n        const dir = new Vector3();\n        const right = new Vector3();\n        const up = new Vector3();\n\n        const upDir = new Vector3(0, 0, 1);\n        for (let i = 0; i < this.m_height; ++i) {\n            for (let j = 0; j < this.m_width; ++j) {\n                if (this.m_projectionType === ProjectionType.Spherical) {\n                    const offsetX = right\n                        .copy(cameraRight[faceIdx])\n                        .multiplyScalar(((j + 0.5) / this.m_width) * 2.0 - 1.0);\n                    const offsetY = up\n                        .copy(cameraUp[faceIdx])\n                        .multiplyScalar(((i + 0.5) / this.m_height) * 2.0 - 1.0);\n                    dir.copy(cameraDir[faceIdx])\n                        .add(offsetX)\n                        .add(offsetY)\n                        .normalize();\n                    const t = Math.max(upDir.dot(dir), 0);\n\n                    color\n                        .copy(groundColor)\n                        .lerp(bottomColor, Math.min(t * 100, 1))\n                        .lerp(topColor, t ** getOptionValue(monomialPower, DEFAULT_MONOMIAL_POWER))\n                        .multiplyScalar(255);\n                } else {\n                    const t = i / this.m_height;\n                    if (i === 0) {\n                        color.copy(groundColor).multiplyScalar(255);\n                    } else {\n                        color\n                            .copy(bottomColor)\n                            .lerp(\n                                topColor,\n                                t ** getOptionValue(monomialPower, DEFAULT_MONOMIAL_POWER)\n                            )\n                            .multiplyScalar(255);\n                    }\n                }\n\n                data[i * this.m_width * 3 + j * 3] = color.r;\n                data[i * this.m_width * 3 + j * 3 + 1] = color.g;\n                data[i * this.m_width * 3 + j * 3 + 2] = color.b;\n            }\n        }\n    }\n\n    private setHorizonPosition(camera: THREE.Camera) {\n        this.m_farClipPlaneCorners![0].set(-1, -1, 1).unproject(camera);\n        this.m_farClipPlaneCorners![1].set(1, -1, 1).unproject(camera);\n        this.m_farClipPlaneCorners![2].set(-1, 1, 1).unproject(camera);\n        this.m_farClipPlaneCorners![3].set(1, 1, 1).unproject(camera);\n\n        this.m_bottomMidFarPoint!.copy(this.m_farClipPlaneCorners![0])\n            .add(this.m_farClipPlaneCorners![1])\n            .multiplyScalar(0.5);\n        this.m_topMidFarPoint!.copy(this.m_farClipPlaneCorners![2])\n            .add(this.m_farClipPlaneCorners![3])\n            .multiplyScalar(0.5);\n        this.m_farClipPlaneDividedVertically!.set(this.m_bottomMidFarPoint, this.m_topMidFarPoint);\n\n        const hasIntersection = this.m_groundPlane!.intersectLine(\n            this.m_farClipPlaneDividedVertically!,\n            this.m_horizonPosition!\n        );\n\n        // When there is no intersection between the ground plane and the\n        // farClipPlaneDividedVertically, be sure that the horizon is reset. Otherwise a previous\n        // intersection point stored in the m_horizonPosition will be considered the valid one.\n        if (!hasIntersection) {\n            this.m_horizonPosition!.set(0.0, 0.0, 0.0);\n        }\n    }\n\n    private updateTexturePosition() {\n        const coveredBySky = this.m_bottomMidFarPoint!.distanceTo(this.m_horizonPosition!);\n        const frustumHeight = this.m_farClipPlaneDividedVertically!.distance();\n        const skyRatio = coveredBySky / frustumHeight;\n\n        // If there is no intersection between the ground plane and the line that defines the far\n        // clip plane divided vertically, it means that there is no sky visible and therefore the\n        // ground color should be displayed. When there is no intersection, the length of the\n        // this.m_horizonPosition is still equal to zero, as threejs initialize an empty vector with\n        // all the three components to zero.\n        // If there is an intersection, calculate the offset.\n        const ratio = this.m_horizonPosition!.length() === 0 ? 1 : skyRatio - 2 / this.m_height;\n\n        // If the bottom part of the far clipping plane is under the ground plane, scroll the\n        // texture down. Otherwise, the camera is looking at the sky, therefore, scroll the texture\n        // up.\n        this.m_faces[0].offset.set(0, this.m_bottomMidFarPoint!.z <= 0 ? -ratio : skyRatio);\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Theme } from \"@here/harp-datasource-protocol\";\nimport { FontCatalog } from \"@here/harp-text-canvas\";\nimport { assert, LoggerManager } from \"@here/harp-utils\";\n\nexport const DEFAULT_FONT_CATALOG_NAME = \"default\";\n\nconst logger = LoggerManager.instance.create(\"FontCatalogLoader\");\n\ntype FontCatalogCallback = (name: string, catalog: FontCatalog) => void;\n\nexport class FontCatalogLoader {\n    private m_catalogsLoading: number = 0;\n\n    constructor(private readonly m_theme: Theme) {}\n\n    /**\n     * Initializes font catalog loader.\n     * @param defaultFontCatalogUrl Url of the font catalog that will be used by default if the\n     * theme doesn't define any font catalog.\n     * @returns Name of the default font catalog.\n     */\n    initialize(defaultFontCatalogUrl: string): string {\n        if (this.m_theme.fontCatalogs === undefined || this.m_theme.fontCatalogs.length === 0) {\n            this.m_theme.fontCatalogs = [\n                {\n                    name: DEFAULT_FONT_CATALOG_NAME,\n                    url: defaultFontCatalogUrl\n                }\n            ];\n            return DEFAULT_FONT_CATALOG_NAME;\n        }\n\n        const defaultFontCatalogName = this.m_theme.fontCatalogs[0].name;\n        return defaultFontCatalogName;\n    }\n\n    async loadCatalogs(catalogCallback: FontCatalogCallback): Promise<void[]> {\n        assert(this.m_theme.fontCatalogs !== undefined);\n        assert(this.m_theme.fontCatalogs!.length > 0);\n\n        const promises: Array<Promise<void>> = [];\n\n        this.m_theme.fontCatalogs!.forEach(fontCatalogConfig => {\n            this.m_catalogsLoading += 1;\n            const fontCatalogPromise: Promise<void> = FontCatalog.load(fontCatalogConfig.url, 1024)\n                .then<void>(catalogCallback.bind(undefined, fontCatalogConfig.name))\n                .catch((error: Error) => {\n                    logger.error(\"Failed to load FontCatalog: \", error);\n                })\n                .finally(() => {\n                    this.m_catalogsLoading -= 1;\n                });\n            promises.push(fontCatalogPromise);\n        });\n\n        return Promise.all(promises);\n    }\n\n    get loading(): boolean {\n        return this.m_catalogsLoading > 0;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeometryKindSet } from \"@here/harp-datasource-protocol\";\nimport { MapView } from \"../MapView\";\nimport { ViewState } from \"./ViewState\";\n\n/**\n * View state obtained from a MapView instance.\n */\nexport class MapViewState implements ViewState {\n    constructor(\n        private readonly m_mapView: MapView,\n        private readonly m_renderedTilesChangeCheck: () => boolean\n    ) {}\n\n    get worldCenter(): THREE.Vector3 {\n        return this.m_mapView.worldCenter;\n    }\n    get cameraIsMoving(): boolean {\n        return this.m_mapView.cameraIsMoving;\n    }\n    get maxVisibilityDist(): number {\n        return this.m_mapView.viewRanges.maximum;\n    }\n    get zoomLevel(): number {\n        return this.m_mapView.zoomLevel;\n    }\n    get frameNumber(): number {\n        return this.m_mapView.frameNumber;\n    }\n    get lookAtDistance(): number {\n        return this.m_mapView.lookAtDistance;\n    }\n    get isDynamic(): boolean {\n        return this.m_mapView.isDynamicFrame;\n    }\n    get hiddenGeometryKinds(): GeometryKindSet | undefined {\n        return this.m_mapView.tileGeometryManager === undefined\n            ? undefined\n            : this.m_mapView.tileGeometryManager.hiddenGeometryKinds;\n    }\n\n    get renderedTilesChanged(): boolean {\n        return this.m_renderedTilesChangeCheck();\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { FontCatalog, TextCanvas } from \"@here/harp-text-canvas\";\nimport { assert } from \"@here/harp-utils\";\n\nexport class TextCanvasFactory {\n    private m_minGlyphCount: number = 0; //Min amount of glyphs each [[TextCanvas]] layer can store.\n    private m_maxGlyphCount: number = 0; //Max amount of glyphs each [[TextCanvas]] layer can store.\n\n    /**\n     * Creates an instance of text canvas factory.\n     * @param m_renderer\n     */\n    constructor(private readonly m_renderer: THREE.WebGLRenderer) {}\n\n    setGlyphCountLimits(min: number, max: number) {\n        this.m_minGlyphCount = min;\n        this.m_maxGlyphCount = max;\n    }\n\n    /**\n     * Creates text canvas\n     * @param fontCatalog Initial [[FontCatalog]].\n     */\n    createTextCanvas(fontCatalog: FontCatalog): TextCanvas {\n        assert(this.m_maxGlyphCount > 0);\n\n        return new TextCanvas({\n            renderer: this.m_renderer,\n            fontCatalog,\n            minGlyphCount: this.m_minGlyphCount,\n            maxGlyphCount: this.m_maxGlyphCount\n        });\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { getOptionValue } from \"@here/harp-utils\";\nimport { MapView, MapViewEventNames } from \"../MapView\";\nimport { CopyrightInfo } from \"./CopyrightInfo\";\n\n/**\n * Helper class that maintains up-to-date [[MapView]] copyright information in DOM element.\n *\n * @example\n *\n *     // HTML snippet\n *     <div id=\"copyrightNotice\" style=\"position:absolute; right:0; bottom:0; z-index:100\"></div>\n *\n *     // JavaScript\n *     const mapView = new MapView({ ... });\n *     CopyrightElementHandler.install(\"copyrightNotice\", mapView);\n */\nexport class CopyrightElementHandler {\n    /**\n     * Install [[CopyrightElementHandler]] on DOM element and - optionally - attach to a [[MapView]]\n     * instance.\n     *\n     * @param element HTML DOM element or a HTML DOM element id\n     * @param mapView, optional, [[attach]] to this [[MapView]]\n     */\n    static install(element: string | HTMLElement, mapView?: MapView): CopyrightElementHandler {\n        return new CopyrightElementHandler(element, mapView);\n    }\n\n    /**\n     * Static copyright info.\n     *\n     * Use when [[MapView]]'s [[DataSource]]'s do not provide proper copyright information.\n     */\n    staticInfo: CopyrightInfo[] | undefined;\n\n    private m_defaults: Map<string, CopyrightInfo> = new Map();\n    private m_element: HTMLElement;\n    private m_mapViews: MapView[] = [];\n\n    /**\n     * Creates a new `CopyrightElementHandler` that updates the DOM element with the copyright info\n     * of the given `mapView`.\n     *\n     * Note: Generally, the static [[install]] method can be used to create and attach a new\n     * `CopyrightElementHandler` to a [[MapView]]\n     *\n     * @param element HTML DOM element or a HTML DOM element id\n     * @param mapView optional, [[attach]] to this [[MapView]] instance\n     */\n    constructor(element: string | HTMLElement, mapView?: MapView) {\n        if (typeof element === \"string\") {\n            const htmlElement = document.getElementById(element);\n            if (!htmlElement) {\n                throw new Error(`CopyrightElementHandler: unable to find DOM element #${element}`);\n            }\n            this.m_element = htmlElement;\n        } else {\n            this.m_element = element;\n        }\n\n        if (mapView !== undefined) {\n            this.attach(mapView);\n        }\n    }\n\n    /**\n     * Destroys this object by removing all event listeners from the attached [[MapView]]s.\n     */\n    destroy() {\n        for (const mapView of this.m_mapViews) {\n            mapView.removeEventListener(MapViewEventNames.CopyrightChanged, this.update);\n        }\n    }\n\n    /**\n     * Attaches this [[CopyrightInfo]] updates from [[MapView]] instance.\n     */\n    attach(mapView: MapView): this {\n        this.m_mapViews.push(mapView);\n\n        mapView.addEventListener(MapViewEventNames.CopyrightChanged, this.update);\n        this.update();\n\n        return this;\n    }\n\n    /**\n     * Stop following [[CopyrightInfo]] updates from [[MapView]] instance.\n     */\n    detach(mapView: MapView): this {\n        mapView.removeEventListener(MapViewEventNames.CopyrightChanged, this.update);\n\n        this.m_mapViews = this.m_mapViews.filter(item => item !== mapView);\n        this.update();\n\n        return this;\n    }\n\n    /**\n     * Set [[CopyrightInfo]] defaults to be used in case [[DataSource]] does not provide deatailed\n     * copyright information.\n     *\n     * The defaults will applied to all undefined `year`, `label` and `link` values in the copyright\n     * information retrieved from [[MapView]].\n     */\n    setDefaults(defaults: CopyrightInfo[] | undefined): this {\n        this.m_defaults.clear();\n        if (defaults !== undefined) {\n            for (const item of defaults) {\n                this.m_defaults.set(item.id, item);\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Sets the [[staticInfo]] property.\n     *\n     * A `CopyrightElementHandler` always displays a deduplicated sum of static copyright info and\n     * copyright information obtained from attached [[MapView]]s.\n     *\n     * This information is used when [[DataSource]] instances of given [[MapView]] do not provide\n     * copyright information.\n     */\n    setStaticCopyightInfo(staticInfo: CopyrightInfo[] | undefined): this {\n        this.staticInfo = staticInfo;\n        return this;\n    }\n\n    /**\n     * Update copyright info text in controlled HTML element.\n     */\n    update = () => {\n        const mergedCopyrightInfo = this.m_mapViews\n            .map(mapView => mapView.copyrightInfo)\n            .reduce(CopyrightInfo.mergeArrays, this.staticInfo || []);\n\n        // Conditionally hiding of element with copyright information.\n        // If nothing to show we schould to avoid empty white rectangle in right bottom corner.\n        if (mergedCopyrightInfo.length === 0) {\n            this.m_element.style.display = \"none\";\n            return;\n        } else {\n            this.m_element.style.display = \"block\";\n        }\n\n        if (this.m_defaults.size !== 0) {\n            for (const sourceInfo of mergedCopyrightInfo) {\n                const defaults = this.m_defaults.get(sourceInfo.id);\n                if (defaults !== undefined) {\n                    sourceInfo.year = getOptionValue(sourceInfo.year, defaults.year);\n                    sourceInfo.label = getOptionValue(sourceInfo.label, defaults.label);\n                    sourceInfo.link = getOptionValue(sourceInfo.link, defaults.link);\n                }\n            }\n        }\n        const deduped = CopyrightInfo.mergeArrays(mergedCopyrightInfo);\n\n        this.m_element.innerHTML = CopyrightInfo.formatAsHtml(deduped);\n    };\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { TransferManager } from \"@here/harp-transfer-manager\";\nimport {\n    AreaCopyrightInfo,\n    CopyrightCoverageProvider,\n    CopyrightCoverageResponse\n} from \"./CopyrightCoverageProvider\";\n\n/**\n * Copyright provider which retrieves copyright coverage information from provided URL.\n */\nexport class UrlCopyrightProvider extends CopyrightCoverageProvider {\n    private m_cachedCopyrightResponse: Promise<AreaCopyrightInfo[]> | undefined;\n\n    /**\n     * Default constructor.\n     *\n     * @param m_fetchURL URL to fetch copyrights data from.\n     * @param m_baseScheme Scheme to get copyrights from.\n     */\n    constructor(private m_fetchURL: string, private m_baseScheme: string) {\n        super();\n    }\n\n    /** @inheritdoc */\n    getCopyrightCoverageData(): Promise<AreaCopyrightInfo[]> {\n        if (this.m_cachedCopyrightResponse !== undefined) {\n            return this.m_cachedCopyrightResponse;\n        }\n\n        this.m_cachedCopyrightResponse = new TransferManager()\n            .downloadJson<CopyrightCoverageResponse>(this.m_fetchURL)\n            .then(json => json[this.m_baseScheme])\n            .catch(error => {\n                this.logger.error(error);\n                return [];\n            });\n\n        return this.m_cachedCopyrightResponse;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/** @module\n *\n * This module provides classes to ease downloading URLs. In particular, following redirects,\n * retrying on HTTP errors, and limiting the number of parallel concurrent downloads.\n */\n\nimport \"@here/harp-fetch\";\n\n/** @internal\n * DeferredPromise takes an executor function for executing it later, when [[exec]] is called.\n * This class allows wrapping other promises or long running functions for later execution.\n */\nclass DeferredPromise<T> {\n    /**\n     * Internal promise to store the deferred executor function.\n     */\n    readonly promise: Promise<T>;\n    private doExec = false;\n    private resolveFunc?: (result?: T) => void;\n    private rejectFunc?: (reason?: any) => void;\n\n    constructor(private readonly executor: () => Promise<T>) {\n        this.promise = new Promise<T>((resolve, reject) => {\n            this.resolveFunc = resolve;\n            this.rejectFunc = reject;\n\n            if (this.doExec) {\n                this.execInnerPromise(this.resolveFunc, this.rejectFunc);\n            }\n        });\n    }\n\n    /**\n     * When `exec` is called the deferred executor function is executed.\n     */\n    exec() {\n        if (this.resolveFunc === undefined || this.rejectFunc === undefined) {\n            // deferred promise not yet initialized - handle it in callback above\n            this.doExec = true;\n            return;\n        }\n\n        this.execInnerPromise(this.resolveFunc, this.rejectFunc);\n    }\n\n    private execInnerPromise(\n        resolveFunc: (result?: T) => void,\n        rejectFunc: (reason?: any) => void\n    ) {\n        this.executor()\n            .then(result => resolveFunc(result))\n            .catch(err => rejectFunc(err));\n    }\n}\n\n/**\n * `TransferManager` for downloading URLs.\n *\n * Features:\n *\n * * Merges JSON downloads, for example, the same URL if requested as JSON will only be downloaded\n *   once.\n * * Limits the amount of parallel downloads, useful when requesting a large amount of URLs that\n *   would otherwise stall the browser.\n * * Retries the downloads with an increasing timeout on HTTP 503 replies.\n *\n * The static method [[instance]] can be used to get a default constructed instance.\n */\nexport class TransferManager {\n    /**\n     * The timeout in milliseconds to wait between retries. This timeout is multiplied with the\n     * number of retries. First retry waits for 0 ms, second retry for 500 ms, third for 1000 ms and\n     * so on.\n     */\n    static readonly retryTimeout = 500;\n    /**\n     * The amount of maximum parallel downloads to allow.\n     */\n    static readonly maxParallelDownloads = 16;\n    /**\n     * Returns a default instance of [[TransferManager]].\n     */\n    static instance(): TransferManager {\n        return TransferManager.defaultInstance;\n    }\n    private static readonly defaultInstance = new TransferManager();\n    private static async fetchRepeatedly(\n        fetchFunction: typeof fetch,\n        retryCount: number,\n        maxRetries: number,\n        url: string,\n        init?: RequestInit\n    ): Promise<Response> {\n        try {\n            const response = await fetchFunction(url, init);\n            if (response.status !== 503 || retryCount > maxRetries) {\n                return response;\n            }\n        } catch (err) {\n            if (\n                err.hasOwnProperty(\"isCancelled\") ||\n                (err.hasOwnProperty(\"name\") && err.name === \"AbortError\") ||\n                retryCount > maxRetries\n            ) {\n                throw err;\n            }\n        }\n        return TransferManager.waitFor(TransferManager.retryTimeout * retryCount).then(() =>\n            TransferManager.fetchRepeatedly(fetchFunction, maxRetries, retryCount + 1, url, init)\n        );\n    }\n    private static waitFor(milliseconds: number): Promise<void> {\n        return new Promise<void>(resolve => setTimeout(resolve, milliseconds));\n    }\n    private activeDownloadCount = 0;\n    private downloadQueue = new Array<DeferredPromise<Response>>();\n    private activeDownloads = new Map<string, Promise<any>>();\n    /**\n     * Constructs a new [[TransferManager]].\n     *\n     * @param fetchFunction The default fetch function to use.\n     * @param maxRetries The maximum amount to try to re-fetch a resource.\n     */\n    constructor(readonly fetchFunction = fetch, readonly maxRetries: number = 5) {}\n    /**\n     * Downloads a JSON object. Merges downloads if requested multiple times.\n     *\n     * Note: This method merges multiple downloads of the same resource to\n     * only one request. The init parameter is ignored if the download is merged.\n     * Call [[download]] instead to download the resource without merging.\n     *\n     * @param url The URL to download\n     * @param init Optional extra parameters for the download.\n     */\n    downloadJson<T>(url: string, init?: RequestInit): Promise<T> {\n        return this.downloadAs<T>(response => response.json(), url, init);\n    }\n    /**\n     * Downloads a binary object. Merges downloads if requested multiple times.\n     *\n     * Note: This method merges multiple downloads of the same resource to\n     * only one request. The init parameter is ignored if the download is merged.\n     * Call [[download]] instead to download the resource without merging.\n     *\n     * @param url The URL to download\n     * @param init Optional extra parameters for the download\n     */\n    downloadArrayBuffer(url: string, init?: RequestInit): Promise<ArrayBuffer> {\n        return this.download(url, init).then(response => response.arrayBuffer());\n    }\n    /**\n     * Downloads a URL and returns the response.\n     *\n     * Does not merge multiple requests to the same URL.\n     *\n     * @param url The URL to download.\n     * @param init Optional extra parameters for the download.\n     */\n    download(url: string, init?: RequestInit): Promise<Response> {\n        if (this.activeDownloadCount >= TransferManager.maxParallelDownloads) {\n            const deferred = new DeferredPromise<Response>(() => this.doDownload(url, init));\n            this.downloadQueue.push(deferred);\n            return deferred.promise;\n        }\n        return this.doDownload(url, init);\n    }\n    private doDownload(url: string, init?: RequestInit): Promise<Response> {\n        ++this.activeDownloadCount;\n        return TransferManager.fetchRepeatedly(this.fetchFunction, 0, this.maxRetries, url, init)\n            .then(response => {\n                this.onDownloadDone();\n                return response;\n            })\n            .catch(err => {\n                this.onDownloadDone();\n                throw err;\n            });\n    }\n    private onDownloadDone() {\n        --this.activeDownloadCount;\n        this.execDeferredDownload();\n    }\n    private execDeferredDownload() {\n        const future = this.downloadQueue.pop();\n        if (future === undefined) {\n            return;\n        }\n        future.exec();\n    }\n    private downloadAs<T>(\n        converter: (response: Response) => Promise<T>,\n        url: string,\n        init?: RequestInit\n    ): Promise<T> {\n        const cacheKey = url;\n        const pendingFetch = this.activeDownloads.get(cacheKey);\n        if (pendingFetch !== undefined) {\n            return Promise.resolve(pendingFetch);\n        }\n        const newFetch = this.download(url, init)\n            .then(response => {\n                this.activeDownloads.delete(cacheKey);\n                if (response.ok) {\n                    return converter(response);\n                }\n                throw new Error(JSON.stringify(response));\n            })\n            .catch(err => {\n                this.activeDownloads.delete(cacheKey);\n                throw err;\n            });\n        this.activeDownloads.set(cacheKey, newFetch);\n        return newFetch;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * `ImageItem` is used to identify an image in the [[ImageCache]].\n */\nexport interface ImageItem {\n    /** URL of the image, or unique identifier. */\n    url: string;\n    /** Pixel data. */\n    imageData?: ImageData | ImageBitmap;\n    /** Turns to `true` when the data has finished loading. */\n    loaded: boolean;\n    /** `loadingPromise` is only used during loading/generating the image. */\n    loadingPromise?: Promise<ImageItem | undefined>;\n}\n\nexport namespace ImageItem {\n    /**\n     * Missing Typedoc\n     */\n    export function isLoading(imageItem: ImageItem): boolean {\n        return imageItem.loadingPromise !== undefined;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { GeometryType, getFeatureId } from \"@here/harp-datasource-protocol\";\nimport { assert, LoggerManager } from \"@here/harp-utils\";\nimport { Tile, TileFeatureData } from \"../Tile\";\nimport {\n    BufferedGeometryLineAccessor,\n    BufferedGeometryObject3dAccessor,\n    IGeometryAccessor,\n    ILineAccessor,\n    IndexedBufferedGeometryLineAccessor,\n    IObject3dAccessor,\n    isLineAccessor,\n    isObject3dAccessor\n} from \"./TileGeometry\";\n\nconst logger = LoggerManager.instance.create(\"TileDataAccessor\");\n\n/**\n * Interface for a client visitor that is used to visit all `THREE.Object`s in a tile.\n */\nexport interface ITileDataVisitor {\n    tile: Tile;\n\n    /**\n     * Should return `true` if the visitor wants to visit the object with the specified\n     * `featureId`. This function is called before the type of the object is even known.\n     */\n    wantsFeature(featureId: number | undefined): boolean;\n\n    /**\n     * Should return `true` if the visitor wants to visit the point with the specified\n     * `featureId`.\n     */\n    wantsPoint(featureId: number | undefined): boolean;\n\n    /**\n     * Should return `true` if the visitor wants to visit the line with the specified\n     * `featureId`.\n     */\n    wantsLine(featureId: number | undefined): boolean;\n\n    /**\n     * Should return `true` if the visitor wants to visit the area object with the specified\n     * `featureId`.\n     */\n    wantsArea(featureId: number | undefined): boolean;\n\n    /**\n     * Should return `true` if the visitor wants to visit the object with the specified\n     * `featureId`.\n     */\n    wantsObject3D(featureId: number | undefined): boolean;\n\n    /**\n     * Visits a point object with the specified `featureId`; use `pointAccessor` to get the\n     * object's properties.\n     */\n    visitPoint(featureId: number | undefined): void;\n\n    /**\n     * Visits a line object with the specified `featureId`; use `pointAccessor` to get the\n     * object's properties.\n     */\n    visitLine(featureId: number | undefined, lineAccessor: ILineAccessor): void;\n\n    /**\n     * Visit an area object with the specified `featureId`; use `pointAccessor` to get the\n     * object's properties.\n     */\n    visitArea(featureId: number | undefined): void;\n\n    /**\n     * Visits a 3D object with the specified `featureId`; use `pointAccessor` to get the\n     * object's properties.\n     */\n    visitObject3D(featureId: number | undefined, object3dAccessor: IObject3dAccessor): void;\n}\n\n/**\n * An interface that provides options for [[TileDataAccessor]].\n */\nexport interface TileDataAccessorOptions {\n    /** Limit to objects that have `featureID`s. */\n    onlyWithFeatureIds?: boolean;\n    /** Sets and overrides `wantPoints`, `wantLines`, `wantAreas`, `wantObject3D`. */\n    wantsAll?: boolean;\n    /** `true` to visit points. */\n    wantsPoints?: boolean;\n    /** `true` to visit lines. */\n    wantsLines?: boolean;\n    /** `true` to visit area objects. */\n    wantsAreas?: boolean;\n    /** `true` to visit general 3D objects. */\n    wantsObject3D?: boolean;\n}\n\n/**\n * An accessor for all geometries in a tile. This class uses a client-provided [[ITileDataVisitor]]\n * to visit all objects, based on filtering options specified by both, the `TileDataAccessor` and\n * the visitor itself.\n */\nexport class TileDataAccessor {\n    private m_wantsPoints = true;\n    private m_wantsLines = true;\n    private m_wantsAreas = true;\n    private m_wantsObject3D = true;\n\n    /**\n     * Constructs a `TileDataAccessor` instance.\n     *\n     * @param tile The tile to access.\n     * @param visitor The visitor.\n     * @param options Options for the tile.\n     */\n    constructor(\n        public tile: Tile,\n        private visitor: ITileDataVisitor,\n        options: TileDataAccessorOptions\n    ) {\n        const wantsAll = options.wantsAll === true;\n        this.m_wantsPoints = wantsAll || !(options.wantsPoints === false);\n        this.m_wantsLines = wantsAll || !(options.wantsLines === false);\n        this.m_wantsAreas = wantsAll || !(options.wantsAreas === false);\n        this.m_wantsObject3D = wantsAll || !(options.wantsObject3D === false);\n    }\n\n    /**\n     * Calls the visitor on all objects in the tile.\n     */\n    visitAll(): void {\n        const objects = this.tile.objects;\n\n        for (const object of objects) {\n            this.visitObject(object);\n        }\n    }\n\n    /**\n     * Visits a single object. This function should normally be called during visiting.\n     *\n     * @param object The object to visit.\n     */\n    protected visitObject(object: THREE.Object3D): void {\n        const featureData: TileFeatureData | undefined =\n            object.userData !== undefined\n                ? (object.userData.feature as TileFeatureData)\n                : undefined;\n\n        // early opt out if there is no feature data, or if the feature data has only a single id\n        // and the visitor wants to ignore that featureId\n        if (\n            featureData === undefined ||\n            (featureData.objInfos !== undefined &&\n                featureData.objInfos.length === 1 &&\n                !this.visitor.wantsFeature(getFeatureId(featureData.objInfos[0])))\n        ) {\n            return;\n        }\n\n        const geometryType = featureData.geometryType;\n        if (geometryType === undefined) {\n            logger.warn(\"#visitObject: visiting object failed, no geometryType\", object);\n            return;\n        }\n\n        assert(featureData.objInfos !== undefined, \"featureData.ids missing\");\n        assert(featureData.starts !== undefined, \"featureData.starts missing\");\n        assert(Array.isArray(featureData.starts), \"featureData.starts is not an array\");\n        if (featureData.objInfos !== undefined && featureData.starts !== undefined) {\n            assert(\n                featureData.objInfos.length === featureData.starts.length,\n                \"featureData.ids and featureData.starts have unequal length\"\n            );\n        }\n\n        switch (geometryType) {\n            case GeometryType.Point:\n            case GeometryType.Text:\n                if (!this.m_wantsPoints) {\n                    return;\n                }\n                break;\n            case GeometryType.SolidLine:\n            case GeometryType.ExtrudedLine:\n            case GeometryType.TextPath:\n                if (!this.m_wantsLines) {\n                    return;\n                }\n                break;\n            case GeometryType.Polygon:\n            case GeometryType.ExtrudedPolygon:\n                if (!this.m_wantsAreas) {\n                    return;\n                }\n                break;\n            case GeometryType.Object3D:\n                if (!this.m_wantsObject3D) {\n                    return;\n                }\n                break;\n            default:\n                logger.warn(\"#visitObject: invalid geometryType\");\n        }\n\n        if (object.type !== \"Mesh\") {\n            logger.warn(\"#visitObject: visiting object failed, not of type 'Mesh'\", object);\n            return;\n        }\n\n        const mesh = object as THREE.Mesh;\n\n        this.visitMesh(mesh, featureData);\n    }\n\n    /**\n     * Gets the `BufferGeometry` from the specified object. This function requires the\n     * attribute `position` in `BufferGeometry` to be set.\n     *\n     * @param object The object from which to get the geometry.\n     * @returns the geometry of the object, or `undefined`.\n     */\n    protected getBufferGeometry(object: THREE.Mesh): THREE.BufferGeometry | undefined {\n        const geometry = object.geometry;\n\n        if (geometry.type !== \"BufferGeometry\") {\n            logger.warn(\"#visitObject: object does not have BufferGeometry\");\n            return undefined;\n        }\n\n        const bufferGeometry = geometry as THREE.BufferGeometry;\n\n        // we know its a BufferAttribute because it is a BufferGeometry\n        const position: THREE.BufferAttribute = bufferGeometry.getAttribute(\n            \"position\"\n        ) as THREE.BufferAttribute;\n\n        if (!position) {\n            logger.warn(\"#visitLines: BufferGeometry has no position attribute\");\n            return undefined;\n        }\n\n        return bufferGeometry;\n    }\n\n    /**\n     * Obtains an accessor for the nonindexed geometry. This function may return `undefined`\n     * if the accessor is not implemented.\n     *\n     * @param geometryType The type of geometry.\n     * @param object The object for which to access the attributes and geometry.\n     * @param bufferGeometry The object's `BufferGeometry`.\n     * @returns an accessor for a specified object, if available.\n     */\n    protected getGeometryAccessor(\n        geometryType: GeometryType,\n        object: THREE.Mesh,\n        bufferGeometry: THREE.BufferGeometry\n    ): IGeometryAccessor | undefined {\n        switch (geometryType) {\n            case GeometryType.Point:\n            case GeometryType.Text:\n                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);\n                return undefined;\n            case GeometryType.SolidLine:\n            case GeometryType.ExtrudedLine:\n            case GeometryType.TextPath:\n                return new BufferedGeometryLineAccessor(object, geometryType, bufferGeometry);\n            case GeometryType.Polygon:\n            case GeometryType.ExtrudedPolygon:\n                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);\n                return undefined;\n            case GeometryType.Object3D:\n                return new BufferedGeometryObject3dAccessor(object, geometryType, bufferGeometry);\n            default:\n                logger.warn(\"#getGeometryAccessor: invalid geometryType\");\n        }\n        return undefined;\n    }\n\n    /**\n     * Obtains an accessor for the indexed geometry. This function may return `undefined`\n     * if the accessor is not implemented.\n     *\n     * @param geometryType The type of geometry.\n     * @param object The object for which to access the attributes and geometry.\n     * @param bufferGeometry The object's `BufferGeometry`.\n     * @returns an accessor for a specified object, if available.\n     */\n    protected getIndexedGeometryAccessor(\n        geometryType: GeometryType,\n        object: THREE.Mesh,\n        bufferGeometry: THREE.BufferGeometry\n    ): IGeometryAccessor | undefined {\n        switch (geometryType) {\n            case GeometryType.Point:\n            case GeometryType.Text:\n                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);\n                return undefined;\n            case GeometryType.SolidLine:\n            case GeometryType.ExtrudedLine:\n            case GeometryType.TextPath:\n                return new IndexedBufferedGeometryLineAccessor(\n                    object,\n                    geometryType,\n                    bufferGeometry\n                );\n            case GeometryType.Polygon:\n            case GeometryType.ExtrudedPolygon:\n                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);\n                return undefined;\n            case GeometryType.Object3D:\n                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);\n                return undefined;\n            default:\n                logger.warn(\"#getIndexedGeometryAccessor: invalid geometryType\");\n        }\n        return undefined;\n    }\n\n    /**\n     * Visit the object.\n     *\n     * @param meshObject Object of type `Mesh`.\n     * @param featureData Dataset stored along with the object.\n     */\n    protected visitMesh(meshObject: THREE.Mesh, featureData: TileFeatureData): void {\n        const { objInfos, starts } = featureData;\n        const geometryType = featureData.geometryType;\n\n        // make linter happy: we already know that these both are valid\n        if (objInfos === undefined || starts === undefined || geometryType === undefined) {\n            return;\n        }\n\n        let geometryAccessor: IGeometryAccessor | undefined;\n\n        for (let featureIndex = 0; featureIndex < objInfos.length; featureIndex++) {\n            const featureId = getFeatureId(objInfos[featureIndex]);\n\n            if (!this.visitor.wantsFeature(featureId)) {\n                continue;\n            }\n\n            const featureStart = starts[featureIndex];\n            let featureEnd: number = -1;\n\n            // lazy creation of accessor, in case featureId was not wanted...\n            if (geometryAccessor === undefined) {\n                const bufferGeometry = this.getBufferGeometry(meshObject);\n                if (bufferGeometry === undefined) {\n                    continue;\n                }\n\n                if (bufferGeometry.index !== null) {\n                    geometryAccessor = this.getIndexedGeometryAccessor(\n                        geometryType,\n                        meshObject,\n                        bufferGeometry\n                    );\n                } else {\n                    geometryAccessor = this.getGeometryAccessor(\n                        geometryType,\n                        meshObject,\n                        bufferGeometry\n                    );\n                }\n\n                if (geometryAccessor === undefined) {\n                    logger.warn(\"#visitObject: no accessor geometryType\", geometryType);\n                    continue;\n                }\n            }\n\n            featureEnd =\n                featureIndex < starts.length - 1\n                    ? starts[featureIndex + 1]\n                    : geometryAccessor.getCount();\n\n            // setup/update the accessor for the new range of the object\n            geometryAccessor.setRange(featureStart, featureEnd);\n\n            switch (geometryType) {\n                case GeometryType.Point:\n                case GeometryType.Text:\n                    this.visitor.visitPoint(featureId);\n                    break;\n                case GeometryType.SolidLine:\n                case GeometryType.ExtrudedLine:\n                case GeometryType.TextPath:\n                    assert(isLineAccessor(geometryAccessor));\n                    this.visitor.visitLine(featureId, (geometryAccessor as any) as ILineAccessor);\n                    break;\n                case GeometryType.Polygon:\n                case GeometryType.ExtrudedPolygon:\n                    this.visitor.visitArea(featureId);\n                    break;\n                case GeometryType.Object3D:\n                    assert(isObject3dAccessor(geometryAccessor));\n                    this.visitor.visitObject3D(\n                        featureId,\n                        (geometryAccessor as any) as IObject3dAccessor\n                    );\n                    break;\n                default:\n                    logger.warn(\"#visitObject: invalid geometryType\");\n            }\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport * from \"./lib/Lines\";\nexport * from \"./lib/TriangulateLines\";\nexport * from \"./lib/HighPrecisionLines\";\nexport * from \"./lib/HighPrecisionUtils\";\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { assert } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\n// Preallocate temp variables used during line generation.\nconst tmpV = new THREE.Vector3();\nconst tmpNormal = new THREE.Vector3();\nconst tmpTangent0 = new THREE.Vector3();\nconst tmpTangent1 = new THREE.Vector3();\nconst tmpBitangent = new THREE.Vector3();\nconst SEGMENT_OFFSET = 0.1;\n\n/**\n * Describes vertex attribute parameters of interleaved buffer.\n */\ninterface VertexAttributeDescriptor {\n    name: string;\n    itemSize: number;\n    offset: number;\n}\n\ninterface VertexDescriptor {\n    attributes: VertexAttributeDescriptor[];\n    stride: number;\n}\n\n/**\n * Declares all the vertex attributes used for rendering a line using the [[SolidLineMaterial]].\n */\n\n/** Base line vertex attributes. */\nconst LINE_VERTEX_ATTRIBUTES: VertexDescriptor = {\n    attributes: [\n        // The \"extrusionCoord\" is a vec4 which represents:\n        // xy: Extrusion coordinates\n        // sign(xy): Extrusion direction\n        // z: Line length\n        { name: \"extrusionCoord\", itemSize: 3, offset: 0 },\n        { name: \"position\", itemSize: 3, offset: 3 },\n        { name: \"tangent\", itemSize: 3, offset: 6 },\n        { name: \"bitangent\", itemSize: 4, offset: 9 }\n    ],\n    stride: 13\n};\n\n/** Optional normal and uv coordinates. */\nconst NORMAL_UV_VERTEX_ATTRIBUTES: VertexDescriptor = {\n    attributes: [\n        { name: \"uv\", itemSize: 2, offset: LINE_VERTEX_ATTRIBUTES.stride },\n        { name: \"normal\", itemSize: 3, offset: LINE_VERTEX_ATTRIBUTES.stride + 2 }\n    ],\n    stride: 5\n};\n\n/** Base line vertex attributes plus normals and uv coordinates. */\nconst LINE_VERTEX_ATTRIBUTES_NUV: VertexDescriptor = {\n    attributes: [...LINE_VERTEX_ATTRIBUTES.attributes, ...NORMAL_UV_VERTEX_ATTRIBUTES.attributes],\n    stride: LINE_VERTEX_ATTRIBUTES.stride + NORMAL_UV_VERTEX_ATTRIBUTES.stride\n};\n\n/**\n * Declares all the vertex attributes used for rendering a line using the\n * [[HighPrecisionLineMaterial]].\n */\nconst HP_LINE_VERTEX_ATTRIBUTES: VertexDescriptor = {\n    attributes: [\n        { name: \"extrusionCoord\", itemSize: 2, offset: 0 },\n        { name: \"position\", itemSize: 3, offset: 2 },\n        { name: \"positionLow\", itemSize: 3, offset: 5 },\n        { name: \"tangent\", itemSize: 3, offset: 8 },\n        { name: \"bitangent\", itemSize: 4, offset: 11 }\n    ],\n    stride: 15\n};\n\n/** High precision line vertex attributes plus normals and uv coordinates. */\nconst HP_LINE_VERTEX_ATTRIBUTES_NUV: VertexDescriptor = {\n    attributes: [\n        ...HP_LINE_VERTEX_ATTRIBUTES.attributes,\n        ...NORMAL_UV_VERTEX_ATTRIBUTES.attributes\n    ],\n    stride: HP_LINE_VERTEX_ATTRIBUTES.stride + NORMAL_UV_VERTEX_ATTRIBUTES.stride\n};\n\n/**\n * Class that holds the vertex and index attributes for a [[Lines]] object.\n */\nexport class LineGeometry {\n    vertices: number[] = [];\n    vertexColors: number[] = [];\n    indices: number[] = [];\n}\n\nfunction getVertexDescriptor(hasNormalsAndUvs: boolean, highPrecision: boolean): VertexDescriptor {\n    if (highPrecision) {\n        return hasNormalsAndUvs ? HP_LINE_VERTEX_ATTRIBUTES_NUV : HP_LINE_VERTEX_ATTRIBUTES;\n    } else {\n        return hasNormalsAndUvs ? LINE_VERTEX_ATTRIBUTES_NUV : LINE_VERTEX_ATTRIBUTES;\n    }\n}\n\n/**\n * Creates a [[LineGeometry]] object out of a polyline.\n *\n * @param center Center of the polyline.\n * @param polyline Array of `numbers` describing a polyline.\n * @param offsets Array of `numbers` representing line segment offsets.\n * @param uvs Array of `numbers` representing texture coordinates.\n * @param colors Array of `numbers` describing a polyline's colors.\n * @param geometry [[LineGeometry]] object used to store the vertex and index attributes.\n * @param highPrecision If `true` will create high-precision vertex information.\n */\nexport function createLineGeometry(\n    center: THREE.Vector3,\n    polyline: ArrayLike<number>,\n    offsets?: ArrayLike<number>,\n    uvs?: ArrayLike<number>,\n    colors?: ArrayLike<number>,\n    geometry = new LineGeometry(),\n    highPrecision: boolean = false\n): LineGeometry {\n    if (polyline.length === 0) {\n        return geometry;\n    }\n\n    const stride = getVertexDescriptor(uvs !== undefined, highPrecision).stride;\n\n    const pointCount = polyline.length / 3;\n    const segments = new Array<number>(pointCount);\n    const tangents = new Array<number>(polyline.length - 3);\n    const baseVertex = geometry.vertices.length / stride;\n\n    const hasSegmentOffsets = offsets !== undefined && offsets.length > 0;\n    const hasTexCoords = uvs !== undefined && uvs.length > 0;\n    const vertexColors = colors !== undefined && colors.length && polyline.length;\n\n    assert(!hasSegmentOffsets || offsets!.length === pointCount);\n    assert(!hasTexCoords || uvs!.length / 2 === pointCount);\n    assert(!vertexColors || colors!.length === polyline.length);\n\n    // Compute segments and tangents.\n    let sum = SEGMENT_OFFSET;\n    segments[0] = sum;\n    let isFlat = true;\n    for (let i = 0; i < pointCount - 1; ++i) {\n        let sqrLength = 0;\n        for (let j = 0; j < 3; ++j) {\n            const d = polyline[(i + 1) * 3 + j] - polyline[i * 3 + j];\n            tangents[i * 3 + j] = d;\n            sqrLength += d * d;\n            isFlat = j === 2 ? isFlat && polyline[(i + 1) * 3 + j] === 0.0 : isFlat;\n        }\n        const len = Math.sqrt(sqrLength);\n        sum = sum + len;\n        segments[i + 1] = sum;\n    }\n\n    const lineCoverage = hasSegmentOffsets\n        ? Math.abs(offsets![offsets!.length - 1] - offsets![0])\n        : 1.0;\n    const lineLength = segments[segments.length - 1] / lineCoverage;\n\n    // Override the segments if offsets are explicitly provided.\n    if (hasSegmentOffsets) {\n        for (let i = 0; i < pointCount; ++i) {\n            segments[i] = offsets![i] * lineLength + SEGMENT_OFFSET;\n        }\n    }\n\n    // Check if we're working with a closed line.\n    let isClosed = true;\n    for (let j = 0; j < 3; ++j) {\n        isClosed = isClosed && polyline[j] === polyline[polyline.length - 3 + j];\n    }\n\n    const tmpVertices: number[] = [];\n\n    const addVertexPair = (\n        i: number,\n        T1: number,\n        T2: number,\n        segment: number,\n        extrusionCoord: number\n    ) => {\n        tmpVertices.length = 0;\n\n        // Store the segment and extrusionCoord attributes.\n        geometry.vertices.push(segment, extrusionCoord * -1, lineLength);\n        tmpVertices.push(segment, extrusionCoord * 1, lineLength);\n\n        // Store the position attribute (component-dependant).\n        for (let j = 0; j < 3; ++j) {\n            if (!highPrecision) {\n                geometry.vertices.push(polyline[i * 3 + j]);\n                tmpVertices.push(polyline[i * 3 + j]);\n            } else {\n                const highComp = Math.fround(polyline[i * 3 + j]);\n                const lowComp = polyline[i * 3 + j] - highComp;\n                geometry.vertices.push(highComp, lowComp);\n                tmpVertices.push(highComp, lowComp);\n            }\n            tmpNormal.setComponent(j, polyline[i * 3 + j]);\n        }\n\n        // Store the bitangent attribute (component-dependant).\n        for (let j = 0; j < 3; ++j) {\n            tmpTangent0.setComponent(j, tangents[T1 + j]);\n            tmpTangent1.setComponent(j, tangents[T2 + j]);\n        }\n        tmpTangent0.normalize();\n        geometry.vertices.push(tmpTangent0.x, tmpTangent0.y, tmpTangent0.z);\n        tmpVertices.push(tmpTangent0.x, tmpTangent0.y, tmpTangent0.z);\n        const angle = computeBitangent(\n            isFlat ? tmpNormal.set(0, 0, 1) : tmpNormal.add(center).normalize(),\n            tmpTangent0,\n            tmpTangent1.normalize(),\n            tmpBitangent\n        );\n        geometry.vertices.push(tmpBitangent.x, tmpBitangent.y, tmpBitangent.z, angle);\n        tmpVertices.push(tmpBitangent.x, tmpBitangent.y, tmpBitangent.z, angle);\n\n        if (hasTexCoords) {\n            // uvs\n            geometry.vertices.push(uvs![i * 2], uvs![i * 2 + 1]);\n            tmpVertices.push(uvs![i * 2], uvs![i * 2 + 1]);\n            // normals\n            geometry.vertices.push(tmpNormal.x, tmpNormal.y, tmpNormal.z);\n            tmpVertices.push(tmpNormal.x, tmpNormal.y, tmpNormal.z);\n        }\n\n        geometry.vertices.push(...tmpVertices);\n\n        // Add vertex colors (if supplied).\n        if (vertexColors) {\n            geometry.vertexColors.push(colors![i * 3], colors![i * 3 + 1], colors![i * 3 + 2]);\n            geometry.vertexColors.push(colors![i * 3], colors![i * 3 + 1], colors![i * 3 + 2]);\n        }\n    };\n\n    for (let i = 0; i < pointCount; ++i) {\n        // Retrieve the per-point tangents.\n        const T1 = isClosed && i === 0 ? tangents.length - 3 : Math.max(0, i - 1) * 3;\n        const T2 = isClosed && i === pointCount - 1 ? 0 : Math.min(i * 3, tangents.length - 3);\n\n        // Process v0 and v1.\n        if (i > 0) {\n            addVertexPair(i, T1, T2, segments[i - 1], segments[i]);\n        }\n\n        // Process v2 and v3.\n        if (i + 1 < pointCount) {\n            addVertexPair(\n                i,\n                T1,\n                T2,\n                segments[Math.min(i, segments.length - 1)] * -1,\n                segments[Math.min(i + 1, segments.length - 1)]\n            );\n        }\n    }\n\n    // Store the triangle indices in the final index buffer.\n    for (let i = 0; i < pointCount - 1; ++i) {\n        const base = baseVertex + i * 4;\n        geometry.indices.push(base, base + 1, base + 2, base + 2, base + 1, base + 3);\n    }\n\n    return geometry;\n}\n\n/**\n * Creates a [[LineGeometry]] object out of a polyline.\n *\n * @param polyline Array of `numbers` describing a polyline.\n * @param colors Array of `numbers` describing a polyline's colors.\n * @param geometry [[LineGeometry]] object used to store the vertex and index attributes.\n */\nexport function createSimpleLineGeometry(\n    polyline: ArrayLike<number>,\n    colors?: ArrayLike<number>,\n    geometry = new LineGeometry()\n): LineGeometry {\n    if (polyline.length === 0) {\n        return geometry;\n    }\n\n    const pointCount = polyline.length / 3;\n    let index = geometry.vertices.length / 3;\n\n    const vertexColors = colors !== undefined && colors.length && polyline.length;\n\n    for (let i = 0; i < pointCount; ++i, index++) {\n        if (i > 0) {\n            geometry.indices.push(index);\n        }\n        if (i < pointCount - 1) {\n            geometry.indices.push(index);\n        }\n        for (let j = 0; j < 3; ++j) {\n            geometry.vertices.push(polyline[i * 3 + j]);\n            if (vertexColors) {\n                geometry.vertexColors.push(colors![i * 3 + j]);\n            }\n        }\n    }\n\n    return geometry;\n}\n\n/**\n * Class used to render groups (or batches) of width-variable lines (in the same tile).\n */\nexport class LineGroup {\n    /**\n     * Adds all the attribute data needed to a [[BufferGeometry]] object for rendering `Lines`.\n     *\n     * @param vertices Array of vertex attributes.\n     * @param colors Array of vertex colors.\n     * @param indices Array of vertex indices.\n     * @param geometry [[BufferGeometry]] object which will store all the `Lines` attribute data.\n     * @param hasNormalsAnUvs Whether vertices have normal and uv coordinates as attributes.\n     * @param highPrecision If `true` will create high-precision vertex information.\n     * @param isSimple `true` to create simple (nonsolid, nonextruded) lines. Defaults to `false`.\n     */\n    static createGeometry(\n        vertices: ArrayLike<number>,\n        colors: ArrayLike<number>,\n        indices: ArrayLike<number>,\n        geometry: THREE.BufferGeometry,\n        hasNormalsAndUvs: boolean = false,\n        highPrecision = false,\n        isSimple = false\n    ): THREE.BufferGeometry {\n        if (isSimple) {\n            geometry.setAttribute(\n                \"position\",\n                new THREE.BufferAttribute(new Float32Array(vertices), 3)\n            );\n            if (colors.length === vertices.length) {\n                geometry.setAttribute(\n                    \"color\",\n                    new THREE.BufferAttribute(new Float32Array(colors), 3)\n                );\n            }\n            geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indices), 1));\n            return geometry;\n        } else {\n            const vertexDescriptor = getVertexDescriptor(hasNormalsAndUvs, highPrecision);\n\n            const buffer = new THREE.InterleavedBuffer(\n                new Float32Array(vertices),\n                vertexDescriptor.stride\n            );\n            vertexDescriptor.attributes.forEach(descr => {\n                const attribute = new THREE.InterleavedBufferAttribute(\n                    buffer,\n                    descr.itemSize,\n                    descr.offset,\n                    false\n                );\n                geometry.setAttribute(descr.name, attribute);\n            });\n            if (colors.length === vertices.length) {\n                geometry.setAttribute(\n                    \"color\",\n                    new THREE.BufferAttribute(new Float32Array(colors), 3)\n                );\n            }\n\n            geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indices), 1));\n\n            return geometry;\n        }\n    }\n\n    private readonly m_geometry: LineGeometry;\n\n    constructor(\n        readonly hasNormalsAndUvs: boolean = false,\n        readonly highPrecision: boolean = false,\n        readonly isSimple: boolean = false\n    ) {\n        this.m_geometry = new LineGeometry();\n    }\n\n    /**\n     * Clears the list of line strips.\n     */\n    clear() {\n        this.m_geometry.vertices = [];\n        this.m_geometry.vertexColors = [];\n        this.m_geometry.indices = [];\n    }\n\n    /**\n     * Add the given points to this line group.\n     *\n     * @param center World center of the provided points.\n     * @param points Sequence of (x,y,z) coordinates.\n     * @param offsets Sequence of line segment offsets.\n     * @param uvs Sequence of (u,v) texture coordinates.\n     * @param colors Sequence of (r,g,b) color components.\n     */\n    add(\n        center: THREE.Vector3,\n        points: ArrayLike<number>,\n        offsets?: ArrayLike<number>,\n        uvs?: ArrayLike<number>,\n        colors?: ArrayLike<number>\n    ): this {\n        if (!this.isSimple) {\n            assert(!this.hasNormalsAndUvs || uvs !== undefined);\n            createLineGeometry(\n                center,\n                points,\n                offsets,\n                uvs,\n                colors,\n                this.m_geometry,\n                this.highPrecision\n            );\n        } else {\n            createSimpleLineGeometry(points, colors, this.m_geometry);\n        }\n        return this;\n    }\n\n    /**\n     * Returns the list of vertices.\n     */\n    get vertices(): number[] {\n        return this.m_geometry.vertices;\n    }\n\n    /**\n     * Returns the list of vertex colors.\n     */\n    get vertexColors(): number[] {\n        return this.m_geometry.vertexColors;\n    }\n\n    /**\n     * Returns the list of indices.\n     */\n    get indices(): number[] {\n        return this.m_geometry.indices;\n    }\n\n    /**\n     * Returns the list of [[VertexAttributeDescriptor]]s.\n     */\n    get vertexAttributes(): VertexAttributeDescriptor[] {\n        return getVertexDescriptor(this.hasNormalsAndUvs, this.highPrecision).attributes;\n    }\n\n    /**\n     * Returns the vertex attribute stride.\n     */\n    get stride(): number {\n        return getVertexDescriptor(this.hasNormalsAndUvs, this.highPrecision).stride;\n    }\n\n    /**\n     * Creates a three.js geometry.\n     */\n    createGeometry(geometry?: THREE.BufferGeometry): THREE.BufferGeometry {\n        if (geometry === undefined) {\n            geometry = new THREE.BufferGeometry();\n        }\n        return LineGroup.createGeometry(\n            this.m_geometry.vertices,\n            this.m_geometry.vertexColors,\n            this.m_geometry.indices,\n            geometry,\n            this.hasNormalsAndUvs,\n            this.highPrecision\n        );\n    }\n}\n\nfunction computeBitangent(\n    n: THREE.Vector3,\n    t0: THREE.Vector3,\n    t1: THREE.Vector3,\n    bt: THREE.Vector3\n): number {\n    let angle = 0;\n    if (!t0.equals(t1)) {\n        angle = Math.acos(t0.dot(t1)) * Math.sign(n.dot(tmpV.copy(t0).cross(t1)));\n        if (Number.isNaN(angle)) {\n            angle = 0;\n        }\n    }\n    bt.copy(t0)\n        .add(t1)\n        .normalize()\n        .cross(n)\n        .normalize();\n    return angle;\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { HighPrecisionPointMaterial } from \"@here/harp-materials\";\n\nimport { HighPrecisionObject } from \"./HighPrecisionLines\";\nimport { HighPrecisionUtils } from \"./HighPrecisionUtils\";\n\n/**\n * Class used to render high-precision points.\n */\nexport class HighPrecisionPoints extends THREE.Points implements HighPrecisionObject {\n    matrixWorldInverse: THREE.Matrix4;\n\n    /**\n     * Number of dimensions this `HighPrecisionObject` is specified in (2D/3D).\n     */\n    dimensionality?: number;\n\n    /**\n     * Creates a `HighPrecisionPoints` object.\n     *\n     * @param geometry [[BufferGeometry]] used to render this object.\n     * @param material [[HighPrecisionLineMaterial]] used to render this object.\n     *     instances.\n     * @param positions Array of 2D/3D positions.\n     * @param color Color of the rendered point.\n     * @param opacity Opacity of the rendered point.\n     */\n    constructor(\n        geometry?: THREE.BufferGeometry,\n        material?: HighPrecisionPointMaterial,\n        positions?: number[] | THREE.Vector3[],\n        color?: THREE.Color,\n        opacity?: number\n    ) {\n        if (material === undefined) {\n            material = new HighPrecisionPointMaterial({\n                color: color ? color : HighPrecisionPointMaterial.DEFAULT_COLOR,\n                opacity: opacity !== undefined ? opacity : 1\n            });\n        }\n\n        super(geometry === undefined ? new THREE.BufferGeometry() : geometry, material);\n\n        this.matrixWorldInverse = new THREE.Matrix4();\n\n        if (positions) {\n            this.setPositions(positions);\n        }\n    }\n\n    get bufferGeometry(): THREE.BufferGeometry {\n        return this.geometry as THREE.BufferGeometry;\n    }\n\n    /**\n     * Clears the [[BufferGeometry]] used to render this point.\n     */\n    clearGeometry(): THREE.BufferGeometry {\n        return (this.geometry = new THREE.BufferGeometry());\n    }\n\n    get shaderMaterial(): THREE.ShaderMaterial {\n        return this.material as THREE.ShaderMaterial;\n    }\n\n    setPositions(positions: number[] | THREE.Vector3[]): void {\n        HighPrecisionUtils.setPositions(this, positions);\n    }\n\n    setupForRendering(): void {\n        if (\n            (this.material as any).isHighPrecisionPointsMaterial &&\n            this.dimensionality !== undefined\n        ) {\n            (this.material as any).setDimensionality(this.dimensionality);\n        }\n        this.onBeforeRender = (\n            _renderer: THREE.WebGLRenderer,\n            _scene: THREE.Scene,\n            camera: THREE.Camera,\n            _geometry: THREE.Geometry | THREE.BufferGeometry,\n            _material: THREE.Material,\n            _group: THREE.Group\n        ) => {\n            HighPrecisionUtils.updateHpUniforms(this, camera, this.shaderMaterial);\n        };\n    }\n\n    updateMatrixWorld(force: boolean) {\n        const doUpdateMatrixWorldInverse = this.matrixWorldNeedsUpdate || force;\n\n        super.updateMatrixWorld(force);\n\n        if (doUpdateMatrixWorldInverse) {\n            this.matrixWorldInverse.getInverse(this.matrixWorld);\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport * from \"./lib/OmvDataFilter\";\nexport * from \"./lib/OmvDataSource\";\nexport * from \"./lib/OmvDecoderDefs\";\nexport * from \"./lib/OmvTile\";\nexport * from \"./lib/OmvDebugLabelsTile\";\nexport * from \"./lib/OmvRestClient\";\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { GeometryKind, GeometryKindSet } from \"@here/harp-datasource-protocol\";\nimport { MapEnv } from \"@here/harp-datasource-protocol/index-decoder\";\nimport {\n    OmvFeatureFilterDescription,\n    OmvFilterDescription,\n    OmvFilterFeatureAttribute,\n    OmvFilterString,\n    OmvGeometryType,\n    OmvLayerFilterDescription\n} from \"./OmvDecoderDefs\";\n\n/**\n * The `OmvFeatureFilter` is designed to work in an `OmvVisitor`/`visitOmv` combination (for\n * example, `OmvDecoder`). Returning `false` from any of the calls terminates processing of that\n * layer or feature.\n *\n * The `OmvFeatureFilter` is an \"early-opt-out\" filter, which cannot filter individual features,\n * because at that point the features are not really decoded. Use the [[OmvFeatureModifier]] to\n * filter for individual features.\n */\nexport interface OmvFeatureFilter {\n    /**\n     * Returns `true` if the filter contains rules for specific kinds.\n     */\n    hasKindFilter: boolean;\n\n    /**\n     * Return `false` if the layer should not be processed.\n     *\n     * @param layer Current layer.\n     * @param level Level of tile.\n     */\n    wantsLayer(layer: string, level: number): boolean;\n\n    /**\n     * Return `false` if the point feature should not be processed.\n     *\n     * @param layer Current layer.\n     * @param feature Current feature.\n     * @param level Level of tile.\n     */\n    wantsPointFeature(layer: string, geometryType: OmvGeometryType, level: number): boolean;\n\n    /**\n     * Return `false` if the line feature should not be processed.\n     *\n     * @param layer Current layer.\n     * @param feature Current feature.\n     * @param level Level of tile.\n     */\n    wantsLineFeature(layer: string, geometryType: OmvGeometryType, level: number): boolean;\n\n    /**\n     * Return `false` if the polygon feature should not be processed.\n     *\n     * @param layer Current layer.\n     * @param feature Current feature.\n     * @param level Level of tile.\n     */\n    wantsPolygonFeature(layer: string, geometryType: OmvGeometryType, level: number): boolean;\n\n    /**\n     * Return `false` if kind of object is not enabled and the geometry should not be created.\n     *\n     * @param {(string | string[])} kind Tag \"kind\" of the tag.\n     * @returns {boolean}\n     */\n    wantsKind(kind: string | string[]): boolean;\n}\n\n/**\n * The `OmvFeatureModifier` can be used to filter individual features. It gets passed in the [[Env]]\n * of the feature, which contains all the values that can be searched for in a style. If a filter\n * function returns false, the feature is ignored, and no geometry is being created.\n *\n * In addition to pure filtering, the `OmvFeatureModifier` can also modify the [[Env]] of the\n * feature, or even add new properties to the feature, for example, traffic states. The\n * `OmvFeatureModifier` is executed before the styles are selected, so the geometry is created with\n * the modified feature properties.\n */\nexport interface OmvFeatureModifier {\n    /**\n     * Check if the point feature described by `env` should be processed. The properties can be\n     * modified or added to.\n     *\n     * @param layer Current layer.\n     * @param env Properties of point feature.\n     * @param level Level of tile.\n     * @returns `false` to ignore feature.\n     */\n    doProcessPointFeature(layer: string, env: MapEnv, level: number): boolean;\n\n    /**\n     * Check if the line feature described by `env` should be processed. The properties can be\n     * modified or added to.\n     *\n     * @param layer Current layer.\n     * @param env Properties of line feature.\n     * @param level Level of tile.\n     * @returns `false` to ignore feature.\n     */\n    doProcessLineFeature(layer: string, env: MapEnv, level: number): boolean;\n\n    /**\n     * Check if the polygon feature described by `env` should be processed. The properties can be\n     * modified or added to.\n     *\n     * @param layer Current layer.\n     * @param env Properties of polygon feature.\n     * @param level Level of tile.\n     * @returns `false` to ignore feature.\n     */\n    doProcessPolygonFeature(layer: string, env: MapEnv, level: number): boolean;\n}\n\n/**\n * Builds an `OmvFilterDescription` (internal type) that specifies an [[OmvFeatureFilter]] as well\n * as an [[OmvFeatureModifier]].\n *\n */\nexport class OmvFeatureFilterDescriptionBuilder {\n    private m_processLayersDefault: boolean = true;\n    private m_processPointsDefault: boolean = true;\n    private m_processLinesDefault: boolean = true;\n    private m_processPolygonsDefault: boolean = true;\n\n    private readonly m_layersToProcess = new Array<OmvLayerFilterDescription>();\n    private readonly m_layersToIgnore = new Array<OmvLayerFilterDescription>();\n    private readonly m_pointsToProcess = new Array<OmvFilterDescription>();\n    private readonly m_ignoredPoints = new Array<OmvFilterDescription>();\n    private readonly m_linesToProcess = new Array<OmvFilterDescription>();\n    private readonly m_linesToIgnore = new Array<OmvFilterDescription>();\n    private readonly m_polygonsToProcess = new Array<OmvFilterDescription>();\n    private readonly m_polygonsToIgnore = new Array<OmvFilterDescription>();\n\n    private m_kindsToProcess: string[] = [];\n    private m_kindsToIgnore: string[] = [];\n\n    /**\n     * Builds an `OmvFilterDescription` (internal type) that specifies an [[OmvFeatureFilter]] as\n     * well as an [[OmvFeatureModifier]].\n     *\n     * @param processLayersDefault If `true`, all unspecified layers will be processed. If `false`,\n     * all unspecified layers will be ignored.\n     * @param processPointsDefault If `true`, all unspecified point features will be processed. If\n     * `false`, all unspecified point features will be ignored.\n     * @param processLinesDefault If `true`, all unspecified line features will be processed. If\n     * `false`, all unspecified line features will be ignored.\n     * @param processPolygonsDefault If `true`, all unspecified polygon features will be processed.\n     * If `false`, all unspecified polygon features will be ignored.\n     */\n    constructor(\n        options?: OmvFeatureFilterDescriptionBuilder.OmvFeatureFilterDescriptionBuilderOptions\n    ) {\n        if (options) {\n            this.m_processLayersDefault =\n                options.processLayersDefault !== undefined ? options.processLayersDefault : true;\n            this.m_processPointsDefault =\n                options.processPointsDefault !== undefined ? options.processPointsDefault : true;\n            this.m_processLinesDefault =\n                options.processLinesDefault !== undefined ? options.processLinesDefault : true;\n            this.m_processPolygonsDefault =\n                options.processPolygonsDefault !== undefined\n                    ? options.processPolygonsDefault\n                    : true;\n        }\n    }\n\n    /**\n     * Add a layer that should be processed.\n     *\n     * @param layer Layer name to be matched.\n     * @param match Match condition.\n     */\n    processLayer(\n        layer: string,\n        match = OmvFilterString.StringMatch.Match,\n        minLevel: number = 0,\n        maxLevel: number = Infinity\n    ) {\n        this.m_layersToProcess.push({\n            name: { value: layer, match },\n            minLevel,\n            maxLevel\n        });\n    }\n\n    /**\n     * Add a layer that should be ignored.\n     *\n     * @param layer Layer name to be matched.\n     * @param match Match condition.\n     */\n    ignoreLayer(\n        layer: string,\n        match = OmvFilterString.StringMatch.Match,\n        minLevel: number = 0,\n        maxLevel: number = Infinity\n    ) {\n        this.m_layersToIgnore.push({\n            name: { value: layer, match },\n            minLevel,\n            maxLevel\n        });\n    }\n\n    /**\n     * Add a valid point feature.\n     *\n     * @param options Feature options.\n     */\n    processPoint(options: OmvFeatureFilterDescriptionBuilder.FeatureOption) {\n        this.addItem(this.m_pointsToProcess, options);\n    }\n\n    /**\n     * Add valid point features.\n     *\n     * @param options Multi feature options.\n     */\n    processPoints(options: OmvFeatureFilterDescriptionBuilder.MultiFeatureOption) {\n        this.addItems(this.m_pointsToProcess, options);\n    }\n\n    /**\n     * Add a point feature that should be ignored.\n     *\n     * @param options Feature options.\n     */\n    ignorePoint(options: OmvFeatureFilterDescriptionBuilder.FeatureOption) {\n        this.addItem(this.m_ignoredPoints, options);\n    }\n\n    /**\n     * Add point features that should be ignored.\n     *\n     * @param options Multi feature options.\n     */\n    ignorePoints(options: OmvFeatureFilterDescriptionBuilder.MultiFeatureOption) {\n        this.addItems(this.m_ignoredPoints, options);\n    }\n\n    /**\n     * Add a valid line feature.\n     *\n     * @param options Feature options.\n     */\n    processLine(options: OmvFeatureFilterDescriptionBuilder.FeatureOption) {\n        this.addItem(this.m_linesToProcess, options);\n    }\n\n    /**\n     * Add valid line features.\n     *\n     * @param options Multi feature options.\n     */\n    processLines(options: OmvFeatureFilterDescriptionBuilder.MultiFeatureOption) {\n        this.addItems(this.m_linesToProcess, options);\n    }\n\n    /**\n     * Ignore a line feature.\n     *\n     * @param options Feature options.\n     */\n    ignoreLine(options: OmvFeatureFilterDescriptionBuilder.FeatureOption) {\n        this.addItem(this.m_linesToIgnore, options);\n    }\n\n    /**\n     * Ignore line features.\n     *\n     * @param options Multi feature options.\n     */\n    ignoreLines(options: OmvFeatureFilterDescriptionBuilder.MultiFeatureOption) {\n        this.addItems(this.m_linesToIgnore, options);\n    }\n\n    /**\n     * Add a valid polygon feature.\n     *\n     * @param options Feature options.\n     */\n    processPolygon(options: OmvFeatureFilterDescriptionBuilder.FeatureOption) {\n        this.addItem(this.m_polygonsToProcess, options);\n    }\n\n    /**\n     * Add valid polygon features.\n     *\n     * @param options Multi feature options.\n     */\n    processPolygons(options: OmvFeatureFilterDescriptionBuilder.MultiFeatureOption) {\n        this.addItems(this.m_polygonsToProcess, options);\n    }\n\n    /**\n     * Ignore a valid polygon feature.\n     *\n     * @param options Feature options.\n     */\n    ignorePolygon(options: OmvFeatureFilterDescriptionBuilder.FeatureOption) {\n        this.addItem(this.m_polygonsToIgnore, options);\n    }\n\n    /**\n     * Ignore polygon features.\n     *\n     * @param options Multi feature options.\n     */\n    ignorePolygons(options: OmvFeatureFilterDescriptionBuilder.MultiFeatureOption) {\n        this.addItems(this.m_polygonsToIgnore, options);\n    }\n\n    /**\n     * Add all the specified strings as \"enabledKinds\".\n     *\n     * @param {string[]} enabledKinds List of kinds that should be generated.\n     */\n    processKinds(enabledKinds: string[]) {\n        this.m_kindsToProcess = this.m_kindsToProcess.concat(enabledKinds);\n    }\n\n    /**\n     * Add all the specified strings as \"disabledKinds\".\n     *\n     * @param {string[]} disabledKinds List of kinds that should _not_ be generated.\n     */\n    ignoreKinds(disabledKinds: string[]) {\n        this.m_kindsToIgnore = this.m_kindsToIgnore.concat(disabledKinds);\n    }\n\n    /**\n     * Create a filter description that can be passed as an option to the [[OmvDataSource]].\n     */\n    createDescription(): OmvFeatureFilterDescription {\n        return {\n            processLayersDefault: this.m_processLayersDefault,\n            processPointsDefault: this.m_processPointsDefault,\n            processLinesDefault: this.m_processLinesDefault,\n            processPolygonsDefault: this.m_processPolygonsDefault,\n\n            layersToProcess: this.m_layersToProcess,\n            layersToIgnore: this.m_layersToIgnore,\n            pointsToProcess: this.m_pointsToProcess,\n            pointsToIgnore: this.m_ignoredPoints,\n            linesToProcess: this.m_linesToProcess,\n            linesToIgnore: this.m_linesToIgnore,\n            polygonsToProcess: this.m_polygonsToProcess,\n            polygonsToIgnore: this.m_polygonsToIgnore,\n\n            kindsToProcess: this.m_kindsToProcess,\n            kindsToIgnore: this.m_kindsToIgnore\n        };\n    }\n\n    private addItem(\n        items: OmvFilterDescription[],\n        options: OmvFeatureFilterDescriptionBuilder.FeatureOption\n    ) {\n        if (options.minLevel === undefined || isNaN(options.minLevel)) {\n            options.minLevel = 0;\n        }\n        if (options.maxLevel === undefined || isNaN(options.maxLevel)) {\n            options.maxLevel = Infinity;\n        }\n\n        const item: OmvFilterDescription = {\n            layerName: {\n                value: options.layer,\n                match:\n                    options.matchLayer === undefined\n                        ? OmvFilterString.StringMatch.Match\n                        : options.matchLayer\n            },\n            geometryTypes:\n                options.geomType !== undefined\n                    ? Array.isArray(options.geomType)\n                        ? options.geomType\n                        : [options.geomType]\n                    : undefined,\n            classes: [\n                {\n                    value: options.featureClass,\n                    match:\n                        options.matchClass === undefined\n                            ? OmvFilterString.StringMatch.Match\n                            : options.matchClass\n                }\n            ],\n            minLevel: options.minLevel,\n            maxLevel: options.maxLevel,\n            featureAttribute: options.featureAttribute\n        };\n\n        items.push(item);\n    }\n\n    private addItems(\n        items: OmvFilterDescription[],\n        options: OmvFeatureFilterDescriptionBuilder.MultiFeatureOption\n    ) {\n        if (options.minLevel === undefined || isNaN(options.minLevel)) {\n            options.minLevel = 0;\n        }\n        if (options.maxLevel === undefined || isNaN(options.maxLevel)) {\n            options.maxLevel = Infinity;\n        }\n\n        const item: OmvFilterDescription = {\n            layerName: {\n                value: options.layer,\n                match:\n                    options.matchLayer === undefined\n                        ? OmvFilterString.StringMatch.Match\n                        : options.matchLayer\n            },\n            geometryTypes:\n                options.geomTypes !== undefined\n                    ? Array.isArray(options.geomTypes)\n                        ? options.geomTypes\n                        : [options.geomTypes]\n                    : undefined,\n            classes: options.featureClasses,\n            minLevel: options.minLevel,\n            maxLevel: options.maxLevel,\n            featureAttribute: options.featureAttribute\n        };\n\n        items.push(item);\n    }\n}\n\nexport namespace OmvFeatureFilterDescriptionBuilder {\n    /**\n     * Options for `OmvFeatureFilterDescriptionBuilder`.\n     */\n    export interface OmvFeatureFilterDescriptionBuilderOptions {\n        /**\n         * If `true`, all unspecified layers will be processed. If `false`, all unspecified layers\n         * will be ignored.\n         */\n        processLayersDefault?: boolean;\n        /**\n         * If `true`, all unspecified point features will be processed. If `false`, all unspecified\n         * point features will be ignored.\n         */\n        processPointsDefault?: boolean;\n        /**\n         * If `true`, all unspecified line features will be processed. If `false`, all unspecified\n         * line\n         * features will be ignored.\n         */\n        processLinesDefault?: boolean;\n        /**\n         * If `true`, all unspecified polygon features will be processed. If `false`, all\n         * unspecified polygon features will be ignored.\n         */\n        processPolygonsDefault?: boolean;\n    }\n\n    /**\n     * Description of a single feature.\n     */\n    export interface FeatureOption {\n        /**\n         * Layer name to be matched.\n         */\n        layer: string;\n        /**\n         * Optional geometry type to be limited to. If specified, but does not match, the feature is\n         * ignored.\n         */\n        geomType: OmvGeometryType | OmvGeometryType[] | undefined;\n        /**\n         * Optional class to match. If specified, but does not match, the feature is ignored.\n         */\n        featureClass: string;\n        /**\n         * Match condition for the layer name.\n         */\n        matchLayer?: OmvFilterString.StringMatch;\n        /**\n         * Match condition for `featureClass`.\n         */\n        matchClass?: OmvFilterString.StringMatch;\n        /**\n         * Minimum tile level to match.\n         */\n        minLevel?: number;\n        /**\n         * Maximum tile level to match.\n         */\n        maxLevel?: number;\n        /**\n         * Feature attribute to match.\n         */\n        featureAttribute?: OmvFilterFeatureAttribute;\n    }\n\n    /**\n     * Description for multiple features.\n     */\n    export interface MultiFeatureOption {\n        /**\n         * Layer name to be matched.\n         */\n        layer: string;\n        /**\n         * Optional geometry type to be limited to. If specified, but does not match, the feature is\n         * ignored.\n         */\n        geomTypes?: OmvGeometryType | OmvGeometryType[] | undefined;\n        /**\n         * Optional classes to match. If specified, but does not match, the feature is ignored.\n         */\n        featureClasses?: OmvFilterString[];\n        /**\n         * Match condition for the layer name.\n         */\n        matchLayer?: OmvFilterString.StringMatch;\n        /**\n         * Minimum tile level to match.\n         */\n        minLevel?: number;\n        /**\n         * Maximum tile level to match.\n         */\n        maxLevel?: number;\n        /**\n         * Feature attribute to match.\n         */\n        featureAttribute?: OmvFilterFeatureAttribute;\n    }\n}\n\n/**\n * `OmvFeatureFilter` implementation that uses a `OmvFeatureFilterDescription` to filter `TileData`\n * features before they are completely decoded.\n *\n * @hidden\n */\nexport class OmvGenericFeatureFilter implements OmvFeatureFilter {\n    private static matchLayer(\n        layer: string,\n        layerItems: OmvLayerFilterDescription[],\n        level: number\n    ): boolean {\n        for (const layerItem of layerItems) {\n            if (level < layerItem.minLevel || level > layerItem.maxLevel) {\n                continue;\n            }\n\n            if (OmvFilterString.matchString(layer, layerItem.name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private disabledKinds: GeometryKindSet | undefined;\n    private enabledKinds: GeometryKindSet | undefined;\n\n    constructor(private description: OmvFeatureFilterDescription) {\n        if (this.description.kindsToProcess.length > 0) {\n            this.enabledKinds = new GeometryKindSet(\n                this.description.kindsToProcess as GeometryKind[]\n            );\n        }\n        if (this.description.kindsToIgnore.length > 0) {\n            this.disabledKinds = new GeometryKindSet(\n                this.description.kindsToIgnore as GeometryKind[]\n            );\n        }\n    }\n\n    wantsLayer(layer: string, level: number): boolean {\n        if (OmvGenericFeatureFilter.matchLayer(layer, this.description.layersToProcess, level)) {\n            return true;\n        }\n\n        if (OmvGenericFeatureFilter.matchLayer(layer, this.description.layersToIgnore, level)) {\n            return false;\n        }\n\n        return this.description.processLayersDefault;\n    }\n\n    wantsPointFeature(layer: string, geometryType: OmvGeometryType, level: number): boolean {\n        return this.wantsFeature(\n            this.description.pointsToProcess,\n            this.description.pointsToIgnore,\n            layer,\n            geometryType,\n            level,\n            this.description.processPointsDefault\n        );\n    }\n\n    wantsLineFeature(layer: string, geometryType: OmvGeometryType, level: number): boolean {\n        return this.wantsFeature(\n            this.description.linesToProcess,\n            this.description.linesToIgnore,\n            layer,\n            geometryType,\n            level,\n            this.description.processLinesDefault\n        );\n    }\n\n    wantsPolygonFeature(layer: string, geometryType: OmvGeometryType, level: number): boolean {\n        return this.wantsFeature(\n            this.description.polygonsToProcess,\n            this.description.polygonsToIgnore,\n            layer,\n            geometryType,\n            level,\n            this.description.processPolygonsDefault\n        );\n    }\n\n    wantsKind(kind: string | string[]): boolean {\n        // undefined -> no way to filter\n        if (kind === undefined) {\n            return true;\n        }\n\n        return (\n            !(\n                this.disabledKinds !== undefined &&\n                this.disabledKinds.hasOrIntersects(kind as GeometryKind)\n            ) ||\n            (this.enabledKinds !== undefined &&\n                this.enabledKinds.hasOrIntersects(kind as GeometryKind))\n        );\n    }\n\n    get hasKindFilter(): boolean {\n        return this.enabledKinds !== undefined || this.disabledKinds !== undefined;\n    }\n\n    private wantsFeature(\n        itemsToProcess: OmvFilterDescription[],\n        itemsToIgnore: OmvFilterDescription[],\n        layer: string,\n        geometryType: OmvGeometryType,\n        level: number,\n        defaultResult: boolean\n    ): boolean {\n        for (const item of itemsToProcess) {\n            if (level < item.minLevel || level > item.maxLevel) {\n                continue;\n            }\n\n            if (!OmvFilterString.matchString(layer, item.layerName)) {\n                // this rule is not for this layer\n                continue;\n            }\n\n            if (item.geometryTypes !== undefined && item.geometryTypes.indexOf(geometryType) >= 0) {\n                return true;\n            }\n        }\n\n        for (const item of itemsToIgnore) {\n            if (!OmvFilterString.matchString(layer, item.layerName)) {\n                // this rule is not for this layer\n                continue;\n            }\n\n            if (item.geometryTypes !== undefined && item.geometryTypes.indexOf(geometryType) >= 0) {\n                return false;\n            }\n        }\n\n        return defaultResult;\n    }\n}\n\n/**\n * An [[OmvFeatureFilter]] implementation that delegates all filter decision\n * returning `true` for any predicate if all delegates return `true`.\n */\nexport class ComposedDataFilter implements OmvFeatureFilter {\n    constructor(readonly filters: OmvFeatureFilter[]) {}\n\n    get hasKindFilter() {\n        return this.filters.reduce<boolean>(\n            (result, filter) => result && filter.hasKindFilter,\n            true\n        );\n    }\n\n    wantsLayer(layer: string, level: number): boolean {\n        return this.filters.reduce<boolean>(\n            (result, filter) => result && filter.wantsLayer(layer, level),\n            true\n        );\n    }\n    wantsPointFeature(layer: string, geometryType: OmvGeometryType, level: number): boolean {\n        return this.filters.reduce<boolean>(\n            (result, filter) => result && filter.wantsPointFeature(layer, geometryType, level),\n            true\n        );\n    }\n    wantsLineFeature(layer: string, geometryType: OmvGeometryType, level: number): boolean {\n        return this.filters.reduce<boolean>(\n            (result, filter) => result && filter.wantsLineFeature(layer, geometryType, level),\n            true\n        );\n    }\n    wantsPolygonFeature(layer: string, geometryType: OmvGeometryType, level: number): boolean {\n        return this.filters.reduce<boolean>(\n            (result, filter) => result && filter.wantsPolygonFeature(layer, geometryType, level),\n            true\n        );\n    }\n    wantsKind(kind: string | string[]): boolean {\n        return this.filters.reduce<boolean>(\n            (result, filter) => result && filter.wantsKind(kind),\n            true\n        );\n    }\n}\n/**\n * `OmvFeatureModifier` implementation that uses a `OmvFeatureFilterDescription` to filter\n * `TileData` features before they are completely decoded.\n *\n * @hidden\n */\nexport class OmvGenericFeatureModifier implements OmvFeatureModifier {\n    static matchItems(\n        layerName: string,\n        featureClass: string,\n        items: OmvFilterDescription[]\n    ): boolean {\n        for (const item of items) {\n            if (item.classes !== undefined) {\n                if (!OmvFilterString.matchString(layerName, item.layerName)) {\n                    continue;\n                }\n                for (const matchClass of item.classes) {\n                    if (OmvFilterString.matchString(featureClass, matchClass)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    static matchAttribute(layerName: string, env: MapEnv, items: OmvFilterDescription[]): boolean {\n        for (const item of items) {\n            if (item.featureAttribute !== undefined) {\n                if (\n                    OmvFilterString.matchString(layerName, item.layerName) &&\n                    env.lookup(item.featureAttribute.key) === item.featureAttribute.value\n                ) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    constructor(private description: OmvFeatureFilterDescription) {}\n\n    doProcessPointFeature(layer: string, env: MapEnv): boolean {\n        return this.doProcessFeature(\n            this.description.pointsToProcess,\n            this.description.pointsToIgnore,\n            layer,\n            env,\n            this.description.processPointsDefault\n        );\n    }\n\n    doProcessLineFeature(layer: string, env: MapEnv): boolean {\n        return this.doProcessFeature(\n            this.description.linesToProcess,\n            this.description.linesToIgnore,\n            layer,\n            env,\n            this.description.processLinesDefault\n        );\n    }\n\n    doProcessPolygonFeature(layer: string, env: MapEnv): boolean {\n        return this.doProcessFeature(\n            this.description.polygonsToProcess,\n            this.description.polygonsToIgnore,\n            layer,\n            env,\n            this.description.processPolygonsDefault\n        );\n    }\n\n    protected doProcessFeature(\n        itemsToProcess: OmvFilterDescription[],\n        itemsToIgnore: OmvFilterDescription[],\n        layer: string,\n        env: MapEnv,\n        defaultResult: boolean\n    ): boolean {\n        if (layer === undefined || (itemsToProcess.length === 0 && itemsToIgnore.length === 0)) {\n            return defaultResult;\n        }\n\n        let featureClass: string | undefined;\n        const featureClassThing = env.lookup(\"class\");\n\n        if (featureClassThing !== undefined && featureClassThing !== null) {\n            featureClass = featureClassThing.toString();\n        }\n\n        if (\n            featureClass &&\n            OmvGenericFeatureModifier.matchItems(layer, featureClass, itemsToProcess)\n        ) {\n            return true;\n        }\n\n        if (\n            featureClass &&\n            OmvGenericFeatureModifier.matchItems(layer, featureClass, itemsToIgnore)\n        ) {\n            return false;\n        }\n\n        if (OmvGenericFeatureModifier.matchAttribute(layer, env, itemsToProcess)) {\n            return true;\n        }\n\n        if (OmvGenericFeatureModifier.matchAttribute(layer, env, itemsToIgnore)) {\n            return false;\n        }\n\n        return defaultResult;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    AttributeMap,\n    Definitions,\n    GeometryType,\n    ITileDecoder,\n    OptionsMap,\n    StyleSet,\n    WorkerServiceProtocol\n} from \"@here/harp-datasource-protocol\";\nimport { EarthConstants, TileKey, webMercatorTilingScheme } from \"@here/harp-geoutils\";\nimport { LineGroup } from \"@here/harp-lines\";\nimport { CopyrightInfo, CopyrightProvider } from \"@here/harp-mapview\";\nimport { DataProvider, TileDataSource, TileFactory } from \"@here/harp-mapview-decoder\";\nimport { getOptionValue, LoggerManager } from \"@here/harp-utils\";\nimport {\n    FeatureModifierId,\n    OMV_TILE_DECODER_SERVICE_TYPE,\n    OmvDecoderOptions,\n    OmvFeatureFilterDescription\n} from \"./OmvDecoderDefs\";\nimport { OmvRestClient, OmvRestClientParameters } from \"./OmvRestClient\";\nimport { OmvTile } from \"./OmvTile\";\n\nconst logger = LoggerManager.instance.create(\"OmvDataSource\");\n\nexport interface LinesGeometry {\n    type: GeometryType;\n    lines: LineGroup;\n    renderOrderOffset?: number;\n    technique: number;\n\n    /**\n     * Optional array of objects. It can be used to pass user data from the geometry to the mesh.\n     */\n    objInfos?: AttributeMap[];\n\n    /**\n     * Optional list of feature start indices. The indices point into the index attribute.\n     */\n    featureStarts?: number[];\n}\n\nexport interface OmvTileFactory {\n    /** Create an instance of [[OmvTile]] or a subclass. */\n    createTile(dataSource: OmvDataSource, tileKey: TileKey): OmvTile;\n}\n\nexport interface OmvDataSourceParameters {\n    /**\n     * The unique name of the [[OmvDataSource]].\n     */\n    name?: string;\n\n    /**\n     * The name of the [[StyleSet]] that this [[OmvDataSource]] should use for decoding.\n     *\n     *  @default \"omv\"\n     */\n    styleSetName?: string;\n\n    /**\n     * If set to `true`, features that have no technique in the theme will be printed to the console\n     * (can be excessive!).\n     */\n    showMissingTechniques?: boolean;\n\n    /**\n     * If set to `true`, an [[ExtendedTileInfo]] is created for every tile in addition to the\n     * [[DecodedTile]]. This is useful if the features should be passed on for processing without\n     * geometry being automatically created from them. One application is picking.\n     */\n    createTileInfo?: boolean;\n\n    /**\n     * Specify the decoder that should be used. If not supplied, the default will be used.\n     */\n    decoder?: ITileDecoder;\n\n    /**\n     * Optionally specify the DataProvider that should be used.\n     */\n    dataProvider?: DataProvider;\n\n    /**\n     * Specify the URL to the decoder bundle. If not supplied, the default will be used.\n     */\n    concurrentDecoderScriptUrl?: string;\n\n    /**\n     * Gather feature IDs from `OmvData`. Defaults to `false`.\n     * @deprecated, FeatureIds are always gathered, use [[gatherFeatureAttributes]] to gather\n     * all feature attributes.\n     */\n    gatherFeatureIds?: boolean;\n\n    /**\n     * Gather feature attributes from `OmvData`. Defaults to `false`.\n     */\n    gatherFeatureAttributes?: boolean;\n\n    /**\n     * Gather road segments data from [[OmvData]]. Defaults to `false`.\n     */\n    gatherRoadSegments?: boolean;\n\n    /**\n     * If not set to `false`, very short text labels will be skipped during decoding based on a\n     * heuristic.\n     */\n    skipShortLabels?: boolean;\n\n    /**\n     * A description for the feature filter that can be safely passed down to the web workers. It\n     * has to be generated with the help of the [[OmvFeatureFilterDescriptionBuilder]] (to guarantee\n     * correctness). This parameter gets applied to the decoder used in the [[OmvDataSource]]\n     * which might be shared between various [[OmvDataSource]]s.\n     */\n    filterDescr?: OmvFeatureFilterDescription;\n\n    /**\n     * Optional, custom factory for [[Tile]] instances created by this [[OmvDataSource]].\n     */\n    tileFactory?: TileFactory<OmvTile>;\n\n    /**\n     * Identifier used to choose OmvFeatureModifier, if undefined [[OmvGenericFeatureModifier]] is\n     * used. This parameter gets applied to the decoder used in the [[OmvDataSource]] which might\n     * be shared between various [[OmvDataSource]]s.\n     */\n    featureModifierId?: FeatureModifierId;\n\n    /**\n     * Optional, default copyright information of tiles provided by this data source.\n     * Implementation should provide this information from the source data if possible.\n     */\n    copyrightInfo?: CopyrightInfo[];\n\n    /**\n     * Optional copyright info provider for tiles provided by this data source.\n     */\n    copyrightProvider?: CopyrightProvider;\n\n    /**\n     * Optional minimum zoom level (storage level) for [[Tile]]s. Default is 1.\n     */\n    minZoomLevel?: number;\n\n    /**\n     * Optional maximum zoom level (storage level) for [[Tile]]s. Default is 14.\n     */\n    maxZoomLevel?: number;\n\n    /**\n     * Maximum geometry height above groud level this `OmvDataSource` can produce.\n     *\n     * Used in first stage of frustum culling before [[Tile.maxGeometryHeight]] data is available.\n     *\n     * @default [[EarthConstants.MAX_BUILDING_HEIGHT]].\n     */\n    maxGeometryHeight?: number;\n\n    /**\n     * Optional storage level offset for [[Tile]]s. Default is -1.\n     */\n    storageLevelOffset?: number;\n\n    /**\n     * Indicates whether overlay on elevation is enabled. Defaults to `false`.\n     */\n    enableElevationOverlay?: boolean;\n\n    /**\n     * Indicates whether to add a ground plane to cover the tile completely. This is necessary for\n     * the fallback logic, such that the parent fall back tiles don't overlap the children tiles.\n     * Default is true (i.e. if not defined it is taken to be true)\n     */\n    addGroundPlane?: boolean;\n}\n\n/**\n * A helper function to retrieve the [[DataProvider]] from the [[OmvDataSource]]s parameters.\n *\n * @param params The parameters passed into the OmvDataSource.\n */\nfunction getDataProvider(params: OmvWithRestClientParams | OmvWithCustomDataProvider) {\n    if ((params as OmvWithCustomDataProvider).dataProvider) {\n        return (params as OmvWithCustomDataProvider).dataProvider;\n    } else if (\n        (params as OmvWithRestClientParams).baseUrl ||\n        (params as OmvWithRestClientParams).url\n    ) {\n        return new OmvRestClient(params as OmvRestClientParameters);\n    } else {\n        throw new Error(\"OmvDataSource: missing url, baseUrl or dataProvider params\");\n    }\n}\n\nexport type OmvWithRestClientParams = OmvRestClientParameters & OmvDataSourceParameters;\nexport type OmvWithCustomDataProvider = OmvDataSourceParameters & { dataProvider: DataProvider };\n\nlet missingOmvDecoderServiceInfoEmitted: boolean = false;\n\nexport class OmvDataSource extends TileDataSource<OmvTile> {\n    private readonly m_decoderOptions: OmvDecoderOptions;\n\n    constructor(private m_params: OmvWithRestClientParams | OmvWithCustomDataProvider) {\n        super(m_params.tileFactory || new TileFactory(OmvTile), {\n            styleSetName: m_params.styleSetName || \"omv\",\n            name: m_params.name,\n            tilingScheme: webMercatorTilingScheme,\n            dataProvider: getDataProvider(m_params),\n            concurrentDecoderServiceName: OMV_TILE_DECODER_SERVICE_TYPE,\n            decoder: m_params.decoder,\n            concurrentDecoderScriptUrl: m_params.concurrentDecoderScriptUrl,\n            copyrightInfo: m_params.copyrightInfo,\n            copyrightProvider: m_params.copyrightProvider,\n            minZoomLevel: getOptionValue(m_params.minZoomLevel, 1),\n            maxZoomLevel: getOptionValue(m_params.maxZoomLevel, 14),\n            storageLevelOffset: getOptionValue(m_params.storageLevelOffset, -1)\n        });\n\n        this.cacheable = true;\n        this.addGroundPlane =\n            m_params.addGroundPlane === undefined || m_params.addGroundPlane === true;\n\n        this.m_decoderOptions = {\n            showMissingTechniques: this.m_params.showMissingTechniques === true,\n            filterDescription: this.m_params.filterDescr,\n            gatherFeatureAttributes: this.m_params.gatherFeatureAttributes === true,\n            createTileInfo: this.m_params.createTileInfo === true,\n            gatherRoadSegments: this.m_params.gatherRoadSegments === true,\n            featureModifierId: this.m_params.featureModifierId,\n            skipShortLabels: this.m_params.skipShortLabels,\n            storageLevelOffset: getOptionValue(m_params.storageLevelOffset, -1),\n            enableElevationOverlay: this.m_params.enableElevationOverlay === true\n        };\n\n        this.maxGeometryHeight = getOptionValue(\n            m_params.maxGeometryHeight,\n            EarthConstants.MAX_BUILDING_HEIGHT\n        );\n    }\n\n    async connect() {\n        try {\n            await super.connect();\n        } catch (error) {\n            if (\n                WorkerServiceProtocol.isUnknownServiceError(error) &&\n                !missingOmvDecoderServiceInfoEmitted\n            ) {\n                logger.info(\n                    \"Unable to create decoder service in worker. Use \" +\n                        \" 'OmvTileDecoderService.start();' in decoder script.\"\n                );\n                missingOmvDecoderServiceInfoEmitted = true;\n            }\n            throw error;\n        }\n        this.configureDecoder(undefined, undefined, undefined, this.m_decoderOptions);\n    }\n\n    /**\n     * Remove the current data filter.\n     * Will be applied to the decoder, which might be shared with other omv datasources.\n     */\n    removeDataFilter(): void {\n        this.configureDecoder(undefined, undefined, undefined, {\n            filterDescription: null\n        });\n    }\n\n    /**\n     * Set a new data filter. Can also be done during the creation of an [[OmvDataSource]].\n     * Will be applied to the decoder, which might be shared with other omv datasources.\n     *\n     * @param filterDescription Data filter description created with\n     * [[OmvFeatureFilterDescriptionBuilder]].\n     */\n    setDataFilter(filterDescription: OmvFeatureFilterDescription): void {\n        this.m_decoderOptions.filterDescription =\n            filterDescription !== null ? filterDescription : undefined;\n\n        this.configureDecoder(undefined, undefined, undefined, {\n            filterDescription\n        });\n    }\n\n    shouldPreloadTiles(): boolean {\n        return true;\n    }\n\n    /**\n     * Check if a data source should be rendered or not depending on the zoom level.\n     *\n     * @param zoomLevel Zoom level.\n     * @param tileKey Level of the tile.\n     * @returns `true` if the data source should be rendered.\n     */\n    shouldRender(zoomLevel: number, tileKey: TileKey): boolean {\n        if (tileKey.level > this.maxZoomLevel) {\n            return false;\n        }\n        if (tileKey.level === this.maxZoomLevel && zoomLevel >= this.maxZoomLevel) {\n            return true;\n        }\n        return super.shouldRender(zoomLevel, tileKey);\n    }\n\n    setLanguages(languages?: string[]): void {\n        if (languages !== undefined) {\n            this.configureDecoder(undefined, undefined, languages, undefined);\n        }\n    }\n\n    get storageLevelOffset() {\n        return super.storageLevelOffset;\n    }\n\n    set storageLevelOffset(levelOffset: number) {\n        super.storageLevelOffset = levelOffset;\n        this.m_decoderOptions.storageLevelOffset = this.storageLevelOffset;\n        this.configureDecoder(undefined, undefined, undefined, {\n            storageLevelOffset: this.storageLevelOffset\n        });\n    }\n\n    setEnableElevationOverlay(enable: boolean) {\n        if (this.m_decoderOptions.enableElevationOverlay !== enable) {\n            this.m_decoderOptions.enableElevationOverlay = enable;\n            this.configureDecoder(undefined, undefined, undefined, {\n                enableElevationOverlay: enable\n            });\n        }\n    }\n\n    private configureDecoder(\n        styleSet?: StyleSet,\n        definitions?: Definitions,\n        languages?: string[],\n        options?: OptionsMap\n    ) {\n        this.clearCache();\n        this.decoder.configure(styleSet, definitions, languages, options);\n        this.mapView.markTilesDirty(this);\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport * from \"./lib/DataProvider\";\nexport * from \"./lib/TileDataSource\";\nexport * from \"./lib/TileLoader\";\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    Definitions,\n    ITileDecoder,\n    StyleSet,\n    Theme,\n    TileInfo\n} from \"@here/harp-datasource-protocol\";\nimport { TileKey, TilingScheme } from \"@here/harp-geoutils\";\nimport { LRUCache } from \"@here/harp-lrucache\";\nimport {\n    ConcurrentDecoderFacade,\n    CopyrightInfo,\n    CopyrightProvider,\n    DataSource,\n    Tile,\n    TileLoaderState\n} from \"@here/harp-mapview\";\nimport { LoggerManager } from \"@here/harp-utils\";\nimport { DataProvider } from \"./DataProvider\";\nimport { TileInfoLoader, TileLoader } from \"./TileLoader\";\n\n/**\n * Set of common options for all [[TileDataSource]]s.\n */\nexport interface TileDataSourceOptions {\n    /**\n     * Name of [[TileDataSource]], must be unique.\n     */\n    name?: string;\n\n    /**\n     * The name of the [[StyleSet]] to evaluate for the decoding.\n     */\n    styleSetName: string;\n\n    /**\n     * The [[TilingScheme]] the data source is using.\n     */\n    tilingScheme: TilingScheme;\n\n    /**\n     * The [[DataProvider]] to use for downloading the actual data.\n     */\n    dataProvider: DataProvider;\n\n    /**\n     * Optional: Specify [[ITileDecoder]] instance.\n     */\n    decoder?: ITileDecoder;\n\n    /**\n     * Optional name of decoder service class.\n     * @see [[ConcurrentDecoderFacade]]\n     * @see [[ConcurrentWorkerSet]]\n     */\n    concurrentDecoderServiceName?: string;\n\n    /**\n     * Optional URL for decoder bundle to be loaded into web worker.\n     */\n    concurrentDecoderScriptUrl?: string;\n\n    /**\n     * Optional count of web workers to use with the decoder bundle.\n     */\n    concurrentDecoderWorkerCount?: number;\n\n    /**\n     * Optional, default copyright information of tiles provided by this data source.\n     * Implementation should provide this information from the source data if possible.\n     */\n    copyrightInfo?: CopyrightInfo[];\n\n    /**\n     * Optional copyright info provider for tiles provided by this data source. Copyrights from\n     * provider are concatenated with default ones from `copyrightInfo`.\n     */\n    copyrightProvider?: CopyrightProvider;\n\n    /**\n     * Optional minimum zoom level (storage level) for [[Tile]]s. Default is 1.\n     */\n    minZoomLevel?: number;\n\n    /**\n     * Optional maximum zoom level (storage level) for [[Tile]]s. Default is 20.\n     */\n    maxZoomLevel?: number;\n\n    /**\n     * Optional storage level offset for [[Tile]]s. Default is 0.\n     */\n    storageLevelOffset?: number;\n}\n\n/**\n * Templated factory class to create instances of [[Tile]].\n */\nexport class TileFactory<TileType extends Tile> {\n    /**\n     * Initialize the factory using the constructor of the element to be called when a [[Tile]] is\n     * created.\n     *\n     * @param m_modelConstructor Constructor of (subclass of) [[Tile]].\n     */\n    constructor(\n        private m_modelConstructor: new (dataSource: DataSource, tileKey: TileKey) => TileType\n    ) {}\n\n    /**\n     * Create an instance of (subclass of) [[Tile]]. The required parameters are passed as arguments\n     * to the constructor of [[Tile]].\n     *\n     * @param dataSource [[Datasource]] this class belongs to.\n     * @param tileKey Quadtree address of the [[Tile]].\n     */\n    create(dataSource: DataSource, tileKey: TileKey): TileType {\n        return new this.m_modelConstructor(dataSource, tileKey);\n    }\n}\n\nconst maxLevelTileLoaderCache = 3;\n/**\n * Common base class for the typical [[DataSource]] which uses an [[ITileDecoder]] to decode the\n * tile content asynchronously. The decoder can be passed in as an option, or a default\n * asynchronous one is generated.\n */\nexport class TileDataSource<TileType extends Tile> extends DataSource {\n    protected readonly logger = LoggerManager.instance.create(\"TileDataSource\");\n    protected readonly m_decoder: ITileDecoder;\n    protected readonly m_tileLoaderCache: LRUCache<number, TileLoader>;\n    private m_isReady: boolean = false;\n\n    /**\n     * Set up the `TileDataSource`.\n     *\n     * @param m_tileFactory Factory to create the [[Tile]] instances.\n     * @param m_options Options specifying the parameters of the [[DataSource]].\n     */\n    constructor(\n        private readonly m_tileFactory: TileFactory<TileType>,\n        private readonly m_options: TileDataSourceOptions\n    ) {\n        super(\n            m_options.name,\n            m_options.styleSetName,\n            m_options.minZoomLevel,\n            m_options.maxZoomLevel,\n            m_options.storageLevelOffset\n        );\n        if (m_options.decoder) {\n            this.m_decoder = m_options.decoder;\n        } else if (m_options.concurrentDecoderServiceName) {\n            this.m_decoder = ConcurrentDecoderFacade.getTileDecoder(\n                m_options.concurrentDecoderServiceName,\n                m_options.concurrentDecoderScriptUrl,\n                m_options.concurrentDecoderWorkerCount\n            );\n        } else {\n            throw new Error(\n                `TileDataSource[${this.name}]: unable to create, missing decoder or ` +\n                    `concurrentDecoderServiceName`\n            );\n        }\n        this.useGeometryLoader = true;\n        this.cacheable = true;\n        this.m_tileLoaderCache = new LRUCache<number, TileLoader>(this.getCacheCount());\n        this.m_tileLoaderCache.evictionCallback = (_, tileLoader) => {\n            // Cancel any pending downloads as early as possible.\n            tileLoader.cancel();\n        };\n    }\n\n    dispose() {\n        this.decoder.dispose();\n    }\n\n    ready(): boolean {\n        return this.m_isReady && this.m_options.dataProvider.ready();\n    }\n\n    /**\n     * Get the [[ITileDecoder]] of this `ITileDataSource`, which has either been passed in with\n     * the options, or has been supplied by the [[ConcurrentDecoderFacade]].\n     */\n    get decoder(): ITileDecoder {\n        return this.m_decoder;\n    }\n\n    async connect() {\n        await Promise.all([this.m_options.dataProvider.connect(), this.m_decoder.connect()]);\n        this.m_isReady = true;\n\n        this.m_decoder.configure(undefined, undefined, undefined, {\n            storageLevelOffset: this.m_options.storageLevelOffset\n        });\n    }\n\n    setStyleSet(styleSet?: StyleSet, definitions?: Definitions, languages?: string[]): void {\n        this.m_decoder.configure(styleSet, definitions, languages);\n        this.mapView.markTilesDirty(this);\n    }\n\n    /**\n     * Apply the [[Theme]] to this data source.\n     *\n     * Applies new [[StyleSet]] and definitions from theme only if matching styleset (see\n     * `styleSetName` property) is found in `theme`.\n     */\n    setTheme(theme: Theme, languages?: string[]): void {\n        const styleSet =\n            this.styleSetName !== undefined && theme.styles\n                ? theme.styles[this.styleSetName]\n                : undefined;\n\n        if (styleSet !== undefined) {\n            this.setStyleSet(styleSet, theme.definitions, languages);\n        }\n    }\n\n    clearCache() {\n        this.m_tileLoaderCache.evictAll();\n    }\n\n    /**\n     * Get the [[DataProvider]] that has been passed in with the options.\n     */\n    dataProvider(): DataProvider {\n        return this.m_options.dataProvider;\n    }\n\n    getTilingScheme(): TilingScheme {\n        return this.m_options.tilingScheme;\n    }\n\n    /**\n     * Create a [[Tile]] and start the asynchronous download of the tile content. The [[Tile]] will\n     * be empty, but the download and decoding will be scheduled immediately. [[Tile]] instance is\n     * initialized with default copyrights, concatenated with copyrights from copyright provider of\n     * this data source.\n     *\n     * @param tileKey Quadtree address of the requested tile.\n     */\n    getTile(tileKey: TileKey): TileType | undefined {\n        const tile = this.m_tileFactory.create(this, tileKey);\n\n        const mortonCode = tileKey.mortonCode();\n        const tileLoader = this.m_tileLoaderCache.get(mortonCode);\n        if (tileLoader !== undefined) {\n            tile.tileLoader = tileLoader;\n        } else {\n            const newTileLoader = new TileLoader(\n                this,\n                tileKey,\n                this.m_options.dataProvider,\n                this.decoder,\n                0\n            );\n            tile.tileLoader = newTileLoader;\n            tile.copyrightInfo = this.m_options.copyrightInfo;\n            if (this.m_options.copyrightProvider !== undefined) {\n                this.m_options.copyrightProvider\n                    .getCopyrights(tile.geoBox, tileKey.level)\n                    .then(copyrightInfo => {\n                        tile.copyrightInfo =\n                            tile.copyrightInfo === undefined\n                                ? copyrightInfo\n                                : [...tile.copyrightInfo, ...copyrightInfo];\n                        this.requestUpdate();\n                    });\n            }\n\n            // We don't cache tiles with level 4 and above, at this level, there are 16 (2^4) tiles\n            // horizontally, given the assumption that the zoom level assumes the tile should be 256\n            // pixels wide (see function [[calculateZoomLevelFromDistance]]), and the current\n            // storage offset of -2 (which makes the tiles then 1024 pixels wide). this would mean a\n            // horizontal width of ~16k pixels for the entire earth, this would be quite a lot to\n            // pan, hence caching doesn't make sense above this point (as the chance that we need to\n            // share the TileLoader is small, and even if we did eventually see it, the original\n            // TileLoader would probably be evicted because it was removed by other more recent\n            // tiles).\n            if (tileKey.level <= maxLevelTileLoaderCache) {\n                this.m_tileLoaderCache.set(mortonCode, newTileLoader);\n            }\n        }\n\n        if (tile.tileLoader.decodedTile !== undefined) {\n            tile.decodedTile = tile.tileLoader.decodedTile;\n        } else {\n            tile.load();\n        }\n        return tile;\n    }\n\n    /**\n     * Get [[TileInfo]] of a tile.\n     *\n     * @param tileKey Quadtree address of the requested tile.\n     * @returns A promise which will contain the [[TileInfo]] when resolved.\n     */\n    getTileInfo(tileKey: TileKey): Promise<TileInfo | undefined> {\n        const promise = new Promise<TileInfo | undefined>((resolve, reject) => {\n            const tileLoader = new TileInfoLoader(\n                this,\n                tileKey,\n                this.m_options.dataProvider,\n                this.decoder,\n                0\n            );\n\n            tileLoader.loadAndDecode().then(loaderState => {\n                if (loaderState === TileLoaderState.Ready) {\n                    resolve(tileLoader.tileInfo);\n                } else {\n                    reject(\n                        new Error(`TileDataSource#getInfoTile wrong final state: ${loaderState}`)\n                    );\n                }\n            });\n        });\n\n        return promise;\n    }\n\n    private getCacheCount(): number {\n        // We support up to [[maxLevelTileLoaderCache]] levels, this equates to roughly\n        // 2^maxLevelTileLoaderCache^2 tiles in total (at level maxLevelTileLoaderCache), we don't\n        // generally see that many, so we add a factor of 2 to try to get the worst case.\n        return Math.pow(2, maxLevelTileLoaderCache) * 2;\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { getPropertyValue, isTextTechnique } from \"@here/harp-datasource-protocol\";\nimport { TileKey } from \"@here/harp-geoutils/lib/tiling/TileKey\";\nimport { DataSource, TextElement } from \"@here/harp-mapview\";\nimport { debugContext } from \"@here/harp-mapview/lib/DebugContext\";\nimport {\n    ContextualArabicConverter,\n    FontUnit,\n    TextLayoutStyle,\n    TextRenderStyle\n} from \"@here/harp-text-canvas\";\nimport * as THREE from \"three\";\n\nimport { TileGeometryCreator } from \"@here/harp-mapview/lib/geometry/TileGeometryCreator\";\nimport { OmvTile } from \"./OmvTile\";\n\nconst debugMaterial = new THREE.LineBasicMaterial({\n    color: 0x000000,\n    linewidth: 2,\n    depthTest: false,\n    depthFunc: THREE.NeverDepth\n});\n\nconst debugCircleMaterial = new THREE.MeshBasicMaterial({\n    color: 0xff0000,\n    depthTest: false,\n    depthFunc: THREE.NeverDepth\n});\n\nconst debugCircleMaterialWF = new THREE.MeshBasicMaterial({\n    color: 0xff0000,\n    depthTest: false,\n    depthFunc: THREE.NeverDepth\n});\ndebugCircleMaterialWF.wireframe = true;\n\nconst debugCircleMaterial2WF = new THREE.MeshBasicMaterial({\n    color: 0x8080ff,\n    depthTest: false,\n    depthFunc: THREE.NeverDepth\n});\ndebugCircleMaterial2WF.wireframe = true;\n\nconst debugBlackCircleMaterial = new THREE.MeshBasicMaterial({\n    color: 0x000000,\n    depthTest: false,\n    depthFunc: THREE.NeverDepth\n});\n\nconst textRenderStyle = new TextRenderStyle();\nconst textLayoutStyle = new TextLayoutStyle();\n\ntextRenderStyle.fontSize = {\n    unit: FontUnit.Point,\n    size: 9,\n    backgroundSize: 0\n};\ntextRenderStyle.opacity = 0.75;\ntextRenderStyle.backgroundOpacity = 0.75;\n\nexport class OmvDebugLabelsTile extends OmvTile {\n    constructor(dataSource: DataSource, tileKey: TileKey) {\n        super(dataSource, tileKey);\n    }\n\n    loadingFinished() {\n        this.addLabelDebugInfo();\n    }\n\n    /**\n     * Create [[TextElement]] objects from the given decoded [[Tile]] and list of materials.\n     */\n    private addLabelDebugInfo() {\n        // activate in the browser with:\n        // window.__debugContext.setValue(\"DEBUG_TEXT_PATHS\", true)\n        const debugTextPaths = debugContext.getValue(\"DEBUG_TEXT_PATHS\");\n        const debugTextPathsFull = debugContext.getValue(\"DEBUG_TEXT_PATHS_FULL\");\n\n        if (!(debugTextPaths || debugTextPathsFull) || this.decodedTile === undefined) {\n            return;\n        }\n\n        const tileGeometryCreator = TileGeometryCreator.instance;\n        const decodedTile = this.decodedTile!;\n\n        tileGeometryCreator.createTextElements(this, decodedTile);\n\n        const colorMap = new Map<number, THREE.Color>();\n\n        // allow limiting to specific names and/or index. There can be many paths with the same text\n        const textFilter = debugContext.getValue(\"DEBUG_TEXT_PATHS.FILTER.TEXT\");\n        const indexFilter = debugContext.getValue(\"DEBUG_TEXT_PATHS.FILTER.INDEX\");\n        const zoomLevel = this.mapView.zoomLevel;\n\n        if (decodedTile.textPathGeometries !== undefined) {\n            this.preparedTextPaths = tileGeometryCreator.prepareTextPaths(\n                decodedTile.textPathGeometries,\n                decodedTile\n            );\n        }\n\n        if (this.preparedTextPaths !== undefined) {\n            const lineGeometry = new THREE.BufferGeometry();\n            const lineIndices = new Array<number>();\n            const linePositions = new Array<number>();\n\n            const redPointGeometry = new THREE.BufferGeometry();\n            const redPointIndices = new Array<number>();\n            const redPointPositions = new Array<number>();\n\n            const blackPointGeometry = new THREE.BufferGeometry();\n            const blackPointIndices = new Array<number>();\n            const blackPointPositions = new Array<number>();\n\n            let baseVertex = 0;\n            const pointScale = this.mapView.pixelToWorld;\n            const worldOffsetX = this.computeWorldOffsetX();\n\n            for (const textPath of this.preparedTextPaths) {\n                const technique = decodedTile.techniques[textPath.technique];\n                if (!isTextTechnique(technique)) {\n                    continue;\n                }\n                if (technique.color !== undefined) {\n                    colorMap.set(\n                        textPath.technique,\n                        new THREE.Color(getPropertyValue(technique.color, zoomLevel))\n                    );\n                }\n\n                baseVertex = linePositions.length / 3;\n\n                const text = textPath.text;\n\n                const elementIndex = this.preparedTextPaths.indexOf(textPath);\n\n                const createDebugInfo =\n                    (!textFilter || (text && text.indexOf(textFilter) >= 0)) &&\n                    (indexFilter === undefined || indexFilter === elementIndex);\n\n                if (createDebugInfo) {\n                    for (let i = 0; i < textPath.path.length; i += 3) {\n                        const pathIndex = i / 3;\n                        const x = textPath.path[i];\n                        const y = textPath.path[i + 1];\n                        // raise it a bit, so we get identify connectivity visually by tilting\n                        const z = textPath.path[i + 2] + i / 3;\n\n                        if (debugTextPaths) {\n                            linePositions.push(x, y, z);\n                        }\n\n                        const isRedPoint = i === 0;\n\n                        if (debugTextPathsFull || isRedPoint) {\n                            const pointSize = pointScale * (isRedPoint ? 6 : 4);\n\n                            const positions = isRedPoint ? redPointPositions : blackPointPositions;\n                            const indices = isRedPoint ? redPointIndices : blackPointIndices;\n\n                            positions.push(x, y - pointSize, z);\n                            positions.push(x + pointSize, y, z);\n                            positions.push(x, y + pointSize, z);\n                            positions.push(x - pointSize, y, z);\n\n                            const pointIndex = positions.length / 3;\n\n                            indices.push(pointIndex - 4);\n                            indices.push(pointIndex - 3);\n                            indices.push(pointIndex - 2);\n                            indices.push(pointIndex - 4);\n                            indices.push(pointIndex - 2);\n                            indices.push(pointIndex - 1);\n\n                            if (debugTextPathsFull) {\n                                // give point index a label\n                                const label: string =\n                                    pathIndex % 5 === 0\n                                        ? text + \":\" + pathIndex\n                                        : Number(pathIndex).toString();\n                                const labelElement = new TextElement(\n                                    ContextualArabicConverter.instance.convert(label),\n                                    new THREE.Vector3(x + worldOffsetX, y, z),\n                                    textRenderStyle,\n                                    textLayoutStyle,\n                                    getPropertyValue(technique.priority || 0, zoomLevel),\n                                    technique.xOffset || 0.0,\n                                    technique.yOffset || 0.0\n                                );\n                                labelElement.minZoomLevel = technique.minZoomLevel;\n                                labelElement.mayOverlap = true;\n                                labelElement.reserveSpace = false;\n                                labelElement.alwaysOnTop = true;\n                                labelElement.ignoreDistance = true;\n                                this.addUserTextElement(labelElement);\n                            }\n                        }\n                    }\n\n                    // the lines of a path share a common geometry\n                    const N = textPath.path.length / 3;\n                    for (let i = 0; i < N; ++i) {\n                        if (i > 0) {\n                            lineIndices.push(baseVertex + i);\n                        }\n                        if (i + 1 < N) {\n                            lineIndices.push(baseVertex + i);\n                        }\n                    }\n                }\n            }\n\n            if (lineIndices.length > 0) {\n                lineGeometry.addGroup(0, lineIndices.length, 0);\n\n                lineGeometry.setAttribute(\n                    \"position\",\n                    new THREE.BufferAttribute(new Float32Array(linePositions), 3)\n                );\n\n                lineGeometry.setIndex(new THREE.BufferAttribute(new Uint32Array(lineIndices), 1));\n                const lineMesh = new THREE.LineSegments(lineGeometry, debugMaterial);\n                lineMesh.renderOrder = 2000;\n                this.objects.push(lineMesh);\n            }\n\n            if (redPointIndices.length > 0) {\n                redPointGeometry.addGroup(0, redPointIndices.length, 0);\n\n                redPointGeometry.setAttribute(\n                    \"position\",\n                    new THREE.BufferAttribute(new Float32Array(redPointPositions), 3)\n                );\n\n                redPointGeometry.setIndex(\n                    new THREE.BufferAttribute(new Uint32Array(redPointIndices), 1)\n                );\n                const redPointMesh = new THREE.Mesh(redPointGeometry, debugCircleMaterial);\n                redPointMesh.renderOrder = 3000;\n                this.objects.push(redPointMesh);\n            }\n\n            if (blackPointIndices.length > 0) {\n                blackPointGeometry.addGroup(0, blackPointIndices.length, 0);\n\n                blackPointGeometry.setAttribute(\n                    \"position\",\n                    new THREE.BufferAttribute(new Float32Array(blackPointPositions), 3)\n                );\n\n                blackPointGeometry.setIndex(\n                    new THREE.BufferAttribute(new Uint32Array(blackPointIndices), 1)\n                );\n                const blackPointMesh = new THREE.Mesh(blackPointGeometry, debugBlackCircleMaterial);\n                blackPointMesh.renderOrder = 2500;\n                this.objects.push(blackPointMesh);\n            }\n        }\n    }\n}\n","/*\n * Copyright (C) 2017-2019 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/** @hidden */\nexport const appId = \"devportal-demo-20180625\";\n\n/** @hidden */\nexport const appCode = \"9v2BkviRwi9Ot26kp2IysQ\";\n\n/** @hidden */\nexport const accessToken = \"AGln99HORnqL1kfIQtsQl70\";\n\n/** @hidden */\nexport const copyrightInfo = [\n    {\n        id: \"here.com\",\n        year: new Date().getFullYear(),\n        label: \"HERE\",\n        link: \"https://legal.here.com/terms\"\n    }\n];\n"],"sourceRoot":""}